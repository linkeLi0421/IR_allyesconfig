; ModuleID = '/llk/IR_all_yes/crypto/simd.c_pt.bc'
source_filename = "../crypto/simd.c"
target datalayout = "E-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64"
target triple = "armebv6k-unknown-linux-gnueabi"

module asm ".syntax unified"
module asm "\09.section \22___kcrctab_gpl+simd_skcipher_create_compat\22, \22a\22\09"
module asm "\09.weak\09__crc_simd_skcipher_create_compat\09\09\09\09"
module asm "\09.long\09__crc_simd_skcipher_create_compat\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simd_skcipher_create_compat:\09\09\09\09\09"
module asm "\09.asciz \09\22simd_skcipher_create_compat\22\09\09\09\09\09"
module asm "__kstrtabns_simd_skcipher_create_compat:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+simd_skcipher_create\22, \22a\22\09"
module asm "\09.weak\09__crc_simd_skcipher_create\09\09\09\09"
module asm "\09.long\09__crc_simd_skcipher_create\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simd_skcipher_create:\09\09\09\09\09"
module asm "\09.asciz \09\22simd_skcipher_create\22\09\09\09\09\09"
module asm "__kstrtabns_simd_skcipher_create:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+simd_skcipher_free\22, \22a\22\09"
module asm "\09.weak\09__crc_simd_skcipher_free\09\09\09\09"
module asm "\09.long\09__crc_simd_skcipher_free\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simd_skcipher_free:\09\09\09\09\09"
module asm "\09.asciz \09\22simd_skcipher_free\22\09\09\09\09\09"
module asm "__kstrtabns_simd_skcipher_free:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+simd_register_skciphers_compat\22, \22a\22\09"
module asm "\09.weak\09__crc_simd_register_skciphers_compat\09\09\09\09"
module asm "\09.long\09__crc_simd_register_skciphers_compat\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simd_register_skciphers_compat:\09\09\09\09\09"
module asm "\09.asciz \09\22simd_register_skciphers_compat\22\09\09\09\09\09"
module asm "__kstrtabns_simd_register_skciphers_compat:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+simd_unregister_skciphers\22, \22a\22\09"
module asm "\09.weak\09__crc_simd_unregister_skciphers\09\09\09\09"
module asm "\09.long\09__crc_simd_unregister_skciphers\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simd_unregister_skciphers:\09\09\09\09\09"
module asm "\09.asciz \09\22simd_unregister_skciphers\22\09\09\09\09\09"
module asm "__kstrtabns_simd_unregister_skciphers:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+simd_aead_create_compat\22, \22a\22\09"
module asm "\09.weak\09__crc_simd_aead_create_compat\09\09\09\09"
module asm "\09.long\09__crc_simd_aead_create_compat\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simd_aead_create_compat:\09\09\09\09\09"
module asm "\09.asciz \09\22simd_aead_create_compat\22\09\09\09\09\09"
module asm "__kstrtabns_simd_aead_create_compat:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+simd_aead_create\22, \22a\22\09"
module asm "\09.weak\09__crc_simd_aead_create\09\09\09\09"
module asm "\09.long\09__crc_simd_aead_create\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simd_aead_create:\09\09\09\09\09"
module asm "\09.asciz \09\22simd_aead_create\22\09\09\09\09\09"
module asm "__kstrtabns_simd_aead_create:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+simd_aead_free\22, \22a\22\09"
module asm "\09.weak\09__crc_simd_aead_free\09\09\09\09"
module asm "\09.long\09__crc_simd_aead_free\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simd_aead_free:\09\09\09\09\09"
module asm "\09.asciz \09\22simd_aead_free\22\09\09\09\09\09"
module asm "__kstrtabns_simd_aead_free:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+simd_register_aeads_compat\22, \22a\22\09"
module asm "\09.weak\09__crc_simd_register_aeads_compat\09\09\09\09"
module asm "\09.long\09__crc_simd_register_aeads_compat\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simd_register_aeads_compat:\09\09\09\09\09"
module asm "\09.asciz \09\22simd_register_aeads_compat\22\09\09\09\09\09"
module asm "__kstrtabns_simd_register_aeads_compat:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+simd_unregister_aeads\22, \22a\22\09"
module asm "\09.weak\09__crc_simd_unregister_aeads\09\09\09\09"
module asm "\09.long\09__crc_simd_unregister_aeads\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simd_unregister_aeads:\09\09\09\09\09"
module asm "\09.asciz \09\22simd_unregister_aeads\22\09\09\09\09\09"
module asm "__kstrtabns_simd_unregister_aeads:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"

%struct.kernel_symbol = type { i32, ptr, ptr }
%struct.crypto_skcipher = type { i32, [124 x i8], %struct.crypto_tfm }
%struct.crypto_tfm = type { i32, i32, ptr, ptr, [112 x i8], [0 x ptr] }
%struct.simd_skcipher_alg = type { ptr, [124 x i8], %struct.skcipher_alg }
%struct.skcipher_alg = type { ptr, ptr, ptr, ptr, ptr, i32, i32, i32, i32, i32, [88 x i8], %struct.crypto_alg }
%struct.crypto_alg = type { %struct.list_head, %struct.list_head, i32, i32, i32, i32, i32, %struct.refcount_struct, [128 x i8], [128 x i8], ptr, %union.anon, ptr, ptr, ptr, ptr, %union.anon.44, [120 x i8] }
%struct.list_head = type { ptr, ptr }
%struct.refcount_struct = type { %struct.atomic_t }
%struct.atomic_t = type { i32 }
%union.anon = type { %struct.cipher_alg }
%struct.cipher_alg = type { i32, i32, ptr, ptr, ptr }
%union.anon.44 = type { %struct.crypto_istat_akcipher }
%struct.crypto_istat_akcipher = type { %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t }
%struct.atomic64_t = type { i64 }
%struct.skcipher_request = type { i32, ptr, ptr, ptr, %struct.crypto_async_request, [88 x i8], [0 x ptr] }
%struct.crypto_async_request = type { %struct.list_head, ptr, ptr, ptr, i32 }
%struct.thread_info = type { i32, i32, ptr, i32, i32, %struct.cpu_context_save, i32, [16 x i8], [2 x i32], %union.fp_state, %union.vfp_state, i32 }
%struct.cpu_context_save = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [2 x i32] }
%union.fp_state = type { %struct.iwmmxt_struct }
%struct.iwmmxt_struct = type { [38 x i32] }
%union.vfp_state = type { %struct.vfp_hard_struct }
%struct.vfp_hard_struct = type { [32 x i64], i32, i32, i32, i32, i32 }
%struct.crypto_aead = type { i32, i32, [120 x i8], %struct.crypto_tfm }
%struct.simd_aead_alg = type { ptr, [124 x i8], %struct.aead_alg }
%struct.aead_alg = type { ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i32, [92 x i8], %struct.crypto_alg }
%struct.aead_request = type { %struct.crypto_async_request, i32, i32, ptr, ptr, ptr, [84 x i8], [0 x ptr] }

@.str = internal constant { [3 x i8], [29 x i8] } { [3 x i8] c"%s\00", [29 x i8] zeroinitializer }, align 32
@__kstrtab_simd_skcipher_create_compat = external dso_local constant [0 x i8], align 1
@__kstrtabns_simd_skcipher_create_compat = external dso_local constant [0 x i8], align 1
@__ksymtab_simd_skcipher_create_compat = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simd_skcipher_create_compat to i32), ptr @__kstrtab_simd_skcipher_create_compat, ptr @__kstrtabns_simd_skcipher_create_compat }, section "___ksymtab_gpl+simd_skcipher_create_compat", align 4
@.str.1 = internal constant { [8 x i8], [24 x i8] } { [8 x i8] c"simd-%s\00", [24 x i8] zeroinitializer }, align 32
@__kstrtab_simd_skcipher_create = external dso_local constant [0 x i8], align 1
@__kstrtabns_simd_skcipher_create = external dso_local constant [0 x i8], align 1
@__ksymtab_simd_skcipher_create = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simd_skcipher_create to i32), ptr @__kstrtab_simd_skcipher_create, ptr @__kstrtabns_simd_skcipher_create }, section "___ksymtab_gpl+simd_skcipher_create", align 4
@__kstrtab_simd_skcipher_free = external dso_local constant [0 x i8], align 1
@__kstrtabns_simd_skcipher_free = external dso_local constant [0 x i8], align 1
@__ksymtab_simd_skcipher_free = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simd_skcipher_free to i32), ptr @__kstrtab_simd_skcipher_free, ptr @__kstrtabns_simd_skcipher_free }, section "___ksymtab_gpl+simd_skcipher_free", align 4
@.str.2 = internal constant { [3 x i8], [29 x i8] } { [3 x i8] c"__\00", [29 x i8] zeroinitializer }, align 32
@.str.3 = internal constant { [14 x i8], [18 x i8] } { [14 x i8] c"crypto/simd.c\00", [18 x i8] zeroinitializer }, align 32
@__kstrtab_simd_register_skciphers_compat = external dso_local constant [0 x i8], align 1
@__kstrtabns_simd_register_skciphers_compat = external dso_local constant [0 x i8], align 1
@__ksymtab_simd_register_skciphers_compat = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simd_register_skciphers_compat to i32), ptr @__kstrtab_simd_register_skciphers_compat, ptr @__kstrtabns_simd_register_skciphers_compat }, section "___ksymtab_gpl+simd_register_skciphers_compat", align 4
@__kstrtab_simd_unregister_skciphers = external dso_local constant [0 x i8], align 1
@__kstrtabns_simd_unregister_skciphers = external dso_local constant [0 x i8], align 1
@__ksymtab_simd_unregister_skciphers = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simd_unregister_skciphers to i32), ptr @__kstrtab_simd_unregister_skciphers, ptr @__kstrtabns_simd_unregister_skciphers }, section "___ksymtab_gpl+simd_unregister_skciphers", align 4
@__kstrtab_simd_aead_create_compat = external dso_local constant [0 x i8], align 1
@__kstrtabns_simd_aead_create_compat = external dso_local constant [0 x i8], align 1
@__ksymtab_simd_aead_create_compat = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simd_aead_create_compat to i32), ptr @__kstrtab_simd_aead_create_compat, ptr @__kstrtabns_simd_aead_create_compat }, section "___ksymtab_gpl+simd_aead_create_compat", align 4
@__kstrtab_simd_aead_create = external dso_local constant [0 x i8], align 1
@__kstrtabns_simd_aead_create = external dso_local constant [0 x i8], align 1
@__ksymtab_simd_aead_create = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simd_aead_create to i32), ptr @__kstrtab_simd_aead_create, ptr @__kstrtabns_simd_aead_create }, section "___ksymtab_gpl+simd_aead_create", align 4
@__kstrtab_simd_aead_free = external dso_local constant [0 x i8], align 1
@__kstrtabns_simd_aead_free = external dso_local constant [0 x i8], align 1
@__ksymtab_simd_aead_free = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simd_aead_free to i32), ptr @__kstrtab_simd_aead_free, ptr @__kstrtabns_simd_aead_free }, section "___ksymtab_gpl+simd_aead_free", align 4
@__kstrtab_simd_register_aeads_compat = external dso_local constant [0 x i8], align 1
@__kstrtabns_simd_register_aeads_compat = external dso_local constant [0 x i8], align 1
@__ksymtab_simd_register_aeads_compat = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simd_register_aeads_compat to i32), ptr @__kstrtab_simd_register_aeads_compat, ptr @__kstrtabns_simd_register_aeads_compat }, section "___ksymtab_gpl+simd_register_aeads_compat", align 4
@__kstrtab_simd_unregister_aeads = external dso_local constant [0 x i8], align 1
@__kstrtabns_simd_unregister_aeads = external dso_local constant [0 x i8], align 1
@__ksymtab_simd_unregister_aeads = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simd_unregister_aeads to i32), ptr @__kstrtab_simd_unregister_aeads, ptr @__kstrtabns_simd_unregister_aeads }, section "___ksymtab_gpl+simd_unregister_aeads", align 4
@__UNIQUE_ID_file177 = internal constant [36 x i8] c"crypto_simd.file=crypto/crypto_simd\00", section ".modinfo", align 1
@__UNIQUE_ID_license178 = internal constant [24 x i8] c"crypto_simd.license=GPL\00", section ".modinfo", align 1
@kmalloc_caches = external dso_local local_unnamed_addr global [4 x [14 x ptr]], align 4
@___asan_gen_.6 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.14, i32 166, i32 56 }
@___asan_gen_.9 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.14, i32 214, i32 45 }
@___asan_gen_.13 = private unnamed_addr constant [17 x i8] c"<string literal>\00", align 1
@___asan_gen_.14 = private constant [17 x i8] c"../crypto/simd.c\00", align 1
@___asan_gen_.15 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.14, i32 244, i32 3 }
@llvm.compiler.used = appending global [16 x ptr] [ptr @__UNIQUE_ID_file177, ptr @__UNIQUE_ID_license178, ptr @__ksymtab_simd_aead_create, ptr @__ksymtab_simd_aead_create_compat, ptr @__ksymtab_simd_aead_free, ptr @__ksymtab_simd_register_aeads_compat, ptr @__ksymtab_simd_register_skciphers_compat, ptr @__ksymtab_simd_skcipher_create, ptr @__ksymtab_simd_skcipher_create_compat, ptr @__ksymtab_simd_skcipher_free, ptr @__ksymtab_simd_unregister_aeads, ptr @__ksymtab_simd_unregister_skciphers, ptr @.str, ptr @.str.1, ptr @.str.2, ptr @.str.3], section "llvm.metadata"
@0 = internal global [4 x { i32, i32, i32, i32, i32, i32, i32, i32 }] [{ i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str to i32), i32 3, i32 32, i32 ptrtoint (ptr @___asan_gen_.13 to i32), i32 ptrtoint (ptr @___asan_gen_.14 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.6 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.1 to i32), i32 8, i32 32, i32 ptrtoint (ptr @___asan_gen_.13 to i32), i32 ptrtoint (ptr @___asan_gen_.14 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.9 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.2 to i32), i32 3, i32 32, i32 ptrtoint (ptr @___asan_gen_.13 to i32), i32 ptrtoint (ptr @___asan_gen_.14 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.15 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.3 to i32), i32 14, i32 32, i32 ptrtoint (ptr @___asan_gen_.13 to i32), i32 ptrtoint (ptr @___asan_gen_.14 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.15 to i32), i32 -1 }]
@llvm.used = appending global [2 x ptr] [ptr @asan.module_ctor, ptr @asan.module_dtor], section "llvm.metadata"
@llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 1, ptr @asan.module_ctor, ptr null }]
@llvm.global_dtors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 1, ptr @asan.module_dtor, ptr null }]

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @simd_skcipher_create_compat(ptr noundef %algname, ptr noundef %drvname, ptr noundef %basename) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call ptr @crypto_alloc_skcipher(ptr noundef %basename, i32 noundef 8192, i32 noundef 8320) #8
  %cmp.i = icmp ugt ptr %call, inttoptr (i32 -4096 to ptr)
  br i1 %cmp.i, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  br label %cleanup

if.end:                                           ; preds = %entry
  %__crt_alg.i = getelementptr inbounds %struct.crypto_skcipher, ptr %call, i32 0, i32 2, i32 3
  %0 = ptrtoint ptr %__crt_alg.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %__crt_alg.i, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 10) to i32))
  %2 = load ptr, ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 10), align 4
  %call7.i.i = tail call noalias align 8 ptr @kmem_cache_alloc_trace(ptr noundef %2, i32 noundef 3520, i32 noundef 768) #11
  %tobool.not = icmp eq ptr %call7.i.i, null
  br i1 %tobool.not, label %if.end.out_put_tfm_crit_edge, label %if.end7

if.end.out_put_tfm_crit_edge:                     ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #10
  br label %out_put_tfm

if.end7:                                          ; preds = %if.end
  %3 = ptrtoint ptr %call7.i.i to i32
  call void @__asan_store4_noabort(i32 %3)
  store ptr %basename, ptr %call7.i.i, align 128
  %alg8 = getelementptr inbounds %struct.simd_skcipher_alg, ptr %call7.i.i, i32 0, i32 2
  %cra_name = getelementptr inbounds %struct.simd_skcipher_alg, ptr %call7.i.i, i32 0, i32 2, i32 11, i32 8
  %call9 = tail call i32 (ptr, i32, ptr, ...) @snprintf(ptr noundef %cra_name, i32 noundef 128, ptr noundef nonnull @.str, ptr noundef %algname)
  call void @__sanitizer_cov_trace_const_cmp4(i32 127, i32 %call9)
  %cmp = icmp sgt i32 %call9, 127
  br i1 %cmp, label %if.end7.out_free_salg_crit_edge, label %if.end11

if.end7.out_free_salg_crit_edge:                  ; preds = %if.end7
  call void @__sanitizer_cov_trace_pc() #10
  br label %out_free_salg

if.end11:                                         ; preds = %if.end7
  %cra_driver_name = getelementptr inbounds %struct.simd_skcipher_alg, ptr %call7.i.i, i32 0, i32 2, i32 11, i32 9
  %call14 = tail call i32 (ptr, i32, ptr, ...) @snprintf(ptr noundef %cra_driver_name, i32 noundef 128, ptr noundef nonnull @.str, ptr noundef %drvname)
  call void @__sanitizer_cov_trace_const_cmp4(i32 127, i32 %call14)
  %cmp15 = icmp sgt i32 %call14, 127
  br i1 %cmp15, label %if.end11.out_free_salg_crit_edge, label %if.end17

if.end11.out_free_salg_crit_edge:                 ; preds = %if.end11
  call void @__sanitizer_cov_trace_pc() #10
  br label %out_free_salg

if.end17:                                         ; preds = %if.end11
  %cra_flags = getelementptr i8, ptr %1, i32 16
  %4 = ptrtoint ptr %cra_flags to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %cra_flags, align 16
  %and = and i32 %5, 65792
  %or = or i32 %and, 128
  %cra_flags20 = getelementptr inbounds %struct.simd_skcipher_alg, ptr %call7.i.i, i32 0, i32 2, i32 11, i32 2
  %6 = ptrtoint ptr %cra_flags20 to i32
  call void @__asan_store4_noabort(i32 %6)
  store i32 %or, ptr %cra_flags20, align 16
  %cra_priority = getelementptr i8, ptr %1, i32 32
  %7 = ptrtoint ptr %cra_priority to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %cra_priority, align 32
  %cra_priority23 = getelementptr inbounds %struct.simd_skcipher_alg, ptr %call7.i.i, i32 0, i32 2, i32 11, i32 6
  %9 = ptrtoint ptr %cra_priority23 to i32
  call void @__asan_store4_noabort(i32 %9)
  store i32 %8, ptr %cra_priority23, align 32
  %cra_blocksize = getelementptr i8, ptr %1, i32 20
  %10 = ptrtoint ptr %cra_blocksize to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %cra_blocksize, align 4
  %cra_blocksize26 = getelementptr inbounds %struct.simd_skcipher_alg, ptr %call7.i.i, i32 0, i32 2, i32 11, i32 3
  %12 = ptrtoint ptr %cra_blocksize26 to i32
  call void @__asan_store4_noabort(i32 %12)
  store i32 %11, ptr %cra_blocksize26, align 4
  %cra_alignmask = getelementptr i8, ptr %1, i32 28
  %13 = ptrtoint ptr %cra_alignmask to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %cra_alignmask, align 4
  %cra_alignmask29 = getelementptr inbounds %struct.simd_skcipher_alg, ptr %call7.i.i, i32 0, i32 2, i32 11, i32 5
  %15 = ptrtoint ptr %cra_alignmask29 to i32
  call void @__asan_store4_noabort(i32 %15)
  store i32 %14, ptr %cra_alignmask29, align 4
  %cra_module = getelementptr i8, ptr %1, i32 332
  %16 = ptrtoint ptr %cra_module to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %cra_module, align 4
  %cra_module32 = getelementptr inbounds %struct.simd_skcipher_alg, ptr %call7.i.i, i32 0, i32 2, i32 11, i32 15
  %18 = ptrtoint ptr %cra_module32 to i32
  call void @__asan_store4_noabort(i32 %18)
  store ptr %17, ptr %cra_module32, align 4
  %cra_ctxsize = getelementptr inbounds %struct.simd_skcipher_alg, ptr %call7.i.i, i32 0, i32 2, i32 11, i32 4
  %19 = ptrtoint ptr %cra_ctxsize to i32
  call void @__asan_store4_noabort(i32 %19)
  store i32 4, ptr %cra_ctxsize, align 8
  %ivsize = getelementptr i8, ptr %1, i32 -100
  %20 = ptrtoint ptr %ivsize to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %ivsize, align 4
  %ivsize34 = getelementptr inbounds %struct.simd_skcipher_alg, ptr %call7.i.i, i32 0, i32 2, i32 7
  %22 = ptrtoint ptr %ivsize34 to i32
  call void @__asan_store4_noabort(i32 %22)
  store i32 %21, ptr %ivsize34, align 4
  %chunksize = getelementptr i8, ptr %1, i32 -96
  %23 = ptrtoint ptr %chunksize to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %chunksize, align 32
  %chunksize35 = getelementptr inbounds %struct.simd_skcipher_alg, ptr %call7.i.i, i32 0, i32 2, i32 8
  %25 = ptrtoint ptr %chunksize35 to i32
  call void @__asan_store4_noabort(i32 %25)
  store i32 %24, ptr %chunksize35, align 32
  %min_keysize = getelementptr i8, ptr %1, i32 -108
  %26 = ptrtoint ptr %min_keysize to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %min_keysize, align 4
  %min_keysize36 = getelementptr inbounds %struct.simd_skcipher_alg, ptr %call7.i.i, i32 0, i32 2, i32 5
  %28 = ptrtoint ptr %min_keysize36 to i32
  call void @__asan_store4_noabort(i32 %28)
  store i32 %27, ptr %min_keysize36, align 4
  %max_keysize = getelementptr i8, ptr %1, i32 -104
  %29 = ptrtoint ptr %max_keysize to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %max_keysize, align 8
  %max_keysize37 = getelementptr inbounds %struct.simd_skcipher_alg, ptr %call7.i.i, i32 0, i32 2, i32 6
  %31 = ptrtoint ptr %max_keysize37 to i32
  call void @__asan_store4_noabort(i32 %31)
  store i32 %30, ptr %max_keysize37, align 8
  %init = getelementptr inbounds %struct.simd_skcipher_alg, ptr %call7.i.i, i32 0, i32 2, i32 3
  %32 = ptrtoint ptr %init to i32
  call void @__asan_store4_noabort(i32 %32)
  store ptr @simd_skcipher_init, ptr %init, align 4
  %exit = getelementptr inbounds %struct.simd_skcipher_alg, ptr %call7.i.i, i32 0, i32 2, i32 4
  %33 = ptrtoint ptr %exit to i32
  call void @__asan_store4_noabort(i32 %33)
  store ptr @simd_skcipher_exit, ptr %exit, align 16
  %34 = ptrtoint ptr %alg8 to i32
  call void @__asan_store4_noabort(i32 %34)
  store ptr @simd_skcipher_setkey, ptr %alg8, align 128
  %encrypt = getelementptr inbounds %struct.simd_skcipher_alg, ptr %call7.i.i, i32 0, i32 2, i32 1
  %35 = ptrtoint ptr %encrypt to i32
  call void @__asan_store4_noabort(i32 %35)
  store ptr @simd_skcipher_encrypt, ptr %encrypt, align 4
  %decrypt = getelementptr inbounds %struct.simd_skcipher_alg, ptr %call7.i.i, i32 0, i32 2, i32 2
  %36 = ptrtoint ptr %decrypt to i32
  call void @__asan_store4_noabort(i32 %36)
  store ptr @simd_skcipher_decrypt, ptr %decrypt, align 8
  %call38 = tail call i32 @crypto_register_skcipher(ptr noundef %alg8) #8
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call38)
  %tobool39.not = icmp eq i32 %call38, 0
  br i1 %tobool39.not, label %if.end17.out_put_tfm_crit_edge, label %if.end17.out_free_salg_crit_edge

if.end17.out_free_salg_crit_edge:                 ; preds = %if.end17
  call void @__sanitizer_cov_trace_pc() #10
  br label %out_free_salg

if.end17.out_put_tfm_crit_edge:                   ; preds = %if.end17
  call void @__sanitizer_cov_trace_pc() #10
  br label %out_put_tfm

out_put_tfm:                                      ; preds = %out_free_salg, %if.end17.out_put_tfm_crit_edge, %if.end.out_put_tfm_crit_edge
  %salg.0 = phi ptr [ %37, %out_free_salg ], [ %call7.i.i, %if.end17.out_put_tfm_crit_edge ], [ inttoptr (i32 -12 to ptr), %if.end.out_put_tfm_crit_edge ]
  %base.i.i = getelementptr inbounds %struct.crypto_skcipher, ptr %call, i32 0, i32 2
  tail call void @crypto_destroy_tfm(ptr noundef %call, ptr noundef %base.i.i) #8
  br label %cleanup

out_free_salg:                                    ; preds = %if.end17.out_free_salg_crit_edge, %if.end11.out_free_salg_crit_edge, %if.end7.out_free_salg_crit_edge
  %err.0 = phi i32 [ -36, %if.end7.out_free_salg_crit_edge ], [ -36, %if.end11.out_free_salg_crit_edge ], [ %call38, %if.end17.out_free_salg_crit_edge ]
  tail call void @kfree(ptr noundef nonnull %call7.i.i) #8
  %37 = inttoptr i32 %err.0 to ptr
  br label %out_put_tfm

cleanup:                                          ; preds = %out_put_tfm, %entry.cleanup_crit_edge
  %retval.0 = phi ptr [ %salg.0, %out_put_tfm ], [ %call, %entry.cleanup_crit_edge ]
  ret ptr %retval.0
}

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @crypto_alloc_skcipher(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: nofree nounwind null_pointer_is_valid
declare dso_local noundef i32 @snprintf(ptr noalias nocapture noundef writeonly, i32 noundef, ptr nocapture noundef readonly, ...) local_unnamed_addr #3

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @simd_skcipher_init(ptr nocapture noundef %tfm) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  %__crt_alg.i = getelementptr inbounds %struct.crypto_skcipher, ptr %tfm, i32 0, i32 2, i32 3
  %0 = ptrtoint ptr %__crt_alg.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %__crt_alg.i, align 4
  %add.ptr = getelementptr i8, ptr %1, i32 -256
  %2 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %add.ptr, align 128
  %call2 = tail call ptr @cryptd_alloc_skcipher(ptr noundef %3, i32 noundef 8192, i32 noundef 8192) #8
  %cmp.i = icmp ugt ptr %call2, inttoptr (i32 -4096 to ptr)
  br i1 %cmp.i, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  %4 = ptrtoint ptr %call2 to i32
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  %__crt_ctx.i.i = getelementptr inbounds %struct.crypto_skcipher, ptr %tfm, i32 1
  %5 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_store4_noabort(i32 %5)
  store ptr %call2, ptr %__crt_ctx.i.i, align 4
  %call6 = tail call ptr @cryptd_skcipher_child(ptr noundef %call2) #8
  %6 = ptrtoint ptr %call6 to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %call6, align 128
  %8 = ptrtoint ptr %call2 to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %call2, align 128
  %10 = tail call i32 @llvm.umax.i32(i32 %7, i32 %9)
  %add = add i32 %10, 128
  %11 = ptrtoint ptr %tfm to i32
  call void @__asan_store4_noabort(i32 %11)
  store i32 %add, ptr %tfm, align 128
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %4, %if.then ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @simd_skcipher_exit(ptr nocapture noundef readonly %tfm) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  %__crt_ctx.i.i = getelementptr inbounds %struct.crypto_skcipher, ptr %tfm, i32 1
  %0 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %__crt_ctx.i.i, align 4
  tail call void @cryptd_free_skcipher(ptr noundef %1) #8
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @simd_skcipher_setkey(ptr nocapture noundef readonly %tfm, ptr noundef %key, i32 noundef %key_len) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  %__crt_ctx.i.i = getelementptr inbounds %struct.crypto_skcipher, ptr %tfm, i32 1
  %0 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %__crt_ctx.i.i, align 4
  %base.i.i = getelementptr inbounds %struct.crypto_skcipher, ptr %1, i32 0, i32 2
  %2 = ptrtoint ptr %base.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %base.i.i, align 128
  %and.i.i = and i32 %3, -1048321
  store i32 %and.i.i, ptr %base.i.i, align 128
  %base.i.i6 = getelementptr inbounds %struct.crypto_skcipher, ptr %tfm, i32 0, i32 2
  %4 = ptrtoint ptr %base.i.i6 to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %base.i.i6, align 128
  %and = and i32 %5, 1048320
  %or.i.i = or i32 %and, %and.i.i
  store i32 %or.i.i, ptr %base.i.i, align 128
  %call2 = tail call i32 @crypto_skcipher_setkey(ptr noundef %1, ptr noundef %key, i32 noundef %key_len) #8
  ret i32 %call2
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @simd_skcipher_encrypt(ptr noundef %req) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  %tfm.i = getelementptr inbounds %struct.skcipher_request, ptr %req, i32 0, i32 4, i32 3
  %0 = ptrtoint ptr %tfm.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %tfm.i, align 16
  %__crt_ctx.i.i = getelementptr i8, ptr %1, i32 128
  %__ctx.i = getelementptr inbounds %struct.skcipher_request, ptr %req, i32 0, i32 6
  %2 = call ptr @memcpy(ptr %__ctx.i, ptr %req, i32 128)
  %3 = tail call i32 @llvm.read_register.i32(metadata !30) #8
  %and.i.i.i = and i32 %3, -16384
  %4 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %4, i32 0, i32 1
  %5 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %preempt_count.i.i, align 4
  %and.i = and i32 %6, 15728640
  %7 = tail call i32 @llvm.read_register.i32(metadata !30) #8
  %and.i.i6.i = and i32 %7, -16384
  %8 = inttoptr i32 %and.i.i6.i to ptr
  %preempt_count.i7.i = getelementptr inbounds %struct.thread_info, ptr %8, i32 0, i32 1
  %9 = ptrtoint ptr %preempt_count.i7.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load volatile i32, ptr %preempt_count.i7.i, align 4
  %and2.i = and i32 %10, 983040
  %or.i = or i32 %and2.i, %and.i
  %11 = tail call i32 @llvm.read_register.i32(metadata !30) #8
  %and.i.i8.i = and i32 %11, -16384
  %12 = inttoptr i32 %and.i.i8.i to ptr
  %preempt_count.i9.i = getelementptr inbounds %struct.thread_info, ptr %12, i32 0, i32 1
  %13 = ptrtoint ptr %preempt_count.i9.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %preempt_count.i9.i, align 4
  %and4.i = and i32 %14, 65280
  %or5.i = or i32 %or.i, %and4.i
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %or5.i)
  %tobool.not.i = icmp eq i32 %or5.i, 0
  br i1 %tobool.not.i, label %lor.lhs.false, label %entry.if.then_crit_edge

entry.if.then_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.then

lor.lhs.false:                                    ; preds = %entry
  %15 = tail call i32 @llvm.read_register.i32(metadata !30) #8
  %and.i.i = and i32 %15, -16384
  %16 = inttoptr i32 %and.i.i to ptr
  %preempt_count.i = getelementptr inbounds %struct.thread_info, ptr %16, i32 0, i32 1
  %17 = ptrtoint ptr %preempt_count.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load volatile i32, ptr %preempt_count.i, align 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %18)
  %cmp.not = icmp eq i32 %18, 0
  br i1 %cmp.not, label %lor.lhs.false.if.else_crit_edge, label %land.lhs.true

lor.lhs.false.if.else_crit_edge:                  ; preds = %lor.lhs.false
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.else

land.lhs.true:                                    ; preds = %lor.lhs.false
  %19 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %__crt_ctx.i.i, align 4
  %call5 = tail call zeroext i1 @cryptd_skcipher_queued(ptr noundef %20) #8
  br i1 %call5, label %land.lhs.true.if.then_crit_edge, label %land.lhs.true.if.else_crit_edge

land.lhs.true.if.else_crit_edge:                  ; preds = %land.lhs.true
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.else

land.lhs.true.if.then_crit_edge:                  ; preds = %land.lhs.true
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.then

if.then:                                          ; preds = %land.lhs.true.if.then_crit_edge, %entry.if.then_crit_edge
  %21 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %__crt_ctx.i.i, align 4
  br label %if.end

if.else:                                          ; preds = %land.lhs.true.if.else_crit_edge, %lor.lhs.false.if.else_crit_edge
  %23 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %__crt_ctx.i.i, align 4
  %call8 = tail call ptr @cryptd_skcipher_child(ptr noundef %24) #8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %child.0 = phi ptr [ %22, %if.then ], [ %call8, %if.else ]
  %base.i.i = getelementptr inbounds %struct.crypto_skcipher, ptr %child.0, i32 0, i32 2
  %tfm1.i = getelementptr inbounds %struct.skcipher_request, ptr %req, i32 1, i32 4, i32 3
  %25 = ptrtoint ptr %tfm1.i to i32
  call void @__asan_store4_noabort(i32 %25)
  store ptr %base.i.i, ptr %tfm1.i, align 16
  %call9 = tail call i32 @crypto_skcipher_encrypt(ptr noundef %__ctx.i) #8
  ret i32 %call9
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @simd_skcipher_decrypt(ptr noundef %req) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  %tfm.i = getelementptr inbounds %struct.skcipher_request, ptr %req, i32 0, i32 4, i32 3
  %0 = ptrtoint ptr %tfm.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %tfm.i, align 16
  %__crt_ctx.i.i = getelementptr i8, ptr %1, i32 128
  %__ctx.i = getelementptr inbounds %struct.skcipher_request, ptr %req, i32 0, i32 6
  %2 = call ptr @memcpy(ptr %__ctx.i, ptr %req, i32 128)
  %3 = tail call i32 @llvm.read_register.i32(metadata !30) #8
  %and.i.i.i = and i32 %3, -16384
  %4 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %4, i32 0, i32 1
  %5 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %preempt_count.i.i, align 4
  %and.i = and i32 %6, 15728640
  %7 = tail call i32 @llvm.read_register.i32(metadata !30) #8
  %and.i.i6.i = and i32 %7, -16384
  %8 = inttoptr i32 %and.i.i6.i to ptr
  %preempt_count.i7.i = getelementptr inbounds %struct.thread_info, ptr %8, i32 0, i32 1
  %9 = ptrtoint ptr %preempt_count.i7.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load volatile i32, ptr %preempt_count.i7.i, align 4
  %and2.i = and i32 %10, 983040
  %or.i = or i32 %and2.i, %and.i
  %11 = tail call i32 @llvm.read_register.i32(metadata !30) #8
  %and.i.i8.i = and i32 %11, -16384
  %12 = inttoptr i32 %and.i.i8.i to ptr
  %preempt_count.i9.i = getelementptr inbounds %struct.thread_info, ptr %12, i32 0, i32 1
  %13 = ptrtoint ptr %preempt_count.i9.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %preempt_count.i9.i, align 4
  %and4.i = and i32 %14, 65280
  %or5.i = or i32 %or.i, %and4.i
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %or5.i)
  %tobool.not.i = icmp eq i32 %or5.i, 0
  br i1 %tobool.not.i, label %lor.lhs.false, label %entry.if.then_crit_edge

entry.if.then_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.then

lor.lhs.false:                                    ; preds = %entry
  %15 = tail call i32 @llvm.read_register.i32(metadata !30) #8
  %and.i.i = and i32 %15, -16384
  %16 = inttoptr i32 %and.i.i to ptr
  %preempt_count.i = getelementptr inbounds %struct.thread_info, ptr %16, i32 0, i32 1
  %17 = ptrtoint ptr %preempt_count.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load volatile i32, ptr %preempt_count.i, align 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %18)
  %cmp.not = icmp eq i32 %18, 0
  br i1 %cmp.not, label %lor.lhs.false.if.else_crit_edge, label %land.lhs.true

lor.lhs.false.if.else_crit_edge:                  ; preds = %lor.lhs.false
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.else

land.lhs.true:                                    ; preds = %lor.lhs.false
  %19 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %__crt_ctx.i.i, align 4
  %call5 = tail call zeroext i1 @cryptd_skcipher_queued(ptr noundef %20) #8
  br i1 %call5, label %land.lhs.true.if.then_crit_edge, label %land.lhs.true.if.else_crit_edge

land.lhs.true.if.else_crit_edge:                  ; preds = %land.lhs.true
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.else

land.lhs.true.if.then_crit_edge:                  ; preds = %land.lhs.true
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.then

if.then:                                          ; preds = %land.lhs.true.if.then_crit_edge, %entry.if.then_crit_edge
  %21 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %__crt_ctx.i.i, align 4
  br label %if.end

if.else:                                          ; preds = %land.lhs.true.if.else_crit_edge, %lor.lhs.false.if.else_crit_edge
  %23 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %__crt_ctx.i.i, align 4
  %call8 = tail call ptr @cryptd_skcipher_child(ptr noundef %24) #8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %child.0 = phi ptr [ %22, %if.then ], [ %call8, %if.else ]
  %base.i.i = getelementptr inbounds %struct.crypto_skcipher, ptr %child.0, i32 0, i32 2
  %tfm1.i = getelementptr inbounds %struct.skcipher_request, ptr %req, i32 1, i32 4, i32 3
  %25 = ptrtoint ptr %tfm1.i to i32
  call void @__asan_store4_noabort(i32 %25)
  store ptr %base.i.i, ptr %tfm1.i, align 16
  %call9 = tail call i32 @crypto_skcipher_decrypt(ptr noundef %__ctx.i) #8
  ret i32 %call9
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @crypto_register_skcipher(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @kfree(ptr noundef) local_unnamed_addr #2

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @simd_skcipher_create(ptr noundef %algname, ptr noundef %basename) #0 align 64 {
entry:
  %drvname = alloca [128 x i8], align 1
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  call void @llvm.lifetime.start.p0(i64 128, ptr nonnull %drvname) #8
  %0 = call ptr @memset(ptr %drvname, i32 255, i32 128)
  %call = call i32 (ptr, i32, ptr, ...) @snprintf(ptr noundef nonnull %drvname, i32 noundef 128, ptr noundef nonnull @.str.1, ptr noundef %basename)
  call void @__sanitizer_cov_trace_const_cmp4(i32 127, i32 %call)
  %cmp = icmp sgt i32 %call, 127
  br i1 %cmp, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  %call3 = call ptr @simd_skcipher_create_compat(ptr noundef %algname, ptr noundef nonnull %drvname, ptr noundef %basename)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry.cleanup_crit_edge
  %retval.0 = phi ptr [ %call3, %if.end ], [ inttoptr (i32 -36 to ptr), %entry.cleanup_crit_edge ]
  call void @llvm.lifetime.end.p0(i64 128, ptr nonnull %drvname) #8
  ret ptr %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @simd_skcipher_free(ptr noundef %salg) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  %alg = getelementptr inbounds %struct.simd_skcipher_alg, ptr %salg, i32 0, i32 2
  tail call void @crypto_unregister_skcipher(ptr noundef %alg) #8
  tail call void @kfree(ptr noundef %salg) #8
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @crypto_unregister_skcipher(ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simd_register_skciphers_compat(ptr noundef %algs, i32 noundef %count, ptr nocapture noundef %simd_algs) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call i32 @crypto_register_skciphers(ptr noundef %algs, i32 noundef %count) #8
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %for.cond.preheader, label %entry.cleanup_crit_edge

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  br label %cleanup

for.cond.preheader:                               ; preds = %entry
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %count)
  %cmp106 = icmp sgt i32 %count, 0
  br i1 %cmp106, label %for.cond.preheader.for.body_crit_edge, label %for.cond.preheader.cleanup_crit_edge

for.cond.preheader.cleanup_crit_edge:             ; preds = %for.cond.preheader
  call void @__sanitizer_cov_trace_pc() #10
  br label %cleanup

for.cond.preheader.for.body_crit_edge:            ; preds = %for.cond.preheader
  br label %for.body

for.body:                                         ; preds = %if.end76.for.body_crit_edge, %for.cond.preheader.for.body_crit_edge
  %i.0107 = phi i32 [ %inc, %if.end76.for.body_crit_edge ], [ 0, %for.cond.preheader.for.body_crit_edge ]
  %cra_name = getelementptr %struct.skcipher_alg, ptr %algs, i32 %i.0107, i32 11, i32 8
  %call1 = tail call i32 @strncmp(ptr noundef %cra_name, ptr noundef nonnull dereferenceable(3) @.str.2, i32 noundef 2)
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call1)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %for.body.if.end17_crit_edge, label %do.end, !prof !40

for.body.if.end17_crit_edge:                      ; preds = %for.body
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.end17

do.end:                                           ; preds = %for.body
  call void @__sanitizer_cov_trace_pc() #10
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.3, i32 noundef 244, i32 noundef 9, ptr noundef null) #8
  br label %if.end17

if.end17:                                         ; preds = %do.end, %for.body.if.end17_crit_edge
  %cra_driver_name = getelementptr %struct.skcipher_alg, ptr %algs, i32 %i.0107, i32 11, i32 9
  %call28 = tail call i32 @strncmp(ptr noundef %cra_driver_name, ptr noundef nonnull dereferenceable(3) @.str.2, i32 noundef 2)
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call28)
  %tobool29.not = icmp eq i32 %call28, 0
  br i1 %tobool29.not, label %if.end17.if.end51_crit_edge, label %do.end45, !prof !40

if.end17.if.end51_crit_edge:                      ; preds = %if.end17
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.end51

do.end45:                                         ; preds = %if.end17
  call void @__sanitizer_cov_trace_pc() #10
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.3, i32 noundef 245, i32 noundef 9, ptr noundef null) #8
  br label %if.end51

if.end51:                                         ; preds = %do.end45, %if.end17.if.end51_crit_edge
  %add.ptr = getelementptr i8, ptr %cra_name, i32 2
  %add.ptr67 = getelementptr i8, ptr %cra_driver_name, i32 2
  %call72 = tail call ptr @simd_skcipher_create_compat(ptr noundef %add.ptr, ptr noundef %add.ptr67, ptr noundef %cra_driver_name)
  %cmp.i = icmp ugt ptr %call72, inttoptr (i32 -4096 to ptr)
  br i1 %cmp.i, label %for.body.i.preheader, label %if.end76

if.end76:                                         ; preds = %if.end51
  %arrayidx77 = getelementptr ptr, ptr %simd_algs, i32 %i.0107
  %0 = ptrtoint ptr %arrayidx77 to i32
  call void @__asan_store4_noabort(i32 %0)
  store ptr %call72, ptr %arrayidx77, align 4
  %inc = add nuw nsw i32 %i.0107, 1
  %exitcond.not = icmp eq i32 %inc, %count
  br i1 %exitcond.not, label %if.end76.cleanup_crit_edge, label %if.end76.for.body_crit_edge

if.end76.for.body_crit_edge:                      ; preds = %if.end76
  call void @__sanitizer_cov_trace_pc() #10
  br label %for.body

if.end76.cleanup_crit_edge:                       ; preds = %if.end76
  call void @__sanitizer_cov_trace_pc() #10
  br label %cleanup

for.body.i.preheader:                             ; preds = %if.end51
  %1 = ptrtoint ptr %call72 to i32
  tail call void @crypto_unregister_skciphers(ptr noundef %algs, i32 noundef %count) #8
  br label %for.body.i

for.body.i:                                       ; preds = %for.inc.i.for.body.i_crit_edge, %for.body.i.preheader
  %i.011.i = phi i32 [ %inc.i, %for.inc.i.for.body.i_crit_edge ], [ 0, %for.body.i.preheader ]
  %arrayidx.i = getelementptr ptr, ptr %simd_algs, i32 %i.011.i
  %2 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %arrayidx.i, align 4
  %tobool.not.i = icmp eq ptr %3, null
  br i1 %tobool.not.i, label %for.body.i.for.inc.i_crit_edge, label %if.then.i

for.body.i.for.inc.i_crit_edge:                   ; preds = %for.body.i
  call void @__sanitizer_cov_trace_pc() #10
  br label %for.inc.i

if.then.i:                                        ; preds = %for.body.i
  call void @__sanitizer_cov_trace_pc() #10
  %alg.i.i = getelementptr inbounds %struct.simd_skcipher_alg, ptr %3, i32 0, i32 2
  tail call void @crypto_unregister_skcipher(ptr noundef %alg.i.i) #8
  tail call void @kfree(ptr noundef nonnull %3) #8
  %4 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_store4_noabort(i32 %4)
  store ptr null, ptr %arrayidx.i, align 4
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then.i, %for.body.i.for.inc.i_crit_edge
  %inc.i = add nuw nsw i32 %i.011.i, 1
  %exitcond.not.i = icmp eq i32 %inc.i, %count
  br i1 %exitcond.not.i, label %for.inc.i.cleanup_crit_edge, label %for.inc.i.for.body.i_crit_edge

for.inc.i.for.body.i_crit_edge:                   ; preds = %for.inc.i
  call void @__sanitizer_cov_trace_pc() #10
  br label %for.body.i

for.inc.i.cleanup_crit_edge:                      ; preds = %for.inc.i
  call void @__sanitizer_cov_trace_pc() #10
  br label %cleanup

cleanup:                                          ; preds = %for.inc.i.cleanup_crit_edge, %if.end76.cleanup_crit_edge, %for.cond.preheader.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ %call, %entry.cleanup_crit_edge ], [ 0, %for.cond.preheader.cleanup_crit_edge ], [ %1, %for.inc.i.cleanup_crit_edge ], [ 0, %if.end76.cleanup_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @crypto_register_skciphers(ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: argmemonly mustprogress nofree nounwind null_pointer_is_valid readonly willreturn
declare dso_local i32 @strncmp(ptr nocapture noundef, ptr nocapture noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @warn_slowpath_fmt(ptr noundef, i32 noundef, i32 noundef, ptr noundef, ...) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @simd_unregister_skciphers(ptr noundef %algs, i32 noundef %count, ptr nocapture noundef %simd_algs) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  tail call void @crypto_unregister_skciphers(ptr noundef %algs, i32 noundef %count) #8
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %count)
  %cmp10 = icmp sgt i32 %count, 0
  br i1 %cmp10, label %entry.for.body_crit_edge, label %entry.for.end_crit_edge

entry.for.end_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  br label %for.end

entry.for.body_crit_edge:                         ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.inc.for.body_crit_edge, %entry.for.body_crit_edge
  %i.011 = phi i32 [ %inc, %for.inc.for.body_crit_edge ], [ 0, %entry.for.body_crit_edge ]
  %arrayidx = getelementptr ptr, ptr %simd_algs, i32 %i.011
  %0 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %arrayidx, align 4
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %for.body.for.inc_crit_edge, label %if.then

for.body.for.inc_crit_edge:                       ; preds = %for.body
  call void @__sanitizer_cov_trace_pc() #10
  br label %for.inc

if.then:                                          ; preds = %for.body
  call void @__sanitizer_cov_trace_pc() #10
  %alg.i = getelementptr inbounds %struct.simd_skcipher_alg, ptr %1, i32 0, i32 2
  tail call void @crypto_unregister_skcipher(ptr noundef %alg.i) #8
  tail call void @kfree(ptr noundef nonnull %1) #8
  %2 = ptrtoint ptr %arrayidx to i32
  call void @__asan_store4_noabort(i32 %2)
  store ptr null, ptr %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body.for.inc_crit_edge
  %inc = add nuw nsw i32 %i.011, 1
  %exitcond.not = icmp eq i32 %inc, %count
  br i1 %exitcond.not, label %for.inc.for.end_crit_edge, label %for.inc.for.body_crit_edge

for.inc.for.body_crit_edge:                       ; preds = %for.inc
  call void @__sanitizer_cov_trace_pc() #10
  br label %for.body

for.inc.for.end_crit_edge:                        ; preds = %for.inc
  call void @__sanitizer_cov_trace_pc() #10
  br label %for.end

for.end:                                          ; preds = %for.inc.for.end_crit_edge, %entry.for.end_crit_edge
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @crypto_unregister_skciphers(ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @simd_aead_create_compat(ptr noundef %algname, ptr noundef %drvname, ptr noundef %basename) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call ptr @crypto_alloc_aead(ptr noundef %basename, i32 noundef 8192, i32 noundef 8320) #8
  %cmp.i = icmp ugt ptr %call, inttoptr (i32 -4096 to ptr)
  br i1 %cmp.i, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  br label %cleanup

if.end:                                           ; preds = %entry
  %__crt_alg.i = getelementptr inbounds %struct.crypto_aead, ptr %call, i32 0, i32 3, i32 3
  %0 = ptrtoint ptr %__crt_alg.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %__crt_alg.i, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 10) to i32))
  %2 = load ptr, ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 10), align 4
  %call7.i.i = tail call noalias align 8 ptr @kmem_cache_alloc_trace(ptr noundef %2, i32 noundef 3520, i32 noundef 768) #11
  %tobool.not = icmp eq ptr %call7.i.i, null
  br i1 %tobool.not, label %if.end.out_put_tfm_crit_edge, label %if.end7

if.end.out_put_tfm_crit_edge:                     ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #10
  br label %out_put_tfm

if.end7:                                          ; preds = %if.end
  %3 = ptrtoint ptr %call7.i.i to i32
  call void @__asan_store4_noabort(i32 %3)
  store ptr %basename, ptr %call7.i.i, align 128
  %alg8 = getelementptr inbounds %struct.simd_aead_alg, ptr %call7.i.i, i32 0, i32 2
  %cra_name = getelementptr inbounds %struct.simd_aead_alg, ptr %call7.i.i, i32 0, i32 2, i32 10, i32 8
  %call9 = tail call i32 (ptr, i32, ptr, ...) @snprintf(ptr noundef %cra_name, i32 noundef 128, ptr noundef nonnull @.str, ptr noundef %algname)
  call void @__sanitizer_cov_trace_const_cmp4(i32 127, i32 %call9)
  %cmp = icmp sgt i32 %call9, 127
  br i1 %cmp, label %if.end7.out_free_salg_crit_edge, label %if.end11

if.end7.out_free_salg_crit_edge:                  ; preds = %if.end7
  call void @__sanitizer_cov_trace_pc() #10
  br label %out_free_salg

if.end11:                                         ; preds = %if.end7
  %cra_driver_name = getelementptr inbounds %struct.simd_aead_alg, ptr %call7.i.i, i32 0, i32 2, i32 10, i32 9
  %call14 = tail call i32 (ptr, i32, ptr, ...) @snprintf(ptr noundef %cra_driver_name, i32 noundef 128, ptr noundef nonnull @.str, ptr noundef %drvname)
  call void @__sanitizer_cov_trace_const_cmp4(i32 127, i32 %call14)
  %cmp15 = icmp sgt i32 %call14, 127
  br i1 %cmp15, label %if.end11.out_free_salg_crit_edge, label %if.end17

if.end11.out_free_salg_crit_edge:                 ; preds = %if.end11
  call void @__sanitizer_cov_trace_pc() #10
  br label %out_free_salg

if.end17:                                         ; preds = %if.end11
  %cra_flags = getelementptr i8, ptr %1, i32 16
  %4 = ptrtoint ptr %cra_flags to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %cra_flags, align 16
  %and = and i32 %5, 65792
  %or = or i32 %and, 128
  %cra_flags20 = getelementptr inbounds %struct.simd_aead_alg, ptr %call7.i.i, i32 0, i32 2, i32 10, i32 2
  %6 = ptrtoint ptr %cra_flags20 to i32
  call void @__asan_store4_noabort(i32 %6)
  store i32 %or, ptr %cra_flags20, align 16
  %cra_priority = getelementptr i8, ptr %1, i32 32
  %7 = ptrtoint ptr %cra_priority to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %cra_priority, align 32
  %cra_priority23 = getelementptr inbounds %struct.simd_aead_alg, ptr %call7.i.i, i32 0, i32 2, i32 10, i32 6
  %9 = ptrtoint ptr %cra_priority23 to i32
  call void @__asan_store4_noabort(i32 %9)
  store i32 %8, ptr %cra_priority23, align 32
  %cra_blocksize = getelementptr i8, ptr %1, i32 20
  %10 = ptrtoint ptr %cra_blocksize to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %cra_blocksize, align 4
  %cra_blocksize26 = getelementptr inbounds %struct.simd_aead_alg, ptr %call7.i.i, i32 0, i32 2, i32 10, i32 3
  %12 = ptrtoint ptr %cra_blocksize26 to i32
  call void @__asan_store4_noabort(i32 %12)
  store i32 %11, ptr %cra_blocksize26, align 4
  %cra_alignmask = getelementptr i8, ptr %1, i32 28
  %13 = ptrtoint ptr %cra_alignmask to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %cra_alignmask, align 4
  %cra_alignmask29 = getelementptr inbounds %struct.simd_aead_alg, ptr %call7.i.i, i32 0, i32 2, i32 10, i32 5
  %15 = ptrtoint ptr %cra_alignmask29 to i32
  call void @__asan_store4_noabort(i32 %15)
  store i32 %14, ptr %cra_alignmask29, align 4
  %cra_module = getelementptr i8, ptr %1, i32 332
  %16 = ptrtoint ptr %cra_module to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %cra_module, align 4
  %cra_module32 = getelementptr inbounds %struct.simd_aead_alg, ptr %call7.i.i, i32 0, i32 2, i32 10, i32 15
  %18 = ptrtoint ptr %cra_module32 to i32
  call void @__asan_store4_noabort(i32 %18)
  store ptr %17, ptr %cra_module32, align 4
  %cra_ctxsize = getelementptr inbounds %struct.simd_aead_alg, ptr %call7.i.i, i32 0, i32 2, i32 10, i32 4
  %19 = ptrtoint ptr %cra_ctxsize to i32
  call void @__asan_store4_noabort(i32 %19)
  store i32 4, ptr %cra_ctxsize, align 8
  %ivsize = getelementptr i8, ptr %1, i32 -104
  %20 = ptrtoint ptr %ivsize to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %ivsize, align 8
  %ivsize34 = getelementptr inbounds %struct.simd_aead_alg, ptr %call7.i.i, i32 0, i32 2, i32 6
  %22 = ptrtoint ptr %ivsize34 to i32
  call void @__asan_store4_noabort(i32 %22)
  store i32 %21, ptr %ivsize34, align 8
  %maxauthsize = getelementptr i8, ptr %1, i32 -100
  %23 = ptrtoint ptr %maxauthsize to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %maxauthsize, align 4
  %maxauthsize35 = getelementptr inbounds %struct.simd_aead_alg, ptr %call7.i.i, i32 0, i32 2, i32 7
  %25 = ptrtoint ptr %maxauthsize35 to i32
  call void @__asan_store4_noabort(i32 %25)
  store i32 %24, ptr %maxauthsize35, align 4
  %chunksize = getelementptr i8, ptr %1, i32 -96
  %26 = ptrtoint ptr %chunksize to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %chunksize, align 32
  %chunksize36 = getelementptr inbounds %struct.simd_aead_alg, ptr %call7.i.i, i32 0, i32 2, i32 8
  %28 = ptrtoint ptr %chunksize36 to i32
  call void @__asan_store4_noabort(i32 %28)
  store i32 %27, ptr %chunksize36, align 32
  %init = getelementptr inbounds %struct.simd_aead_alg, ptr %call7.i.i, i32 0, i32 2, i32 4
  %29 = ptrtoint ptr %init to i32
  call void @__asan_store4_noabort(i32 %29)
  store ptr @simd_aead_init, ptr %init, align 16
  %exit = getelementptr inbounds %struct.simd_aead_alg, ptr %call7.i.i, i32 0, i32 2, i32 5
  %30 = ptrtoint ptr %exit to i32
  call void @__asan_store4_noabort(i32 %30)
  store ptr @simd_aead_exit, ptr %exit, align 4
  %31 = ptrtoint ptr %alg8 to i32
  call void @__asan_store4_noabort(i32 %31)
  store ptr @simd_aead_setkey, ptr %alg8, align 128
  %setauthsize = getelementptr inbounds %struct.simd_aead_alg, ptr %call7.i.i, i32 0, i32 2, i32 1
  %32 = ptrtoint ptr %setauthsize to i32
  call void @__asan_store4_noabort(i32 %32)
  store ptr @simd_aead_setauthsize, ptr %setauthsize, align 4
  %encrypt = getelementptr inbounds %struct.simd_aead_alg, ptr %call7.i.i, i32 0, i32 2, i32 2
  %33 = ptrtoint ptr %encrypt to i32
  call void @__asan_store4_noabort(i32 %33)
  store ptr @simd_aead_encrypt, ptr %encrypt, align 8
  %decrypt = getelementptr inbounds %struct.simd_aead_alg, ptr %call7.i.i, i32 0, i32 2, i32 3
  %34 = ptrtoint ptr %decrypt to i32
  call void @__asan_store4_noabort(i32 %34)
  store ptr @simd_aead_decrypt, ptr %decrypt, align 4
  %call37 = tail call i32 @crypto_register_aead(ptr noundef %alg8) #8
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call37)
  %tobool38.not = icmp eq i32 %call37, 0
  br i1 %tobool38.not, label %if.end17.out_put_tfm_crit_edge, label %if.end17.out_free_salg_crit_edge

if.end17.out_free_salg_crit_edge:                 ; preds = %if.end17
  call void @__sanitizer_cov_trace_pc() #10
  br label %out_free_salg

if.end17.out_put_tfm_crit_edge:                   ; preds = %if.end17
  call void @__sanitizer_cov_trace_pc() #10
  br label %out_put_tfm

out_put_tfm:                                      ; preds = %out_free_salg, %if.end17.out_put_tfm_crit_edge, %if.end.out_put_tfm_crit_edge
  %salg.0 = phi ptr [ %35, %out_free_salg ], [ %call7.i.i, %if.end17.out_put_tfm_crit_edge ], [ inttoptr (i32 -12 to ptr), %if.end.out_put_tfm_crit_edge ]
  %base.i.i = getelementptr inbounds %struct.crypto_aead, ptr %call, i32 0, i32 3
  tail call void @crypto_destroy_tfm(ptr noundef %call, ptr noundef %base.i.i) #8
  br label %cleanup

out_free_salg:                                    ; preds = %if.end17.out_free_salg_crit_edge, %if.end11.out_free_salg_crit_edge, %if.end7.out_free_salg_crit_edge
  %err.0 = phi i32 [ -36, %if.end7.out_free_salg_crit_edge ], [ -36, %if.end11.out_free_salg_crit_edge ], [ %call37, %if.end17.out_free_salg_crit_edge ]
  tail call void @kfree(ptr noundef nonnull %call7.i.i) #8
  %35 = inttoptr i32 %err.0 to ptr
  br label %out_put_tfm

cleanup:                                          ; preds = %out_put_tfm, %entry.cleanup_crit_edge
  %retval.0 = phi ptr [ %salg.0, %out_put_tfm ], [ %call, %entry.cleanup_crit_edge ]
  ret ptr %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @crypto_alloc_aead(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @simd_aead_init(ptr nocapture noundef %tfm) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  %__crt_alg.i = getelementptr inbounds %struct.crypto_aead, ptr %tfm, i32 0, i32 3, i32 3
  %0 = ptrtoint ptr %__crt_alg.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %__crt_alg.i, align 4
  %add.ptr = getelementptr i8, ptr %1, i32 -256
  %2 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %add.ptr, align 128
  %call2 = tail call ptr @cryptd_alloc_aead(ptr noundef %3, i32 noundef 8192, i32 noundef 8192) #8
  %cmp.i = icmp ugt ptr %call2, inttoptr (i32 -4096 to ptr)
  br i1 %cmp.i, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  %4 = ptrtoint ptr %call2 to i32
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  %__crt_ctx.i.i = getelementptr inbounds %struct.crypto_aead, ptr %tfm, i32 1
  %5 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_store4_noabort(i32 %5)
  store ptr %call2, ptr %__crt_ctx.i.i, align 4
  %call6 = tail call ptr @cryptd_aead_child(ptr noundef %call2) #8
  %reqsize.i = getelementptr inbounds %struct.crypto_aead, ptr %call6, i32 0, i32 1
  %6 = ptrtoint ptr %reqsize.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %reqsize.i, align 4
  %reqsize.i24 = getelementptr inbounds %struct.crypto_aead, ptr %call2, i32 0, i32 1
  %8 = ptrtoint ptr %reqsize.i24 to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %reqsize.i24, align 4
  %10 = tail call i32 @llvm.umax.i32(i32 %7, i32 %9)
  %add = add i32 %10, 128
  %reqsize1.i = getelementptr inbounds %struct.crypto_aead, ptr %tfm, i32 0, i32 1
  %11 = ptrtoint ptr %reqsize1.i to i32
  call void @__asan_store4_noabort(i32 %11)
  store i32 %add, ptr %reqsize1.i, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %4, %if.then ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @simd_aead_exit(ptr nocapture noundef readonly %tfm) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  %__crt_ctx.i.i = getelementptr inbounds %struct.crypto_aead, ptr %tfm, i32 1
  %0 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %__crt_ctx.i.i, align 4
  tail call void @cryptd_free_aead(ptr noundef %1) #8
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @simd_aead_setkey(ptr nocapture noundef readonly %tfm, ptr noundef %key, i32 noundef %key_len) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  %__crt_ctx.i.i = getelementptr inbounds %struct.crypto_aead, ptr %tfm, i32 1
  %0 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %__crt_ctx.i.i, align 4
  %base.i.i = getelementptr inbounds %struct.crypto_aead, ptr %1, i32 0, i32 3
  %2 = ptrtoint ptr %base.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %base.i.i, align 128
  %and.i.i = and i32 %3, -1048321
  store i32 %and.i.i, ptr %base.i.i, align 128
  %base.i.i6 = getelementptr inbounds %struct.crypto_aead, ptr %tfm, i32 0, i32 3
  %4 = ptrtoint ptr %base.i.i6 to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %base.i.i6, align 128
  %and = and i32 %5, 1048320
  %or.i.i = or i32 %and, %and.i.i
  store i32 %or.i.i, ptr %base.i.i, align 128
  %call2 = tail call i32 @crypto_aead_setkey(ptr noundef %1, ptr noundef %key, i32 noundef %key_len) #8
  ret i32 %call2
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @simd_aead_setauthsize(ptr nocapture noundef readonly %tfm, i32 noundef %authsize) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  %__crt_ctx.i.i = getelementptr inbounds %struct.crypto_aead, ptr %tfm, i32 1
  %0 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %__crt_ctx.i.i, align 4
  %call1 = tail call i32 @crypto_aead_setauthsize(ptr noundef %1, i32 noundef %authsize) #8
  ret i32 %call1
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @simd_aead_encrypt(ptr noundef %req) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  %tfm.i = getelementptr inbounds %struct.crypto_async_request, ptr %req, i32 0, i32 3
  %0 = ptrtoint ptr %tfm.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %tfm.i, align 16
  %__crt_ctx.i.i = getelementptr i8, ptr %1, i32 128
  %__ctx.i = getelementptr inbounds %struct.aead_request, ptr %req, i32 0, i32 7
  %2 = call ptr @memcpy(ptr %__ctx.i, ptr %req, i32 128)
  %3 = tail call i32 @llvm.read_register.i32(metadata !30) #8
  %and.i.i.i = and i32 %3, -16384
  %4 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %4, i32 0, i32 1
  %5 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %preempt_count.i.i, align 4
  %and.i = and i32 %6, 15728640
  %7 = tail call i32 @llvm.read_register.i32(metadata !30) #8
  %and.i.i6.i = and i32 %7, -16384
  %8 = inttoptr i32 %and.i.i6.i to ptr
  %preempt_count.i7.i = getelementptr inbounds %struct.thread_info, ptr %8, i32 0, i32 1
  %9 = ptrtoint ptr %preempt_count.i7.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load volatile i32, ptr %preempt_count.i7.i, align 4
  %and2.i = and i32 %10, 983040
  %or.i = or i32 %and2.i, %and.i
  %11 = tail call i32 @llvm.read_register.i32(metadata !30) #8
  %and.i.i8.i = and i32 %11, -16384
  %12 = inttoptr i32 %and.i.i8.i to ptr
  %preempt_count.i9.i = getelementptr inbounds %struct.thread_info, ptr %12, i32 0, i32 1
  %13 = ptrtoint ptr %preempt_count.i9.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %preempt_count.i9.i, align 4
  %and4.i = and i32 %14, 65280
  %or5.i = or i32 %or.i, %and4.i
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %or5.i)
  %tobool.not.i = icmp eq i32 %or5.i, 0
  br i1 %tobool.not.i, label %lor.lhs.false, label %entry.if.then_crit_edge

entry.if.then_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.then

lor.lhs.false:                                    ; preds = %entry
  %15 = tail call i32 @llvm.read_register.i32(metadata !30) #8
  %and.i.i = and i32 %15, -16384
  %16 = inttoptr i32 %and.i.i to ptr
  %preempt_count.i = getelementptr inbounds %struct.thread_info, ptr %16, i32 0, i32 1
  %17 = ptrtoint ptr %preempt_count.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load volatile i32, ptr %preempt_count.i, align 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %18)
  %cmp.not = icmp eq i32 %18, 0
  br i1 %cmp.not, label %lor.lhs.false.if.else_crit_edge, label %land.lhs.true

lor.lhs.false.if.else_crit_edge:                  ; preds = %lor.lhs.false
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.else

land.lhs.true:                                    ; preds = %lor.lhs.false
  %19 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %__crt_ctx.i.i, align 4
  %call5 = tail call zeroext i1 @cryptd_aead_queued(ptr noundef %20) #8
  br i1 %call5, label %land.lhs.true.if.then_crit_edge, label %land.lhs.true.if.else_crit_edge

land.lhs.true.if.else_crit_edge:                  ; preds = %land.lhs.true
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.else

land.lhs.true.if.then_crit_edge:                  ; preds = %land.lhs.true
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.then

if.then:                                          ; preds = %land.lhs.true.if.then_crit_edge, %entry.if.then_crit_edge
  %21 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %__crt_ctx.i.i, align 4
  br label %if.end

if.else:                                          ; preds = %land.lhs.true.if.else_crit_edge, %lor.lhs.false.if.else_crit_edge
  %23 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %__crt_ctx.i.i, align 4
  %call8 = tail call ptr @cryptd_aead_child(ptr noundef %24) #8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %child.0 = phi ptr [ %22, %if.then ], [ %call8, %if.else ]
  %base.i.i = getelementptr inbounds %struct.crypto_aead, ptr %child.0, i32 0, i32 3
  %tfm1.i = getelementptr inbounds %struct.aead_request, ptr %req, i32 1, i32 0, i32 3
  %25 = ptrtoint ptr %tfm1.i to i32
  call void @__asan_store4_noabort(i32 %25)
  store ptr %base.i.i, ptr %tfm1.i, align 16
  %call9 = tail call i32 @crypto_aead_encrypt(ptr noundef %__ctx.i) #8
  ret i32 %call9
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @simd_aead_decrypt(ptr noundef %req) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  %tfm.i = getelementptr inbounds %struct.crypto_async_request, ptr %req, i32 0, i32 3
  %0 = ptrtoint ptr %tfm.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %tfm.i, align 16
  %__crt_ctx.i.i = getelementptr i8, ptr %1, i32 128
  %__ctx.i = getelementptr inbounds %struct.aead_request, ptr %req, i32 0, i32 7
  %2 = call ptr @memcpy(ptr %__ctx.i, ptr %req, i32 128)
  %3 = tail call i32 @llvm.read_register.i32(metadata !30) #8
  %and.i.i.i = and i32 %3, -16384
  %4 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %4, i32 0, i32 1
  %5 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %preempt_count.i.i, align 4
  %and.i = and i32 %6, 15728640
  %7 = tail call i32 @llvm.read_register.i32(metadata !30) #8
  %and.i.i6.i = and i32 %7, -16384
  %8 = inttoptr i32 %and.i.i6.i to ptr
  %preempt_count.i7.i = getelementptr inbounds %struct.thread_info, ptr %8, i32 0, i32 1
  %9 = ptrtoint ptr %preempt_count.i7.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load volatile i32, ptr %preempt_count.i7.i, align 4
  %and2.i = and i32 %10, 983040
  %or.i = or i32 %and2.i, %and.i
  %11 = tail call i32 @llvm.read_register.i32(metadata !30) #8
  %and.i.i8.i = and i32 %11, -16384
  %12 = inttoptr i32 %and.i.i8.i to ptr
  %preempt_count.i9.i = getelementptr inbounds %struct.thread_info, ptr %12, i32 0, i32 1
  %13 = ptrtoint ptr %preempt_count.i9.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %preempt_count.i9.i, align 4
  %and4.i = and i32 %14, 65280
  %or5.i = or i32 %or.i, %and4.i
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %or5.i)
  %tobool.not.i = icmp eq i32 %or5.i, 0
  br i1 %tobool.not.i, label %lor.lhs.false, label %entry.if.then_crit_edge

entry.if.then_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.then

lor.lhs.false:                                    ; preds = %entry
  %15 = tail call i32 @llvm.read_register.i32(metadata !30) #8
  %and.i.i = and i32 %15, -16384
  %16 = inttoptr i32 %and.i.i to ptr
  %preempt_count.i = getelementptr inbounds %struct.thread_info, ptr %16, i32 0, i32 1
  %17 = ptrtoint ptr %preempt_count.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load volatile i32, ptr %preempt_count.i, align 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %18)
  %cmp.not = icmp eq i32 %18, 0
  br i1 %cmp.not, label %lor.lhs.false.if.else_crit_edge, label %land.lhs.true

lor.lhs.false.if.else_crit_edge:                  ; preds = %lor.lhs.false
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.else

land.lhs.true:                                    ; preds = %lor.lhs.false
  %19 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %__crt_ctx.i.i, align 4
  %call5 = tail call zeroext i1 @cryptd_aead_queued(ptr noundef %20) #8
  br i1 %call5, label %land.lhs.true.if.then_crit_edge, label %land.lhs.true.if.else_crit_edge

land.lhs.true.if.else_crit_edge:                  ; preds = %land.lhs.true
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.else

land.lhs.true.if.then_crit_edge:                  ; preds = %land.lhs.true
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.then

if.then:                                          ; preds = %land.lhs.true.if.then_crit_edge, %entry.if.then_crit_edge
  %21 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %__crt_ctx.i.i, align 4
  br label %if.end

if.else:                                          ; preds = %land.lhs.true.if.else_crit_edge, %lor.lhs.false.if.else_crit_edge
  %23 = ptrtoint ptr %__crt_ctx.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %__crt_ctx.i.i, align 4
  %call8 = tail call ptr @cryptd_aead_child(ptr noundef %24) #8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %child.0 = phi ptr [ %22, %if.then ], [ %call8, %if.else ]
  %base.i.i = getelementptr inbounds %struct.crypto_aead, ptr %child.0, i32 0, i32 3
  %tfm1.i = getelementptr inbounds %struct.aead_request, ptr %req, i32 1, i32 0, i32 3
  %25 = ptrtoint ptr %tfm1.i to i32
  call void @__asan_store4_noabort(i32 %25)
  store ptr %base.i.i, ptr %tfm1.i, align 16
  %call9 = tail call i32 @crypto_aead_decrypt(ptr noundef %__ctx.i) #8
  ret i32 %call9
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @crypto_register_aead(ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @simd_aead_create(ptr noundef %algname, ptr noundef %basename) #0 align 64 {
entry:
  %drvname = alloca [128 x i8], align 1
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  call void @llvm.lifetime.start.p0(i64 128, ptr nonnull %drvname) #8
  %0 = call ptr @memset(ptr %drvname, i32 255, i32 128)
  %call = call i32 (ptr, i32, ptr, ...) @snprintf(ptr noundef nonnull %drvname, i32 noundef 128, ptr noundef nonnull @.str.1, ptr noundef %basename)
  call void @__sanitizer_cov_trace_const_cmp4(i32 127, i32 %call)
  %cmp = icmp sgt i32 %call, 127
  br i1 %cmp, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  %call3 = call ptr @simd_aead_create_compat(ptr noundef %algname, ptr noundef nonnull %drvname, ptr noundef %basename)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry.cleanup_crit_edge
  %retval.0 = phi ptr [ %call3, %if.end ], [ inttoptr (i32 -36 to ptr), %entry.cleanup_crit_edge ]
  call void @llvm.lifetime.end.p0(i64 128, ptr nonnull %drvname) #8
  ret ptr %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @simd_aead_free(ptr noundef %salg) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  %alg = getelementptr inbounds %struct.simd_aead_alg, ptr %salg, i32 0, i32 2
  tail call void @crypto_unregister_aead(ptr noundef %alg) #8
  tail call void @kfree(ptr noundef %salg) #8
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @crypto_unregister_aead(ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simd_register_aeads_compat(ptr noundef %algs, i32 noundef %count, ptr nocapture noundef %simd_algs) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call i32 @crypto_register_aeads(ptr noundef %algs, i32 noundef %count) #8
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %for.cond.preheader, label %entry.cleanup_crit_edge

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  br label %cleanup

for.cond.preheader:                               ; preds = %entry
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %count)
  %cmp106 = icmp sgt i32 %count, 0
  br i1 %cmp106, label %for.cond.preheader.for.body_crit_edge, label %for.cond.preheader.cleanup_crit_edge

for.cond.preheader.cleanup_crit_edge:             ; preds = %for.cond.preheader
  call void @__sanitizer_cov_trace_pc() #10
  br label %cleanup

for.cond.preheader.for.body_crit_edge:            ; preds = %for.cond.preheader
  br label %for.body

for.body:                                         ; preds = %if.end76.for.body_crit_edge, %for.cond.preheader.for.body_crit_edge
  %i.0107 = phi i32 [ %inc, %if.end76.for.body_crit_edge ], [ 0, %for.cond.preheader.for.body_crit_edge ]
  %cra_name = getelementptr %struct.aead_alg, ptr %algs, i32 %i.0107, i32 10, i32 8
  %call1 = tail call i32 @strncmp(ptr noundef %cra_name, ptr noundef nonnull dereferenceable(3) @.str.2, i32 noundef 2)
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call1)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %for.body.if.end17_crit_edge, label %do.end, !prof !40

for.body.if.end17_crit_edge:                      ; preds = %for.body
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.end17

do.end:                                           ; preds = %for.body
  call void @__sanitizer_cov_trace_pc() #10
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.3, i32 noundef 491, i32 noundef 9, ptr noundef null) #8
  br label %if.end17

if.end17:                                         ; preds = %do.end, %for.body.if.end17_crit_edge
  %cra_driver_name = getelementptr %struct.aead_alg, ptr %algs, i32 %i.0107, i32 10, i32 9
  %call28 = tail call i32 @strncmp(ptr noundef %cra_driver_name, ptr noundef nonnull dereferenceable(3) @.str.2, i32 noundef 2)
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call28)
  %tobool29.not = icmp eq i32 %call28, 0
  br i1 %tobool29.not, label %if.end17.if.end51_crit_edge, label %do.end45, !prof !40

if.end17.if.end51_crit_edge:                      ; preds = %if.end17
  call void @__sanitizer_cov_trace_pc() #10
  br label %if.end51

do.end45:                                         ; preds = %if.end17
  call void @__sanitizer_cov_trace_pc() #10
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.3, i32 noundef 492, i32 noundef 9, ptr noundef null) #8
  br label %if.end51

if.end51:                                         ; preds = %do.end45, %if.end17.if.end51_crit_edge
  %add.ptr = getelementptr i8, ptr %cra_name, i32 2
  %add.ptr67 = getelementptr i8, ptr %cra_driver_name, i32 2
  %call72 = tail call ptr @simd_aead_create_compat(ptr noundef %add.ptr, ptr noundef %add.ptr67, ptr noundef %cra_driver_name)
  %cmp.i = icmp ugt ptr %call72, inttoptr (i32 -4096 to ptr)
  br i1 %cmp.i, label %for.body.i.preheader, label %if.end76

if.end76:                                         ; preds = %if.end51
  %arrayidx77 = getelementptr ptr, ptr %simd_algs, i32 %i.0107
  %0 = ptrtoint ptr %arrayidx77 to i32
  call void @__asan_store4_noabort(i32 %0)
  store ptr %call72, ptr %arrayidx77, align 4
  %inc = add nuw nsw i32 %i.0107, 1
  %exitcond.not = icmp eq i32 %inc, %count
  br i1 %exitcond.not, label %if.end76.cleanup_crit_edge, label %if.end76.for.body_crit_edge

if.end76.for.body_crit_edge:                      ; preds = %if.end76
  call void @__sanitizer_cov_trace_pc() #10
  br label %for.body

if.end76.cleanup_crit_edge:                       ; preds = %if.end76
  call void @__sanitizer_cov_trace_pc() #10
  br label %cleanup

for.body.i.preheader:                             ; preds = %if.end51
  %1 = ptrtoint ptr %call72 to i32
  tail call void @crypto_unregister_aeads(ptr noundef %algs, i32 noundef %count) #8
  br label %for.body.i

for.body.i:                                       ; preds = %for.inc.i.for.body.i_crit_edge, %for.body.i.preheader
  %i.011.i = phi i32 [ %inc.i, %for.inc.i.for.body.i_crit_edge ], [ 0, %for.body.i.preheader ]
  %arrayidx.i = getelementptr ptr, ptr %simd_algs, i32 %i.011.i
  %2 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %arrayidx.i, align 4
  %tobool.not.i = icmp eq ptr %3, null
  br i1 %tobool.not.i, label %for.body.i.for.inc.i_crit_edge, label %if.then.i

for.body.i.for.inc.i_crit_edge:                   ; preds = %for.body.i
  call void @__sanitizer_cov_trace_pc() #10
  br label %for.inc.i

if.then.i:                                        ; preds = %for.body.i
  call void @__sanitizer_cov_trace_pc() #10
  %alg.i.i = getelementptr inbounds %struct.simd_aead_alg, ptr %3, i32 0, i32 2
  tail call void @crypto_unregister_aead(ptr noundef %alg.i.i) #8
  tail call void @kfree(ptr noundef nonnull %3) #8
  %4 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_store4_noabort(i32 %4)
  store ptr null, ptr %arrayidx.i, align 4
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then.i, %for.body.i.for.inc.i_crit_edge
  %inc.i = add nuw nsw i32 %i.011.i, 1
  %exitcond.not.i = icmp eq i32 %inc.i, %count
  br i1 %exitcond.not.i, label %for.inc.i.cleanup_crit_edge, label %for.inc.i.for.body.i_crit_edge

for.inc.i.for.body.i_crit_edge:                   ; preds = %for.inc.i
  call void @__sanitizer_cov_trace_pc() #10
  br label %for.body.i

for.inc.i.cleanup_crit_edge:                      ; preds = %for.inc.i
  call void @__sanitizer_cov_trace_pc() #10
  br label %cleanup

cleanup:                                          ; preds = %for.inc.i.cleanup_crit_edge, %if.end76.cleanup_crit_edge, %for.cond.preheader.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ %call, %entry.cleanup_crit_edge ], [ 0, %for.cond.preheader.cleanup_crit_edge ], [ %1, %for.inc.i.cleanup_crit_edge ], [ 0, %if.end76.cleanup_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @crypto_register_aeads(ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @simd_unregister_aeads(ptr noundef %algs, i32 noundef %count, ptr nocapture noundef %simd_algs) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #10
  call void @llvm.arm.gnu.eabi.mcount()
  tail call void @crypto_unregister_aeads(ptr noundef %algs, i32 noundef %count) #8
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %count)
  %cmp10 = icmp sgt i32 %count, 0
  br i1 %cmp10, label %entry.for.body_crit_edge, label %entry.for.end_crit_edge

entry.for.end_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #10
  br label %for.end

entry.for.body_crit_edge:                         ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.inc.for.body_crit_edge, %entry.for.body_crit_edge
  %i.011 = phi i32 [ %inc, %for.inc.for.body_crit_edge ], [ 0, %entry.for.body_crit_edge ]
  %arrayidx = getelementptr ptr, ptr %simd_algs, i32 %i.011
  %0 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %arrayidx, align 4
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %for.body.for.inc_crit_edge, label %if.then

for.body.for.inc_crit_edge:                       ; preds = %for.body
  call void @__sanitizer_cov_trace_pc() #10
  br label %for.inc

if.then:                                          ; preds = %for.body
  call void @__sanitizer_cov_trace_pc() #10
  %alg.i = getelementptr inbounds %struct.simd_aead_alg, ptr %1, i32 0, i32 2
  tail call void @crypto_unregister_aead(ptr noundef %alg.i) #8
  tail call void @kfree(ptr noundef nonnull %1) #8
  %2 = ptrtoint ptr %arrayidx to i32
  call void @__asan_store4_noabort(i32 %2)
  store ptr null, ptr %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body.for.inc_crit_edge
  %inc = add nuw nsw i32 %i.011, 1
  %exitcond.not = icmp eq i32 %inc, %count
  br i1 %exitcond.not, label %for.inc.for.end_crit_edge, label %for.inc.for.body_crit_edge

for.inc.for.body_crit_edge:                       ; preds = %for.inc
  call void @__sanitizer_cov_trace_pc() #10
  br label %for.body

for.inc.for.end_crit_edge:                        ; preds = %for.inc
  call void @__sanitizer_cov_trace_pc() #10
  br label %for.end

for.end:                                          ; preds = %for.inc.for.end_crit_edge, %entry.for.end_crit_edge
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @crypto_unregister_aeads(ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid allocsize(2)
declare dso_local noalias ptr @kmem_cache_alloc_trace(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #5

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @cryptd_alloc_skcipher(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @cryptd_skcipher_child(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @cryptd_free_skcipher(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @crypto_skcipher_setkey(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @cryptd_skcipher_queued(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @crypto_skcipher_encrypt(ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind readonly
declare i32 @llvm.read_register.i32(metadata) #6

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @crypto_skcipher_decrypt(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @crypto_destroy_tfm(ptr noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @cryptd_alloc_aead(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @cryptd_aead_child(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @cryptd_free_aead(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @crypto_aead_setkey(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @crypto_aead_setauthsize(ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @cryptd_aead_queued(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @crypto_aead_encrypt(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @crypto_aead_decrypt(ptr noundef) local_unnamed_addr #2

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.umax.i32(i32, i32) #7

; Function Attrs: nounwind
declare void @llvm.arm.gnu.eabi.mcount() #8

declare void @__sanitizer_cov_trace_const_cmp4(i32 zeroext, i32 zeroext)

declare void @__sanitizer_cov_trace_pc()

declare void @__asan_load4_noabort(i32)

declare void @__asan_store4_noabort(i32)

declare ptr @memcpy(ptr, ptr, i32)

declare ptr @memset(ptr, i32, i32)

declare void @__asan_register_globals(i32, i32)

declare void @__asan_unregister_globals(i32, i32)

; Function Attrs: nounwind uwtable(sync)
define internal void @asan.module_ctor() #9 {
  call void @__asan_register_globals(i32 ptrtoint (ptr @0 to i32), i32 4)
  ret void
}

; Function Attrs: nounwind uwtable(sync)
define internal void @asan.module_dtor() #9 {
  call void @__asan_unregister_globals(i32 ptrtoint (ptr @0 to i32), i32 4)
  ret void
}

attributes #0 = { nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #1 = { argmemonly nocallback nofree nosync nounwind willreturn }
attributes #2 = { null_pointer_is_valid "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #3 = { nofree nounwind null_pointer_is_valid "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #4 = { argmemonly mustprogress nofree nounwind null_pointer_is_valid readonly willreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #5 = { null_pointer_is_valid allocsize(2) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #6 = { nounwind readonly }
attributes #7 = { nocallback nofree nosync nounwind readnone speculatable willreturn }
attributes #8 = { nounwind }
attributes #9 = { nounwind uwtable(sync) "frame-pointer"="all" }
attributes #10 = { nomerge }
attributes #11 = { nounwind allocsize(2) }

!llvm.asan.globals = !{!0, !2, !4, !6, !8, !10, !12, !13, !15, !17, !19, !21, !23, !25, !27, !29}
!llvm.named.register.sp = !{!30}
!llvm.module.flags = !{!31, !32, !33, !34, !35, !36, !37, !38}
!llvm.ident = !{!39}

!0 = !{ptr @.str, !1, !"<string literal>", i1 false, i1 false}
!1 = !{!"../crypto/simd.c", i32 166, i32 56}
!2 = !{ptr @__ksymtab_simd_skcipher_create_compat, !3, !"__ksymtab_simd_skcipher_create_compat", i1 false, i1 false}
!3 = !{!"../crypto/simd.c", i32 207, i32 1}
!4 = !{ptr @.str.1, !5, !"<string literal>", i1 false, i1 false}
!5 = !{!"../crypto/simd.c", i32 214, i32 45}
!6 = !{ptr @__ksymtab_simd_skcipher_create, !7, !"__ksymtab_simd_skcipher_create", i1 false, i1 false}
!7 = !{!"../crypto/simd.c", i32 220, i32 1}
!8 = !{ptr @__ksymtab_simd_skcipher_free, !9, !"__ksymtab_simd_skcipher_free", i1 false, i1 false}
!9 = !{!"../crypto/simd.c", i32 227, i32 1}
!10 = !{ptr @.str.2, !11, !"<string literal>", i1 false, i1 false}
!11 = !{!"../crypto/simd.c", i32 244, i32 3}
!12 = !{ptr @.str.3, !11, !"<string literal>", i1 false, i1 false}
!13 = !{ptr @__ksymtab_simd_register_skciphers_compat, !14, !"__ksymtab_simd_register_skciphers_compat", i1 false, i1 false}
!14 = !{!"../crypto/simd.c", i32 261, i32 1}
!15 = !{ptr @__ksymtab_simd_unregister_skciphers, !16, !"__ksymtab_simd_unregister_skciphers", i1 false, i1 false}
!16 = !{!"../crypto/simd.c", i32 277, i32 1}
!17 = !{ptr @__ksymtab_simd_aead_create_compat, !18, !"__ksymtab_simd_aead_create_compat", i1 false, i1 false}
!18 = !{!"../crypto/simd.c", i32 454, i32 1}
!19 = !{ptr @__ksymtab_simd_aead_create, !20, !"__ksymtab_simd_aead_create", i1 false, i1 false}
!20 = !{!"../crypto/simd.c", i32 467, i32 1}
!21 = !{ptr @__ksymtab_simd_aead_free, !22, !"__ksymtab_simd_aead_free", i1 false, i1 false}
!22 = !{!"../crypto/simd.c", i32 474, i32 1}
!23 = !{ptr @__ksymtab_simd_register_aeads_compat, !24, !"__ksymtab_simd_register_aeads_compat", i1 false, i1 false}
!24 = !{!"../crypto/simd.c", i32 508, i32 1}
!25 = !{ptr @__ksymtab_simd_unregister_aeads, !26, !"__ksymtab_simd_unregister_aeads", i1 false, i1 false}
!26 = !{!"../crypto/simd.c", i32 524, i32 1}
!27 = !{ptr @__UNIQUE_ID_file177, !28, !"__UNIQUE_ID_file177", i1 false, i1 false}
!28 = !{!"../crypto/simd.c", i32 526, i32 1}
!29 = !{ptr @__UNIQUE_ID_license178, !28, !"__UNIQUE_ID_license178", i1 false, i1 false}
!30 = !{!"sp"}
!31 = !{i32 1, !"wchar_size", i32 2}
!32 = !{i32 1, !"min_enum_size", i32 4}
!33 = !{i32 8, !"branch-target-enforcement", i32 0}
!34 = !{i32 8, !"sign-return-address", i32 0}
!35 = !{i32 8, !"sign-return-address-all", i32 0}
!36 = !{i32 8, !"sign-return-address-with-bkey", i32 0}
!37 = !{i32 7, !"uwtable", i32 1}
!38 = !{i32 7, !"frame-pointer", i32 2}
!39 = !{!"clang version 15.0.0 (git@github.com:linkeLi0421/llvm-project15-IRDumperPass.git 23ab625cb005cd08da083f9b643a7feed9af8abe)"}
!40 = !{!"branch_weights", i32 2000, i32 1}
