; ModuleID = '/llk/IR_all_yes/drivers/clk/qcom/clk-rcg.c_pt.bc'
source_filename = "../drivers/clk/qcom/clk-rcg.c"
target datalayout = "E-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64"
target triple = "armebv6k-unknown-linux-gnueabi"

module asm ".syntax unified"
module asm "\09.section \22___kcrctab_gpl+clk_rcg_ops\22, \22a\22\09"
module asm "\09.weak\09__crc_clk_rcg_ops\09\09\09\09"
module asm "\09.long\09__crc_clk_rcg_ops\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_clk_rcg_ops:\09\09\09\09\09"
module asm "\09.asciz \09\22clk_rcg_ops\22\09\09\09\09\09"
module asm "__kstrtabns_clk_rcg_ops:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+clk_rcg_bypass_ops\22, \22a\22\09"
module asm "\09.weak\09__crc_clk_rcg_bypass_ops\09\09\09\09"
module asm "\09.long\09__crc_clk_rcg_bypass_ops\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_clk_rcg_bypass_ops:\09\09\09\09\09"
module asm "\09.asciz \09\22clk_rcg_bypass_ops\22\09\09\09\09\09"
module asm "__kstrtabns_clk_rcg_bypass_ops:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+clk_rcg_bypass2_ops\22, \22a\22\09"
module asm "\09.weak\09__crc_clk_rcg_bypass2_ops\09\09\09\09"
module asm "\09.long\09__crc_clk_rcg_bypass2_ops\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_clk_rcg_bypass2_ops:\09\09\09\09\09"
module asm "\09.asciz \09\22clk_rcg_bypass2_ops\22\09\09\09\09\09"
module asm "__kstrtabns_clk_rcg_bypass2_ops:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+clk_rcg_pixel_ops\22, \22a\22\09"
module asm "\09.weak\09__crc_clk_rcg_pixel_ops\09\09\09\09"
module asm "\09.long\09__crc_clk_rcg_pixel_ops\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_clk_rcg_pixel_ops:\09\09\09\09\09"
module asm "\09.asciz \09\22clk_rcg_pixel_ops\22\09\09\09\09\09"
module asm "__kstrtabns_clk_rcg_pixel_ops:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+clk_rcg_esc_ops\22, \22a\22\09"
module asm "\09.weak\09__crc_clk_rcg_esc_ops\09\09\09\09"
module asm "\09.long\09__crc_clk_rcg_esc_ops\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_clk_rcg_esc_ops:\09\09\09\09\09"
module asm "\09.asciz \09\22clk_rcg_esc_ops\22\09\09\09\09\09"
module asm "__kstrtabns_clk_rcg_esc_ops:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+clk_rcg_lcc_ops\22, \22a\22\09"
module asm "\09.weak\09__crc_clk_rcg_lcc_ops\09\09\09\09"
module asm "\09.long\09__crc_clk_rcg_lcc_ops\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_clk_rcg_lcc_ops:\09\09\09\09\09"
module asm "\09.asciz \09\22clk_rcg_lcc_ops\22\09\09\09\09\09"
module asm "__kstrtabns_clk_rcg_lcc_ops:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+clk_dyn_rcg_ops\22, \22a\22\09"
module asm "\09.weak\09__crc_clk_dyn_rcg_ops\09\09\09\09"
module asm "\09.long\09__crc_clk_dyn_rcg_ops\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_clk_dyn_rcg_ops:\09\09\09\09\09"
module asm "\09.asciz \09\22clk_dyn_rcg_ops\22\09\09\09\09\09"
module asm "__kstrtabns_clk_dyn_rcg_ops:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"

%struct.clk_ops = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.kernel_symbol = type { i32, ptr, ptr }
%struct.atomic_t = type { i32 }
%struct.frac_entry = type { i32, i32 }
%struct.clk_regmap = type { %struct.clk_hw, ptr, i32, i32, i8 }
%struct.clk_hw = type { ptr, ptr, ptr }
%struct.parent_map = type { i8, i8 }
%struct.freq_tbl = type { i32, i8, i8, i16, i16 }
%struct.clk_rate_request = type { i32, i32, i32, i32, ptr }
%struct.mn = type { i8, i8, i8, i8, i8, i8, i8 }
%struct.pre_div = type { i8, i8 }
%struct.src_sel = type { i8, ptr }
%struct.clk_rcg = type { i32, i32, %struct.mn, %struct.pre_div, %struct.src_sel, ptr, %struct.clk_regmap }
%struct.clk_dyn_rcg = type { [2 x i32], [2 x i32], i32, i8, [2 x %struct.mn], [2 x %struct.pre_div], [2 x %struct.src_sel], ptr, %struct.clk_regmap }

@clk_rcg_ops = dso_local constant { %struct.clk_ops, [60 x i8] } { %struct.clk_ops { ptr null, ptr null, ptr null, ptr null, ptr @clk_enable_regmap, ptr @clk_disable_regmap, ptr null, ptr null, ptr null, ptr null, ptr @clk_rcg_recalc_rate, ptr null, ptr @clk_rcg_determine_rate, ptr @clk_rcg_set_parent, ptr @clk_rcg_get_parent, ptr @clk_rcg_set_rate, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null }, [60 x i8] zeroinitializer }, align 32
@__kstrtab_clk_rcg_ops = external dso_local constant [0 x i8], align 1
@__kstrtabns_clk_rcg_ops = external dso_local constant [0 x i8], align 1
@__ksymtab_clk_rcg_ops = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @clk_rcg_ops to i32), ptr @__kstrtab_clk_rcg_ops, ptr @__kstrtabns_clk_rcg_ops }, section "___ksymtab_gpl+clk_rcg_ops", align 4
@clk_rcg_bypass_ops = dso_local constant { %struct.clk_ops, [60 x i8] } { %struct.clk_ops { ptr null, ptr null, ptr null, ptr null, ptr @clk_enable_regmap, ptr @clk_disable_regmap, ptr null, ptr null, ptr null, ptr null, ptr @clk_rcg_recalc_rate, ptr null, ptr @clk_rcg_bypass_determine_rate, ptr @clk_rcg_set_parent, ptr @clk_rcg_get_parent, ptr @clk_rcg_bypass_set_rate, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null }, [60 x i8] zeroinitializer }, align 32
@__kstrtab_clk_rcg_bypass_ops = external dso_local constant [0 x i8], align 1
@__kstrtabns_clk_rcg_bypass_ops = external dso_local constant [0 x i8], align 1
@__ksymtab_clk_rcg_bypass_ops = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @clk_rcg_bypass_ops to i32), ptr @__kstrtab_clk_rcg_bypass_ops, ptr @__kstrtabns_clk_rcg_bypass_ops }, section "___ksymtab_gpl+clk_rcg_bypass_ops", align 4
@clk_rcg_bypass2_ops = dso_local constant { %struct.clk_ops, [60 x i8] } { %struct.clk_ops { ptr null, ptr null, ptr null, ptr null, ptr @clk_enable_regmap, ptr @clk_disable_regmap, ptr null, ptr null, ptr null, ptr null, ptr @clk_rcg_recalc_rate, ptr null, ptr @clk_rcg_bypass2_determine_rate, ptr @clk_rcg_set_parent, ptr @clk_rcg_get_parent, ptr @clk_rcg_bypass2_set_rate, ptr @clk_rcg_bypass2_set_rate_and_parent, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null }, [60 x i8] zeroinitializer }, align 32
@__kstrtab_clk_rcg_bypass2_ops = external dso_local constant [0 x i8], align 1
@__kstrtabns_clk_rcg_bypass2_ops = external dso_local constant [0 x i8], align 1
@__ksymtab_clk_rcg_bypass2_ops = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @clk_rcg_bypass2_ops to i32), ptr @__kstrtab_clk_rcg_bypass2_ops, ptr @__kstrtabns_clk_rcg_bypass2_ops }, section "___ksymtab_gpl+clk_rcg_bypass2_ops", align 4
@clk_rcg_pixel_ops = dso_local constant { %struct.clk_ops, [60 x i8] } { %struct.clk_ops { ptr null, ptr null, ptr null, ptr null, ptr @clk_enable_regmap, ptr @clk_disable_regmap, ptr null, ptr null, ptr null, ptr null, ptr @clk_rcg_recalc_rate, ptr null, ptr @clk_rcg_pixel_determine_rate, ptr @clk_rcg_set_parent, ptr @clk_rcg_get_parent, ptr @clk_rcg_pixel_set_rate, ptr @clk_rcg_pixel_set_rate_and_parent, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null }, [60 x i8] zeroinitializer }, align 32
@__kstrtab_clk_rcg_pixel_ops = external dso_local constant [0 x i8], align 1
@__kstrtabns_clk_rcg_pixel_ops = external dso_local constant [0 x i8], align 1
@__ksymtab_clk_rcg_pixel_ops = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @clk_rcg_pixel_ops to i32), ptr @__kstrtab_clk_rcg_pixel_ops, ptr @__kstrtabns_clk_rcg_pixel_ops }, section "___ksymtab_gpl+clk_rcg_pixel_ops", align 4
@clk_rcg_esc_ops = dso_local constant { %struct.clk_ops, [60 x i8] } { %struct.clk_ops { ptr null, ptr null, ptr null, ptr null, ptr @clk_enable_regmap, ptr @clk_disable_regmap, ptr null, ptr null, ptr null, ptr null, ptr @clk_rcg_recalc_rate, ptr null, ptr @clk_rcg_esc_determine_rate, ptr @clk_rcg_set_parent, ptr @clk_rcg_get_parent, ptr @clk_rcg_esc_set_rate, ptr @clk_rcg_esc_set_rate_and_parent, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null }, [60 x i8] zeroinitializer }, align 32
@__kstrtab_clk_rcg_esc_ops = external dso_local constant [0 x i8], align 1
@__kstrtabns_clk_rcg_esc_ops = external dso_local constant [0 x i8], align 1
@__ksymtab_clk_rcg_esc_ops = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @clk_rcg_esc_ops to i32), ptr @__kstrtab_clk_rcg_esc_ops, ptr @__kstrtabns_clk_rcg_esc_ops }, section "___ksymtab_gpl+clk_rcg_esc_ops", align 4
@clk_rcg_lcc_ops = dso_local constant { %struct.clk_ops, [60 x i8] } { %struct.clk_ops { ptr null, ptr null, ptr null, ptr null, ptr @clk_rcg_lcc_enable, ptr @clk_rcg_lcc_disable, ptr null, ptr null, ptr null, ptr null, ptr @clk_rcg_recalc_rate, ptr null, ptr @clk_rcg_determine_rate, ptr @clk_rcg_set_parent, ptr @clk_rcg_get_parent, ptr @clk_rcg_lcc_set_rate, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null }, [60 x i8] zeroinitializer }, align 32
@__kstrtab_clk_rcg_lcc_ops = external dso_local constant [0 x i8], align 1
@__kstrtabns_clk_rcg_lcc_ops = external dso_local constant [0 x i8], align 1
@__ksymtab_clk_rcg_lcc_ops = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @clk_rcg_lcc_ops to i32), ptr @__kstrtab_clk_rcg_lcc_ops, ptr @__kstrtabns_clk_rcg_lcc_ops }, section "___ksymtab_gpl+clk_rcg_lcc_ops", align 4
@clk_dyn_rcg_ops = dso_local constant { %struct.clk_ops, [60 x i8] } { %struct.clk_ops { ptr null, ptr null, ptr null, ptr null, ptr @clk_enable_regmap, ptr @clk_disable_regmap, ptr @clk_is_enabled_regmap, ptr null, ptr null, ptr null, ptr @clk_dyn_rcg_recalc_rate, ptr null, ptr @clk_dyn_rcg_determine_rate, ptr @clk_dyn_rcg_set_parent, ptr @clk_dyn_rcg_get_parent, ptr @clk_dyn_rcg_set_rate, ptr @clk_dyn_rcg_set_rate_and_parent, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null }, [60 x i8] zeroinitializer }, align 32
@__kstrtab_clk_dyn_rcg_ops = external dso_local constant [0 x i8], align 1
@__kstrtabns_clk_dyn_rcg_ops = external dso_local constant [0 x i8], align 1
@__ksymtab_clk_dyn_rcg_ops = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @clk_dyn_rcg_ops to i32), ptr @__kstrtab_clk_dyn_rcg_ops, ptr @__kstrtabns_clk_dyn_rcg_ops }, section "___ksymtab_gpl+clk_dyn_rcg_ops", align 4
@clk_rcg_get_parent.__UNIQUE_ID_ddebug154 = internal global { ptr, ptr, ptr, ptr, i8, i8, i8, i8, { { { %struct.atomic_t, { ptr } } } }, [4 x i8] } { ptr @.str, ptr @.str.1, ptr @.str.2, ptr @.str.3, i8 0, i8 13, i8 -128, i8 0, { { { %struct.atomic_t, { ptr } } } } zeroinitializer, [4 x i8] undef }, section "__dyndbg", align 8
@.str = internal constant { [9 x i8], [23 x i8] } { [9 x i8] c"clk_qcom\00", [23 x i8] zeroinitializer }, align 32
@.str.1 = internal constant { [19 x i8], [45 x i8] } { [19 x i8] c"clk_rcg_get_parent\00", [45 x i8] zeroinitializer }, align 32
@.str.2 = internal constant { [27 x i8], [37 x i8] } { [27 x i8] c"drivers/clk/qcom/clk-rcg.c\00", [37 x i8] zeroinitializer }, align 32
@.str.3 = internal constant { [49 x i8], [47 x i8] } { [49 x i8] c"%s: Clock %s has invalid parent, using default.\0A\00", [47 x i8] zeroinitializer }, align 32
@pixel_table = internal constant { [4 x %struct.frac_entry], [32 x i8] } { [4 x %struct.frac_entry] [%struct.frac_entry { i32 1, i32 2 }, %struct.frac_entry { i32 1, i32 3 }, %struct.frac_entry { i32 3, i32 16 }, %struct.frac_entry zeroinitializer], [32 x i8] zeroinitializer }, align 32
@clk_dyn_rcg_get_parent.__UNIQUE_ID_ddebug155 = internal global { ptr, ptr, ptr, ptr, i8, i8, i8, i8, { { { %struct.atomic_t, { ptr } } } }, [4 x i8] } { ptr @.str, ptr @.str.4, ptr @.str.2, ptr @.str.3, i8 0, i8 22, i8 -128, i8 0, { { { %struct.atomic_t, { ptr } } } } zeroinitializer, [4 x i8] undef }, section "__dyndbg", align 8
@.str.4 = internal constant { [23 x i8], [41 x i8] } { [23 x i8] c"clk_dyn_rcg_get_parent\00", [41 x i8] zeroinitializer }, align 32
@___asan_gen_.5 = private unnamed_addr constant [12 x i8] c"clk_rcg_ops\00", align 1
@___asan_gen_.7 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.42, i32 808, i32 22 }
@___asan_gen_.8 = private unnamed_addr constant [19 x i8] c"clk_rcg_bypass_ops\00", align 1
@___asan_gen_.10 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.42, i32 819, i32 22 }
@___asan_gen_.11 = private unnamed_addr constant [20 x i8] c"clk_rcg_bypass2_ops\00", align 1
@___asan_gen_.13 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.42, i32 830, i32 22 }
@___asan_gen_.14 = private unnamed_addr constant [18 x i8] c"clk_rcg_pixel_ops\00", align 1
@___asan_gen_.16 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.42, i32 842, i32 22 }
@___asan_gen_.17 = private unnamed_addr constant [16 x i8] c"clk_rcg_esc_ops\00", align 1
@___asan_gen_.19 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.42, i32 854, i32 22 }
@___asan_gen_.20 = private unnamed_addr constant [16 x i8] c"clk_rcg_lcc_ops\00", align 1
@___asan_gen_.22 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.42, i32 866, i32 22 }
@___asan_gen_.23 = private unnamed_addr constant [16 x i8] c"clk_dyn_rcg_ops\00", align 1
@___asan_gen_.25 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.42, i32 877, i32 22 }
@___asan_gen_.37 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.42, i32 53, i32 2 }
@___asan_gen_.38 = private unnamed_addr constant [12 x i8] c"pixel_table\00", align 1
@___asan_gen_.40 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.42, i32 586, i32 32 }
@___asan_gen_.41 = private unnamed_addr constant [17 x i8] c"<string literal>\00", align 1
@___asan_gen_.42 = private constant [30 x i8] c"../drivers/clk/qcom/clk-rcg.c\00", align 1
@___asan_gen_.43 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.42, i32 89, i32 2 }
@llvm.compiler.used = appending global [20 x ptr] [ptr @__ksymtab_clk_dyn_rcg_ops, ptr @__ksymtab_clk_rcg_bypass2_ops, ptr @__ksymtab_clk_rcg_bypass_ops, ptr @__ksymtab_clk_rcg_esc_ops, ptr @__ksymtab_clk_rcg_lcc_ops, ptr @__ksymtab_clk_rcg_ops, ptr @__ksymtab_clk_rcg_pixel_ops, ptr @clk_rcg_ops, ptr @clk_rcg_bypass_ops, ptr @clk_rcg_bypass2_ops, ptr @clk_rcg_pixel_ops, ptr @clk_rcg_esc_ops, ptr @clk_rcg_lcc_ops, ptr @clk_dyn_rcg_ops, ptr @.str, ptr @.str.1, ptr @.str.2, ptr @.str.3, ptr @pixel_table, ptr @.str.4], section "llvm.metadata"
@0 = internal global [13 x { i32, i32, i32, i32, i32, i32, i32, i32 }] [{ i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @clk_rcg_ops to i32), i32 100, i32 160, i32 ptrtoint (ptr @___asan_gen_.5 to i32), i32 ptrtoint (ptr @___asan_gen_.42 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.7 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @clk_rcg_bypass_ops to i32), i32 100, i32 160, i32 ptrtoint (ptr @___asan_gen_.8 to i32), i32 ptrtoint (ptr @___asan_gen_.42 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.10 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @clk_rcg_bypass2_ops to i32), i32 100, i32 160, i32 ptrtoint (ptr @___asan_gen_.11 to i32), i32 ptrtoint (ptr @___asan_gen_.42 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.13 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @clk_rcg_pixel_ops to i32), i32 100, i32 160, i32 ptrtoint (ptr @___asan_gen_.14 to i32), i32 ptrtoint (ptr @___asan_gen_.42 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.16 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @clk_rcg_esc_ops to i32), i32 100, i32 160, i32 ptrtoint (ptr @___asan_gen_.17 to i32), i32 ptrtoint (ptr @___asan_gen_.42 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.19 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @clk_rcg_lcc_ops to i32), i32 100, i32 160, i32 ptrtoint (ptr @___asan_gen_.20 to i32), i32 ptrtoint (ptr @___asan_gen_.42 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.22 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @clk_dyn_rcg_ops to i32), i32 100, i32 160, i32 ptrtoint (ptr @___asan_gen_.23 to i32), i32 ptrtoint (ptr @___asan_gen_.42 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.25 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str to i32), i32 9, i32 32, i32 ptrtoint (ptr @___asan_gen_.41 to i32), i32 ptrtoint (ptr @___asan_gen_.42 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.37 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.1 to i32), i32 19, i32 64, i32 ptrtoint (ptr @___asan_gen_.41 to i32), i32 ptrtoint (ptr @___asan_gen_.42 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.37 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.2 to i32), i32 27, i32 64, i32 ptrtoint (ptr @___asan_gen_.41 to i32), i32 ptrtoint (ptr @___asan_gen_.42 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.37 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.3 to i32), i32 49, i32 96, i32 ptrtoint (ptr @___asan_gen_.41 to i32), i32 ptrtoint (ptr @___asan_gen_.42 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.37 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @pixel_table to i32), i32 32, i32 64, i32 ptrtoint (ptr @___asan_gen_.38 to i32), i32 ptrtoint (ptr @___asan_gen_.42 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.40 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.4 to i32), i32 23, i32 64, i32 ptrtoint (ptr @___asan_gen_.41 to i32), i32 ptrtoint (ptr @___asan_gen_.42 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.43 to i32), i32 -1 }]
@llvm.used = appending global [2 x ptr] [ptr @asan.module_ctor, ptr @asan.module_dtor], section "llvm.metadata"
@llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 1, ptr @asan.module_ctor, ptr null }]
@llvm.global_dtors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 1, ptr @asan.module_dtor, ptr null }]

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @clk_enable_regmap(ptr noundef) #0

; Function Attrs: null_pointer_is_valid
declare dso_local void @clk_disable_regmap(ptr noundef) #0

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_rcg_recalc_rate(ptr nocapture noundef readonly %hw, i32 noundef %parent_rate) #1 align 64 {
entry:
  %ns = alloca i32, align 4
  %md = alloca i32, align 4
  %mode = alloca i32, align 4
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %hw, i32 -32
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ns) #3
  %0 = ptrtoint ptr %ns to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %ns, align 4, !annotation !48
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %md) #3
  %1 = ptrtoint ptr %md to i32
  call void @__asan_store4_noabort(i32 %1)
  store i32 -1, ptr %md, align 4, !annotation !48
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %mode) #3
  %2 = ptrtoint ptr %mode to i32
  call void @__asan_store4_noabort(i32 %2)
  store i32 0, ptr %mode, align 4
  %regmap = getelementptr inbounds %struct.clk_regmap, ptr %hw, i32 0, i32 1
  %3 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %regmap, align 4
  %5 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %add.ptr, align 4
  %call2 = call i32 @regmap_read(ptr noundef %4, i32 noundef %6, ptr noundef nonnull %ns) #3
  %p = getelementptr i8, ptr %hw, i32 -17
  %7 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %ns, align 4
  %9 = ptrtoint ptr %p to i32
  call void @__asan_load1_noabort(i32 %9)
  %10 = load i8, ptr %p, align 1
  %conv.i = zext i8 %10 to i32
  %shr.i = lshr i32 %8, %conv.i
  %pre_div_width.i = getelementptr i8, ptr %hw, i32 -16
  %11 = ptrtoint ptr %pre_div_width.i to i32
  call void @__asan_load1_noabort(i32 %11)
  %12 = load i8, ptr %pre_div_width.i, align 1
  %conv1.i = zext i8 %12 to i32
  %notmask.i = shl nsw i32 -1, %conv1.i
  %sub.i = xor i32 %notmask.i, -1
  %and.i = and i32 %shr.i, %sub.i
  %width = getelementptr i8, ptr %hw, i32 -19
  %13 = ptrtoint ptr %width to i32
  call void @__asan_load1_noabort(i32 %13)
  %14 = load i8, ptr %width, align 1
  call void @__sanitizer_cov_trace_const_cmp1(i8 0, i8 %14)
  %tobool.not = icmp eq i8 %14, 0
  br i1 %tobool.not, label %if.end19thread-pre-split, label %if.then

if.then:                                          ; preds = %entry
  %15 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %regmap, align 4
  %md_reg = getelementptr i8, ptr %hw, i32 -28
  %17 = ptrtoint ptr %md_reg to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %md_reg, align 4
  %call7 = call i32 @regmap_read(ptr noundef %16, i32 noundef %18, ptr noundef nonnull %md) #3
  %19 = ptrtoint ptr %md to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %md, align 4
  %m_val_shift.i = getelementptr i8, ptr %hw, i32 -20
  %21 = ptrtoint ptr %m_val_shift.i to i32
  call void @__asan_load1_noabort(i32 %21)
  %22 = load i8, ptr %m_val_shift.i, align 1
  %conv.i34 = zext i8 %22 to i32
  %shr.i35 = lshr i32 %20, %conv.i34
  %23 = ptrtoint ptr %width to i32
  call void @__asan_load1_noabort(i32 %23)
  %24 = load i8, ptr %width, align 1
  %conv1.i36 = zext i8 %24 to i32
  %notmask.i37 = shl nsw i32 -1, %conv1.i36
  %sub.i38 = xor i32 %notmask.i37, -1
  %and.i39 = and i32 %shr.i35, %sub.i38
  %25 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %ns, align 4
  %neg.i = xor i32 %26, -1
  %n_val_shift.i = getelementptr i8, ptr %hw, i32 -21
  %27 = ptrtoint ptr %n_val_shift.i to i32
  call void @__asan_load1_noabort(i32 %27)
  %28 = load i8, ptr %n_val_shift.i, align 1
  %conv.i40 = zext i8 %28 to i32
  %shr.i41 = lshr i32 %neg.i, %conv.i40
  %and.i46 = and i32 %shr.i41, %sub.i38
  %add.i = add i32 %and.i46, %and.i39
  %enable_reg = getelementptr inbounds %struct.clk_regmap, ptr %hw, i32 0, i32 2
  %29 = ptrtoint ptr %enable_reg to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %enable_reg, align 4
  %31 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %add.ptr, align 4
  call void @__sanitizer_cov_trace_cmp4(i32 %30, i32 %32)
  %cmp.not = icmp eq i32 %30, %32
  br i1 %cmp.not, label %if.else, label %if.then12

if.then12:                                        ; preds = %if.then
  call void @__sanitizer_cov_trace_pc() #5
  %33 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load ptr, ptr %regmap, align 4
  %call17 = call i32 @regmap_read(ptr noundef %34, i32 noundef %30, ptr noundef nonnull %mode) #3
  br label %if.end

if.else:                                          ; preds = %if.then
  call void @__sanitizer_cov_trace_pc() #5
  %35 = ptrtoint ptr %mode to i32
  call void @__asan_store4_noabort(i32 %35)
  store i32 %26, ptr %mode, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then12
  %36 = ptrtoint ptr %mode to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load i32, ptr %mode, align 4
  %mnctr_mode_shift.i = getelementptr i8, ptr %hw, i32 -22
  %38 = ptrtoint ptr %mnctr_mode_shift.i to i32
  call void @__asan_load1_noabort(i32 %38)
  %39 = load i8, ptr %mnctr_mode_shift.i, align 1
  %conv.i47 = zext i8 %39 to i32
  %shr.i48 = lshr i32 %37, %conv.i47
  %and.i49 = and i32 %shr.i48, 3
  br label %if.end19

if.end19thread-pre-split:                         ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  %40 = ptrtoint ptr %mode to i32
  call void @__asan_load4_noabort(i32 %40)
  %.pr = load i32, ptr %mode, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.end19thread-pre-split, %if.end
  %41 = phi i32 [ %.pr, %if.end19thread-pre-split ], [ %and.i49, %if.end ]
  %m.0 = phi i32 [ 0, %if.end19thread-pre-split ], [ %and.i39, %if.end ]
  %n.0 = phi i32 [ 0, %if.end19thread-pre-split ], [ %add.i, %if.end ]
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and.i)
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end19.if.end.i_crit_edge, label %if.then.i

if.end19.if.end.i_crit_edge:                      ; preds = %if.end19
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end.i

if.then.i:                                        ; preds = %if.end19
  call void @__sanitizer_cov_trace_pc() #5
  %add.i50 = add i32 %and.i, 1
  %div.i = udiv i32 %parent_rate, %add.i50
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.end19.if.end.i_crit_edge
  %rate.addr.0.i = phi i32 [ %div.i, %if.then.i ], [ %parent_rate, %if.end19.if.end.i_crit_edge ]
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %41)
  %tobool1.not.i = icmp eq i32 %41, 0
  br i1 %tobool1.not.i, label %if.end.i.calc_rate.exit_crit_edge, label %if.then2.i

if.end.i.calc_rate.exit_crit_edge:                ; preds = %if.end.i
  call void @__sanitizer_cov_trace_pc() #5
  br label %calc_rate.exit

if.then2.i:                                       ; preds = %if.end.i
  %conv.i51 = zext i32 %rate.addr.0.i to i64
  %conv3.i = zext i32 %m.0 to i64
  %mul.i = mul nuw i64 %conv.i51, %conv3.i
  call void @__sanitizer_cov_trace_const_cmp8(i64 4294967296, i64 %mul.i)
  %cmp176.i = icmp ult i64 %mul.i, 4294967296
  br i1 %cmp176.i, label %if.then180.i, label %if.else186.i, !prof !49

if.then180.i:                                     ; preds = %if.then2.i
  call void @__sanitizer_cov_trace_pc() #5
  %conv181.i = trunc i64 %mul.i to i32
  %div184.i = udiv i32 %conv181.i, %n.0
  br label %calc_rate.exit

if.else186.i:                                     ; preds = %if.then2.i
  call void @__sanitizer_cov_trace_pc() #5
  %42 = call { i64, i64 } asm ".ifnc $0,r0; .ifnc $0r0,fpr11; .ifnc $0r0,r11fp; .ifnc $0r0,ipr12; .ifnc $0r0,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09.ifnc $1,r2; .ifnc $1r2,fpr11; .ifnc $1r2,r11fp; .ifnc $1r2,ipr12; .ifnc $1r2,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09.ifnc $2,r4; .ifnc $2r4,fpr11; .ifnc $2r4,r11fp; .ifnc $2r4,ipr12; .ifnc $2r4,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09bl\09__do_div64", "={r0},={r2},{r4},{r0},~{r12},~{lr},~{cc}"(i32 %n.0, i64 %mul.i) #6, !srcloc !50
  %asmresult1.i.i = extractvalue { i64, i64 } %42, 1
  %extract.t301.i = trunc i64 %asmresult1.i.i to i32
  br label %calc_rate.exit

calc_rate.exit:                                   ; preds = %if.else186.i, %if.then180.i, %if.end.i.calc_rate.exit_crit_edge
  %rate.addr.1.i = phi i32 [ %rate.addr.0.i, %if.end.i.calc_rate.exit_crit_edge ], [ %div184.i, %if.then180.i ], [ %extract.t301.i, %if.else186.i ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %mode) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %md) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ns) #3
  ret i32 %rate.addr.1.i
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_rcg_determine_rate(ptr noundef %hw, ptr nocapture noundef %req) #1 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %freq_tbl = getelementptr i8, ptr %hw, i32 -4
  %0 = ptrtoint ptr %freq_tbl to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %freq_tbl, align 4
  %parent_map = getelementptr i8, ptr %hw, i32 -8
  %2 = ptrtoint ptr %parent_map to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %parent_map, align 4
  %call1 = tail call fastcc i32 @_freq_tbl_determine_rate(ptr noundef %hw, ptr noundef %1, ptr noundef %req, ptr noundef %3)
  ret i32 %call1
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_rcg_set_parent(ptr nocapture noundef readonly %hw, i8 noundef zeroext %index) #1 align 64 {
entry:
  %ns = alloca i32, align 4
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %hw, i32 -32
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ns) #3
  %0 = ptrtoint ptr %ns to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %ns, align 4, !annotation !48
  %regmap = getelementptr inbounds %struct.clk_regmap, ptr %hw, i32 0, i32 1
  %1 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %regmap, align 4
  %3 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %add.ptr, align 4
  %call1 = call i32 @regmap_read(ptr noundef %2, i32 noundef %4, ptr noundef nonnull %ns) #3
  %s = getelementptr i8, ptr %hw, i32 -12
  %parent_map = getelementptr i8, ptr %hw, i32 -8
  %5 = ptrtoint ptr %parent_map to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %parent_map, align 4
  %idxprom = zext i8 %index to i32
  %cfg = getelementptr %struct.parent_map, ptr %6, i32 %idxprom, i32 1
  %7 = ptrtoint ptr %cfg to i32
  call void @__asan_load1_noabort(i32 %7)
  %8 = load i8, ptr %cfg, align 1
  %9 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %ns, align 4
  %11 = ptrtoint ptr %s to i32
  call void @__asan_load1_noabort(i32 %11)
  %12 = load i8, ptr %s, align 4
  %conv.i = zext i8 %12 to i32
  %shl.i = shl i32 7, %conv.i
  %neg.i = xor i32 %shl.i, -1
  %and.i = and i32 %10, %neg.i
  %conv1.i = zext i8 %8 to i32
  %shl4.i = shl i32 %conv1.i, %conv.i
  %or.i = or i32 %and.i, %shl4.i
  store i32 %or.i, ptr %ns, align 4
  %13 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %regmap, align 4
  %15 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %add.ptr, align 4
  %call7 = call i32 @regmap_write(ptr noundef %14, i32 noundef %16, i32 noundef %or.i) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ns) #3
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal zeroext i8 @clk_rcg_get_parent(ptr noundef %hw) #1 align 64 {
entry:
  %ns = alloca i32, align 4
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %hw, i32 -32
  %call1 = tail call i32 @clk_hw_get_num_parents(ptr noundef %hw) #3
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ns) #3
  %0 = ptrtoint ptr %ns to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %ns, align 4, !annotation !48
  %regmap = getelementptr inbounds %struct.clk_regmap, ptr %hw, i32 0, i32 1
  %1 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %regmap, align 4
  %3 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %add.ptr, align 4
  %call2 = call i32 @regmap_read(ptr noundef %2, i32 noundef %4, ptr noundef nonnull %ns) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call2)
  %tobool.not = icmp eq i32 %call2, 0
  br i1 %tobool.not, label %if.end, label %entry.do.body_crit_edge

entry.do.body_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  br label %do.body

if.end:                                           ; preds = %entry
  %s = getelementptr i8, ptr %hw, i32 -12
  %5 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %ns, align 4
  %7 = ptrtoint ptr %s to i32
  call void @__asan_load1_noabort(i32 %7)
  %8 = load i8, ptr %s, align 4
  %conv.i = zext i8 %8 to i32
  %shr.i = lshr i32 %6, %conv.i
  %and.i = and i32 %shr.i, 7
  store i32 %and.i, ptr %ns, align 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call1)
  %cmp32 = icmp sgt i32 %call1, 0
  br i1 %cmp32, label %for.body.lr.ph, label %if.end.do.body_crit_edge

if.end.do.body_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #5
  br label %do.body

for.body.lr.ph:                                   ; preds = %if.end
  %parent_map = getelementptr i8, ptr %hw, i32 -8
  %9 = ptrtoint ptr %parent_map to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %parent_map, align 4
  br label %for.body

for.body:                                         ; preds = %for.inc.for.body_crit_edge, %for.body.lr.ph
  %i.033 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.inc.for.body_crit_edge ]
  %cfg = getelementptr %struct.parent_map, ptr %10, i32 %i.033, i32 1
  %11 = ptrtoint ptr %cfg to i32
  call void @__asan_load1_noabort(i32 %11)
  %12 = load i8, ptr %cfg, align 1
  %conv = zext i8 %12 to i32
  call void @__sanitizer_cov_trace_cmp4(i32 %and.i, i32 %conv)
  %cmp5 = icmp eq i32 %and.i, %conv
  br i1 %cmp5, label %if.then7, label %for.inc

if.then7:                                         ; preds = %for.body
  call void @__sanitizer_cov_trace_pc() #5
  %conv8 = trunc i32 %i.033 to i8
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nuw nsw i32 %i.033, 1
  %exitcond.not = icmp eq i32 %inc, %call1
  br i1 %exitcond.not, label %for.inc.do.body_crit_edge, label %for.inc.for.body_crit_edge

for.inc.for.body_crit_edge:                       ; preds = %for.inc
  call void @__sanitizer_cov_trace_pc() #5
  br label %for.body

for.inc.do.body_crit_edge:                        ; preds = %for.inc
  call void @__sanitizer_cov_trace_pc() #5
  br label %do.body

do.body:                                          ; preds = %for.inc.do.body_crit_edge, %if.end.do.body_crit_edge, %entry.do.body_crit_edge
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds ({ ptr, ptr, ptr, ptr, i8, i8, i8, i8, { { { %struct.atomic_t, { ptr } } } }, [4 x i8] }, ptr @clk_rcg_get_parent.__UNIQUE_ID_ddebug154, i32 0, i32 8, i32 0, i32 0, i32 0, i32 0), ptr blockaddress(@clk_rcg_get_parent, %if.then15)) #3
          to label %cleanup [label %if.then15], !srcloc !51

if.then15:                                        ; preds = %do.body
  call void @__sanitizer_cov_trace_pc() #5
  %call16 = call ptr @clk_hw_get_name(ptr noundef %hw) #3
  call void (ptr, ptr, ...) @__dynamic_pr_debug(ptr noundef nonnull @clk_rcg_get_parent.__UNIQUE_ID_ddebug154, ptr noundef nonnull @.str.3, ptr noundef nonnull @.str.1, ptr noundef %call16) #3
  br label %cleanup

cleanup:                                          ; preds = %if.then15, %do.body, %if.then7
  %retval.0 = phi i8 [ %conv8, %if.then7 ], [ 0, %if.then15 ], [ 0, %do.body ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ns) #3
  ret i8 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_rcg_set_rate(ptr nocapture noundef readonly %hw, i32 noundef %rate, i32 noundef %parent_rate) #1 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %freq_tbl = getelementptr i8, ptr %hw, i32 -4
  %0 = ptrtoint ptr %freq_tbl to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %freq_tbl, align 4
  %call1 = tail call ptr @qcom_find_freq(ptr noundef %1, i32 noundef %rate) #3
  %tobool.not = icmp eq ptr %call1, null
  br i1 %tobool.not, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  %add.ptr = getelementptr i8, ptr %hw, i32 -32
  tail call fastcc void @__clk_rcg_set_rate(ptr noundef %add.ptr, ptr noundef nonnull %call1)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ 0, %if.end ], [ -22, %entry.cleanup_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_rcg_bypass_determine_rate(ptr noundef %hw, ptr nocapture noundef %req) #1 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %freq_tbl = getelementptr i8, ptr %hw, i32 -4
  %0 = ptrtoint ptr %freq_tbl to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %freq_tbl, align 4
  %parent_map = getelementptr i8, ptr %hw, i32 -8
  %2 = ptrtoint ptr %parent_map to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %parent_map, align 4
  %src = getelementptr inbounds %struct.freq_tbl, ptr %1, i32 0, i32 1
  %4 = ptrtoint ptr %src to i32
  call void @__asan_load1_noabort(i32 %4)
  %5 = load i8, ptr %src, align 4
  %call1 = tail call i32 @qcom_find_src_index(ptr noundef %hw, ptr noundef %3, i8 noundef zeroext %5) #3
  %call2 = tail call ptr @clk_hw_get_parent_by_index(ptr noundef %hw, i32 noundef %call1) #3
  %best_parent_hw = getelementptr inbounds %struct.clk_rate_request, ptr %req, i32 0, i32 4
  %6 = ptrtoint ptr %best_parent_hw to i32
  call void @__asan_store4_noabort(i32 %6)
  store ptr %call2, ptr %best_parent_hw, align 4
  %7 = ptrtoint ptr %req to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %req, align 4
  %call3 = tail call i32 @clk_hw_round_rate(ptr noundef %call2, i32 noundef %8) #3
  %best_parent_rate = getelementptr inbounds %struct.clk_rate_request, ptr %req, i32 0, i32 3
  %9 = ptrtoint ptr %best_parent_rate to i32
  call void @__asan_store4_noabort(i32 %9)
  store i32 %call3, ptr %best_parent_rate, align 4
  %10 = ptrtoint ptr %req to i32
  call void @__asan_store4_noabort(i32 %10)
  store i32 %call3, ptr %req, align 4
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_rcg_bypass_set_rate(ptr nocapture noundef readonly %hw, i32 noundef %rate, i32 noundef %parent_rate) #1 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %hw, i32 -32
  %freq_tbl = getelementptr i8, ptr %hw, i32 -4
  %0 = ptrtoint ptr %freq_tbl to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %freq_tbl, align 4
  tail call fastcc void @__clk_rcg_set_rate(ptr noundef %add.ptr, ptr noundef %1)
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_rcg_bypass2_determine_rate(ptr nocapture noundef readnone %hw, ptr nocapture noundef %req) #1 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %best_parent_hw = getelementptr inbounds %struct.clk_rate_request, ptr %req, i32 0, i32 4
  %0 = ptrtoint ptr %best_parent_hw to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %best_parent_hw, align 4
  %2 = ptrtoint ptr %req to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %req, align 4
  %call = tail call i32 @clk_hw_round_rate(ptr noundef %1, i32 noundef %3) #3
  %best_parent_rate = getelementptr inbounds %struct.clk_rate_request, ptr %req, i32 0, i32 3
  %4 = ptrtoint ptr %best_parent_rate to i32
  call void @__asan_store4_noabort(i32 %4)
  store i32 %call, ptr %best_parent_rate, align 4
  %5 = ptrtoint ptr %req to i32
  call void @__asan_store4_noabort(i32 %5)
  store i32 %call, ptr %req, align 4
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_rcg_bypass2_set_rate(ptr noundef %hw, i32 noundef %rate, i32 noundef %parent_rate) #1 align 64 {
entry:
  %f = alloca %struct.freq_tbl, align 4
  %ns = alloca i32, align 4
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %hw, i32 -32
  call void @llvm.lifetime.start.p0(i64 12, ptr nonnull %f) #3
  %0 = call ptr @memset(ptr %f, i32 0, i32 12)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ns) #3
  %1 = ptrtoint ptr %ns to i32
  call void @__asan_store4_noabort(i32 %1)
  store i32 -1, ptr %ns, align 4, !annotation !48
  %call1 = tail call i32 @clk_hw_get_num_parents(ptr noundef %hw) #3
  %regmap = getelementptr inbounds %struct.clk_regmap, ptr %hw, i32 0, i32 1
  %2 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %regmap, align 4
  %4 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %add.ptr, align 4
  %call2 = call i32 @regmap_read(ptr noundef %3, i32 noundef %5, ptr noundef nonnull %ns) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call2)
  %tobool.not = icmp eq i32 %call2, 0
  br i1 %tobool.not, label %if.end, label %entry.cleanup_crit_edge

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end:                                           ; preds = %entry
  %s = getelementptr i8, ptr %hw, i32 -12
  %6 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %ns, align 4
  %8 = ptrtoint ptr %s to i32
  call void @__asan_load1_noabort(i32 %8)
  %9 = load i8, ptr %s, align 4
  %conv.i = zext i8 %9 to i32
  %shr.i = lshr i32 %7, %conv.i
  %and.i = and i32 %shr.i, 7
  %p = getelementptr i8, ptr %hw, i32 -17
  %10 = ptrtoint ptr %p to i32
  call void @__asan_load1_noabort(i32 %10)
  %11 = load i8, ptr %p, align 1
  %conv.i35 = zext i8 %11 to i32
  %shr.i36 = lshr i32 %7, %conv.i35
  %pre_div_width.i = getelementptr i8, ptr %hw, i32 -16
  %12 = ptrtoint ptr %pre_div_width.i to i32
  call void @__asan_load1_noabort(i32 %12)
  %13 = load i8, ptr %pre_div_width.i, align 1
  %conv1.i = zext i8 %13 to i32
  %notmask.i = shl nsw i32 -1, %conv1.i
  %sub.i = xor i32 %notmask.i, -1
  %and.i37 = and i32 %shr.i36, %sub.i
  %14 = trunc i32 %and.i37 to i8
  %conv = add i8 %14, 1
  %pre_div = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 2
  %15 = ptrtoint ptr %pre_div to i32
  call void @__asan_store1_noabort(i32 %15)
  store i8 %conv, ptr %pre_div, align 1
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call1)
  %cmp39 = icmp sgt i32 %call1, 0
  br i1 %cmp39, label %for.body.lr.ph, label %if.end.cleanup_crit_edge

if.end.cleanup_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

for.body.lr.ph:                                   ; preds = %if.end
  %parent_map = getelementptr i8, ptr %hw, i32 -8
  %16 = ptrtoint ptr %parent_map to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %parent_map, align 4
  br label %for.body

for.body:                                         ; preds = %for.inc.for.body_crit_edge, %for.body.lr.ph
  %i.040 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.inc.for.body_crit_edge ]
  %cfg = getelementptr %struct.parent_map, ptr %17, i32 %i.040, i32 1
  %18 = ptrtoint ptr %cfg to i32
  call void @__asan_load1_noabort(i32 %18)
  %19 = load i8, ptr %cfg, align 1
  %conv7 = zext i8 %19 to i32
  call void @__sanitizer_cov_trace_cmp4(i32 %and.i, i32 %conv7)
  %cmp8 = icmp eq i32 %and.i, %conv7
  br i1 %cmp8, label %if.then10, label %for.inc

if.then10:                                        ; preds = %for.body
  call void @__sanitizer_cov_trace_pc() #5
  %arrayidx = getelementptr %struct.parent_map, ptr %17, i32 %i.040
  %20 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load1_noabort(i32 %20)
  %21 = load i8, ptr %arrayidx, align 1
  %src15 = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 1
  %22 = ptrtoint ptr %src15 to i32
  call void @__asan_store1_noabort(i32 %22)
  store i8 %21, ptr %src15, align 4
  call fastcc void @__clk_rcg_set_rate(ptr noundef %add.ptr, ptr noundef nonnull %f)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nuw nsw i32 %i.040, 1
  %exitcond.not = icmp eq i32 %inc, %call1
  br i1 %exitcond.not, label %for.inc.cleanup_crit_edge, label %for.inc.for.body_crit_edge

for.inc.for.body_crit_edge:                       ; preds = %for.inc
  call void @__sanitizer_cov_trace_pc() #5
  br label %for.body

for.inc.cleanup_crit_edge:                        ; preds = %for.inc
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

cleanup:                                          ; preds = %for.inc.cleanup_crit_edge, %if.then10, %if.end.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ 0, %if.then10 ], [ %call2, %entry.cleanup_crit_edge ], [ -22, %if.end.cleanup_crit_edge ], [ -22, %for.inc.cleanup_crit_edge ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ns) #3
  call void @llvm.lifetime.end.p0(i64 12, ptr nonnull %f) #3
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_rcg_bypass2_set_rate_and_parent(ptr noundef %hw, i32 noundef %rate, i32 noundef %parent_rate, i8 noundef zeroext %index) #1 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call i32 @clk_rcg_bypass2_set_rate(ptr noundef %hw, i32 noundef %rate, i32 noundef %parent_rate)
  ret i32 %call
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_rcg_pixel_determine_rate(ptr nocapture noundef readnone %hw, ptr nocapture noundef %req) #1 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %best_parent_hw = getelementptr inbounds %struct.clk_rate_request, ptr %req, i32 0, i32 4
  %0 = ptrtoint ptr %req to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %req, align 4
  %mul = shl i32 %1, 1
  %2 = ptrtoint ptr %best_parent_hw to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %best_parent_hw, align 4
  %call = tail call i32 @clk_hw_round_rate(ptr noundef %3, i32 noundef %mul) #3
  %sub = add i32 %mul, -100000
  call void @__sanitizer_cov_trace_cmp4(i32 %call, i32 %sub)
  %cmp = icmp ult i32 %call, %sub
  %add = add i32 %mul, 100000
  call void @__sanitizer_cov_trace_cmp4(i32 %call, i32 %add)
  %cmp2 = icmp ugt i32 %call, %add
  %or.cond = or i1 %cmp, %cmp2
  br i1 %or.cond, label %for.inc, label %entry.if.end_crit_edge

entry.if.end_crit_edge:                           ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end

if.end:                                           ; preds = %for.inc.1.if.end_crit_edge, %for.inc.if.end_crit_edge, %entry.if.end_crit_edge
  %frac.026.lcssa = phi ptr [ @pixel_table, %entry.if.end_crit_edge ], [ getelementptr inbounds ([4 x %struct.frac_entry], ptr @pixel_table, i32 0, i32 1), %for.inc.if.end_crit_edge ], [ getelementptr inbounds ([4 x %struct.frac_entry], ptr @pixel_table, i32 0, i32 2), %for.inc.1.if.end_crit_edge ]
  %call.lcssa = phi i32 [ %call, %entry.if.end_crit_edge ], [ %call.1, %for.inc.if.end_crit_edge ], [ %call.2, %for.inc.1.if.end_crit_edge ]
  %den.le = getelementptr inbounds %struct.frac_entry, ptr %frac.026.lcssa, i32 0, i32 1
  %best_parent_rate = getelementptr inbounds %struct.clk_rate_request, ptr %req, i32 0, i32 3
  %4 = ptrtoint ptr %best_parent_rate to i32
  call void @__asan_store4_noabort(i32 %4)
  store i32 %call.lcssa, ptr %best_parent_rate, align 4
  %5 = ptrtoint ptr %frac.026.lcssa to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %frac.026.lcssa, align 4
  %mul4 = mul i32 %6, %call.lcssa
  %7 = ptrtoint ptr %den.le to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %den.le, align 4
  %div6 = udiv i32 %mul4, %8
  %9 = ptrtoint ptr %req to i32
  call void @__asan_store4_noabort(i32 %9)
  store i32 %div6, ptr %req, align 4
  br label %cleanup

for.inc:                                          ; preds = %entry
  %10 = ptrtoint ptr %req to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %req, align 4
  %mul.1 = mul i32 %11, 3
  %12 = ptrtoint ptr %best_parent_hw to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %best_parent_hw, align 4
  %call.1 = tail call i32 @clk_hw_round_rate(ptr noundef %13, i32 noundef %mul.1) #3
  %sub.1 = add i32 %mul.1, -100000
  call void @__sanitizer_cov_trace_cmp4(i32 %call.1, i32 %sub.1)
  %cmp.1 = icmp ult i32 %call.1, %sub.1
  %add.1 = add i32 %mul.1, 100000
  call void @__sanitizer_cov_trace_cmp4(i32 %call.1, i32 %add.1)
  %cmp2.1 = icmp ugt i32 %call.1, %add.1
  %or.cond.1 = or i1 %cmp.1, %cmp2.1
  br i1 %or.cond.1, label %for.inc.1, label %for.inc.if.end_crit_edge

for.inc.if.end_crit_edge:                         ; preds = %for.inc
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end

for.inc.1:                                        ; preds = %for.inc
  %14 = ptrtoint ptr %req to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %req, align 4
  %mul.2 = shl i32 %15, 4
  %div.2 = udiv i32 %mul.2, 3
  %16 = ptrtoint ptr %best_parent_hw to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %best_parent_hw, align 4
  %call.2 = tail call i32 @clk_hw_round_rate(ptr noundef %17, i32 noundef %div.2) #3
  %sub.2 = add nsw i32 %div.2, -100000
  call void @__sanitizer_cov_trace_cmp4(i32 %call.2, i32 %sub.2)
  %cmp.2 = icmp ult i32 %call.2, %sub.2
  %add.2 = add nuw nsw i32 %div.2, 100000
  call void @__sanitizer_cov_trace_cmp4(i32 %call.2, i32 %add.2)
  %cmp2.2 = icmp ugt i32 %call.2, %add.2
  %or.cond.2 = or i1 %cmp.2, %cmp2.2
  br i1 %or.cond.2, label %for.inc.1.cleanup_crit_edge, label %for.inc.1.if.end_crit_edge

for.inc.1.if.end_crit_edge:                       ; preds = %for.inc.1
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end

for.inc.1.cleanup_crit_edge:                      ; preds = %for.inc.1
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

cleanup:                                          ; preds = %for.inc.1.cleanup_crit_edge, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ -22, %for.inc.1.cleanup_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_rcg_pixel_set_rate(ptr noundef %hw, i32 noundef %rate, i32 noundef %parent_rate) #1 align 64 {
entry:
  %f = alloca %struct.freq_tbl, align 4
  %ns = alloca i32, align 4
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %hw, i32 -32
  call void @llvm.lifetime.start.p0(i64 12, ptr nonnull %f) #3
  %0 = call ptr @memset(ptr %f, i32 0, i32 12)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ns) #3
  %1 = ptrtoint ptr %ns to i32
  call void @__asan_store4_noabort(i32 %1)
  store i32 -1, ptr %ns, align 4, !annotation !48
  %call1 = tail call i32 @clk_hw_get_num_parents(ptr noundef %hw) #3
  %regmap = getelementptr inbounds %struct.clk_regmap, ptr %hw, i32 0, i32 1
  %2 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %regmap, align 4
  %4 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %add.ptr, align 4
  %call2 = call i32 @regmap_read(ptr noundef %3, i32 noundef %5, ptr noundef nonnull %ns) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call2)
  %tobool.not = icmp eq i32 %call2, 0
  br i1 %tobool.not, label %if.end, label %entry.cleanup_crit_edge

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end:                                           ; preds = %entry
  %s = getelementptr i8, ptr %hw, i32 -12
  %6 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %ns, align 4
  %8 = ptrtoint ptr %s to i32
  call void @__asan_load1_noabort(i32 %8)
  %9 = load i8, ptr %s, align 4
  %conv.i = zext i8 %9 to i32
  %shr.i = lshr i32 %7, %conv.i
  %and.i = and i32 %shr.i, 7
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call1)
  %cmp61 = icmp sgt i32 %call1, 0
  br i1 %cmp61, label %for.body.lr.ph, label %if.end.for.end_crit_edge

if.end.for.end_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #5
  br label %for.end

for.body.lr.ph:                                   ; preds = %if.end
  %parent_map = getelementptr i8, ptr %hw, i32 -8
  %10 = ptrtoint ptr %parent_map to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %parent_map, align 4
  br label %for.body

for.body:                                         ; preds = %for.inc.for.body_crit_edge, %for.body.lr.ph
  %i.062 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.inc.for.body_crit_edge ]
  %cfg = getelementptr %struct.parent_map, ptr %11, i32 %i.062, i32 1
  %12 = ptrtoint ptr %cfg to i32
  call void @__asan_load1_noabort(i32 %12)
  %13 = load i8, ptr %cfg, align 1
  %conv = zext i8 %13 to i32
  call void @__sanitizer_cov_trace_cmp4(i32 %and.i, i32 %conv)
  %cmp5 = icmp eq i32 %and.i, %conv
  br i1 %cmp5, label %if.then7, label %for.inc

if.then7:                                         ; preds = %for.body
  call void @__sanitizer_cov_trace_pc() #5
  %arrayidx = getelementptr %struct.parent_map, ptr %11, i32 %i.062
  %14 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load1_noabort(i32 %14)
  %15 = load i8, ptr %arrayidx, align 1
  %src12 = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 1
  %16 = ptrtoint ptr %src12 to i32
  call void @__asan_store1_noabort(i32 %16)
  store i8 %15, ptr %src12, align 4
  br label %for.end

for.inc:                                          ; preds = %for.body
  %inc = add nuw nsw i32 %i.062, 1
  %exitcond.not = icmp eq i32 %inc, %call1
  br i1 %exitcond.not, label %for.inc.for.end_crit_edge, label %for.inc.for.body_crit_edge

for.inc.for.body_crit_edge:                       ; preds = %for.inc
  call void @__sanitizer_cov_trace_pc() #5
  br label %for.body

for.inc.for.end_crit_edge:                        ; preds = %for.inc
  call void @__sanitizer_cov_trace_pc() #5
  br label %for.end

for.end:                                          ; preds = %for.inc.for.end_crit_edge, %if.then7, %if.end.for.end_crit_edge
  %pre_div = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 2
  %17 = ptrtoint ptr %pre_div to i32
  call void @__asan_store1_noabort(i32 %17)
  store i8 1, ptr %pre_div, align 1
  %mul = shl i32 %rate, 1
  %sub = add i32 %mul, -100000
  call void @__sanitizer_cov_trace_cmp4(i32 %sub, i32 %parent_rate)
  %cmp18 = icmp ugt i32 %sub, %parent_rate
  %add = add i32 %mul, 100000
  call void @__sanitizer_cov_trace_cmp4(i32 %add, i32 %parent_rate)
  %cmp20 = icmp ult i32 %add, %parent_rate
  %or.cond = or i1 %cmp18, %cmp20
  br i1 %or.cond, label %for.cond14, label %for.end.if.end23_crit_edge

for.end.if.end23_crit_edge:                       ; preds = %for.end
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end23

for.cond14:                                       ; preds = %for.end
  %mul.1 = mul i32 %rate, 3
  %sub.1 = add i32 %mul.1, -100000
  call void @__sanitizer_cov_trace_cmp4(i32 %sub.1, i32 %parent_rate)
  %cmp18.1 = icmp ugt i32 %sub.1, %parent_rate
  %add.1 = add i32 %mul.1, 100000
  call void @__sanitizer_cov_trace_cmp4(i32 %add.1, i32 %parent_rate)
  %cmp20.1 = icmp ult i32 %add.1, %parent_rate
  %or.cond.1 = or i1 %cmp18.1, %cmp20.1
  br i1 %or.cond.1, label %for.cond14.1, label %for.cond14.if.end23_crit_edge

for.cond14.if.end23_crit_edge:                    ; preds = %for.cond14
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end23

for.cond14.1:                                     ; preds = %for.cond14
  %mul.2 = shl i32 %rate, 4
  %div.2 = udiv i32 %mul.2, 3
  %sub.2 = add nsw i32 %div.2, -100000
  call void @__sanitizer_cov_trace_cmp4(i32 %sub.2, i32 %parent_rate)
  %cmp18.2 = icmp ugt i32 %sub.2, %parent_rate
  %add.2 = add nuw nsw i32 %div.2, 100000
  call void @__sanitizer_cov_trace_cmp4(i32 %add.2, i32 %parent_rate)
  %cmp20.2 = icmp ult i32 %add.2, %parent_rate
  %or.cond.2 = or i1 %cmp18.2, %cmp20.2
  br i1 %or.cond.2, label %for.cond14.1.cleanup_crit_edge, label %for.cond14.1.if.end23_crit_edge

for.cond14.1.if.end23_crit_edge:                  ; preds = %for.cond14.1
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end23

for.cond14.1.cleanup_crit_edge:                   ; preds = %for.cond14.1
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end23:                                         ; preds = %for.cond14.1.if.end23_crit_edge, %for.cond14.if.end23_crit_edge, %for.end.if.end23_crit_edge
  %.lcssa65 = phi i16 [ 1, %for.end.if.end23_crit_edge ], [ 1, %for.cond14.if.end23_crit_edge ], [ 3, %for.cond14.1.if.end23_crit_edge ]
  %.lcssa = phi i16 [ 2, %for.end.if.end23_crit_edge ], [ 3, %for.cond14.if.end23_crit_edge ], [ 16, %for.cond14.1.if.end23_crit_edge ]
  %m = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 3
  %18 = ptrtoint ptr %m to i32
  call void @__asan_store2_noabort(i32 %18)
  store i16 %.lcssa65, ptr %m, align 2
  %n = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 4
  %19 = ptrtoint ptr %n to i32
  call void @__asan_store2_noabort(i32 %19)
  store i16 %.lcssa, ptr %n, align 4
  call fastcc void @__clk_rcg_set_rate(ptr noundef %add.ptr, ptr noundef nonnull %f)
  br label %cleanup

cleanup:                                          ; preds = %if.end23, %for.cond14.1.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ 0, %if.end23 ], [ %call2, %entry.cleanup_crit_edge ], [ -22, %for.cond14.1.cleanup_crit_edge ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ns) #3
  call void @llvm.lifetime.end.p0(i64 12, ptr nonnull %f) #3
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_rcg_pixel_set_rate_and_parent(ptr noundef %hw, i32 noundef %rate, i32 noundef %parent_rate, i8 noundef zeroext %index) #1 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call i32 @clk_rcg_pixel_set_rate(ptr noundef %hw, i32 noundef %rate, i32 noundef %parent_rate)
  ret i32 %call
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_rcg_esc_determine_rate(ptr nocapture noundef readonly %hw, ptr nocapture noundef %req) #1 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = ptrtoint ptr %req to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %req, align 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %1)
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end:                                           ; preds = %entry
  %pre_div_width = getelementptr i8, ptr %hw, i32 -16
  %2 = ptrtoint ptr %pre_div_width to i32
  call void @__asan_load1_noabort(i32 %2)
  %3 = load i8, ptr %pre_div_width, align 1
  %conv = zext i8 %3 to i32
  %shl = shl nuw i32 1, %conv
  %best_parent_hw = getelementptr inbounds %struct.clk_rate_request, ptr %req, i32 0, i32 4
  %4 = ptrtoint ptr %best_parent_hw to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %best_parent_hw, align 4
  %call2 = tail call i32 @clk_hw_get_rate(ptr noundef %5) #3
  %6 = ptrtoint ptr %req to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %req, align 4
  %div4 = udiv i32 %call2, %7
  call void @__sanitizer_cov_trace_const_cmp4(i32 1, i32 %div4)
  %cmp5 = icmp slt i32 %div4, 1
  call void @__sanitizer_cov_trace_cmp4(i32 %div4, i32 %shl)
  %cmp7.not = icmp sgt i32 %div4, %shl
  %or.cond = select i1 %cmp5, i1 true, i1 %cmp7.not
  br i1 %or.cond, label %if.end.cleanup_crit_edge, label %if.then9

if.end.cleanup_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.then9:                                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #5
  %best_parent_rate = getelementptr inbounds %struct.clk_rate_request, ptr %req, i32 0, i32 3
  %8 = ptrtoint ptr %best_parent_rate to i32
  call void @__asan_store4_noabort(i32 %8)
  store i32 %call2, ptr %best_parent_rate, align 4
  %div10 = udiv i32 %call2, %div4
  %9 = ptrtoint ptr %req to i32
  call void @__asan_store4_noabort(i32 %9)
  store i32 %div10, ptr %req, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.then9, %if.end.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ 0, %if.then9 ], [ -22, %entry.cleanup_crit_edge ], [ -22, %if.end.cleanup_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_rcg_esc_set_rate(ptr noundef %hw, i32 noundef %rate, i32 noundef %parent_rate) #1 align 64 {
entry:
  %f = alloca %struct.freq_tbl, align 4
  %ns = alloca i32, align 4
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %hw, i32 -32
  call void @llvm.lifetime.start.p0(i64 12, ptr nonnull %f) #3
  %0 = call ptr @memset(ptr %f, i32 0, i32 12)
  %pre_div_width = getelementptr i8, ptr %hw, i32 -16
  %1 = ptrtoint ptr %pre_div_width to i32
  call void @__asan_load1_noabort(i32 %1)
  %2 = load i8, ptr %pre_div_width, align 1
  %conv = zext i8 %2 to i32
  %shl = shl nuw i32 1, %conv
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ns) #3
  %3 = ptrtoint ptr %ns to i32
  call void @__asan_store4_noabort(i32 %3)
  store i32 -1, ptr %ns, align 4, !annotation !48
  %call1 = tail call i32 @clk_hw_get_num_parents(ptr noundef %hw) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %rate)
  %cmp = icmp eq i32 %rate, 0
  br i1 %cmp, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end:                                           ; preds = %entry
  %regmap = getelementptr inbounds %struct.clk_regmap, ptr %hw, i32 0, i32 1
  %4 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %regmap, align 4
  %6 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %add.ptr, align 4
  %call3 = call i32 @regmap_read(ptr noundef %5, i32 noundef %7, ptr noundef nonnull %ns) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call3)
  %tobool.not = icmp eq i32 %call3, 0
  br i1 %tobool.not, label %if.end5, label %if.end.cleanup_crit_edge

if.end.cleanup_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end5:                                          ; preds = %if.end
  %s = getelementptr i8, ptr %hw, i32 -12
  %8 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %ns, align 4
  %10 = ptrtoint ptr %s to i32
  call void @__asan_load1_noabort(i32 %10)
  %11 = load i8, ptr %s, align 4
  %conv.i = zext i8 %11 to i32
  %shr.i = lshr i32 %9, %conv.i
  %and.i = and i32 %shr.i, 7
  store i32 %and.i, ptr %ns, align 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call1)
  %cmp750 = icmp sgt i32 %call1, 0
  br i1 %cmp750, label %for.body.lr.ph, label %if.end5.for.end_crit_edge

if.end5.for.end_crit_edge:                        ; preds = %if.end5
  call void @__sanitizer_cov_trace_pc() #5
  br label %for.end

for.body.lr.ph:                                   ; preds = %if.end5
  %parent_map = getelementptr i8, ptr %hw, i32 -8
  %12 = ptrtoint ptr %parent_map to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %parent_map, align 4
  br label %for.body

for.body:                                         ; preds = %for.inc.for.body_crit_edge, %for.body.lr.ph
  %i.051 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.inc.for.body_crit_edge ]
  %cfg = getelementptr %struct.parent_map, ptr %13, i32 %i.051, i32 1
  %14 = ptrtoint ptr %cfg to i32
  call void @__asan_load1_noabort(i32 %14)
  %15 = load i8, ptr %cfg, align 1
  %conv10 = zext i8 %15 to i32
  call void @__sanitizer_cov_trace_cmp4(i32 %and.i, i32 %conv10)
  %cmp11 = icmp eq i32 %and.i, %conv10
  br i1 %cmp11, label %if.then13, label %for.inc

if.then13:                                        ; preds = %for.body
  call void @__sanitizer_cov_trace_pc() #5
  %arrayidx = getelementptr %struct.parent_map, ptr %13, i32 %i.051
  %16 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load1_noabort(i32 %16)
  %17 = load i8, ptr %arrayidx, align 1
  %src17 = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 1
  %18 = ptrtoint ptr %src17 to i32
  call void @__asan_store1_noabort(i32 %18)
  store i8 %17, ptr %src17, align 4
  br label %for.end

for.inc:                                          ; preds = %for.body
  %inc = add nuw nsw i32 %i.051, 1
  %exitcond.not = icmp eq i32 %inc, %call1
  br i1 %exitcond.not, label %for.inc.for.end_crit_edge, label %for.inc.for.body_crit_edge

for.inc.for.body_crit_edge:                       ; preds = %for.inc
  call void @__sanitizer_cov_trace_pc() #5
  br label %for.body

for.inc.for.end_crit_edge:                        ; preds = %for.inc
  call void @__sanitizer_cov_trace_pc() #5
  br label %for.end

for.end:                                          ; preds = %for.inc.for.end_crit_edge, %if.then13, %if.end5.for.end_crit_edge
  %div19 = udiv i32 %parent_rate, %rate
  call void @__sanitizer_cov_trace_const_cmp4(i32 1, i32 %div19)
  %cmp20 = icmp slt i32 %div19, 1
  call void @__sanitizer_cov_trace_cmp4(i32 %div19, i32 %shl)
  %cmp22.not = icmp sgt i32 %div19, %shl
  %or.cond = select i1 %cmp20, i1 true, i1 %cmp22.not
  br i1 %or.cond, label %for.end.cleanup_crit_edge, label %if.then24

for.end.cleanup_crit_edge:                        ; preds = %for.end
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.then24:                                        ; preds = %for.end
  call void @__sanitizer_cov_trace_pc() #5
  %conv25 = trunc i32 %div19 to i8
  %pre_div = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 2
  %19 = ptrtoint ptr %pre_div to i32
  call void @__asan_store1_noabort(i32 %19)
  store i8 %conv25, ptr %pre_div, align 1
  call fastcc void @__clk_rcg_set_rate(ptr noundef %add.ptr, ptr noundef nonnull %f)
  br label %cleanup

cleanup:                                          ; preds = %if.then24, %for.end.cleanup_crit_edge, %if.end.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ 0, %if.then24 ], [ -22, %entry.cleanup_crit_edge ], [ %call3, %if.end.cleanup_crit_edge ], [ -22, %for.end.cleanup_crit_edge ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ns) #3
  call void @llvm.lifetime.end.p0(i64 12, ptr nonnull %f) #3
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_rcg_esc_set_rate_and_parent(ptr noundef %hw, i32 noundef %rate, i32 noundef %parent_rate, i8 noundef zeroext %index) #1 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call i32 @clk_rcg_esc_set_rate(ptr noundef %hw, i32 noundef %rate, i32 noundef %parent_rate)
  ret i32 %call
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_rcg_lcc_enable(ptr nocapture noundef readonly %hw) #1 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %hw, i32 -32
  %regmap = getelementptr inbounds %struct.clk_regmap, ptr %hw, i32 0, i32 1
  %0 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %regmap, align 4
  %2 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %add.ptr, align 4
  %call.i = tail call i32 @regmap_update_bits_base(ptr noundef %1, i32 noundef %3, i32 noundef 1024, i32 noundef 1024, ptr noundef null, i1 noundef zeroext false, i1 noundef zeroext false) #3
  ret i32 %call.i
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @clk_rcg_lcc_disable(ptr nocapture noundef readonly %hw) #1 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %hw, i32 -32
  %regmap = getelementptr inbounds %struct.clk_regmap, ptr %hw, i32 0, i32 1
  %0 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %regmap, align 4
  %2 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %add.ptr, align 4
  %call.i = tail call i32 @regmap_update_bits_base(ptr noundef %1, i32 noundef %3, i32 noundef 1024, i32 noundef 0, ptr noundef null, i1 noundef zeroext false, i1 noundef zeroext false) #3
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_rcg_lcc_set_rate(ptr nocapture noundef readonly %hw, i32 noundef %rate, i32 noundef %parent_rate) #1 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %hw, i32 -32
  %freq_tbl = getelementptr i8, ptr %hw, i32 -4
  %0 = ptrtoint ptr %freq_tbl to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %freq_tbl, align 4
  %call1 = tail call ptr @qcom_find_freq(ptr noundef %1, i32 noundef %rate) #3
  %tobool.not = icmp eq ptr %call1, null
  br i1 %tobool.not, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end:                                           ; preds = %entry
  %regmap = getelementptr inbounds %struct.clk_regmap, ptr %hw, i32 0, i32 1
  %2 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %regmap, align 4
  %4 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %add.ptr, align 4
  %call.i = tail call i32 @regmap_update_bits_base(ptr noundef %3, i32 noundef %5, i32 noundef 1024, i32 noundef 0, ptr noundef null, i1 noundef zeroext false, i1 noundef zeroext false) #3
  tail call fastcc void @__clk_rcg_set_rate(ptr noundef %add.ptr, ptr noundef nonnull %call1)
  %clk = getelementptr inbounds %struct.clk_hw, ptr %hw, i32 0, i32 1
  %6 = ptrtoint ptr %clk to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %clk, align 4
  %call4 = tail call zeroext i1 @__clk_is_enabled(ptr noundef %7) #3
  br i1 %call4, label %if.then5, label %if.end.cleanup_crit_edge

if.end.cleanup_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.then5:                                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #5
  %8 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %regmap, align 4
  %10 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %add.ptr, align 4
  %call.i23 = tail call i32 @regmap_update_bits_base(ptr noundef %9, i32 noundef %11, i32 noundef 1024, i32 noundef 1024, ptr noundef null, i1 noundef zeroext false, i1 noundef zeroext false) #3
  br label %cleanup

cleanup:                                          ; preds = %if.then5, %if.end.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ -22, %entry.cleanup_crit_edge ], [ 0, %if.then5 ], [ 0, %if.end.cleanup_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @clk_is_enabled_regmap(ptr noundef) #0

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_dyn_rcg_recalc_rate(ptr nocapture noundef readonly %hw, i32 noundef %parent_rate) #1 align 64 {
entry:
  %ns = alloca i32, align 4
  %md = alloca i32, align 4
  %reg = alloca i32, align 4
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %hw, i32 -60
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ns) #3
  %0 = ptrtoint ptr %ns to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %ns, align 4, !annotation !48
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %md) #3
  %1 = ptrtoint ptr %md to i32
  call void @__asan_store4_noabort(i32 %1)
  store i32 -1, ptr %md, align 4, !annotation !48
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %reg) #3
  %2 = ptrtoint ptr %reg to i32
  call void @__asan_store4_noabort(i32 %2)
  store i32 -1, ptr %reg, align 4, !annotation !48
  %p = getelementptr i8, ptr %hw, i32 -25
  %pre_div_width = getelementptr i8, ptr %hw, i32 -22
  %3 = ptrtoint ptr %pre_div_width to i32
  call void @__asan_load1_noabort(i32 %3)
  %4 = load i8, ptr %pre_div_width, align 1
  call void @__sanitizer_cov_trace_const_cmp1(i8 0, i8 %4)
  %tobool.not = icmp eq i8 %4, 0
  %width = getelementptr i8, ptr %hw, i32 -27
  %5 = ptrtoint ptr %width to i32
  call void @__asan_load1_noabort(i32 %5)
  %6 = load i8, ptr %width, align 1
  call void @__sanitizer_cov_trace_const_cmp1(i8 0, i8 %6)
  %tobool4.not = icmp eq i8 %6, 0
  %regmap = getelementptr inbounds %struct.clk_regmap, ptr %hw, i32 0, i32 1
  %7 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %regmap, align 4
  %bank_reg = getelementptr i8, ptr %hw, i32 -44
  %9 = ptrtoint ptr %bank_reg to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %bank_reg, align 4
  %call8 = call i32 @regmap_read(ptr noundef %8, i32 noundef %10, ptr noundef nonnull %reg) #3
  %11 = ptrtoint ptr %reg to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %reg, align 4
  %mux_sel_bit.i = getelementptr i8, ptr %hw, i32 -40
  %13 = ptrtoint ptr %mux_sel_bit.i to i32
  call void @__asan_load1_noabort(i32 %13)
  %14 = load i8, ptr %mux_sel_bit.i, align 4
  %conv.i = zext i8 %14 to i32
  %15 = lshr i32 %12, %conv.i
  %16 = and i32 %15, 1
  %17 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %regmap, align 4
  %arrayidx12 = getelementptr [2 x i32], ptr %add.ptr, i32 0, i32 %16
  %19 = ptrtoint ptr %arrayidx12 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %arrayidx12, align 4
  %call13 = call i32 @regmap_read(ptr noundef %18, i32 noundef %20, ptr noundef nonnull %ns) #3
  br i1 %tobool4.not, label %entry.if.end29_crit_edge, label %if.then

entry.if.end29_crit_edge:                         ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end29

if.then:                                          ; preds = %entry
  %mn2 = getelementptr i8, ptr %hw, i32 -39
  %arrayidx16 = getelementptr [2 x %struct.mn], ptr %mn2, i32 0, i32 %16
  %21 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %regmap, align 4
  %md_reg = getelementptr i8, ptr %hw, i32 -52
  %arrayidx19 = getelementptr [2 x i32], ptr %md_reg, i32 0, i32 %16
  %23 = ptrtoint ptr %arrayidx19 to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %arrayidx19, align 4
  %call20 = call i32 @regmap_read(ptr noundef %22, i32 noundef %24, ptr noundef nonnull %md) #3
  %25 = ptrtoint ptr %md to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %md, align 4
  %m_val_shift.i = getelementptr inbounds %struct.mn, ptr %arrayidx16, i32 0, i32 4
  %27 = ptrtoint ptr %m_val_shift.i to i32
  call void @__asan_load1_noabort(i32 %27)
  %28 = load i8, ptr %m_val_shift.i, align 1
  %conv.i55 = zext i8 %28 to i32
  %shr.i = lshr i32 %26, %conv.i55
  %width.i = getelementptr inbounds %struct.mn, ptr %arrayidx16, i32 0, i32 5
  %29 = ptrtoint ptr %width.i to i32
  call void @__asan_load1_noabort(i32 %29)
  %30 = load i8, ptr %width.i, align 1
  %conv1.i = zext i8 %30 to i32
  %notmask.i = shl nsw i32 -1, %conv1.i
  %sub.i = xor i32 %notmask.i, -1
  %and.i = and i32 %shr.i, %sub.i
  %31 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %ns, align 4
  %neg.i = xor i32 %32, -1
  %n_val_shift.i = getelementptr inbounds %struct.mn, ptr %arrayidx16, i32 0, i32 3
  %33 = ptrtoint ptr %n_val_shift.i to i32
  call void @__asan_load1_noabort(i32 %33)
  %34 = load i8, ptr %n_val_shift.i, align 1
  %conv.i56 = zext i8 %34 to i32
  %shr.i57 = lshr i32 %neg.i, %conv.i56
  %and.i62 = and i32 %shr.i57, %sub.i
  %add.i = add i32 %and.i62, %and.i
  %35 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %add.ptr, align 4
  %arrayidx26 = getelementptr i8, ptr %hw, i32 -56
  %37 = ptrtoint ptr %arrayidx26 to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %arrayidx26, align 4
  call void @__sanitizer_cov_trace_cmp4(i32 %36, i32 %38)
  %cmp.not = icmp eq i32 %36, %38
  br i1 %cmp.not, label %if.then.if.end_crit_edge, label %if.then27

if.then.if.end_crit_edge:                         ; preds = %if.then
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end

if.then27:                                        ; preds = %if.then
  call void @__sanitizer_cov_trace_pc() #5
  %39 = ptrtoint ptr %reg to i32
  call void @__asan_store4_noabort(i32 %39)
  store i32 %32, ptr %reg, align 4
  br label %if.end

if.end:                                           ; preds = %if.then27, %if.then.if.end_crit_edge
  %40 = ptrtoint ptr %reg to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %reg, align 4
  %mnctr_mode_shift.i = getelementptr inbounds %struct.mn, ptr %arrayidx16, i32 0, i32 2
  %42 = ptrtoint ptr %mnctr_mode_shift.i to i32
  call void @__asan_load1_noabort(i32 %42)
  %43 = load i8, ptr %mnctr_mode_shift.i, align 1
  %conv.i63 = zext i8 %43 to i32
  %shr.i64 = lshr i32 %41, %conv.i63
  %and.i65 = and i32 %shr.i64, 3
  br label %if.end29

if.end29:                                         ; preds = %if.end, %entry.if.end29_crit_edge
  %m.0 = phi i32 [ %and.i, %if.end ], [ 0, %entry.if.end29_crit_edge ]
  %n.0 = phi i32 [ %add.i, %if.end ], [ 0, %entry.if.end29_crit_edge ]
  %mode.0 = phi i32 [ %and.i65, %if.end ], [ 0, %entry.if.end29_crit_edge ]
  br i1 %tobool.not, label %if.end29.if.end.i_crit_edge, label %if.end35

if.end29.if.end.i_crit_edge:                      ; preds = %if.end29
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end.i

if.end35:                                         ; preds = %if.end29
  %arrayidx33 = getelementptr [2 x %struct.pre_div], ptr %p, i32 0, i32 %16
  %44 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load i32, ptr %ns, align 4
  %46 = ptrtoint ptr %arrayidx33 to i32
  call void @__asan_load1_noabort(i32 %46)
  %47 = load i8, ptr %arrayidx33, align 1
  %conv.i66 = zext i8 %47 to i32
  %shr.i67 = lshr i32 %45, %conv.i66
  %pre_div_width.i = getelementptr inbounds %struct.pre_div, ptr %arrayidx33, i32 0, i32 1
  %48 = ptrtoint ptr %pre_div_width.i to i32
  call void @__asan_load1_noabort(i32 %48)
  %49 = load i8, ptr %pre_div_width.i, align 1
  %conv1.i68 = zext i8 %49 to i32
  %notmask.i69 = shl nsw i32 -1, %conv1.i68
  %sub.i70 = xor i32 %notmask.i69, -1
  %and.i71 = and i32 %shr.i67, %sub.i70
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and.i71)
  %tobool.not.i = icmp eq i32 %and.i71, 0
  br i1 %tobool.not.i, label %if.end35.if.end.i_crit_edge, label %if.then.i

if.end35.if.end.i_crit_edge:                      ; preds = %if.end35
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end.i

if.then.i:                                        ; preds = %if.end35
  call void @__sanitizer_cov_trace_pc() #5
  %add.i72 = add i32 %and.i71, 1
  %div.i = udiv i32 %parent_rate, %add.i72
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.end35.if.end.i_crit_edge, %if.end29.if.end.i_crit_edge
  %rate.addr.0.i = phi i32 [ %div.i, %if.then.i ], [ %parent_rate, %if.end35.if.end.i_crit_edge ], [ %parent_rate, %if.end29.if.end.i_crit_edge ]
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %mode.0)
  %tobool1.not.i = icmp eq i32 %mode.0, 0
  br i1 %tobool1.not.i, label %if.end.i.calc_rate.exit_crit_edge, label %if.then2.i

if.end.i.calc_rate.exit_crit_edge:                ; preds = %if.end.i
  call void @__sanitizer_cov_trace_pc() #5
  br label %calc_rate.exit

if.then2.i:                                       ; preds = %if.end.i
  %conv.i73 = zext i32 %rate.addr.0.i to i64
  %conv3.i = zext i32 %m.0 to i64
  %mul.i = mul nuw i64 %conv.i73, %conv3.i
  call void @__sanitizer_cov_trace_const_cmp8(i64 4294967296, i64 %mul.i)
  %cmp176.i = icmp ult i64 %mul.i, 4294967296
  br i1 %cmp176.i, label %if.then180.i, label %if.else186.i, !prof !49

if.then180.i:                                     ; preds = %if.then2.i
  call void @__sanitizer_cov_trace_pc() #5
  %conv181.i = trunc i64 %mul.i to i32
  %div184.i = udiv i32 %conv181.i, %n.0
  br label %calc_rate.exit

if.else186.i:                                     ; preds = %if.then2.i
  call void @__sanitizer_cov_trace_pc() #5
  %50 = call { i64, i64 } asm ".ifnc $0,r0; .ifnc $0r0,fpr11; .ifnc $0r0,r11fp; .ifnc $0r0,ipr12; .ifnc $0r0,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09.ifnc $1,r2; .ifnc $1r2,fpr11; .ifnc $1r2,r11fp; .ifnc $1r2,ipr12; .ifnc $1r2,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09.ifnc $2,r4; .ifnc $2r4,fpr11; .ifnc $2r4,r11fp; .ifnc $2r4,ipr12; .ifnc $2r4,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09bl\09__do_div64", "={r0},={r2},{r4},{r0},~{r12},~{lr},~{cc}"(i32 %n.0, i64 %mul.i) #6, !srcloc !50
  %asmresult1.i.i = extractvalue { i64, i64 } %50, 1
  %extract.t301.i = trunc i64 %asmresult1.i.i to i32
  br label %calc_rate.exit

calc_rate.exit:                                   ; preds = %if.else186.i, %if.then180.i, %if.end.i.calc_rate.exit_crit_edge
  %rate.addr.1.i = phi i32 [ %rate.addr.0.i, %if.end.i.calc_rate.exit_crit_edge ], [ %div184.i, %if.then180.i ], [ %extract.t301.i, %if.else186.i ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %reg) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %md) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ns) #3
  ret i32 %rate.addr.1.i
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_dyn_rcg_determine_rate(ptr noundef %hw, ptr nocapture noundef %req) #1 align 64 {
entry:
  %reg = alloca i32, align 4
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %reg) #3
  %0 = ptrtoint ptr %reg to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %reg, align 4, !annotation !48
  %regmap = getelementptr inbounds %struct.clk_regmap, ptr %hw, i32 0, i32 1
  %1 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %regmap, align 4
  %bank_reg = getelementptr i8, ptr %hw, i32 -44
  %3 = ptrtoint ptr %bank_reg to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %bank_reg, align 4
  %call1 = call i32 @regmap_read(ptr noundef %2, i32 noundef %4, ptr noundef nonnull %reg) #3
  %5 = ptrtoint ptr %reg to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %reg, align 4
  %mux_sel_bit.i = getelementptr i8, ptr %hw, i32 -40
  %7 = ptrtoint ptr %mux_sel_bit.i to i32
  call void @__asan_load1_noabort(i32 %7)
  %8 = load i8, ptr %mux_sel_bit.i, align 4
  %conv.i = zext i8 %8 to i32
  %9 = lshr i32 %6, %conv.i
  %10 = and i32 %9, 1
  %s3 = getelementptr i8, ptr %hw, i32 -20
  %arrayidx = getelementptr [2 x %struct.src_sel], ptr %s3, i32 0, i32 %10
  %freq_tbl = getelementptr i8, ptr %hw, i32 -4
  %11 = ptrtoint ptr %freq_tbl to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %freq_tbl, align 4
  %parent_map = getelementptr inbounds %struct.src_sel, ptr %arrayidx, i32 0, i32 1
  %13 = ptrtoint ptr %parent_map to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %parent_map, align 4
  %call4 = call fastcc i32 @_freq_tbl_determine_rate(ptr noundef %hw, ptr noundef %12, ptr noundef %req, ptr noundef %14)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %reg) #3
  ret i32 %call4
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_dyn_rcg_set_parent(ptr noundef %hw, i8 noundef zeroext %index) #1 align 64 {
entry:
  %ns = alloca i32, align 4
  %md = alloca i32, align 4
  %reg = alloca i32, align 4
  %f = alloca %struct.freq_tbl, align 4
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %hw, i32 -60
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ns) #3
  %0 = ptrtoint ptr %ns to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %ns, align 4, !annotation !48
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %md) #3
  %1 = ptrtoint ptr %md to i32
  call void @__asan_store4_noabort(i32 %1)
  store i32 -1, ptr %md, align 4, !annotation !48
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %reg) #3
  %2 = ptrtoint ptr %reg to i32
  call void @__asan_store4_noabort(i32 %2)
  store i32 -1, ptr %reg, align 4, !annotation !48
  call void @llvm.lifetime.start.p0(i64 12, ptr nonnull %f) #3
  %3 = call ptr @memset(ptr %f, i32 0, i32 12)
  %width = getelementptr i8, ptr %hw, i32 -27
  %4 = ptrtoint ptr %width to i32
  call void @__asan_load1_noabort(i32 %4)
  %5 = load i8, ptr %width, align 1
  call void @__sanitizer_cov_trace_const_cmp1(i8 0, i8 %5)
  %tobool.not = icmp eq i8 %5, 0
  %p = getelementptr i8, ptr %hw, i32 -25
  %pre_div_width = getelementptr i8, ptr %hw, i32 -22
  %6 = ptrtoint ptr %pre_div_width to i32
  call void @__asan_load1_noabort(i32 %6)
  %7 = load i8, ptr %pre_div_width, align 1
  call void @__sanitizer_cov_trace_const_cmp1(i8 0, i8 %7)
  %tobool3.not = icmp eq i8 %7, 0
  %regmap = getelementptr inbounds %struct.clk_regmap, ptr %hw, i32 0, i32 1
  %8 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %regmap, align 4
  %bank_reg = getelementptr i8, ptr %hw, i32 -44
  %10 = ptrtoint ptr %bank_reg to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %bank_reg, align 4
  %call7 = call i32 @regmap_read(ptr noundef %9, i32 noundef %11, ptr noundef nonnull %reg) #3
  %12 = ptrtoint ptr %reg to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %reg, align 4
  %mux_sel_bit.i = getelementptr i8, ptr %hw, i32 -40
  %14 = ptrtoint ptr %mux_sel_bit.i to i32
  call void @__asan_load1_noabort(i32 %14)
  %15 = load i8, ptr %mux_sel_bit.i, align 4
  %conv.i = zext i8 %15 to i32
  %16 = lshr i32 %13, %conv.i
  %17 = and i32 %16, 1
  %18 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load ptr, ptr %regmap, align 4
  %arrayidx11 = getelementptr [2 x i32], ptr %add.ptr, i32 0, i32 %17
  %20 = ptrtoint ptr %arrayidx11 to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %arrayidx11, align 4
  %call12 = call i32 @regmap_read(ptr noundef %19, i32 noundef %21, ptr noundef nonnull %ns) #3
  br i1 %tobool.not, label %entry.if.end_crit_edge, label %if.then

entry.if.end_crit_edge:                           ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end

if.then:                                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  %mn = getelementptr i8, ptr %hw, i32 -39
  %22 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %regmap, align 4
  %md_reg = getelementptr i8, ptr %hw, i32 -52
  %arrayidx16 = getelementptr [2 x i32], ptr %md_reg, i32 0, i32 %17
  %24 = ptrtoint ptr %arrayidx16 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %arrayidx16, align 4
  %call17 = call i32 @regmap_read(ptr noundef %23, i32 noundef %25, ptr noundef nonnull %md) #3
  %arrayidx19 = getelementptr [2 x %struct.mn], ptr %mn, i32 0, i32 %17
  %26 = ptrtoint ptr %md to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %md, align 4
  %m_val_shift.i = getelementptr inbounds %struct.mn, ptr %arrayidx19, i32 0, i32 4
  %28 = ptrtoint ptr %m_val_shift.i to i32
  call void @__asan_load1_noabort(i32 %28)
  %29 = load i8, ptr %m_val_shift.i, align 1
  %conv.i57 = zext i8 %29 to i32
  %shr.i = lshr i32 %27, %conv.i57
  %width.i = getelementptr inbounds %struct.mn, ptr %arrayidx19, i32 0, i32 5
  %30 = ptrtoint ptr %width.i to i32
  call void @__asan_load1_noabort(i32 %30)
  %31 = load i8, ptr %width.i, align 1
  %conv1.i = zext i8 %31 to i32
  %notmask.i = shl nsw i32 -1, %conv1.i
  %sub.i = xor i32 %notmask.i, -1
  %and.i = and i32 %shr.i, %sub.i
  %conv = trunc i32 %and.i to i16
  %m = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 3
  %32 = ptrtoint ptr %m to i32
  call void @__asan_store2_noabort(i32 %32)
  store i16 %conv, ptr %m, align 2
  %33 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %ns, align 4
  %neg.i = xor i32 %34, -1
  %n_val_shift.i = getelementptr inbounds %struct.mn, ptr %arrayidx19, i32 0, i32 3
  %35 = ptrtoint ptr %n_val_shift.i to i32
  call void @__asan_load1_noabort(i32 %35)
  %36 = load i8, ptr %n_val_shift.i, align 1
  %conv.i58 = zext i8 %36 to i32
  %shr.i59 = lshr i32 %neg.i, %conv.i58
  %and.i64 = and i32 %shr.i59, %sub.i
  %add.i = add i32 %and.i64, %and.i
  %conv26 = trunc i32 %add.i to i16
  %n = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 4
  %37 = ptrtoint ptr %n to i32
  call void @__asan_store2_noabort(i32 %37)
  store i16 %conv26, ptr %n, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry.if.end_crit_edge
  br i1 %tobool3.not, label %if.end.if.end33_crit_edge, label %if.then28

if.end.if.end33_crit_edge:                        ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end33

if.then28:                                        ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #5
  %arrayidx30 = getelementptr [2 x %struct.pre_div], ptr %p, i32 0, i32 %17
  %38 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load i32, ptr %ns, align 4
  %40 = ptrtoint ptr %arrayidx30 to i32
  call void @__asan_load1_noabort(i32 %40)
  %41 = load i8, ptr %arrayidx30, align 1
  %conv.i65 = zext i8 %41 to i32
  %shr.i66 = lshr i32 %39, %conv.i65
  %pre_div_width.i = getelementptr inbounds %struct.pre_div, ptr %arrayidx30, i32 0, i32 1
  %42 = ptrtoint ptr %pre_div_width.i to i32
  call void @__asan_load1_noabort(i32 %42)
  %43 = load i8, ptr %pre_div_width.i, align 1
  %conv1.i67 = zext i8 %43 to i32
  %notmask.i68 = shl nsw i32 -1, %conv1.i67
  %sub.i69 = xor i32 %notmask.i68, -1
  %and.i70 = and i32 %shr.i66, %sub.i69
  %44 = trunc i32 %and.i70 to i8
  %conv32 = add i8 %44, 1
  %pre_div = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 2
  %45 = ptrtoint ptr %pre_div to i32
  call void @__asan_store1_noabort(i32 %45)
  store i8 %conv32, ptr %pre_div, align 1
  br label %if.end33

if.end33:                                         ; preds = %if.then28, %if.end.if.end33_crit_edge
  %s = getelementptr i8, ptr %hw, i32 -20
  %arrayidx34 = getelementptr [2 x %struct.src_sel], ptr %s, i32 0, i32 %17
  %parent_map = getelementptr inbounds %struct.src_sel, ptr %arrayidx34, i32 0, i32 1
  %46 = ptrtoint ptr %parent_map to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load ptr, ptr %parent_map, align 4
  %call35 = call i32 @qcom_find_src_index(ptr noundef %hw, ptr noundef %47, i8 noundef zeroext %index) #3
  %conv36 = trunc i32 %call35 to i8
  %src = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 1
  %48 = ptrtoint ptr %src to i32
  call void @__asan_store1_noabort(i32 %48)
  store i8 %conv36, ptr %src, align 4
  %call37 = call fastcc i32 @configure_bank(ptr noundef %add.ptr, ptr noundef nonnull %f)
  call void @llvm.lifetime.end.p0(i64 12, ptr nonnull %f) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %reg) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %md) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ns) #3
  ret i32 %call37
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal zeroext i8 @clk_dyn_rcg_get_parent(ptr noundef %hw) #1 align 64 {
entry:
  %ns = alloca i32, align 4
  %reg = alloca i32, align 4
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %call1 = tail call i32 @clk_hw_get_num_parents(ptr noundef %hw) #3
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ns) #3
  %0 = ptrtoint ptr %ns to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %ns, align 4, !annotation !48
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %reg) #3
  %1 = ptrtoint ptr %reg to i32
  call void @__asan_store4_noabort(i32 %1)
  store i32 -1, ptr %reg, align 4, !annotation !48
  %regmap = getelementptr inbounds %struct.clk_regmap, ptr %hw, i32 0, i32 1
  %2 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %regmap, align 4
  %bank_reg = getelementptr i8, ptr %hw, i32 -44
  %4 = ptrtoint ptr %bank_reg to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %bank_reg, align 4
  %call2 = call i32 @regmap_read(ptr noundef %3, i32 noundef %5, ptr noundef nonnull %reg) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call2)
  %tobool.not = icmp eq i32 %call2, 0
  br i1 %tobool.not, label %if.end, label %entry.do.body_crit_edge

entry.do.body_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  br label %do.body

if.end:                                           ; preds = %entry
  %add.ptr = getelementptr i8, ptr %hw, i32 -60
  %6 = ptrtoint ptr %reg to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %reg, align 4
  %mux_sel_bit.i = getelementptr i8, ptr %hw, i32 -40
  %8 = ptrtoint ptr %mux_sel_bit.i to i32
  call void @__asan_load1_noabort(i32 %8)
  %9 = load i8, ptr %mux_sel_bit.i, align 4
  %conv.i = zext i8 %9 to i32
  %10 = lshr i32 %7, %conv.i
  %11 = and i32 %10, 1
  %s4 = getelementptr i8, ptr %hw, i32 -20
  %arrayidx = getelementptr [2 x %struct.src_sel], ptr %s4, i32 0, i32 %11
  %12 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %regmap, align 4
  %arrayidx7 = getelementptr [2 x i32], ptr %add.ptr, i32 0, i32 %11
  %14 = ptrtoint ptr %arrayidx7 to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %arrayidx7, align 4
  %call8 = call i32 @regmap_read(ptr noundef %13, i32 noundef %15, ptr noundef nonnull %ns) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call8)
  %tobool9.not = icmp eq i32 %call8, 0
  br i1 %tobool9.not, label %if.end11, label %if.end.do.body_crit_edge

if.end.do.body_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #5
  br label %do.body

if.end11:                                         ; preds = %if.end
  %16 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %ns, align 4
  %18 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load1_noabort(i32 %18)
  %19 = load i8, ptr %arrayidx, align 4
  %conv.i47 = zext i8 %19 to i32
  %shr.i = lshr i32 %17, %conv.i47
  %and.i = and i32 %shr.i, 7
  store i32 %and.i, ptr %ns, align 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call1)
  %cmp50 = icmp sgt i32 %call1, 0
  br i1 %cmp50, label %for.body.lr.ph, label %if.end11.do.body_crit_edge

if.end11.do.body_crit_edge:                       ; preds = %if.end11
  call void @__sanitizer_cov_trace_pc() #5
  br label %do.body

for.body.lr.ph:                                   ; preds = %if.end11
  %parent_map = getelementptr inbounds %struct.src_sel, ptr %arrayidx, i32 0, i32 1
  %20 = ptrtoint ptr %parent_map to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %parent_map, align 4
  br label %for.body

for.body:                                         ; preds = %for.inc.for.body_crit_edge, %for.body.lr.ph
  %i.051 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.inc.for.body_crit_edge ]
  %cfg = getelementptr %struct.parent_map, ptr %21, i32 %i.051, i32 1
  %22 = ptrtoint ptr %cfg to i32
  call void @__asan_load1_noabort(i32 %22)
  %23 = load i8, ptr %cfg, align 1
  %conv = zext i8 %23 to i32
  call void @__sanitizer_cov_trace_cmp4(i32 %and.i, i32 %conv)
  %cmp14 = icmp eq i32 %and.i, %conv
  br i1 %cmp14, label %if.then16, label %for.inc

if.then16:                                        ; preds = %for.body
  call void @__sanitizer_cov_trace_pc() #5
  %conv17 = trunc i32 %i.051 to i8
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nuw nsw i32 %i.051, 1
  %exitcond.not = icmp eq i32 %inc, %call1
  br i1 %exitcond.not, label %for.inc.do.body_crit_edge, label %for.inc.for.body_crit_edge

for.inc.for.body_crit_edge:                       ; preds = %for.inc
  call void @__sanitizer_cov_trace_pc() #5
  br label %for.body

for.inc.do.body_crit_edge:                        ; preds = %for.inc
  call void @__sanitizer_cov_trace_pc() #5
  br label %do.body

do.body:                                          ; preds = %for.inc.do.body_crit_edge, %if.end11.do.body_crit_edge, %if.end.do.body_crit_edge, %entry.do.body_crit_edge
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds ({ ptr, ptr, ptr, ptr, i8, i8, i8, i8, { { { %struct.atomic_t, { ptr } } } }, [4 x i8] }, ptr @clk_dyn_rcg_get_parent.__UNIQUE_ID_ddebug155, i32 0, i32 8, i32 0, i32 0, i32 0, i32 0), ptr blockaddress(@clk_dyn_rcg_get_parent, %if.then24)) #3
          to label %cleanup [label %if.then24], !srcloc !51

if.then24:                                        ; preds = %do.body
  call void @__sanitizer_cov_trace_pc() #5
  %call25 = call ptr @clk_hw_get_name(ptr noundef %hw) #3
  call void (ptr, ptr, ...) @__dynamic_pr_debug(ptr noundef nonnull @clk_dyn_rcg_get_parent.__UNIQUE_ID_ddebug155, ptr noundef nonnull @.str.3, ptr noundef nonnull @.str.4, ptr noundef %call25) #3
  br label %cleanup

cleanup:                                          ; preds = %if.then24, %do.body, %if.then16
  %retval.0 = phi i8 [ %conv17, %if.then16 ], [ 0, %if.then24 ], [ 0, %do.body ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %reg) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ns) #3
  ret i8 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_dyn_rcg_set_rate(ptr noundef %hw, i32 noundef %rate, i32 noundef %parent_rate) #1 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %freq_tbl.i = getelementptr i8, ptr %hw, i32 -4
  %0 = ptrtoint ptr %freq_tbl.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %freq_tbl.i, align 4
  %call1.i = tail call ptr @qcom_find_freq(ptr noundef %1, i32 noundef %rate) #3
  %tobool.not.i = icmp eq ptr %call1.i, null
  br i1 %tobool.not.i, label %entry.__clk_dyn_rcg_set_rate.exit_crit_edge, label %if.end.i

entry.__clk_dyn_rcg_set_rate.exit_crit_edge:      ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  br label %__clk_dyn_rcg_set_rate.exit

if.end.i:                                         ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  %add.ptr.i = getelementptr i8, ptr %hw, i32 -60
  %call2.i = tail call fastcc i32 @configure_bank(ptr noundef %add.ptr.i, ptr noundef nonnull %call1.i) #3
  br label %__clk_dyn_rcg_set_rate.exit

__clk_dyn_rcg_set_rate.exit:                      ; preds = %if.end.i, %entry.__clk_dyn_rcg_set_rate.exit_crit_edge
  %retval.0.i = phi i32 [ %call2.i, %if.end.i ], [ -22, %entry.__clk_dyn_rcg_set_rate.exit_crit_edge ]
  ret i32 %retval.0.i
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @clk_dyn_rcg_set_rate_and_parent(ptr noundef %hw, i32 noundef %rate, i32 noundef %parent_rate, i8 noundef zeroext %index) #1 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %freq_tbl.i = getelementptr i8, ptr %hw, i32 -4
  %0 = ptrtoint ptr %freq_tbl.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %freq_tbl.i, align 4
  %call1.i = tail call ptr @qcom_find_freq(ptr noundef %1, i32 noundef %rate) #3
  %tobool.not.i = icmp eq ptr %call1.i, null
  br i1 %tobool.not.i, label %entry.__clk_dyn_rcg_set_rate.exit_crit_edge, label %if.end.i

entry.__clk_dyn_rcg_set_rate.exit_crit_edge:      ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  br label %__clk_dyn_rcg_set_rate.exit

if.end.i:                                         ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  %add.ptr.i = getelementptr i8, ptr %hw, i32 -60
  %call2.i = tail call fastcc i32 @configure_bank(ptr noundef %add.ptr.i, ptr noundef nonnull %call1.i) #3
  br label %__clk_dyn_rcg_set_rate.exit

__clk_dyn_rcg_set_rate.exit:                      ; preds = %if.end.i, %entry.__clk_dyn_rcg_set_rate.exit_crit_edge
  %retval.0.i = phi i32 [ %call2.i, %if.end.i ], [ -22, %entry.__clk_dyn_rcg_set_rate.exit_crit_edge ]
  ret i32 %retval.0.i
}

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #2

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @regmap_read(ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #0

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @_freq_tbl_determine_rate(ptr noundef %hw, ptr noundef %f, ptr nocapture noundef %req, ptr noundef %parent_map) unnamed_addr #1 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = ptrtoint ptr %req to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %req, align 4
  %call = tail call ptr @qcom_find_freq(ptr noundef %f, i32 noundef %1) #3
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end:                                           ; preds = %entry
  %src = getelementptr inbounds %struct.freq_tbl, ptr %call, i32 0, i32 1
  %2 = ptrtoint ptr %src to i32
  call void @__asan_load1_noabort(i32 %2)
  %3 = load i8, ptr %src, align 4
  %call2 = tail call i32 @qcom_find_src_index(ptr noundef %hw, ptr noundef %parent_map, i8 noundef zeroext %3) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call2)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %if.end.cleanup_crit_edge, label %if.end4

if.end.cleanup_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %call5 = tail call i32 @clk_hw_get_flags(ptr noundef %hw) #3
  %call6 = tail call ptr @clk_hw_get_parent_by_index(ptr noundef %hw, i32 noundef %call2) #3
  %and = and i32 %call5, 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and)
  %tobool7.not = icmp eq i32 %and, 0
  br i1 %tobool7.not, label %if.else207, label %if.then8

if.then8:                                         ; preds = %if.end4
  %pre_div = getelementptr inbounds %struct.freq_tbl, ptr %call, i32 0, i32 2
  %4 = ptrtoint ptr %pre_div to i32
  call void @__asan_load1_noabort(i32 %4)
  %5 = load i8, ptr %pre_div, align 1
  %conv = zext i8 %5 to i32
  %mul = mul i32 %1, %conv
  %n = getelementptr inbounds %struct.freq_tbl, ptr %call, i32 0, i32 4
  %6 = ptrtoint ptr %n to i32
  call void @__asan_load2_noabort(i32 %6)
  %7 = load i16, ptr %n, align 4
  call void @__sanitizer_cov_trace_const_cmp2(i16 0, i16 %7)
  %tobool9.not = icmp eq i16 %7, 0
  br i1 %tobool9.not, label %if.then8.if.end209_crit_edge, label %if.then10

if.then8.if.end209_crit_edge:                     ; preds = %if.then8
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end209

if.then10:                                        ; preds = %if.then8
  %conv11 = zext i32 %mul to i64
  %conv13 = zext i16 %7 to i64
  %mul14 = mul nuw nsw i64 %conv11, %conv13
  %m = getelementptr inbounds %struct.freq_tbl, ptr %call, i32 0, i32 3
  %8 = ptrtoint ptr %m to i32
  call void @__asan_load2_noabort(i32 %8)
  %9 = load i16, ptr %m, align 2
  %conv15 = zext i16 %9 to i32
  call void @__sanitizer_cov_trace_const_cmp8(i64 4294967296, i64 %mul14)
  %cmp189 = icmp ult i64 %mul14, 4294967296
  br i1 %cmp189, label %if.then193, label %if.else199, !prof !49

if.then193:                                       ; preds = %if.then10
  call void @__sanitizer_cov_trace_pc() #5
  %conv194 = trunc i64 %mul14 to i32
  %div197 = udiv i32 %conv194, %conv15
  br label %if.end209

if.else199:                                       ; preds = %if.then10
  call void @__sanitizer_cov_trace_pc() #5
  %10 = tail call { i64, i64 } asm ".ifnc $0,r0; .ifnc $0r0,fpr11; .ifnc $0r0,r11fp; .ifnc $0r0,ipr12; .ifnc $0r0,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09.ifnc $1,r2; .ifnc $1r2,fpr11; .ifnc $1r2,r11fp; .ifnc $1r2,ipr12; .ifnc $1r2,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09.ifnc $2,r4; .ifnc $2r4,fpr11; .ifnc $2r4,r11fp; .ifnc $2r4,ipr12; .ifnc $2r4,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09bl\09__do_div64", "={r0},={r2},{r4},{r0},~{r12},~{lr},~{cc}"(i32 %conv15, i64 %mul14) #6, !srcloc !50
  %asmresult1.i = extractvalue { i64, i64 } %10, 1
  %extract.t323 = trunc i64 %asmresult1.i to i32
  br label %if.end209

if.else207:                                       ; preds = %if.end4
  call void @__sanitizer_cov_trace_pc() #5
  %call208 = tail call i32 @clk_hw_get_rate(ptr noundef %call6) #3
  br label %if.end209

if.end209:                                        ; preds = %if.else207, %if.else199, %if.then193, %if.then8.if.end209_crit_edge
  %rate.0 = phi i32 [ %mul, %if.then8.if.end209_crit_edge ], [ %call208, %if.else207 ], [ %div197, %if.then193 ], [ %extract.t323, %if.else199 ]
  %best_parent_hw = getelementptr inbounds %struct.clk_rate_request, ptr %req, i32 0, i32 4
  %11 = ptrtoint ptr %best_parent_hw to i32
  call void @__asan_store4_noabort(i32 %11)
  store ptr %call6, ptr %best_parent_hw, align 4
  %best_parent_rate = getelementptr inbounds %struct.clk_rate_request, ptr %req, i32 0, i32 3
  %12 = ptrtoint ptr %best_parent_rate to i32
  call void @__asan_store4_noabort(i32 %12)
  store i32 %rate.0, ptr %best_parent_rate, align 4
  %13 = ptrtoint ptr %call to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %call, align 4
  %15 = ptrtoint ptr %req to i32
  call void @__asan_store4_noabort(i32 %15)
  store i32 %14, ptr %req, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end209, %if.end.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ 0, %if.end209 ], [ -22, %entry.cleanup_crit_edge ], [ %call2, %if.end.cleanup_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @qcom_find_freq(ptr noundef, i32 noundef) local_unnamed_addr #0

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @qcom_find_src_index(ptr noundef, ptr noundef, i8 noundef zeroext) local_unnamed_addr #0

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @clk_hw_get_flags(ptr noundef) local_unnamed_addr #0

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @clk_hw_get_parent_by_index(ptr noundef, i32 noundef) local_unnamed_addr #0

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @clk_hw_get_rate(ptr noundef) local_unnamed_addr #0

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @regmap_write(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #0

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @clk_hw_get_num_parents(ptr noundef) local_unnamed_addr #0

; Function Attrs: null_pointer_is_valid
declare dso_local void @__dynamic_pr_debug(ptr noundef, ptr noundef, ...) local_unnamed_addr #0

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @clk_hw_get_name(ptr noundef) local_unnamed_addr #0

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @__clk_rcg_set_rate(ptr nocapture noundef readonly %rcg, ptr nocapture noundef readonly %f) unnamed_addr #1 align 64 {
entry:
  %ns = alloca i32, align 4
  %md = alloca i32, align 4
  %ctl = alloca i32, align 4
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ns) #3
  %0 = ptrtoint ptr %ns to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %ns, align 4, !annotation !48
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %md) #3
  %1 = ptrtoint ptr %md to i32
  call void @__asan_store4_noabort(i32 %1)
  store i32 -1, ptr %md, align 4, !annotation !48
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ctl) #3
  %2 = ptrtoint ptr %ctl to i32
  call void @__asan_store4_noabort(i32 %2)
  store i32 -1, ptr %ctl, align 4, !annotation !48
  %mn1 = getelementptr inbounds %struct.clk_rcg, ptr %rcg, i32 0, i32 2
  %reset_in_cc = getelementptr inbounds %struct.clk_rcg, ptr %rcg, i32 0, i32 2, i32 6
  %3 = ptrtoint ptr %reset_in_cc to i32
  call void @__asan_load1_noabort(i32 %3)
  %4 = load i8, ptr %reset_in_cc, align 2, !range !52
  call void @__sanitizer_cov_trace_const_cmp1(i8 0, i8 %4)
  %tobool.not = icmp eq i8 %4, 0
  %enable_reg = getelementptr inbounds %struct.clk_rcg, ptr %rcg, i32 0, i32 6, i32 2
  %reset_reg.0.in = select i1 %tobool.not, ptr %rcg, ptr %enable_reg
  %5 = ptrtoint ptr %reset_reg.0.in to i32
  call void @__asan_load4_noabort(i32 %5)
  %reset_reg.0 = load i32, ptr %reset_reg.0.in, align 4
  %width = getelementptr inbounds %struct.clk_rcg, ptr %rcg, i32 0, i32 2, i32 5
  %6 = ptrtoint ptr %width to i32
  call void @__asan_load1_noabort(i32 %6)
  %7 = load i8, ptr %width, align 1
  call void @__sanitizer_cov_trace_const_cmp1(i8 0, i8 %7)
  %tobool4.not = icmp eq i8 %7, 0
  br i1 %tobool4.not, label %if.else53, label %if.then5

if.then5:                                         ; preds = %entry
  %mnctr_reset_bit = getelementptr inbounds %struct.clk_rcg, ptr %rcg, i32 0, i32 2, i32 1
  %8 = ptrtoint ptr %mnctr_reset_bit to i32
  call void @__asan_load1_noabort(i32 %8)
  %9 = load i8, ptr %mnctr_reset_bit, align 1
  %conv = zext i8 %9 to i32
  %shl = shl nuw i32 1, %conv
  %regmap = getelementptr inbounds %struct.clk_rcg, ptr %rcg, i32 0, i32 6, i32 1
  %10 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %regmap, align 4
  %call.i = tail call i32 @regmap_update_bits_base(ptr noundef %11, i32 noundef %reset_reg.0, i32 noundef %shl, i32 noundef %shl, ptr noundef null, i1 noundef zeroext false, i1 noundef zeroext false) #3
  %12 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %regmap, align 4
  %md_reg = getelementptr inbounds %struct.clk_rcg, ptr %rcg, i32 0, i32 1
  %14 = ptrtoint ptr %md_reg to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %md_reg, align 4
  %call9 = call i32 @regmap_read(ptr noundef %13, i32 noundef %15, ptr noundef nonnull %md) #3
  %m = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 3
  %n = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 4
  %16 = ptrtoint ptr %n to i32
  call void @__asan_load2_noabort(i32 %16)
  %17 = load i16, ptr %n, align 4
  %18 = ptrtoint ptr %md to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %md, align 4
  %20 = ptrtoint ptr %width to i32
  call void @__asan_load1_noabort(i32 %20)
  %21 = load i8, ptr %width, align 1
  %conv.i = zext i8 %21 to i32
  %notmask.i = shl nsw i32 -1, %conv.i
  %sub.i = xor i32 %notmask.i, -1
  %m_val_shift.i = getelementptr inbounds %struct.clk_rcg, ptr %rcg, i32 0, i32 2, i32 4
  %22 = ptrtoint ptr %m_val_shift.i to i32
  call void @__asan_load1_noabort(i32 %22)
  %23 = load i8, ptr %m_val_shift.i, align 1
  %conv1.i = zext i8 %23 to i32
  %shl2.i = shl i32 %sub.i, %conv1.i
  %shl2.not.i = xor i32 %shl2.i, -1
  %neg.i = and i32 %notmask.i, %19
  %and.i = and i32 %neg.i, %shl2.not.i
  call void @__sanitizer_cov_trace_const_cmp2(i16 0, i16 %17)
  %tobool.not.i = icmp eq i16 %17, 0
  br i1 %tobool.not.i, label %if.then5.mn_to_md.exit_crit_edge, label %if.then.i

if.then5.mn_to_md.exit_crit_edge:                 ; preds = %if.then5
  call void @__sanitizer_cov_trace_pc() #5
  br label %mn_to_md.exit

if.then.i:                                        ; preds = %if.then5
  call void @__sanitizer_cov_trace_pc() #5
  %conv11 = zext i16 %17 to i32
  %24 = ptrtoint ptr %m to i32
  call void @__asan_load2_noabort(i32 %24)
  %25 = load i16, ptr %m, align 2
  %conv10 = zext i16 %25 to i32
  %shl5.i = shl i32 %conv10, %conv1.i
  %neg7.i = xor i32 %conv11, -1
  %and8.i = and i32 %sub.i, %neg7.i
  %or6.i = or i32 %and.i, %and8.i
  %or9.i = or i32 %or6.i, %shl5.i
  br label %mn_to_md.exit

mn_to_md.exit:                                    ; preds = %if.then.i, %if.then5.mn_to_md.exit_crit_edge
  %md.addr.0.i = phi i32 [ %or9.i, %if.then.i ], [ %and.i, %if.then5.mn_to_md.exit_crit_edge ]
  %26 = ptrtoint ptr %md to i32
  call void @__asan_store4_noabort(i32 %26)
  store i32 %md.addr.0.i, ptr %md, align 4
  %27 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %regmap, align 4
  %29 = ptrtoint ptr %md_reg to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %md_reg, align 4
  %call16 = call i32 @regmap_write(ptr noundef %28, i32 noundef %30, i32 noundef %md.addr.0.i) #3
  %31 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %regmap, align 4
  %33 = ptrtoint ptr %rcg to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %rcg, align 4
  %call20 = call i32 @regmap_read(ptr noundef %32, i32 noundef %34, ptr noundef nonnull %ns) #3
  %35 = ptrtoint ptr %enable_reg to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %enable_reg, align 4
  %37 = ptrtoint ptr %rcg to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %rcg, align 4
  call void @__sanitizer_cov_trace_cmp4(i32 %36, i32 %38)
  %cmp.not = icmp eq i32 %36, %38
  br i1 %cmp.not, label %if.else41, label %if.then25

if.then25:                                        ; preds = %mn_to_md.exit
  call void @__sanitizer_cov_trace_pc() #5
  %39 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load ptr, ptr %regmap, align 4
  %call30 = call i32 @regmap_read(ptr noundef %40, i32 noundef %36, ptr noundef nonnull %ctl) #3
  %41 = ptrtoint ptr %n to i32
  call void @__asan_load2_noabort(i32 %41)
  %42 = load i16, ptr %n, align 4
  %43 = ptrtoint ptr %ctl to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load i32, ptr %ctl, align 4
  %mnctr_mode_shift.i = getelementptr inbounds %struct.clk_rcg, ptr %rcg, i32 0, i32 2, i32 2
  %45 = ptrtoint ptr %mnctr_mode_shift.i to i32
  call void @__asan_load1_noabort(i32 %45)
  %46 = load i8, ptr %mnctr_mode_shift.i, align 1
  %conv.i1 = zext i8 %46 to i32
  %shl.i = shl i32 3, %conv.i1
  %47 = ptrtoint ptr %mn1 to i32
  call void @__asan_load1_noabort(i32 %47)
  %48 = load i8, ptr %mn1, align 1
  %conv1.i2 = zext i8 %48 to i32
  %shl2.i3 = shl nuw i32 1, %conv1.i2
  %or.i = or i32 %shl2.i3, %shl.i
  %neg.i4 = xor i32 %or.i, -1
  %and.i5 = and i32 %44, %neg.i4
  call void @__sanitizer_cov_trace_const_cmp2(i16 0, i16 %42)
  %tobool.not.i6 = icmp eq i16 %42, 0
  %shl9.i = shl i32 2, %conv.i1
  %or6.i7 = or i32 %shl2.i3, %shl9.i
  %or10.i = select i1 %tobool.not.i6, i32 0, i32 %or6.i7
  %val.addr.0.i = or i32 %and.i5, %or10.i
  %49 = ptrtoint ptr %ctl to i32
  call void @__asan_store4_noabort(i32 %49)
  store i32 %val.addr.0.i, ptr %ctl, align 4
  %50 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load ptr, ptr %regmap, align 4
  %52 = ptrtoint ptr %enable_reg to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load i32, ptr %enable_reg, align 4
  %call40 = call i32 @regmap_write(ptr noundef %51, i32 noundef %53, i32 noundef %val.addr.0.i) #3
  br label %if.end47

if.else41:                                        ; preds = %mn_to_md.exit
  call void @__sanitizer_cov_trace_pc() #5
  %54 = ptrtoint ptr %n to i32
  call void @__asan_load2_noabort(i32 %54)
  %55 = load i16, ptr %n, align 4
  %56 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load i32, ptr %ns, align 4
  %mnctr_mode_shift.i8 = getelementptr inbounds %struct.clk_rcg, ptr %rcg, i32 0, i32 2, i32 2
  %58 = ptrtoint ptr %mnctr_mode_shift.i8 to i32
  call void @__asan_load1_noabort(i32 %58)
  %59 = load i8, ptr %mnctr_mode_shift.i8, align 1
  %conv.i9 = zext i8 %59 to i32
  %shl.i10 = shl i32 3, %conv.i9
  %60 = ptrtoint ptr %mn1 to i32
  call void @__asan_load1_noabort(i32 %60)
  %61 = load i8, ptr %mn1, align 1
  %conv1.i11 = zext i8 %61 to i32
  %shl2.i12 = shl nuw i32 1, %conv1.i11
  %or.i13 = or i32 %shl2.i12, %shl.i10
  %neg.i14 = xor i32 %or.i13, -1
  %and.i15 = and i32 %57, %neg.i14
  call void @__sanitizer_cov_trace_const_cmp2(i16 0, i16 %55)
  %tobool.not.i16 = icmp eq i16 %55, 0
  %shl9.i17 = shl i32 2, %conv.i9
  %or6.i18 = or i32 %shl2.i12, %shl9.i17
  %or10.i19 = select i1 %tobool.not.i16, i32 0, i32 %or6.i18
  %val.addr.0.i20 = or i32 %and.i15, %or10.i19
  %62 = ptrtoint ptr %ns to i32
  call void @__asan_store4_noabort(i32 %62)
  store i32 %val.addr.0.i20, ptr %ns, align 4
  br label %if.end47

if.end47:                                         ; preds = %if.else41, %if.then25
  %63 = ptrtoint ptr %n to i32
  call void @__asan_load2_noabort(i32 %63)
  %64 = load i16, ptr %n, align 4
  %65 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %65)
  %66 = load i32, ptr %ns, align 4
  %67 = ptrtoint ptr %width to i32
  call void @__asan_load1_noabort(i32 %67)
  %68 = load i8, ptr %width, align 1
  %conv.i22 = zext i8 %68 to i32
  %notmask.i23 = shl nsw i32 -1, %conv.i22
  %sub.i24 = xor i32 %notmask.i23, -1
  %n_val_shift.i = getelementptr inbounds %struct.clk_rcg, ptr %rcg, i32 0, i32 2, i32 3
  %69 = ptrtoint ptr %n_val_shift.i to i32
  call void @__asan_load1_noabort(i32 %69)
  %70 = load i8, ptr %n_val_shift.i, align 1
  %conv1.i25 = zext i8 %70 to i32
  %shl2.i26 = shl i32 %sub.i24, %conv1.i25
  %neg.i27 = xor i32 %shl2.i26, -1
  %and.i28 = and i32 %66, %neg.i27
  call void @__sanitizer_cov_trace_const_cmp2(i16 0, i16 %64)
  %tobool.not.i29 = icmp eq i16 %64, 0
  br i1 %tobool.not.i29, label %if.end47.mn_to_ns.exit_crit_edge, label %if.then.i31

if.end47.mn_to_ns.exit_crit_edge:                 ; preds = %if.end47
  call void @__sanitizer_cov_trace_pc() #5
  br label %mn_to_ns.exit

if.then.i31:                                      ; preds = %if.end47
  call void @__sanitizer_cov_trace_pc() #5
  %conv51 = zext i16 %64 to i32
  %71 = ptrtoint ptr %m to i32
  call void @__asan_load2_noabort(i32 %71)
  %72 = load i16, ptr %m, align 2
  %conv49 = zext i16 %72 to i32
  %73 = xor i32 %conv51, -1
  %neg4.i = add nsw i32 %conv49, %73
  %and9.i = and i32 %neg4.i, %sub.i24
  %shl12.i = shl i32 %and9.i, %conv1.i25
  %or.i30 = or i32 %shl12.i, %and.i28
  br label %mn_to_ns.exit

mn_to_ns.exit:                                    ; preds = %if.then.i31, %if.end47.mn_to_ns.exit_crit_edge
  %ns.addr.0.i = phi i32 [ %or.i30, %if.then.i31 ], [ %and.i28, %if.end47.mn_to_ns.exit_crit_edge ]
  %74 = ptrtoint ptr %ns to i32
  call void @__asan_store4_noabort(i32 %74)
  store i32 %ns.addr.0.i, ptr %ns, align 4
  br label %if.end58

if.else53:                                        ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  %regmap55 = getelementptr inbounds %struct.clk_rcg, ptr %rcg, i32 0, i32 6, i32 1
  %75 = ptrtoint ptr %regmap55 to i32
  call void @__asan_load4_noabort(i32 %75)
  %76 = load ptr, ptr %regmap55, align 4
  %77 = ptrtoint ptr %rcg to i32
  call void @__asan_load4_noabort(i32 %77)
  %78 = load i32, ptr %rcg, align 4
  %call57 = call i32 @regmap_read(ptr noundef %76, i32 noundef %78, ptr noundef nonnull %ns) #3
  br label %if.end58

if.end58:                                         ; preds = %if.else53, %mn_to_ns.exit
  %mask.0 = phi i32 [ %shl, %mn_to_ns.exit ], [ 0, %if.else53 ]
  %p = getelementptr inbounds %struct.clk_rcg, ptr %rcg, i32 0, i32 3
  %pre_div = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 2
  %79 = ptrtoint ptr %pre_div to i32
  call void @__asan_load1_noabort(i32 %79)
  %80 = load i8, ptr %pre_div, align 1
  %sub = add i8 %80, -1
  %81 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %81)
  %82 = load i32, ptr %ns, align 4
  %pre_div_width.i = getelementptr inbounds %struct.clk_rcg, ptr %rcg, i32 0, i32 3, i32 1
  %83 = ptrtoint ptr %pre_div_width.i to i32
  call void @__asan_load1_noabort(i32 %83)
  %84 = load i8, ptr %pre_div_width.i, align 1
  %conv.i32 = zext i8 %84 to i32
  %notmask.i33 = shl nsw i32 -1, %conv.i32
  %sub.i34 = xor i32 %notmask.i33, -1
  %85 = ptrtoint ptr %p to i32
  call void @__asan_load1_noabort(i32 %85)
  %86 = load i8, ptr %p, align 1
  %conv1.i35 = zext i8 %86 to i32
  %shl2.i36 = shl i32 %sub.i34, %conv1.i35
  %neg.i37 = xor i32 %shl2.i36, -1
  %and.i38 = and i32 %82, %neg.i37
  %conv3.i = zext i8 %sub to i32
  %shl6.i = shl i32 %conv3.i, %conv1.i35
  %or.i39 = or i32 %and.i38, %shl6.i
  store i32 %or.i39, ptr %ns, align 4
  %regmap63 = getelementptr inbounds %struct.clk_rcg, ptr %rcg, i32 0, i32 6, i32 1
  %87 = ptrtoint ptr %regmap63 to i32
  call void @__asan_load4_noabort(i32 %87)
  %88 = load ptr, ptr %regmap63, align 4
  %89 = ptrtoint ptr %rcg to i32
  call void @__asan_load4_noabort(i32 %89)
  %90 = load i32, ptr %rcg, align 4
  %call65 = call i32 @regmap_write(ptr noundef %88, i32 noundef %90, i32 noundef %or.i39) #3
  %91 = ptrtoint ptr %regmap63 to i32
  call void @__asan_load4_noabort(i32 %91)
  %92 = load ptr, ptr %regmap63, align 4
  %call.i40 = call i32 @regmap_update_bits_base(ptr noundef %92, i32 noundef %reset_reg.0, i32 noundef %mask.0, i32 noundef 0, ptr noundef null, i1 noundef zeroext false, i1 noundef zeroext false) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ctl) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %md) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ns) #3
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @regmap_update_bits_base(ptr noundef, i32 noundef, i32 noundef, i32 noundef, ptr noundef, i1 noundef zeroext, i1 noundef zeroext) local_unnamed_addr #0

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @clk_hw_round_rate(ptr noundef, i32 noundef) local_unnamed_addr #0

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @__clk_is_enabled(ptr noundef) local_unnamed_addr #0

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @configure_bank(ptr noundef %rcg, ptr nocapture noundef readonly %f) unnamed_addr #1 align 64 {
entry:
  %ns = alloca i32, align 4
  %md = alloca i32, align 4
  %reg = alloca i32, align 4
  call void @__sanitizer_cov_trace_pc() #5
  call void @llvm.arm.gnu.eabi.mcount()
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ns) #3
  %0 = ptrtoint ptr %ns to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %ns, align 4, !annotation !48
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %md) #3
  %1 = ptrtoint ptr %md to i32
  call void @__asan_store4_noabort(i32 %1)
  store i32 -1, ptr %md, align 4, !annotation !48
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %reg) #3
  %2 = ptrtoint ptr %reg to i32
  call void @__asan_store4_noabort(i32 %2)
  store i32 -1, ptr %reg, align 4, !annotation !48
  %width = getelementptr %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 4, i32 1, i32 5
  %3 = ptrtoint ptr %width to i32
  call void @__asan_load1_noabort(i32 %3)
  %4 = load i8, ptr %width, align 1
  call void @__sanitizer_cov_trace_const_cmp1(i8 0, i8 %4)
  %tobool.not = icmp eq i8 %4, 0
  %pre_div_width = getelementptr %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 5, i32 1, i32 1
  %5 = ptrtoint ptr %pre_div_width to i32
  call void @__asan_load1_noabort(i32 %5)
  %6 = load i8, ptr %pre_div_width, align 1
  call void @__sanitizer_cov_trace_const_cmp1(i8 0, i8 %6)
  %tobool5.not = icmp eq i8 %6, 0
  %clkr = getelementptr inbounds %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 8
  %clk = getelementptr inbounds %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 8, i32 0, i32 1
  %7 = ptrtoint ptr %clk to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %clk, align 4
  %call = tail call zeroext i1 @__clk_is_enabled(ptr noundef %8) #3
  %regmap = getelementptr inbounds %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 8, i32 1
  %9 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %regmap, align 4
  %bank_reg = getelementptr inbounds %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 2
  %11 = ptrtoint ptr %bank_reg to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %bank_reg, align 4
  %call12 = call i32 @regmap_read(ptr noundef %10, i32 noundef %12, ptr noundef nonnull %reg) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call12)
  %tobool13.not = icmp eq i32 %call12, 0
  br i1 %tobool13.not, label %if.end, label %entry.cleanup_crit_edge

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end:                                           ; preds = %entry
  %13 = ptrtoint ptr %reg to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %reg, align 4
  %mux_sel_bit.i = getelementptr inbounds %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 3
  %15 = ptrtoint ptr %mux_sel_bit.i to i32
  call void @__asan_load1_noabort(i32 %15)
  %16 = load i8, ptr %mux_sel_bit.i, align 4
  %conv.i = zext i8 %16 to i32
  %17 = lshr i32 %14, %conv.i
  %18 = and i32 %17, 1
  %19 = zext i1 %call to i32
  %cond = xor i32 %18, %19
  %arrayidx19 = getelementptr [2 x i32], ptr %rcg, i32 0, i32 %cond
  %20 = ptrtoint ptr %arrayidx19 to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %arrayidx19, align 4
  %22 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %regmap, align 4
  %call22 = call i32 @regmap_read(ptr noundef %23, i32 noundef %21, ptr noundef nonnull %ns) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call22)
  %tobool23.not = icmp eq i32 %call22, 0
  br i1 %tobool23.not, label %if.end25, label %if.end.cleanup_crit_edge

if.end.cleanup_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end25:                                         ; preds = %if.end
  br i1 %tobool.not, label %if.end25.if.end103_crit_edge, label %if.then27

if.end25.if.end103_crit_edge:                     ; preds = %if.end25
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end103

if.then27:                                        ; preds = %if.end25
  %arrayidx29 = getelementptr %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 4, i32 %cond
  %arrayidx31 = getelementptr %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 1, i32 %cond
  %24 = ptrtoint ptr %arrayidx31 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %arrayidx31, align 4
  %mnctr_reset_bit = getelementptr %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 4, i32 %cond, i32 1
  %26 = ptrtoint ptr %mnctr_reset_bit to i32
  call void @__asan_load1_noabort(i32 %26)
  %27 = load i8, ptr %mnctr_reset_bit, align 1
  %conv = zext i8 %27 to i32
  %shl = shl nuw i32 1, %conv
  %28 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %ns, align 4
  %or = or i32 %shl, %29
  store i32 %or, ptr %ns, align 4
  %30 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %regmap, align 4
  %call34 = call i32 @regmap_write(ptr noundef %31, i32 noundef %21, i32 noundef %or) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call34)
  %tobool35.not = icmp eq i32 %call34, 0
  br i1 %tobool35.not, label %if.end37, label %if.then27.cleanup_crit_edge

if.then27.cleanup_crit_edge:                      ; preds = %if.then27
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end37:                                         ; preds = %if.then27
  %32 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load ptr, ptr %regmap, align 4
  %call40 = call i32 @regmap_read(ptr noundef %33, i32 noundef %25, ptr noundef nonnull %md) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call40)
  %tobool41.not = icmp eq i32 %call40, 0
  br i1 %tobool41.not, label %if.end43, label %if.end37.cleanup_crit_edge

if.end37.cleanup_crit_edge:                       ; preds = %if.end37
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end43:                                         ; preds = %if.end37
  %m = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 3
  %n = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 4
  %34 = ptrtoint ptr %n to i32
  call void @__asan_load2_noabort(i32 %34)
  %35 = load i16, ptr %n, align 4
  %36 = ptrtoint ptr %md to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load i32, ptr %md, align 4
  %width.i = getelementptr %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 4, i32 %cond, i32 5
  %38 = ptrtoint ptr %width.i to i32
  call void @__asan_load1_noabort(i32 %38)
  %39 = load i8, ptr %width.i, align 1
  %conv.i243 = zext i8 %39 to i32
  %notmask.i = shl nsw i32 -1, %conv.i243
  %sub.i = xor i32 %notmask.i, -1
  %m_val_shift.i = getelementptr %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 4, i32 %cond, i32 4
  %40 = ptrtoint ptr %m_val_shift.i to i32
  call void @__asan_load1_noabort(i32 %40)
  %41 = load i8, ptr %m_val_shift.i, align 1
  %conv1.i = zext i8 %41 to i32
  %shl2.i = shl i32 %sub.i, %conv1.i
  %shl2.not.i = xor i32 %shl2.i, -1
  %neg.i = and i32 %notmask.i, %37
  %and.i = and i32 %neg.i, %shl2.not.i
  call void @__sanitizer_cov_trace_const_cmp2(i16 0, i16 %35)
  %tobool.not.i = icmp eq i16 %35, 0
  br i1 %tobool.not.i, label %if.end43.mn_to_md.exit_crit_edge, label %if.then.i

if.end43.mn_to_md.exit_crit_edge:                 ; preds = %if.end43
  call void @__sanitizer_cov_trace_pc() #5
  br label %mn_to_md.exit

if.then.i:                                        ; preds = %if.end43
  call void @__sanitizer_cov_trace_pc() #5
  %conv45 = zext i16 %35 to i32
  %42 = ptrtoint ptr %m to i32
  call void @__asan_load2_noabort(i32 %42)
  %43 = load i16, ptr %m, align 2
  %conv44 = zext i16 %43 to i32
  %shl5.i = shl i32 %conv44, %conv1.i
  %neg7.i = xor i32 %conv45, -1
  %and8.i = and i32 %sub.i, %neg7.i
  %or6.i = or i32 %and.i, %and8.i
  %or9.i = or i32 %or6.i, %shl5.i
  br label %mn_to_md.exit

mn_to_md.exit:                                    ; preds = %if.then.i, %if.end43.mn_to_md.exit_crit_edge
  %md.addr.0.i = phi i32 [ %or9.i, %if.then.i ], [ %and.i, %if.end43.mn_to_md.exit_crit_edge ]
  %44 = ptrtoint ptr %md to i32
  call void @__asan_store4_noabort(i32 %44)
  store i32 %md.addr.0.i, ptr %md, align 4
  %45 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load ptr, ptr %regmap, align 4
  %call49 = call i32 @regmap_write(ptr noundef %46, i32 noundef %25, i32 noundef %md.addr.0.i) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call49)
  %tobool50.not = icmp eq i32 %call49, 0
  br i1 %tobool50.not, label %if.end52, label %mn_to_md.exit.cleanup_crit_edge

mn_to_md.exit.cleanup_crit_edge:                  ; preds = %mn_to_md.exit
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end52:                                         ; preds = %mn_to_md.exit
  %47 = ptrtoint ptr %n to i32
  call void @__asan_load2_noabort(i32 %47)
  %48 = load i16, ptr %n, align 4
  %49 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load i32, ptr %ns, align 4
  %51 = ptrtoint ptr %width.i to i32
  call void @__asan_load1_noabort(i32 %51)
  %52 = load i8, ptr %width.i, align 1
  %conv.i245 = zext i8 %52 to i32
  %notmask.i246 = shl nsw i32 -1, %conv.i245
  %sub.i247 = xor i32 %notmask.i246, -1
  %n_val_shift.i = getelementptr %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 4, i32 %cond, i32 3
  %53 = ptrtoint ptr %n_val_shift.i to i32
  call void @__asan_load1_noabort(i32 %53)
  %54 = load i8, ptr %n_val_shift.i, align 1
  %conv1.i248 = zext i8 %54 to i32
  %shl2.i249 = shl i32 %sub.i247, %conv1.i248
  %neg.i250 = xor i32 %shl2.i249, -1
  %and.i251 = and i32 %50, %neg.i250
  call void @__sanitizer_cov_trace_const_cmp2(i16 0, i16 %48)
  %tobool.not.i252 = icmp eq i16 %48, 0
  br i1 %tobool.not.i252, label %if.end52.mn_to_ns.exit_crit_edge, label %if.then.i253

if.end52.mn_to_ns.exit_crit_edge:                 ; preds = %if.end52
  call void @__sanitizer_cov_trace_pc() #5
  br label %mn_to_ns.exit

if.then.i253:                                     ; preds = %if.end52
  call void @__sanitizer_cov_trace_pc() #5
  %conv56 = zext i16 %48 to i32
  %55 = ptrtoint ptr %m to i32
  call void @__asan_load2_noabort(i32 %55)
  %56 = load i16, ptr %m, align 2
  %conv54 = zext i16 %56 to i32
  %57 = xor i32 %conv56, -1
  %neg4.i = add nsw i32 %conv54, %57
  %and9.i = and i32 %neg4.i, %sub.i247
  %shl12.i = shl i32 %and9.i, %conv1.i248
  %or.i = or i32 %shl12.i, %and.i251
  br label %mn_to_ns.exit

mn_to_ns.exit:                                    ; preds = %if.then.i253, %if.end52.mn_to_ns.exit_crit_edge
  %ns.addr.0.i = phi i32 [ %or.i, %if.then.i253 ], [ %and.i251, %if.end52.mn_to_ns.exit_crit_edge ]
  %58 = ptrtoint ptr %ns to i32
  call void @__asan_store4_noabort(i32 %58)
  store i32 %ns.addr.0.i, ptr %ns, align 4
  %59 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load ptr, ptr %regmap, align 4
  %call60 = call i32 @regmap_write(ptr noundef %60, i32 noundef %21, i32 noundef %ns.addr.0.i) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call60)
  %tobool61.not = icmp eq i32 %call60, 0
  br i1 %tobool61.not, label %if.end63, label %mn_to_ns.exit.cleanup_crit_edge

mn_to_ns.exit.cleanup_crit_edge:                  ; preds = %mn_to_ns.exit
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end63:                                         ; preds = %mn_to_ns.exit
  %61 = ptrtoint ptr %rcg to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load i32, ptr %rcg, align 4
  %arrayidx67 = getelementptr [2 x i32], ptr %rcg, i32 0, i32 1
  %63 = ptrtoint ptr %arrayidx67 to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load i32, ptr %arrayidx67, align 4
  call void @__sanitizer_cov_trace_cmp4(i32 %62, i32 %64)
  %cmp.not = icmp eq i32 %62, %64
  %65 = ptrtoint ptr %n to i32
  call void @__asan_load2_noabort(i32 %65)
  %66 = load i16, ptr %n, align 4
  br i1 %cmp.not, label %if.else, label %if.then69

if.then69:                                        ; preds = %if.end63
  %67 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load i32, ptr %ns, align 4
  %mnctr_mode_shift.i = getelementptr %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 4, i32 %cond, i32 2
  %69 = ptrtoint ptr %mnctr_mode_shift.i to i32
  call void @__asan_load1_noabort(i32 %69)
  %70 = load i8, ptr %mnctr_mode_shift.i, align 1
  %conv.i254 = zext i8 %70 to i32
  %shl.i = shl i32 3, %conv.i254
  %71 = ptrtoint ptr %arrayidx29 to i32
  call void @__asan_load1_noabort(i32 %71)
  %72 = load i8, ptr %arrayidx29, align 1
  %conv1.i255 = zext i8 %72 to i32
  %shl2.i256 = shl nuw i32 1, %conv1.i255
  %or.i257 = or i32 %shl2.i256, %shl.i
  %neg.i258 = xor i32 %or.i257, -1
  %and.i259 = and i32 %68, %neg.i258
  call void @__sanitizer_cov_trace_const_cmp2(i16 0, i16 %66)
  %tobool.not.i260 = icmp eq i16 %66, 0
  %shl9.i = shl i32 2, %conv.i254
  %or6.i261 = or i32 %shl2.i256, %shl9.i
  %or10.i = select i1 %tobool.not.i260, i32 0, i32 %or6.i261
  %val.addr.0.i = or i32 %and.i259, %or10.i
  %73 = ptrtoint ptr %ns to i32
  call void @__asan_store4_noabort(i32 %73)
  store i32 %val.addr.0.i, ptr %ns, align 4
  %74 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %74)
  %75 = load ptr, ptr %regmap, align 4
  %call77 = call i32 @regmap_write(ptr noundef %75, i32 noundef %21, i32 noundef %val.addr.0.i) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call77)
  %tobool78.not = icmp eq i32 %call77, 0
  br i1 %tobool78.not, label %if.then69.if.end93_crit_edge, label %if.then69.cleanup_crit_edge

if.then69.cleanup_crit_edge:                      ; preds = %if.then69
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.then69.if.end93_crit_edge:                     ; preds = %if.then69
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end93

if.else:                                          ; preds = %if.end63
  %76 = ptrtoint ptr %reg to i32
  call void @__asan_load4_noabort(i32 %76)
  %77 = load i32, ptr %reg, align 4
  %mnctr_mode_shift.i262 = getelementptr %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 4, i32 %cond, i32 2
  %78 = ptrtoint ptr %mnctr_mode_shift.i262 to i32
  call void @__asan_load1_noabort(i32 %78)
  %79 = load i8, ptr %mnctr_mode_shift.i262, align 1
  %conv.i263 = zext i8 %79 to i32
  %shl.i264 = shl i32 3, %conv.i263
  %80 = ptrtoint ptr %arrayidx29 to i32
  call void @__asan_load1_noabort(i32 %80)
  %81 = load i8, ptr %arrayidx29, align 1
  %conv1.i265 = zext i8 %81 to i32
  %shl2.i266 = shl nuw i32 1, %conv1.i265
  %or.i267 = or i32 %shl2.i266, %shl.i264
  %neg.i268 = xor i32 %or.i267, -1
  %and.i269 = and i32 %77, %neg.i268
  call void @__sanitizer_cov_trace_const_cmp2(i16 0, i16 %66)
  %tobool.not.i270 = icmp eq i16 %66, 0
  %shl9.i271 = shl i32 2, %conv.i263
  %or6.i272 = or i32 %shl2.i266, %shl9.i271
  %or10.i273 = select i1 %tobool.not.i270, i32 0, i32 %or6.i272
  %val.addr.0.i274 = or i32 %and.i269, %or10.i273
  %82 = ptrtoint ptr %reg to i32
  call void @__asan_store4_noabort(i32 %82)
  store i32 %val.addr.0.i274, ptr %reg, align 4
  %83 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %83)
  %84 = load ptr, ptr %regmap, align 4
  %85 = ptrtoint ptr %bank_reg to i32
  call void @__asan_load4_noabort(i32 %85)
  %86 = load i32, ptr %bank_reg, align 4
  %call89 = call i32 @regmap_write(ptr noundef %84, i32 noundef %86, i32 noundef %val.addr.0.i274) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call89)
  %tobool90.not = icmp eq i32 %call89, 0
  br i1 %tobool90.not, label %if.else.if.end93_crit_edge, label %if.else.cleanup_crit_edge

if.else.cleanup_crit_edge:                        ; preds = %if.else
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.else.if.end93_crit_edge:                       ; preds = %if.else
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end93

if.end93:                                         ; preds = %if.else.if.end93_crit_edge, %if.then69.if.end93_crit_edge
  %87 = ptrtoint ptr %mnctr_reset_bit to i32
  call void @__asan_load1_noabort(i32 %87)
  %88 = load i8, ptr %mnctr_reset_bit, align 1
  %conv95 = zext i8 %88 to i32
  %shl96 = shl nuw i32 1, %conv95
  %neg = xor i32 %shl96, -1
  %89 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %89)
  %90 = load i32, ptr %ns, align 4
  %and = and i32 %90, %neg
  store i32 %and, ptr %ns, align 4
  %91 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %91)
  %92 = load ptr, ptr %regmap, align 4
  %call99 = call i32 @regmap_write(ptr noundef %92, i32 noundef %21, i32 noundef %and) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call99)
  %tobool100.not = icmp eq i32 %call99, 0
  br i1 %tobool100.not, label %if.end93.if.end103_crit_edge, label %if.end93.cleanup_crit_edge

if.end93.cleanup_crit_edge:                       ; preds = %if.end93
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end93.if.end103_crit_edge:                     ; preds = %if.end93
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end103

if.end103:                                        ; preds = %if.end93.if.end103_crit_edge, %if.end25.if.end103_crit_edge
  br i1 %tobool5.not, label %if.end103.if.end111_crit_edge, label %if.then105

if.end103.if.end111_crit_edge:                    ; preds = %if.end103
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end111

if.then105:                                       ; preds = %if.end103
  call void @__sanitizer_cov_trace_pc() #5
  %arrayidx107 = getelementptr %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 5, i32 %cond
  %pre_div = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 2
  %93 = ptrtoint ptr %pre_div to i32
  call void @__asan_load1_noabort(i32 %93)
  %94 = load i8, ptr %pre_div, align 1
  %sub = add i8 %94, -1
  %95 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %95)
  %96 = load i32, ptr %ns, align 4
  %pre_div_width.i = getelementptr %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 5, i32 %cond, i32 1
  %97 = ptrtoint ptr %pre_div_width.i to i32
  call void @__asan_load1_noabort(i32 %97)
  %98 = load i8, ptr %pre_div_width.i, align 1
  %conv.i275 = zext i8 %98 to i32
  %notmask.i276 = shl nsw i32 -1, %conv.i275
  %sub.i277 = xor i32 %notmask.i276, -1
  %99 = ptrtoint ptr %arrayidx107 to i32
  call void @__asan_load1_noabort(i32 %99)
  %100 = load i8, ptr %arrayidx107, align 1
  %conv1.i278 = zext i8 %100 to i32
  %shl2.i279 = shl i32 %sub.i277, %conv1.i278
  %neg.i280 = xor i32 %shl2.i279, -1
  %and.i281 = and i32 %96, %neg.i280
  %conv3.i = zext i8 %sub to i32
  %shl6.i = shl i32 %conv3.i, %conv1.i278
  %or.i282 = or i32 %and.i281, %shl6.i
  store i32 %or.i282, ptr %ns, align 4
  br label %if.end111

if.end111:                                        ; preds = %if.then105, %if.end103.if.end111_crit_edge
  %parent_map = getelementptr %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 6, i32 %cond, i32 1
  %101 = ptrtoint ptr %parent_map to i32
  call void @__asan_load4_noabort(i32 %101)
  %102 = load ptr, ptr %parent_map, align 4
  %src = getelementptr inbounds %struct.freq_tbl, ptr %f, i32 0, i32 1
  %103 = ptrtoint ptr %src to i32
  call void @__asan_load1_noabort(i32 %103)
  %104 = load i8, ptr %src, align 4
  %call114 = call i32 @qcom_find_src_index(ptr noundef %clkr, ptr noundef %102, i8 noundef zeroext %104) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call114)
  %cmp115 = icmp slt i32 %call114, 0
  br i1 %cmp115, label %if.end111.cleanup_crit_edge, label %if.end118

if.end111.cleanup_crit_edge:                      ; preds = %if.end111
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end118:                                        ; preds = %if.end111
  %arrayidx113 = getelementptr %struct.clk_dyn_rcg, ptr %rcg, i32 0, i32 6, i32 %cond
  %105 = ptrtoint ptr %parent_map to i32
  call void @__asan_load4_noabort(i32 %105)
  %106 = load ptr, ptr %parent_map, align 4
  %cfg = getelementptr %struct.parent_map, ptr %106, i32 %call114, i32 1
  %107 = ptrtoint ptr %cfg to i32
  call void @__asan_load1_noabort(i32 %107)
  %108 = load i8, ptr %cfg, align 1
  %109 = ptrtoint ptr %ns to i32
  call void @__asan_load4_noabort(i32 %109)
  %110 = load i32, ptr %ns, align 4
  %111 = ptrtoint ptr %arrayidx113 to i32
  call void @__asan_load1_noabort(i32 %111)
  %112 = load i8, ptr %arrayidx113, align 4
  %conv.i283 = zext i8 %112 to i32
  %shl.i284 = shl i32 7, %conv.i283
  %neg.i285 = xor i32 %shl.i284, -1
  %and.i286 = and i32 %110, %neg.i285
  %conv1.i287 = zext i8 %108 to i32
  %shl4.i = shl i32 %conv1.i287, %conv.i283
  %or.i288 = or i32 %and.i286, %shl4.i
  store i32 %or.i288, ptr %ns, align 4
  %113 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %113)
  %114 = load ptr, ptr %regmap, align 4
  %call124 = call i32 @regmap_write(ptr noundef %114, i32 noundef %21, i32 noundef %or.i288) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call124)
  %tobool125.not = icmp eq i32 %call124, 0
  br i1 %tobool125.not, label %if.end127, label %if.end118.cleanup_crit_edge

if.end118.cleanup_crit_edge:                      ; preds = %if.end118
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end127:                                        ; preds = %if.end118
  br i1 %call, label %if.then129, label %if.end127.if.end146_crit_edge

if.end127.if.end146_crit_edge:                    ; preds = %if.end127
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end146

if.then129:                                       ; preds = %if.end127
  %115 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %115)
  %116 = load ptr, ptr %regmap, align 4
  %117 = ptrtoint ptr %bank_reg to i32
  call void @__asan_load4_noabort(i32 %117)
  %118 = load i32, ptr %bank_reg, align 4
  %call133 = call i32 @regmap_read(ptr noundef %116, i32 noundef %118, ptr noundef nonnull %reg) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call133)
  %tobool134.not = icmp eq i32 %call133, 0
  br i1 %tobool134.not, label %if.end136, label %if.then129.cleanup_crit_edge

if.then129.cleanup_crit_edge:                     ; preds = %if.then129
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end136:                                        ; preds = %if.then129
  %119 = ptrtoint ptr %mux_sel_bit.i to i32
  call void @__asan_load1_noabort(i32 %119)
  %120 = load i8, ptr %mux_sel_bit.i, align 4
  %conv137 = zext i8 %120 to i32
  %shl138 = shl nuw i32 1, %conv137
  %121 = ptrtoint ptr %reg to i32
  call void @__asan_load4_noabort(i32 %121)
  %122 = load i32, ptr %reg, align 4
  %xor = xor i32 %shl138, %122
  store i32 %xor, ptr %reg, align 4
  %123 = ptrtoint ptr %regmap to i32
  call void @__asan_load4_noabort(i32 %123)
  %124 = load ptr, ptr %regmap, align 4
  %125 = ptrtoint ptr %bank_reg to i32
  call void @__asan_load4_noabort(i32 %125)
  %126 = load i32, ptr %bank_reg, align 4
  %call142 = call i32 @regmap_write(ptr noundef %124, i32 noundef %126, i32 noundef %xor) #3
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call142)
  %tobool143.not = icmp eq i32 %call142, 0
  br i1 %tobool143.not, label %if.end136.if.end146_crit_edge, label %if.end136.cleanup_crit_edge

if.end136.cleanup_crit_edge:                      ; preds = %if.end136
  call void @__sanitizer_cov_trace_pc() #5
  br label %cleanup

if.end136.if.end146_crit_edge:                    ; preds = %if.end136
  call void @__sanitizer_cov_trace_pc() #5
  br label %if.end146

if.end146:                                        ; preds = %if.end136.if.end146_crit_edge, %if.end127.if.end146_crit_edge
  br label %cleanup

cleanup:                                          ; preds = %if.end146, %if.end136.cleanup_crit_edge, %if.then129.cleanup_crit_edge, %if.end118.cleanup_crit_edge, %if.end111.cleanup_crit_edge, %if.end93.cleanup_crit_edge, %if.else.cleanup_crit_edge, %if.then69.cleanup_crit_edge, %mn_to_ns.exit.cleanup_crit_edge, %mn_to_md.exit.cleanup_crit_edge, %if.end37.cleanup_crit_edge, %if.then27.cleanup_crit_edge, %if.end.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ 0, %if.end146 ], [ %call12, %entry.cleanup_crit_edge ], [ %call22, %if.end.cleanup_crit_edge ], [ %call34, %if.then27.cleanup_crit_edge ], [ %call40, %if.end37.cleanup_crit_edge ], [ %call49, %mn_to_md.exit.cleanup_crit_edge ], [ %call60, %mn_to_ns.exit.cleanup_crit_edge ], [ %call77, %if.then69.cleanup_crit_edge ], [ %call89, %if.else.cleanup_crit_edge ], [ %call99, %if.end93.cleanup_crit_edge ], [ %call114, %if.end111.cleanup_crit_edge ], [ %call124, %if.end118.cleanup_crit_edge ], [ %call133, %if.then129.cleanup_crit_edge ], [ %call142, %if.end136.cleanup_crit_edge ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %reg) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %md) #3
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ns) #3
  ret i32 %retval.0
}

; Function Attrs: nounwind
declare void @llvm.arm.gnu.eabi.mcount() #3

declare void @__sanitizer_cov_trace_cmp4(i32 zeroext, i32 zeroext)

declare void @__sanitizer_cov_trace_const_cmp1(i8 zeroext, i8 zeroext)

declare void @__sanitizer_cov_trace_const_cmp2(i16 zeroext, i16 zeroext)

declare void @__sanitizer_cov_trace_const_cmp4(i32 zeroext, i32 zeroext)

declare void @__sanitizer_cov_trace_const_cmp8(i64, i64)

declare void @__sanitizer_cov_trace_pc()

declare void @__asan_load1_noabort(i32)

declare void @__asan_load2_noabort(i32)

declare void @__asan_load4_noabort(i32)

declare void @__asan_store1_noabort(i32)

declare void @__asan_store2_noabort(i32)

declare void @__asan_store4_noabort(i32)

declare ptr @memset(ptr, i32, i32)

declare void @__asan_register_globals(i32, i32)

declare void @__asan_unregister_globals(i32, i32)

; Function Attrs: nounwind uwtable(sync)
define internal void @asan.module_ctor() #4 {
  call void @__asan_register_globals(i32 ptrtoint (ptr @0 to i32), i32 13)
  ret void
}

; Function Attrs: nounwind uwtable(sync)
define internal void @asan.module_dtor() #4 {
  call void @__asan_unregister_globals(i32 ptrtoint (ptr @0 to i32), i32 13)
  ret void
}

attributes #0 = { null_pointer_is_valid "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #1 = { nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #2 = { argmemonly nocallback nofree nosync nounwind willreturn }
attributes #3 = { nounwind }
attributes #4 = { nounwind uwtable(sync) "frame-pointer"="all" }
attributes #5 = { nomerge }
attributes #6 = { nounwind readnone }

!llvm.asan.globals = !{!0, !2, !4, !6, !8, !10, !12, !14, !16, !18, !20, !22, !24, !26, !28, !30, !31, !32, !33, !34, !36, !38}
!llvm.module.flags = !{!39, !40, !41, !42, !43, !44, !45, !46}
!llvm.ident = !{!47}

!0 = !{ptr @clk_rcg_ops, !1, !"clk_rcg_ops", i1 false, i1 false}
!1 = !{!"../drivers/clk/qcom/clk-rcg.c", i32 808, i32 22}
!2 = !{ptr @__ksymtab_clk_rcg_ops, !3, !"__ksymtab_clk_rcg_ops", i1 false, i1 false}
!3 = !{!"../drivers/clk/qcom/clk-rcg.c", i32 817, i32 1}
!4 = !{ptr @clk_rcg_bypass_ops, !5, !"clk_rcg_bypass_ops", i1 false, i1 false}
!5 = !{!"../drivers/clk/qcom/clk-rcg.c", i32 819, i32 22}
!6 = !{ptr @__ksymtab_clk_rcg_bypass_ops, !7, !"__ksymtab_clk_rcg_bypass_ops", i1 false, i1 false}
!7 = !{!"../drivers/clk/qcom/clk-rcg.c", i32 828, i32 1}
!8 = !{ptr @clk_rcg_bypass2_ops, !9, !"clk_rcg_bypass2_ops", i1 false, i1 false}
!9 = !{!"../drivers/clk/qcom/clk-rcg.c", i32 830, i32 22}
!10 = !{ptr @__ksymtab_clk_rcg_bypass2_ops, !11, !"__ksymtab_clk_rcg_bypass2_ops", i1 false, i1 false}
!11 = !{!"../drivers/clk/qcom/clk-rcg.c", i32 840, i32 1}
!12 = !{ptr @clk_rcg_pixel_ops, !13, !"clk_rcg_pixel_ops", i1 false, i1 false}
!13 = !{!"../drivers/clk/qcom/clk-rcg.c", i32 842, i32 22}
!14 = !{ptr @__ksymtab_clk_rcg_pixel_ops, !15, !"__ksymtab_clk_rcg_pixel_ops", i1 false, i1 false}
!15 = !{!"../drivers/clk/qcom/clk-rcg.c", i32 852, i32 1}
!16 = !{ptr @clk_rcg_esc_ops, !17, !"clk_rcg_esc_ops", i1 false, i1 false}
!17 = !{!"../drivers/clk/qcom/clk-rcg.c", i32 854, i32 22}
!18 = !{ptr @__ksymtab_clk_rcg_esc_ops, !19, !"__ksymtab_clk_rcg_esc_ops", i1 false, i1 false}
!19 = !{!"../drivers/clk/qcom/clk-rcg.c", i32 864, i32 1}
!20 = !{ptr @clk_rcg_lcc_ops, !21, !"clk_rcg_lcc_ops", i1 false, i1 false}
!21 = !{!"../drivers/clk/qcom/clk-rcg.c", i32 866, i32 22}
!22 = !{ptr @__ksymtab_clk_rcg_lcc_ops, !23, !"__ksymtab_clk_rcg_lcc_ops", i1 false, i1 false}
!23 = !{!"../drivers/clk/qcom/clk-rcg.c", i32 875, i32 1}
!24 = !{ptr @clk_dyn_rcg_ops, !25, !"clk_dyn_rcg_ops", i1 false, i1 false}
!25 = !{!"../drivers/clk/qcom/clk-rcg.c", i32 877, i32 22}
!26 = !{ptr @__ksymtab_clk_dyn_rcg_ops, !27, !"__ksymtab_clk_dyn_rcg_ops", i1 false, i1 false}
!27 = !{!"../drivers/clk/qcom/clk-rcg.c", i32 888, i32 1}
!28 = !{ptr @.str, !29, !"<string literal>", i1 false, i1 false}
!29 = !{!"../drivers/clk/qcom/clk-rcg.c", i32 53, i32 2}
!30 = !{ptr @.str.1, !29, !"<string literal>", i1 false, i1 false}
!31 = !{ptr @.str.2, !29, !"<string literal>", i1 false, i1 false}
!32 = !{ptr @.str.3, !29, !"<string literal>", i1 false, i1 false}
!33 = !{ptr @clk_rcg_get_parent.__UNIQUE_ID_ddebug154, !29, !"__UNIQUE_ID_ddebug154", i1 false, i1 false}
!34 = !{ptr @pixel_table, !35, !"pixel_table", i1 false, i1 false}
!35 = !{!"../drivers/clk/qcom/clk-rcg.c", i32 586, i32 32}
!36 = !{ptr @.str.4, !37, !"<string literal>", i1 false, i1 false}
!37 = !{!"../drivers/clk/qcom/clk-rcg.c", i32 89, i32 2}
!38 = !{ptr @clk_dyn_rcg_get_parent.__UNIQUE_ID_ddebug155, !37, !"__UNIQUE_ID_ddebug155", i1 false, i1 false}
!39 = !{i32 1, !"wchar_size", i32 2}
!40 = !{i32 1, !"min_enum_size", i32 4}
!41 = !{i32 8, !"branch-target-enforcement", i32 0}
!42 = !{i32 8, !"sign-return-address", i32 0}
!43 = !{i32 8, !"sign-return-address-all", i32 0}
!44 = !{i32 8, !"sign-return-address-with-bkey", i32 0}
!45 = !{i32 7, !"uwtable", i32 1}
!46 = !{i32 7, !"frame-pointer", i32 2}
!47 = !{!"clang version 15.0.0 (git@github.com:linkeLi0421/llvm-project15-IRDumperPass.git 23ab625cb005cd08da083f9b643a7feed9af8abe)"}
!48 = !{!"auto-init"}
!49 = !{!"branch_weights", i32 2000, i32 1}
!50 = !{i64 2148619337, i64 2148619617, i64 2148619951, i64 2148620285}
!51 = !{i64 2148710618, i64 2148710623, i64 2148710636, i64 2148710680, i64 2148710714, i64 2148710735}
!52 = !{i8 0, i8 2}
