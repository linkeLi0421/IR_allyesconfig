; ModuleID = '/llk/IR_all_yes/fs/libfs.c_pt.bc'
source_filename = "../fs/libfs.c"
target datalayout = "E-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64"
target triple = "armebv6k-unknown-linux-gnueabi"

module asm ".syntax unified"
module asm "\09.section \22___kcrctab+simple_getattr\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_getattr\09\09\09\09"
module asm "\09.long\09__crc_simple_getattr\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_getattr:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_getattr\22\09\09\09\09\09"
module asm "__kstrtabns_simple_getattr:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_statfs\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_statfs\09\09\09\09"
module asm "\09.long\09__crc_simple_statfs\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_statfs:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_statfs\22\09\09\09\09\09"
module asm "__kstrtabns_simple_statfs:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+always_delete_dentry\22, \22a\22\09"
module asm "\09.weak\09__crc_always_delete_dentry\09\09\09\09"
module asm "\09.long\09__crc_always_delete_dentry\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_always_delete_dentry:\09\09\09\09\09"
module asm "\09.asciz \09\22always_delete_dentry\22\09\09\09\09\09"
module asm "__kstrtabns_always_delete_dentry:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_dentry_operations\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_dentry_operations\09\09\09\09"
module asm "\09.long\09__crc_simple_dentry_operations\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_dentry_operations:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_dentry_operations\22\09\09\09\09\09"
module asm "__kstrtabns_simple_dentry_operations:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_lookup\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_lookup\09\09\09\09"
module asm "\09.long\09__crc_simple_lookup\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_lookup:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_lookup\22\09\09\09\09\09"
module asm "__kstrtabns_simple_lookup:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+dcache_dir_open\22, \22a\22\09"
module asm "\09.weak\09__crc_dcache_dir_open\09\09\09\09"
module asm "\09.long\09__crc_dcache_dir_open\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_dcache_dir_open:\09\09\09\09\09"
module asm "\09.asciz \09\22dcache_dir_open\22\09\09\09\09\09"
module asm "__kstrtabns_dcache_dir_open:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+dcache_dir_close\22, \22a\22\09"
module asm "\09.weak\09__crc_dcache_dir_close\09\09\09\09"
module asm "\09.long\09__crc_dcache_dir_close\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_dcache_dir_close:\09\09\09\09\09"
module asm "\09.asciz \09\22dcache_dir_close\22\09\09\09\09\09"
module asm "__kstrtabns_dcache_dir_close:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+dcache_dir_lseek\22, \22a\22\09"
module asm "\09.weak\09__crc_dcache_dir_lseek\09\09\09\09"
module asm "\09.long\09__crc_dcache_dir_lseek\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_dcache_dir_lseek:\09\09\09\09\09"
module asm "\09.asciz \09\22dcache_dir_lseek\22\09\09\09\09\09"
module asm "__kstrtabns_dcache_dir_lseek:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+dcache_readdir\22, \22a\22\09"
module asm "\09.weak\09__crc_dcache_readdir\09\09\09\09"
module asm "\09.long\09__crc_dcache_readdir\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_dcache_readdir:\09\09\09\09\09"
module asm "\09.asciz \09\22dcache_readdir\22\09\09\09\09\09"
module asm "__kstrtabns_dcache_readdir:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+generic_read_dir\22, \22a\22\09"
module asm "\09.weak\09__crc_generic_read_dir\09\09\09\09"
module asm "\09.long\09__crc_generic_read_dir\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_generic_read_dir:\09\09\09\09\09"
module asm "\09.asciz \09\22generic_read_dir\22\09\09\09\09\09"
module asm "__kstrtabns_generic_read_dir:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_dir_operations\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_dir_operations\09\09\09\09"
module asm "\09.long\09__crc_simple_dir_operations\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_dir_operations:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_dir_operations\22\09\09\09\09\09"
module asm "__kstrtabns_simple_dir_operations:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_dir_inode_operations\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_dir_inode_operations\09\09\09\09"
module asm "\09.long\09__crc_simple_dir_inode_operations\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_dir_inode_operations:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_dir_inode_operations\22\09\09\09\09\09"
module asm "__kstrtabns_simple_dir_inode_operations:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_recursive_removal\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_recursive_removal\09\09\09\09"
module asm "\09.long\09__crc_simple_recursive_removal\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_recursive_removal:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_recursive_removal\22\09\09\09\09\09"
module asm "__kstrtabns_simple_recursive_removal:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+init_pseudo\22, \22a\22\09"
module asm "\09.weak\09__crc_init_pseudo\09\09\09\09"
module asm "\09.long\09__crc_init_pseudo\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_init_pseudo:\09\09\09\09\09"
module asm "\09.asciz \09\22init_pseudo\22\09\09\09\09\09"
module asm "__kstrtabns_init_pseudo:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_open\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_open\09\09\09\09"
module asm "\09.long\09__crc_simple_open\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_open:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_open\22\09\09\09\09\09"
module asm "__kstrtabns_simple_open:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_link\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_link\09\09\09\09"
module asm "\09.long\09__crc_simple_link\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_link:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_link\22\09\09\09\09\09"
module asm "__kstrtabns_simple_link:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_empty\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_empty\09\09\09\09"
module asm "\09.long\09__crc_simple_empty\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_empty:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_empty\22\09\09\09\09\09"
module asm "__kstrtabns_simple_empty:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_unlink\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_unlink\09\09\09\09"
module asm "\09.long\09__crc_simple_unlink\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_unlink:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_unlink\22\09\09\09\09\09"
module asm "__kstrtabns_simple_unlink:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_rmdir\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_rmdir\09\09\09\09"
module asm "\09.long\09__crc_simple_rmdir\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_rmdir:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_rmdir\22\09\09\09\09\09"
module asm "__kstrtabns_simple_rmdir:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+simple_rename_exchange\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_rename_exchange\09\09\09\09"
module asm "\09.long\09__crc_simple_rename_exchange\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_rename_exchange:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_rename_exchange\22\09\09\09\09\09"
module asm "__kstrtabns_simple_rename_exchange:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_rename\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_rename\09\09\09\09"
module asm "\09.long\09__crc_simple_rename\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_rename:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_rename\22\09\09\09\09\09"
module asm "__kstrtabns_simple_rename:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_setattr\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_setattr\09\09\09\09"
module asm "\09.long\09__crc_simple_setattr\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_setattr:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_setattr\22\09\09\09\09\09"
module asm "__kstrtabns_simple_setattr:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_write_begin\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_write_begin\09\09\09\09"
module asm "\09.long\09__crc_simple_write_begin\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_write_begin:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_write_begin\22\09\09\09\09\09"
module asm "__kstrtabns_simple_write_begin:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+ram_aops\22, \22a\22\09"
module asm "\09.weak\09__crc_ram_aops\09\09\09\09"
module asm "\09.long\09__crc_ram_aops\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_ram_aops:\09\09\09\09\09"
module asm "\09.asciz \09\22ram_aops\22\09\09\09\09\09"
module asm "__kstrtabns_ram_aops:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_fill_super\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_fill_super\09\09\09\09"
module asm "\09.long\09__crc_simple_fill_super\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_fill_super:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_fill_super\22\09\09\09\09\09"
module asm "__kstrtabns_simple_fill_super:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_pin_fs\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_pin_fs\09\09\09\09"
module asm "\09.long\09__crc_simple_pin_fs\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_pin_fs:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_pin_fs\22\09\09\09\09\09"
module asm "__kstrtabns_simple_pin_fs:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_release_fs\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_release_fs\09\09\09\09"
module asm "\09.long\09__crc_simple_release_fs\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_release_fs:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_release_fs\22\09\09\09\09\09"
module asm "__kstrtabns_simple_release_fs:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_read_from_buffer\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_read_from_buffer\09\09\09\09"
module asm "\09.long\09__crc_simple_read_from_buffer\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_read_from_buffer:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_read_from_buffer\22\09\09\09\09\09"
module asm "__kstrtabns_simple_read_from_buffer:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_write_to_buffer\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_write_to_buffer\09\09\09\09"
module asm "\09.long\09__crc_simple_write_to_buffer\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_write_to_buffer:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_write_to_buffer\22\09\09\09\09\09"
module asm "__kstrtabns_simple_write_to_buffer:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+memory_read_from_buffer\22, \22a\22\09"
module asm "\09.weak\09__crc_memory_read_from_buffer\09\09\09\09"
module asm "\09.long\09__crc_memory_read_from_buffer\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_memory_read_from_buffer:\09\09\09\09\09"
module asm "\09.asciz \09\22memory_read_from_buffer\22\09\09\09\09\09"
module asm "__kstrtabns_memory_read_from_buffer:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_transaction_set\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_transaction_set\09\09\09\09"
module asm "\09.long\09__crc_simple_transaction_set\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_transaction_set:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_transaction_set\22\09\09\09\09\09"
module asm "__kstrtabns_simple_transaction_set:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_transaction_get\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_transaction_get\09\09\09\09"
module asm "\09.long\09__crc_simple_transaction_get\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_transaction_get:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_transaction_get\22\09\09\09\09\09"
module asm "__kstrtabns_simple_transaction_get:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_transaction_read\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_transaction_read\09\09\09\09"
module asm "\09.long\09__crc_simple_transaction_read\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_transaction_read:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_transaction_read\22\09\09\09\09\09"
module asm "__kstrtabns_simple_transaction_read:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_transaction_release\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_transaction_release\09\09\09\09"
module asm "\09.long\09__crc_simple_transaction_release\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_transaction_release:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_transaction_release\22\09\09\09\09\09"
module asm "__kstrtabns_simple_transaction_release:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+simple_attr_open\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_attr_open\09\09\09\09"
module asm "\09.long\09__crc_simple_attr_open\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_attr_open:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_attr_open\22\09\09\09\09\09"
module asm "__kstrtabns_simple_attr_open:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+simple_attr_release\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_attr_release\09\09\09\09"
module asm "\09.long\09__crc_simple_attr_release\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_attr_release:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_attr_release\22\09\09\09\09\09"
module asm "__kstrtabns_simple_attr_release:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+simple_attr_read\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_attr_read\09\09\09\09"
module asm "\09.long\09__crc_simple_attr_read\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_attr_read:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_attr_read\22\09\09\09\09\09"
module asm "__kstrtabns_simple_attr_read:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+simple_attr_write\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_attr_write\09\09\09\09"
module asm "\09.long\09__crc_simple_attr_write\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_attr_write:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_attr_write\22\09\09\09\09\09"
module asm "__kstrtabns_simple_attr_write:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+generic_fh_to_dentry\22, \22a\22\09"
module asm "\09.weak\09__crc_generic_fh_to_dentry\09\09\09\09"
module asm "\09.long\09__crc_generic_fh_to_dentry\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_generic_fh_to_dentry:\09\09\09\09\09"
module asm "\09.asciz \09\22generic_fh_to_dentry\22\09\09\09\09\09"
module asm "__kstrtabns_generic_fh_to_dentry:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+generic_fh_to_parent\22, \22a\22\09"
module asm "\09.weak\09__crc_generic_fh_to_parent\09\09\09\09"
module asm "\09.long\09__crc_generic_fh_to_parent\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_generic_fh_to_parent:\09\09\09\09\09"
module asm "\09.asciz \09\22generic_fh_to_parent\22\09\09\09\09\09"
module asm "__kstrtabns_generic_fh_to_parent:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+__generic_file_fsync\22, \22a\22\09"
module asm "\09.weak\09__crc___generic_file_fsync\09\09\09\09"
module asm "\09.long\09__crc___generic_file_fsync\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab___generic_file_fsync:\09\09\09\09\09"
module asm "\09.asciz \09\22__generic_file_fsync\22\09\09\09\09\09"
module asm "__kstrtabns___generic_file_fsync:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+generic_file_fsync\22, \22a\22\09"
module asm "\09.weak\09__crc_generic_file_fsync\09\09\09\09"
module asm "\09.long\09__crc_generic_file_fsync\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_generic_file_fsync:\09\09\09\09\09"
module asm "\09.asciz \09\22generic_file_fsync\22\09\09\09\09\09"
module asm "__kstrtabns_generic_file_fsync:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+generic_check_addressable\22, \22a\22\09"
module asm "\09.weak\09__crc_generic_check_addressable\09\09\09\09"
module asm "\09.long\09__crc_generic_check_addressable\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_generic_check_addressable:\09\09\09\09\09"
module asm "\09.asciz \09\22generic_check_addressable\22\09\09\09\09\09"
module asm "__kstrtabns_generic_check_addressable:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+noop_fsync\22, \22a\22\09"
module asm "\09.weak\09__crc_noop_fsync\09\09\09\09"
module asm "\09.long\09__crc_noop_fsync\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_noop_fsync:\09\09\09\09\09"
module asm "\09.asciz \09\22noop_fsync\22\09\09\09\09\09"
module asm "__kstrtabns_noop_fsync:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+noop_invalidatepage\22, \22a\22\09"
module asm "\09.weak\09__crc_noop_invalidatepage\09\09\09\09"
module asm "\09.long\09__crc_noop_invalidatepage\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_noop_invalidatepage:\09\09\09\09\09"
module asm "\09.asciz \09\22noop_invalidatepage\22\09\09\09\09\09"
module asm "__kstrtabns_noop_invalidatepage:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+noop_direct_IO\22, \22a\22\09"
module asm "\09.weak\09__crc_noop_direct_IO\09\09\09\09"
module asm "\09.long\09__crc_noop_direct_IO\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_noop_direct_IO:\09\09\09\09\09"
module asm "\09.asciz \09\22noop_direct_IO\22\09\09\09\09\09"
module asm "__kstrtabns_noop_direct_IO:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+kfree_link\22, \22a\22\09"
module asm "\09.weak\09__crc_kfree_link\09\09\09\09"
module asm "\09.long\09__crc_kfree_link\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_kfree_link:\09\09\09\09\09"
module asm "\09.asciz \09\22kfree_link\22\09\09\09\09\09"
module asm "__kstrtabns_kfree_link:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+alloc_anon_inode\22, \22a\22\09"
module asm "\09.weak\09__crc_alloc_anon_inode\09\09\09\09"
module asm "\09.long\09__crc_alloc_anon_inode\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_alloc_anon_inode:\09\09\09\09\09"
module asm "\09.asciz \09\22alloc_anon_inode\22\09\09\09\09\09"
module asm "__kstrtabns_alloc_anon_inode:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_nosetlease\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_nosetlease\09\09\09\09"
module asm "\09.long\09__crc_simple_nosetlease\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_nosetlease:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_nosetlease\22\09\09\09\09\09"
module asm "__kstrtabns_simple_nosetlease:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_get_link\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_get_link\09\09\09\09"
module asm "\09.long\09__crc_simple_get_link\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_get_link:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_get_link\22\09\09\09\09\09"
module asm "__kstrtabns_simple_get_link:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+simple_symlink_inode_operations\22, \22a\22\09"
module asm "\09.weak\09__crc_simple_symlink_inode_operations\09\09\09\09"
module asm "\09.long\09__crc_simple_symlink_inode_operations\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_simple_symlink_inode_operations:\09\09\09\09\09"
module asm "\09.asciz \09\22simple_symlink_inode_operations\22\09\09\09\09\09"
module asm "__kstrtabns_simple_symlink_inode_operations:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+generic_set_encrypted_ci_d_ops\22, \22a\22\09"
module asm "\09.weak\09__crc_generic_set_encrypted_ci_d_ops\09\09\09\09"
module asm "\09.long\09__crc_generic_set_encrypted_ci_d_ops\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_generic_set_encrypted_ci_d_ops:\09\09\09\09\09"
module asm "\09.asciz \09\22generic_set_encrypted_ci_d_ops\22\09\09\09\09\09"
module asm "__kstrtabns_generic_set_encrypted_ci_d_ops:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"

%struct.user_namespace = type { %struct.uid_gid_map, %struct.uid_gid_map, %struct.uid_gid_map, ptr, i32, %struct.kuid_t, %struct.kgid_t, %struct.ns_common, i32, i8, %struct.list_head, ptr, %struct.rw_semaphore, ptr, %struct.work_struct, %struct.ctl_table_set, ptr, ptr, [16 x i32] }
%struct.uid_gid_map = type { i32, %union.anon }
%union.anon = type { [5 x %struct.uid_gid_extent] }
%struct.uid_gid_extent = type { i32, i32, i32 }
%struct.kuid_t = type { i32 }
%struct.kgid_t = type { i32 }
%struct.ns_common = type { %struct.atomic_t, ptr, i32, %struct.refcount_struct }
%struct.atomic_t = type { i32 }
%struct.refcount_struct = type { %struct.atomic_t }
%struct.list_head = type { ptr, ptr }
%struct.rw_semaphore = type { %struct.atomic_t, %struct.atomic_t, %struct.optimistic_spin_queue, %struct.raw_spinlock, %struct.list_head, ptr, %struct.lockdep_map }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.raw_spinlock = type { %struct.arch_spinlock_t, i32, i32, ptr, %struct.lockdep_map }
%struct.arch_spinlock_t = type { %union.anon.1 }
%union.anon.1 = type { i32 }
%struct.lockdep_map = type { ptr, [2 x ptr], ptr, i8, i8, i8, i32, i32 }
%struct.work_struct = type { %struct.atomic_t, %struct.list_head, ptr, %struct.lockdep_map }
%struct.ctl_table_set = type { ptr, %struct.ctl_dir }
%struct.ctl_dir = type { %struct.ctl_table_header, %struct.rb_root }
%struct.ctl_table_header = type { %union.anon.10, ptr, ptr, ptr, ptr, ptr, ptr, %struct.hlist_head }
%union.anon.10 = type { %struct.anon.11 }
%struct.anon.11 = type { ptr, i32, i32, i32 }
%struct.hlist_head = type { ptr }
%struct.rb_root = type { ptr }
%struct.kernel_symbol = type { i32, ptr, ptr }
%struct.dentry_operations = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, [76 x i8] }
%struct.file_operations = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.inode_operations = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, [36 x i8] }
%struct.fs_context_operations = type { ptr, ptr, ptr, ptr, ptr, ptr }
%struct.address_space_operations = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.super_operations = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.pi_entry = type { ptr, ptr, ptr, i32, ptr, ptr }
%struct.spinlock = type { %union.anon.12 }
%union.anon.12 = type { %struct.raw_spinlock }
%struct.lock_class_key = type { %union.anon.2 }
%union.anon.2 = type { %struct.hlist_node }
%struct.hlist_node = type { ptr, ptr }
%struct.tracepoint = type { ptr, %struct.static_key, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.static_key = type { %struct.atomic_t, %union.anon.70 }
%union.anon.70 = type { i32 }
%struct.path = type { ptr, ptr }
%struct.dentry = type { i32, %struct.seqcount_spinlock, %struct.hlist_bl_node, ptr, %struct.qstr, ptr, [36 x i8], %struct.lockref, ptr, ptr, i32, ptr, %union.anon.84, %struct.list_head, %struct.list_head, %union.anon.85 }
%struct.seqcount_spinlock = type { %struct.seqcount, ptr }
%struct.seqcount = type { i32, %struct.lockdep_map }
%struct.hlist_bl_node = type { ptr, ptr }
%struct.qstr = type { %union.anon.14, ptr }
%union.anon.14 = type { i64 }
%struct.lockref = type { %union.anon.82 }
%union.anon.82 = type { %struct.anon.83 }
%struct.anon.83 = type { %struct.spinlock, i32 }
%union.anon.84 = type { %struct.list_head }
%union.anon.85 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.kuid_t, %struct.kgid_t, i32, ptr, ptr, ptr, ptr, ptr, ptr, i32, %union.anon.76, i32, i64, %struct.timespec64, %struct.timespec64, %struct.timespec64, %struct.spinlock, i16, i8, i8, i64, %struct.seqcount, i32, %struct.rw_semaphore, i32, i32, %struct.hlist_node, %struct.list_head, ptr, i32, i16, i16, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.77, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %union.anon.78, ptr, %struct.address_space, %struct.list_head, %union.anon.81, i32, i32, ptr, ptr, ptr, ptr }
%union.anon.76 = type { i32 }
%struct.timespec64 = type { i64, i32 }
%union.anon.77 = type { %struct.callback_head }
%struct.callback_head = type { ptr, ptr }
%struct.atomic64_t = type { i64 }
%union.anon.78 = type { ptr }
%struct.address_space = type { ptr, %struct.xarray, %struct.rw_semaphore, i32, %struct.atomic_t, %struct.rb_root_cached, %struct.rw_semaphore, i32, i32, ptr, i32, i32, %struct.spinlock, %struct.list_head, ptr }
%struct.xarray = type { %struct.spinlock, i32, ptr }
%struct.rb_root_cached = type { %struct.rb_root, ptr }
%union.anon.81 = type { ptr }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec64, %struct.timespec64, %struct.timespec64, %struct.timespec64, i64, i64 }
%struct.super_block = type { %struct.list_head, i32, i8, i32, i64, ptr, ptr, ptr, ptr, ptr, i32, i32, i32, ptr, %struct.rw_semaphore, i32, %struct.atomic_t, ptr, ptr, ptr, ptr, ptr, ptr, i16, %struct.hlist_bl_head, %struct.list_head, ptr, ptr, ptr, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, ptr, i32, i64, i64, i32, ptr, [32 x i8], %struct.uuid_t, i32, i32, %struct.mutex, ptr, ptr, %struct.shrinker, %struct.atomic_t, %struct.atomic_t, i32, i32, ptr, %struct.hlist_head, ptr, %struct.list_lru, %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [24 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [24 x i8] }
%struct.hlist_bl_head = type { ptr }
%struct.quota_info = type { i32, %struct.rw_semaphore, [3 x ptr], [3 x %struct.mem_dqinfo], [3 x ptr] }
%struct.mem_dqinfo = type { ptr, i32, %struct.list_head, i32, i32, i32, i64, i64, ptr }
%struct.sb_writers = type { i32, %struct.wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, ptr, %struct.rcuwait, %struct.wait_queue_head, %struct.atomic_t, %struct.lockdep_map }
%struct.rcu_sync = type { i32, i32, %struct.wait_queue_head, %struct.callback_head }
%struct.rcuwait = type { ptr }
%struct.uuid_t = type { [16 x i8] }
%struct.shrinker = type { ptr, ptr, i32, i32, i32, %struct.list_head, i32, ptr }
%struct.list_lru = type { ptr, %struct.list_head, i32, i8 }
%struct.mutex = type { %struct.atomic_t, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.list_head, ptr, %struct.lockdep_map }
%struct.kstatfs = type { i32, i32, i64, i64, i64, i64, i64, %struct.__kernel_fsid_t, i32, i32, i32, [4 x i32] }
%struct.__kernel_fsid_t = type { [2 x i32] }
%struct.file = type { %union.anon.86, %struct.path, ptr, ptr, %struct.spinlock, i32, %struct.atomic_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, ptr, %struct.file_ra_state, i64, ptr, ptr, ptr, ptr, i32, i32 }
%union.anon.86 = type { %struct.callback_head }
%struct.fown_struct = type { %struct.rwlock_t, ptr, i32, %struct.kuid_t, %struct.kuid_t, i32 }
%struct.rwlock_t = type { %struct.arch_rwlock_t, i32, i32, ptr, %struct.lockdep_map }
%struct.arch_rwlock_t = type { i32 }
%struct.file_ra_state = type { i32, i32, i32, i32, i32, i64 }
%struct.dir_context = type { ptr, i64 }
%struct.pseudo_fs_context = type { ptr, ptr, ptr, i32 }
%struct.fs_context = type { ptr, %struct.mutex, ptr, ptr, ptr, ptr, ptr, ptr, ptr, %struct.p_log, ptr, ptr, ptr, i32, i32, i32, i32, i24 }
%struct.p_log = type { ptr, ptr }
%struct.iattr = type { i32, i16, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec64, %struct.timespec64, %struct.timespec64, ptr }
%struct.page = type { i32, %union.anon.18, %union.anon.63, %struct.atomic_t, i32 }
%union.anon.18 = type { %struct.anon.19 }
%struct.anon.19 = type { %struct.list_head, ptr, i32, i32 }
%union.anon.63 = type { %struct.atomic_t }
%struct.thread_info = type { i32, i32, ptr, i32, i32, %struct.cpu_context_save, i32, [16 x i8], [2 x i32], %union.fp_state, %union.vfp_state, i32 }
%struct.cpu_context_save = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [2 x i32] }
%union.fp_state = type { %struct.iwmmxt_struct }
%struct.iwmmxt_struct = type { [38 x i32] }
%union.vfp_state = type { %struct.vfp_hard_struct }
%struct.vfp_hard_struct = type { [32 x i64], i32, i32, i32, i32, i32 }
%struct.tree_descr = type { ptr, ptr, i32 }
%struct.simple_transaction_argresp = type { i32, [0 x i8] }
%struct.simple_attr = type { ptr, ptr, [24 x i8], [24 x i8], ptr, ptr, %struct.mutex }
%struct.anon.73 = type { i32, i32, i32, i32 }
%struct.task_struct = type { i32, ptr, %struct.refcount_struct, i32, i32, i32, %struct.__call_single_node, i32, i32, ptr, i32, i32, i32, i32, i32, i32, i32, [56 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.sched_dl_entity, ptr, %struct.rb_node, i32, i32, ptr, [2 x %struct.uclamp_se], [2 x %struct.uclamp_se], [116 x i8], %struct.sched_statistics, i32, i32, i32, ptr, ptr, %struct.cpumask, ptr, i16, i16, i32, i8, i8, i32, %struct.list_head, i32, i32, %union.rcu_special, i8, %struct.list_head, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, ptr, ptr, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i32, i32, i8, [3 x i8], i16, i32, %struct.restart_block, i32, i32, i32, ptr, ptr, %struct.list_head, %struct.list_head, ptr, %struct.list_head, %struct.list_head, ptr, [4 x %struct.hlist_node], %struct.list_head, %struct.list_head, ptr, ptr, ptr, ptr, i64, i64, i64, %struct.prev_cputime, i32, i32, i64, i64, i32, i32, %struct.posix_cputimers, ptr, ptr, ptr, ptr, [16 x i8], ptr, %struct.sysv_sem, %struct.sysv_shm, i32, i32, ptr, ptr, ptr, ptr, ptr, ptr, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i32, i32, i32, ptr, %struct.kuid_t, i32, %struct.seccomp, %struct.syscall_user_dispatch, i64, i64, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root_cached, ptr, ptr, ptr, i32, %struct.irqtrace_events, i32, i64, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, %struct.task_io_accounting, i32, i64, i64, i64, %struct.nodemask_t, %struct.seqcount_spinlock, i32, i32, ptr, %struct.list_head, ptr, %struct.list_head, ptr, %struct.mutex, i32, [2 x ptr], %struct.mutex, %struct.list_head, ptr, i32, i32, %struct.tlbflush_unmap_batch, %union.anon.57, ptr, %struct.page_frag, ptr, i32, i32, i32, i32, i32, i32, [32 x %struct.latency_record], i64, i64, i32, ptr, i32, i32, i32, i32, ptr, ptr, i64, i32, i32, ptr, i32, i32, i32, ptr, ptr, ptr, i32, i32, %struct.kmap_ctrl, i32, i32, ptr, ptr, ptr, ptr, %struct.llist_head, %struct.thread_struct, [84 x i8] }
%struct.__call_single_node = type { %struct.llist_node, %union.anon.31 }
%struct.llist_node = type { ptr }
%union.anon.31 = type { i32 }
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, i32, ptr, ptr, ptr, i32, [36 x i8], %struct.sched_avg }
%struct.load_weight = type { i32, i32 }
%struct.sched_avg = type { i64, i64, i64, i32, i32, i32, i32, i32, [4 x i8], %struct.util_est, [72 x i8] }
%struct.util_est = type { i32, i32 }
%struct.sched_rt_entity = type { %struct.list_head, i32, i32, i32, i16, i16, ptr, ptr, ptr, ptr }
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i64, i32, i8, %struct.hrtimer, %struct.hrtimer, ptr }
%struct.hrtimer = type { %struct.timerqueue_node, i64, ptr, ptr, i8, i8, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.uclamp_se = type { i16, [2 x i8] }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [24 x i8] }
%struct.cpumask = type { [1 x i32] }
%union.rcu_special = type { i32 }
%struct.sched_info = type { i32, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.rb_node = type { i32, ptr, ptr }
%struct.vmacache = type { i64, [4 x ptr] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i32, ptr, %union.anon.33 }
%union.anon.33 = type { %struct.anon.34 }
%struct.anon.34 = type { ptr, i32, i32, i32, i64, ptr }
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.posix_cputimers = type { [3 x %struct.posix_cputimer_base], i32, i32 }
%struct.posix_cputimer_base = type { i64, %struct.timerqueue_head }
%struct.timerqueue_head = type { %struct.rb_root_cached }
%struct.sysv_sem = type { ptr }
%struct.sysv_shm = type { %struct.list_head }
%struct.sigset_t = type { [2 x i32] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.seccomp = type { i32, %struct.atomic_t, ptr }
%struct.syscall_user_dispatch = type {}
%struct.wake_q_node = type { ptr }
%struct.irqtrace_events = type { i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.held_lock = type { i64, i32, ptr, ptr, i64, i64, i32, i32 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i32] }
%struct.tlbflush_unmap_batch = type {}
%union.anon.57 = type { %struct.callback_head }
%struct.page_frag = type { ptr, i16, i16 }
%struct.latency_record = type { [12 x i32], i32, i32, i32 }
%struct.kmap_ctrl = type { i32, [33 x i32] }
%struct.llist_head = type { ptr }
%struct.thread_struct = type { i32, i32, i32, %struct.debug_info }
%struct.debug_info = type { [32 x ptr] }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, ptr, i32, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, %union.anon.17 }
%struct.kernel_cap_struct = type { [2 x i32] }
%union.anon.17 = type { %struct.callback_head }
%struct.anon.15 = type { i32, i32 }

@init_user_ns = external dso_local global %struct.user_namespace, align 4
@__kstrtab_simple_getattr = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_getattr = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_getattr = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_getattr to i32), ptr @__kstrtab_simple_getattr, ptr @__kstrtabns_simple_getattr }, section "___ksymtab+simple_getattr", align 4
@__kstrtab_simple_statfs = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_statfs = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_statfs = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_statfs to i32), ptr @__kstrtab_simple_statfs, ptr @__kstrtabns_simple_statfs }, section "___ksymtab+simple_statfs", align 4
@__kstrtab_always_delete_dentry = external dso_local constant [0 x i8], align 1
@__kstrtabns_always_delete_dentry = external dso_local constant [0 x i8], align 1
@__ksymtab_always_delete_dentry = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @always_delete_dentry to i32), ptr @__kstrtab_always_delete_dentry, ptr @__kstrtabns_always_delete_dentry }, section "___ksymtab+always_delete_dentry", align 4
@simple_dentry_operations = dso_local constant %struct.dentry_operations { ptr null, ptr null, ptr null, ptr null, ptr @always_delete_dentry, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, [76 x i8] undef }, align 128
@__kstrtab_simple_dentry_operations = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_dentry_operations = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_dentry_operations = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_dentry_operations to i32), ptr @__kstrtab_simple_dentry_operations, ptr @__kstrtabns_simple_dentry_operations }, section "___ksymtab+simple_dentry_operations", align 4
@__kstrtab_simple_lookup = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_lookup = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_lookup = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_lookup to i32), ptr @__kstrtab_simple_lookup, ptr @__kstrtabns_simple_lookup }, section "___ksymtab+simple_lookup", align 4
@__kstrtab_dcache_dir_open = external dso_local constant [0 x i8], align 1
@__kstrtabns_dcache_dir_open = external dso_local constant [0 x i8], align 1
@__ksymtab_dcache_dir_open = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @dcache_dir_open to i32), ptr @__kstrtab_dcache_dir_open, ptr @__kstrtabns_dcache_dir_open }, section "___ksymtab+dcache_dir_open", align 4
@__kstrtab_dcache_dir_close = external dso_local constant [0 x i8], align 1
@__kstrtabns_dcache_dir_close = external dso_local constant [0 x i8], align 1
@__ksymtab_dcache_dir_close = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @dcache_dir_close to i32), ptr @__kstrtab_dcache_dir_close, ptr @__kstrtabns_dcache_dir_close }, section "___ksymtab+dcache_dir_close", align 4
@__kstrtab_dcache_dir_lseek = external dso_local constant [0 x i8], align 1
@__kstrtabns_dcache_dir_lseek = external dso_local constant [0 x i8], align 1
@__ksymtab_dcache_dir_lseek = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @dcache_dir_lseek to i32), ptr @__kstrtab_dcache_dir_lseek, ptr @__kstrtabns_dcache_dir_lseek }, section "___ksymtab+dcache_dir_lseek", align 4
@__kstrtab_dcache_readdir = external dso_local constant [0 x i8], align 1
@__kstrtabns_dcache_readdir = external dso_local constant [0 x i8], align 1
@__ksymtab_dcache_readdir = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @dcache_readdir to i32), ptr @__kstrtab_dcache_readdir, ptr @__kstrtabns_dcache_readdir }, section "___ksymtab+dcache_readdir", align 4
@__kstrtab_generic_read_dir = external dso_local constant [0 x i8], align 1
@__kstrtabns_generic_read_dir = external dso_local constant [0 x i8], align 1
@__ksymtab_generic_read_dir = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @generic_read_dir to i32), ptr @__kstrtab_generic_read_dir, ptr @__kstrtabns_generic_read_dir }, section "___ksymtab+generic_read_dir", align 4
@simple_dir_operations = dso_local constant { %struct.file_operations, [32 x i8] } { %struct.file_operations { ptr null, ptr @dcache_dir_lseek, ptr @generic_read_dir, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @dcache_readdir, ptr null, ptr null, ptr null, ptr null, i32 0, ptr @dcache_dir_open, ptr null, ptr @dcache_dir_close, ptr @noop_fsync, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null }, [32 x i8] zeroinitializer }, align 32
@__kstrtab_simple_dir_operations = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_dir_operations = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_dir_operations = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_dir_operations to i32), ptr @__kstrtab_simple_dir_operations, ptr @__kstrtabns_simple_dir_operations }, section "___ksymtab+simple_dir_operations", align 4
@simple_dir_inode_operations = dso_local constant %struct.inode_operations { ptr @simple_lookup, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, [36 x i8] undef }, align 128
@__kstrtab_simple_dir_inode_operations = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_dir_inode_operations = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_dir_inode_operations = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_dir_inode_operations to i32), ptr @__kstrtab_simple_dir_inode_operations, ptr @__kstrtabns_simple_dir_inode_operations }, section "___ksymtab+simple_dir_inode_operations", align 4
@__kstrtab_simple_recursive_removal = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_recursive_removal = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_recursive_removal = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_recursive_removal to i32), ptr @__kstrtab_simple_recursive_removal, ptr @__kstrtabns_simple_recursive_removal }, section "___ksymtab+simple_recursive_removal", align 4
@pseudo_fs_context_ops = internal constant { %struct.fs_context_operations, [40 x i8] } { %struct.fs_context_operations { ptr @pseudo_fs_free, ptr null, ptr null, ptr null, ptr @pseudo_fs_get_tree, ptr null }, [40 x i8] zeroinitializer }, align 32
@__kstrtab_init_pseudo = external dso_local constant [0 x i8], align 1
@__kstrtabns_init_pseudo = external dso_local constant [0 x i8], align 1
@__ksymtab_init_pseudo = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @init_pseudo to i32), ptr @__kstrtab_init_pseudo, ptr @__kstrtabns_init_pseudo }, section "___ksymtab+init_pseudo", align 4
@__kstrtab_simple_open = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_open = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_open = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_open to i32), ptr @__kstrtab_simple_open, ptr @__kstrtabns_simple_open }, section "___ksymtab+simple_open", align 4
@__kstrtab_simple_link = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_link = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_link = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_link to i32), ptr @__kstrtab_simple_link, ptr @__kstrtabns_simple_link }, section "___ksymtab+simple_link", align 4
@__kstrtab_simple_empty = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_empty = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_empty = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_empty to i32), ptr @__kstrtab_simple_empty, ptr @__kstrtabns_simple_empty }, section "___ksymtab+simple_empty", align 4
@__kstrtab_simple_unlink = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_unlink = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_unlink = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_unlink to i32), ptr @__kstrtab_simple_unlink, ptr @__kstrtabns_simple_unlink }, section "___ksymtab+simple_unlink", align 4
@__kstrtab_simple_rmdir = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_rmdir = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_rmdir = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_rmdir to i32), ptr @__kstrtab_simple_rmdir, ptr @__kstrtabns_simple_rmdir }, section "___ksymtab+simple_rmdir", align 4
@__kstrtab_simple_rename_exchange = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_rename_exchange = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_rename_exchange = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_rename_exchange to i32), ptr @__kstrtab_simple_rename_exchange, ptr @__kstrtabns_simple_rename_exchange }, section "___ksymtab_gpl+simple_rename_exchange", align 4
@__kstrtab_simple_rename = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_rename = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_rename = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_rename to i32), ptr @__kstrtab_simple_rename, ptr @__kstrtabns_simple_rename }, section "___ksymtab+simple_rename", align 4
@__kstrtab_simple_setattr = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_setattr = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_setattr = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_setattr to i32), ptr @__kstrtab_simple_setattr, ptr @__kstrtabns_simple_setattr }, section "___ksymtab+simple_setattr", align 4
@__kstrtab_simple_write_begin = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_write_begin = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_write_begin = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_write_begin to i32), ptr @__kstrtab_simple_write_begin, ptr @__kstrtabns_simple_write_begin }, section "___ksymtab+simple_write_begin", align 4
@ram_aops = dso_local constant { %struct.address_space_operations, [40 x i8] } { %struct.address_space_operations { ptr null, ptr @simple_readpage, ptr null, ptr @__set_page_dirty_no_writeback, ptr null, ptr null, ptr @simple_write_begin, ptr @simple_write_end, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@__kstrtab_ram_aops = external dso_local constant [0 x i8], align 1
@__kstrtabns_ram_aops = external dso_local constant [0 x i8], align 1
@__ksymtab_ram_aops = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @ram_aops to i32), ptr @__kstrtab_ram_aops, ptr @__kstrtabns_ram_aops }, section "___ksymtab+ram_aops", align 4
@simple_super_operations = internal constant { %struct.super_operations, [60 x i8] } { %struct.super_operations { ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @simple_statfs, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null }, [60 x i8] zeroinitializer }, align 32
@simple_fill_super._entry = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str, ptr @.str.1, ptr @.str.2, i32 681, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str = internal constant { [53 x i8], [43 x i8] } { [53 x i8] c"\014%s: %s passed in a files arraywith an index of 1!\0A\00", [43 x i8] zeroinitializer }, align 32
@.str.1 = internal constant { [18 x i8], [46 x i8] } { [18 x i8] c"simple_fill_super\00", [46 x i8] zeroinitializer }, align 32
@.str.2 = internal constant { [11 x i8], [21 x i8] } { [11 x i8] c"fs/libfs.c\00", [21 x i8] zeroinitializer }, align 32
@simple_fill_super._entry_ptr = internal global ptr @simple_fill_super._entry, section ".printk_index", align 4
@__kstrtab_simple_fill_super = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_fill_super = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_fill_super = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_fill_super to i32), ptr @__kstrtab_simple_fill_super, ptr @__kstrtabns_simple_fill_super }, section "___ksymtab+simple_fill_super", align 4
@pin_fs_lock = internal global { %struct.spinlock, [52 x i8] } { %struct.spinlock { %union.anon.12 { %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.13, i8 0, i8 3, i8 0, i32 0, i32 0 } } } }, [52 x i8] zeroinitializer }, align 32
@__kstrtab_simple_pin_fs = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_pin_fs = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_pin_fs = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_pin_fs to i32), ptr @__kstrtab_simple_pin_fs, ptr @__kstrtabns_simple_pin_fs }, section "___ksymtab+simple_pin_fs", align 4
@__kstrtab_simple_release_fs = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_release_fs = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_release_fs = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_release_fs to i32), ptr @__kstrtab_simple_release_fs, ptr @__kstrtabns_simple_release_fs }, section "___ksymtab+simple_release_fs", align 4
@__kstrtab_simple_read_from_buffer = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_read_from_buffer = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_read_from_buffer = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_read_from_buffer to i32), ptr @__kstrtab_simple_read_from_buffer, ptr @__kstrtabns_simple_read_from_buffer }, section "___ksymtab+simple_read_from_buffer", align 4
@__kstrtab_simple_write_to_buffer = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_write_to_buffer = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_write_to_buffer = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_write_to_buffer to i32), ptr @__kstrtab_simple_write_to_buffer, ptr @__kstrtabns_simple_write_to_buffer }, section "___ksymtab+simple_write_to_buffer", align 4
@__kstrtab_memory_read_from_buffer = external dso_local constant [0 x i8], align 1
@__kstrtabns_memory_read_from_buffer = external dso_local constant [0 x i8], align 1
@__ksymtab_memory_read_from_buffer = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @memory_read_from_buffer to i32), ptr @__kstrtab_memory_read_from_buffer, ptr @__kstrtabns_memory_read_from_buffer }, section "___ksymtab+memory_read_from_buffer", align 4
@__kstrtab_simple_transaction_set = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_transaction_set = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_transaction_set = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_transaction_set to i32), ptr @__kstrtab_simple_transaction_set, ptr @__kstrtabns_simple_transaction_set }, section "___ksymtab+simple_transaction_set", align 4
@simple_transaction_get.simple_transaction_lock = internal global { %struct.spinlock, [52 x i8] } { %struct.spinlock { %union.anon.12 { %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.3, i8 0, i8 3, i8 0, i32 0, i32 0 } } } }, [52 x i8] zeroinitializer }, align 32
@.str.3 = internal constant { [24 x i8], [40 x i8] } { [24 x i8] c"simple_transaction_lock\00", [40 x i8] zeroinitializer }, align 32
@__kstrtab_simple_transaction_get = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_transaction_get = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_transaction_get = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_transaction_get to i32), ptr @__kstrtab_simple_transaction_get, ptr @__kstrtabns_simple_transaction_get }, section "___ksymtab+simple_transaction_get", align 4
@__kstrtab_simple_transaction_read = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_transaction_read = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_transaction_read = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_transaction_read to i32), ptr @__kstrtab_simple_transaction_read, ptr @__kstrtabns_simple_transaction_read }, section "___ksymtab+simple_transaction_read", align 4
@__kstrtab_simple_transaction_release = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_transaction_release = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_transaction_release = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_transaction_release to i32), ptr @__kstrtab_simple_transaction_release, ptr @__kstrtabns_simple_transaction_release }, section "___ksymtab+simple_transaction_release", align 4
@simple_attr_open.__key = internal global { %struct.lock_class_key, [24 x i8] } zeroinitializer, align 32
@.str.4 = internal constant { [13 x i8], [19 x i8] } { [13 x i8] c"&attr->mutex\00", [19 x i8] zeroinitializer }, align 32
@__kstrtab_simple_attr_open = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_attr_open = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_attr_open = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_attr_open to i32), ptr @__kstrtab_simple_attr_open, ptr @__kstrtabns_simple_attr_open }, section "___ksymtab_gpl+simple_attr_open", align 4
@__kstrtab_simple_attr_release = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_attr_release = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_attr_release = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_attr_release to i32), ptr @__kstrtab_simple_attr_release, ptr @__kstrtabns_simple_attr_release }, section "___ksymtab_gpl+simple_attr_release", align 4
@__kstrtab_simple_attr_read = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_attr_read = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_attr_read = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_attr_read to i32), ptr @__kstrtab_simple_attr_read, ptr @__kstrtabns_simple_attr_read }, section "___ksymtab_gpl+simple_attr_read", align 4
@__kstrtab_simple_attr_write = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_attr_write = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_attr_write = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_attr_write to i32), ptr @__kstrtab_simple_attr_write, ptr @__kstrtabns_simple_attr_write }, section "___ksymtab_gpl+simple_attr_write", align 4
@__kstrtab_generic_fh_to_dentry = external dso_local constant [0 x i8], align 1
@__kstrtabns_generic_fh_to_dentry = external dso_local constant [0 x i8], align 1
@__ksymtab_generic_fh_to_dentry = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @generic_fh_to_dentry to i32), ptr @__kstrtab_generic_fh_to_dentry, ptr @__kstrtabns_generic_fh_to_dentry }, section "___ksymtab_gpl+generic_fh_to_dentry", align 4
@__kstrtab_generic_fh_to_parent = external dso_local constant [0 x i8], align 1
@__kstrtabns_generic_fh_to_parent = external dso_local constant [0 x i8], align 1
@__ksymtab_generic_fh_to_parent = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @generic_fh_to_parent to i32), ptr @__kstrtab_generic_fh_to_parent, ptr @__kstrtabns_generic_fh_to_parent }, section "___ksymtab_gpl+generic_fh_to_parent", align 4
@__kstrtab___generic_file_fsync = external dso_local constant [0 x i8], align 1
@__kstrtabns___generic_file_fsync = external dso_local constant [0 x i8], align 1
@__ksymtab___generic_file_fsync = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @__generic_file_fsync to i32), ptr @__kstrtab___generic_file_fsync, ptr @__kstrtabns___generic_file_fsync }, section "___ksymtab+__generic_file_fsync", align 4
@__kstrtab_generic_file_fsync = external dso_local constant [0 x i8], align 1
@__kstrtabns_generic_file_fsync = external dso_local constant [0 x i8], align 1
@__ksymtab_generic_file_fsync = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @generic_file_fsync to i32), ptr @__kstrtab_generic_file_fsync, ptr @__kstrtabns_generic_file_fsync }, section "___ksymtab+generic_file_fsync", align 4
@__kstrtab_generic_check_addressable = external dso_local constant [0 x i8], align 1
@__kstrtabns_generic_check_addressable = external dso_local constant [0 x i8], align 1
@__ksymtab_generic_check_addressable = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @generic_check_addressable to i32), ptr @__kstrtab_generic_check_addressable, ptr @__kstrtabns_generic_check_addressable }, section "___ksymtab+generic_check_addressable", align 4
@__kstrtab_noop_fsync = external dso_local constant [0 x i8], align 1
@__kstrtabns_noop_fsync = external dso_local constant [0 x i8], align 1
@__ksymtab_noop_fsync = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @noop_fsync to i32), ptr @__kstrtab_noop_fsync, ptr @__kstrtabns_noop_fsync }, section "___ksymtab+noop_fsync", align 4
@__kstrtab_noop_invalidatepage = external dso_local constant [0 x i8], align 1
@__kstrtabns_noop_invalidatepage = external dso_local constant [0 x i8], align 1
@__ksymtab_noop_invalidatepage = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @noop_invalidatepage to i32), ptr @__kstrtab_noop_invalidatepage, ptr @__kstrtabns_noop_invalidatepage }, section "___ksymtab_gpl+noop_invalidatepage", align 4
@__kstrtab_noop_direct_IO = external dso_local constant [0 x i8], align 1
@__kstrtabns_noop_direct_IO = external dso_local constant [0 x i8], align 1
@__ksymtab_noop_direct_IO = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @noop_direct_IO to i32), ptr @__kstrtab_noop_direct_IO, ptr @__kstrtabns_noop_direct_IO }, section "___ksymtab_gpl+noop_direct_IO", align 4
@__kstrtab_kfree_link = external dso_local constant [0 x i8], align 1
@__kstrtabns_kfree_link = external dso_local constant [0 x i8], align 1
@__ksymtab_kfree_link = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @kfree_link to i32), ptr @__kstrtab_kfree_link, ptr @__kstrtabns_kfree_link }, section "___ksymtab+kfree_link", align 4
@alloc_anon_inode.anon_aops = internal constant { %struct.address_space_operations, [40 x i8] } { %struct.address_space_operations { ptr null, ptr null, ptr null, ptr @__set_page_dirty_no_writeback, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@__kstrtab_alloc_anon_inode = external dso_local constant [0 x i8], align 1
@__kstrtabns_alloc_anon_inode = external dso_local constant [0 x i8], align 1
@__ksymtab_alloc_anon_inode = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @alloc_anon_inode to i32), ptr @__kstrtab_alloc_anon_inode, ptr @__kstrtabns_alloc_anon_inode }, section "___ksymtab+alloc_anon_inode", align 4
@__kstrtab_simple_nosetlease = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_nosetlease = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_nosetlease = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_nosetlease to i32), ptr @__kstrtab_simple_nosetlease, ptr @__kstrtabns_simple_nosetlease }, section "___ksymtab+simple_nosetlease", align 4
@__kstrtab_simple_get_link = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_get_link = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_get_link = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_get_link to i32), ptr @__kstrtab_simple_get_link, ptr @__kstrtabns_simple_get_link }, section "___ksymtab+simple_get_link", align 4
@simple_symlink_inode_operations = dso_local constant %struct.inode_operations { ptr null, ptr @simple_get_link, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, [36 x i8] undef }, align 128
@__kstrtab_simple_symlink_inode_operations = external dso_local constant [0 x i8], align 1
@__kstrtabns_simple_symlink_inode_operations = external dso_local constant [0 x i8], align 1
@__ksymtab_simple_symlink_inode_operations = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @simple_symlink_inode_operations to i32), ptr @__kstrtab_simple_symlink_inode_operations, ptr @__kstrtabns_simple_symlink_inode_operations }, section "___ksymtab+simple_symlink_inode_operations", align 4
@empty_dir_inode_operations = internal constant %struct.inode_operations { ptr @empty_dir_lookup, ptr null, ptr @generic_permission, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @empty_dir_setattr, ptr @empty_dir_getattr, ptr @empty_dir_listxattr, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, [36 x i8] undef }, align 128
@empty_dir_operations = internal constant { %struct.file_operations, [32 x i8] } { %struct.file_operations { ptr null, ptr @empty_dir_llseek, ptr @generic_read_dir, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @empty_dir_readdir, ptr null, ptr null, ptr null, ptr null, i32 0, ptr null, ptr null, ptr null, ptr @noop_fsync, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null }, [32 x i8] zeroinitializer }, align 32
@generic_encrypted_ci_dentry_ops = internal constant %struct.dentry_operations { ptr @fscrypt_d_revalidate, ptr null, ptr @generic_ci_d_hash, ptr @generic_ci_d_compare, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, [76 x i8] undef }, align 128
@generic_encrypted_dentry_ops = internal constant %struct.dentry_operations { ptr @fscrypt_d_revalidate, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, [76 x i8] undef }, align 128
@generic_ci_dentry_ops = internal constant %struct.dentry_operations { ptr null, ptr null, ptr @generic_ci_d_hash, ptr @generic_ci_d_compare, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, [76 x i8] undef }, align 128
@__kstrtab_generic_set_encrypted_ci_d_ops = external dso_local constant [0 x i8], align 1
@__kstrtabns_generic_set_encrypted_ci_d_ops = external dso_local constant [0 x i8], align 1
@__ksymtab_generic_set_encrypted_ci_d_ops = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @generic_set_encrypted_ci_d_ops to i32), ptr @__kstrtab_generic_set_encrypted_ci_d_ops, ptr @__kstrtabns_generic_set_encrypted_ci_d_ops }, section "___ksymtab+generic_set_encrypted_ci_d_ops", align 4
@.str.6 = internal constant { [2 x i8], [30 x i8] } { [2 x i8] c".\00", [30 x i8] zeroinitializer }, align 32
@.str.7 = internal constant { [3 x i8], [29 x i8] } { [3 x i8] c"..\00", [29 x i8] zeroinitializer }, align 32
@fsnotify_rmdir.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.8 = internal constant { [25 x i8], [39 x i8] } { [25 x i8] c"include/linux/fsnotify.h\00", [39 x i8] zeroinitializer }, align 32
@fsnotify_unlink.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@kmalloc_caches = external dso_local local_unnamed_addr global [4 x [14 x ptr]], align 4
@.str.9 = internal constant { [31 x i8], [33 x i8] } { [31 x i8] c"VM_BUG_ON_PAGE(PageTail(page))\00", [33 x i8] zeroinitializer }, align 32
@pgprot_kernel = external dso_local local_unnamed_addr global i32, align 4
@__seqprop_assert.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@debug_locks = external dso_local local_unnamed_addr global i32, section ".data..read_mostly", align 4
@lockdep_recursion = external dso_local global i32, section ".data..percpu", align 4
@__per_cpu_offset = external dso_local local_unnamed_addr global [4 x i32], align 4
@hardirqs_enabled = external dso_local global i32, section ".data..percpu", align 4
@.str.11 = internal constant { [24 x i8], [40 x i8] } { [24 x i8] c"include/linux/seqlock.h\00", [40 x i8] zeroinitializer }, align 32
@.str.12 = internal constant { [42 x i8], [54 x i8] } { [42 x i8] c"VM_BUG_ON_PAGE(page_ref_count(page) == 0)\00", [54 x i8] zeroinitializer }, align 32
@__tracepoint_page_ref_mod_and_test = external dso_local global %struct.tracepoint, align 4
@.str.13 = internal constant { [12 x i8], [20 x i8] } { [12 x i8] c"pin_fs_lock\00", [20 x i8] zeroinitializer }, align 32
@check_copy_size.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.14 = internal constant { [28 x i8], [36 x i8] } { [28 x i8] c"include/linux/thread_info.h\00", [36 x i8] zeroinitializer }, align 32
@.str.15 = internal constant { [38 x i8], [58 x i8] } { [38 x i8] c"Buffer overflow detected (%d < %lu)!\0A\00", [58 x i8] zeroinitializer }, align 32
@.str.16 = internal constant { [24 x i8], [40 x i8] } { [24 x i8] c"include/linux/uaccess.h\00", [40 x i8] zeroinitializer }, align 32
@__sancov_gen_cov_switch_values = internal global [4 x i64] [i64 2, i64 32, i64 0, i64 1]
@__sancov_gen_cov_switch_values.17 = internal global [5 x i64] [i64 3, i64 64, i64 0, i64 1, i64 2]
@__sancov_gen_cov_switch_values.18 = internal global [4 x i64] [i64 2, i64 64, i64 0, i64 1]
@___asan_gen_.19 = private unnamed_addr constant [22 x i8] c"simple_dir_operations\00", align 1
@___asan_gen_.21 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.83, i32 231, i32 30 }
@___asan_gen_.22 = private unnamed_addr constant [22 x i8] c"pseudo_fs_context_ops\00", align 1
@___asan_gen_.24 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.83, i32 360, i32 43 }
@___asan_gen_.25 = private unnamed_addr constant [9 x i8] c"ram_aops\00", align 1
@___asan_gen_.27 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.83, i32 630, i32 39 }
@___asan_gen_.28 = private unnamed_addr constant [24 x i8] c"simple_super_operations\00", align 1
@___asan_gen_.30 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.83, i32 315, i32 38 }
@___asan_gen_.31 = private unnamed_addr constant [7 x i8] c"_entry\00", align 1
@___asan_gen_.42 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.83, i32 679, i32 4 }
@___asan_gen_.43 = private unnamed_addr constant [12 x i8] c"pin_fs_lock\00", align 1
@___asan_gen_.46 = private unnamed_addr constant [24 x i8] c"simple_transaction_lock\00", align 1
@___asan_gen_.51 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.83, i32 869, i32 9 }
@___asan_gen_.52 = private unnamed_addr constant [6 x i8] c"__key\00", align 1
@___asan_gen_.57 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.83, i32 943, i32 2 }
@___asan_gen_.58 = private unnamed_addr constant [10 x i8] c"anon_aops\00", align 1
@___asan_gen_.60 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.83, i32 1233, i32 47 }
@___asan_gen_.61 = private unnamed_addr constant [21 x i8] c"empty_dir_operations\00", align 1
@___asan_gen_.63 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.83, i32 1352, i32 37 }
@___asan_gen_.66 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.68, i32 3566, i32 25 }
@___asan_gen_.68 = private unnamed_addr constant [22 x i8] c"../include/linux/fs.h\00", align 1
@___asan_gen_.69 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.68, i32 3571, i32 25 }
@___asan_gen_.71 = private unnamed_addr constant [28 x i8] c"../include/linux/fsnotify.h\00", align 1
@___asan_gen_.72 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.71, i32 298, i32 6 }
@___asan_gen_.74 = private unnamed_addr constant [30 x i8] c"../include/linux/page-flags.h\00", align 1
@___asan_gen_.75 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.74, i32 260, i32 2 }
@___asan_gen_.77 = private unnamed_addr constant [27 x i8] c"../include/linux/seqlock.h\00", align 1
@___asan_gen_.78 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.77, i32 271, i32 2 }
@___asan_gen_.80 = private unnamed_addr constant [22 x i8] c"../include/linux/mm.h\00", align 1
@___asan_gen_.81 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.80, i32 717, i32 2 }
@___asan_gen_.83 = private constant [14 x i8] c"../fs/libfs.c\00", align 1
@___asan_gen_.84 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.83, i32 707, i32 8 }
@___asan_gen_.87 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.89, i32 230, i32 6 }
@___asan_gen_.89 = private unnamed_addr constant [31 x i8] c"../include/linux/thread_info.h\00", align 1
@___asan_gen_.90 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.89, i32 214, i32 2 }
@___asan_gen_.91 = private unnamed_addr constant [17 x i8] c"<string literal>\00", align 1
@___asan_gen_.92 = private unnamed_addr constant [27 x i8] c"../include/linux/uaccess.h\00", align 1
@___asan_gen_.93 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.92, i32 174, i32 2 }
@llvm.compiler.used = appending global [78 x ptr] [ptr @__ksymtab___generic_file_fsync, ptr @__ksymtab_alloc_anon_inode, ptr @__ksymtab_always_delete_dentry, ptr @__ksymtab_dcache_dir_close, ptr @__ksymtab_dcache_dir_lseek, ptr @__ksymtab_dcache_dir_open, ptr @__ksymtab_dcache_readdir, ptr @__ksymtab_generic_check_addressable, ptr @__ksymtab_generic_fh_to_dentry, ptr @__ksymtab_generic_fh_to_parent, ptr @__ksymtab_generic_file_fsync, ptr @__ksymtab_generic_read_dir, ptr @__ksymtab_generic_set_encrypted_ci_d_ops, ptr @__ksymtab_init_pseudo, ptr @__ksymtab_kfree_link, ptr @__ksymtab_memory_read_from_buffer, ptr @__ksymtab_noop_direct_IO, ptr @__ksymtab_noop_fsync, ptr @__ksymtab_noop_invalidatepage, ptr @__ksymtab_ram_aops, ptr @__ksymtab_simple_attr_open, ptr @__ksymtab_simple_attr_read, ptr @__ksymtab_simple_attr_release, ptr @__ksymtab_simple_attr_write, ptr @__ksymtab_simple_dentry_operations, ptr @__ksymtab_simple_dir_inode_operations, ptr @__ksymtab_simple_dir_operations, ptr @__ksymtab_simple_empty, ptr @__ksymtab_simple_fill_super, ptr @__ksymtab_simple_get_link, ptr @__ksymtab_simple_getattr, ptr @__ksymtab_simple_link, ptr @__ksymtab_simple_lookup, ptr @__ksymtab_simple_nosetlease, ptr @__ksymtab_simple_open, ptr @__ksymtab_simple_pin_fs, ptr @__ksymtab_simple_read_from_buffer, ptr @__ksymtab_simple_recursive_removal, ptr @__ksymtab_simple_release_fs, ptr @__ksymtab_simple_rename, ptr @__ksymtab_simple_rename_exchange, ptr @__ksymtab_simple_rmdir, ptr @__ksymtab_simple_setattr, ptr @__ksymtab_simple_statfs, ptr @__ksymtab_simple_symlink_inode_operations, ptr @__ksymtab_simple_transaction_get, ptr @__ksymtab_simple_transaction_read, ptr @__ksymtab_simple_transaction_release, ptr @__ksymtab_simple_transaction_set, ptr @__ksymtab_simple_unlink, ptr @__ksymtab_simple_write_begin, ptr @__ksymtab_simple_write_to_buffer, ptr @simple_fill_super._entry, ptr @simple_fill_super._entry_ptr, ptr @simple_dir_operations, ptr @pseudo_fs_context_ops, ptr @ram_aops, ptr @simple_super_operations, ptr @.str, ptr @.str.1, ptr @.str.2, ptr @pin_fs_lock, ptr @simple_transaction_get.simple_transaction_lock, ptr @.str.3, ptr @simple_attr_open.__key, ptr @.str.4, ptr @alloc_anon_inode.anon_aops, ptr @empty_dir_operations, ptr @.str.6, ptr @.str.7, ptr @.str.8, ptr @.str.9, ptr @.str.11, ptr @.str.12, ptr @.str.13, ptr @.str.14, ptr @.str.15, ptr @.str.16], section "llvm.metadata"
@0 = internal global [25 x { i32, i32, i32, i32, i32, i32, i32, i32 }] [{ i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @simple_dir_operations to i32), i32 128, i32 160, i32 ptrtoint (ptr @___asan_gen_.19 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.21 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @pseudo_fs_context_ops to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.22 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.24 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @ram_aops to i32), i32 88, i32 128, i32 ptrtoint (ptr @___asan_gen_.25 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.27 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @simple_super_operations to i32), i32 100, i32 160, i32 ptrtoint (ptr @___asan_gen_.28 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.30 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @simple_fill_super._entry to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.31 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.42 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str to i32), i32 53, i32 96, i32 ptrtoint (ptr @___asan_gen_.91 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.42 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.1 to i32), i32 18, i32 64, i32 ptrtoint (ptr @___asan_gen_.91 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.42 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.2 to i32), i32 11, i32 32, i32 ptrtoint (ptr @___asan_gen_.91 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.42 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @pin_fs_lock to i32), i32 44, i32 96, i32 ptrtoint (ptr @___asan_gen_.43 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.84 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @simple_transaction_get.simple_transaction_lock to i32), i32 44, i32 96, i32 ptrtoint (ptr @___asan_gen_.46 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.51 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.3 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.91 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.51 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @simple_attr_open.__key to i32), i32 8, i32 32, i32 ptrtoint (ptr @___asan_gen_.52 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.57 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.4 to i32), i32 13, i32 32, i32 ptrtoint (ptr @___asan_gen_.91 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.57 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @alloc_anon_inode.anon_aops to i32), i32 88, i32 128, i32 ptrtoint (ptr @___asan_gen_.58 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.60 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @empty_dir_operations to i32), i32 128, i32 160, i32 ptrtoint (ptr @___asan_gen_.61 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.63 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.6 to i32), i32 2, i32 32, i32 ptrtoint (ptr @___asan_gen_.91 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.66 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.7 to i32), i32 3, i32 32, i32 ptrtoint (ptr @___asan_gen_.91 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.69 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.8 to i32), i32 25, i32 64, i32 ptrtoint (ptr @___asan_gen_.91 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.72 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.9 to i32), i32 31, i32 64, i32 ptrtoint (ptr @___asan_gen_.91 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.75 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.11 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.91 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.78 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.12 to i32), i32 42, i32 96, i32 ptrtoint (ptr @___asan_gen_.91 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.81 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.13 to i32), i32 12, i32 32, i32 ptrtoint (ptr @___asan_gen_.91 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.84 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.14 to i32), i32 28, i32 64, i32 ptrtoint (ptr @___asan_gen_.91 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.87 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.15 to i32), i32 38, i32 96, i32 ptrtoint (ptr @___asan_gen_.91 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.90 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.16 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.91 to i32), i32 ptrtoint (ptr @___asan_gen_.83 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.93 to i32), i32 -1 }]
@llvm.used = appending global [2 x ptr] [ptr @asan.module_ctor, ptr @asan.module_dtor], section "llvm.metadata"
@llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 1, ptr @asan.module_ctor, ptr null }]
@llvm.global_dtors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 1, ptr @asan.module_dtor, ptr null }]

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_getattr(ptr nocapture readnone %mnt_userns, ptr nocapture noundef readonly %path, ptr noundef %stat, i32 %request_mask, i32 %query_flags) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %dentry = getelementptr inbounds %struct.path, ptr %path, i32 0, i32 1
  %0 = ptrtoint ptr %dentry to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %dentry, align 4
  %d_inode.i = getelementptr inbounds %struct.dentry, ptr %1, i32 0, i32 5
  %2 = ptrtoint ptr %d_inode.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %d_inode.i, align 8
  tail call void @generic_fillattr(ptr noundef nonnull @init_user_ns, ptr noundef %3, ptr noundef %stat) #16
  %i_mapping = getelementptr inbounds %struct.inode, ptr %3, i32 0, i32 9
  %4 = ptrtoint ptr %i_mapping to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %i_mapping, align 8
  %nrpages = getelementptr inbounds %struct.address_space, ptr %5, i32 0, i32 7
  %6 = ptrtoint ptr %nrpages to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %nrpages, align 4
  %shl = shl i32 %7, 3
  %conv = zext i32 %shl to i64
  %blocks = getelementptr inbounds %struct.kstat, ptr %stat, i32 0, i32 16
  %8 = ptrtoint ptr %blocks to i32
  call void @__asan_store8_noabort(i32 %8)
  store i64 %conv, ptr %blocks, align 8
  ret i32 0
}

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: null_pointer_is_valid
declare dso_local void @generic_fillattr(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid sanitize_address sspstrong willreturn uwtable(sync)
define dso_local i32 @simple_statfs(ptr nocapture noundef readonly %dentry, ptr nocapture noundef writeonly %buf) #3 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %d_sb = getelementptr inbounds %struct.dentry, ptr %dentry, i32 0, i32 9
  %0 = ptrtoint ptr %d_sb to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %d_sb, align 4
  %s_magic = getelementptr inbounds %struct.super_block, ptr %1, i32 0, i32 12
  %2 = ptrtoint ptr %s_magic to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %s_magic, align 4
  %4 = ptrtoint ptr %buf to i32
  call void @__asan_store4_noabort(i32 %4)
  store i32 %3, ptr %buf, align 8
  %f_bsize = getelementptr inbounds %struct.kstatfs, ptr %buf, i32 0, i32 1
  %5 = ptrtoint ptr %f_bsize to i32
  call void @__asan_store4_noabort(i32 %5)
  store i32 4096, ptr %f_bsize, align 4
  %f_namelen = getelementptr inbounds %struct.kstatfs, ptr %buf, i32 0, i32 8
  %6 = ptrtoint ptr %f_namelen to i32
  call void @__asan_store4_noabort(i32 %6)
  store i32 255, ptr %f_namelen, align 8
  ret i32 0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync)
define dso_local i32 @always_delete_dentry(ptr nocapture readnone %dentry) #4 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  ret i32 1
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @simple_lookup(ptr nocapture readnone %dir, ptr noundef %dentry, i32 %flags) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %d_name = getelementptr inbounds %struct.dentry, ptr %dentry, i32 0, i32 4
  %0 = ptrtoint ptr %d_name to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %d_name, align 8
  call void @__sanitizer_cov_trace_const_cmp4(i32 255, i32 %1)
  %cmp = icmp ugt i32 %1, 255
  br i1 %cmp, label %entry.return_crit_edge, label %if.end

entry.return_crit_edge:                           ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %return

if.end:                                           ; preds = %entry
  %d_sb = getelementptr inbounds %struct.dentry, ptr %dentry, i32 0, i32 9
  %2 = ptrtoint ptr %d_sb to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %d_sb, align 4
  %s_d_op = getelementptr inbounds %struct.super_block, ptr %3, i32 0, i32 45
  %4 = ptrtoint ptr %s_d_op to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %s_d_op, align 8
  %tobool.not = icmp eq ptr %5, null
  br i1 %tobool.not, label %if.then1, label %if.end.if.end2_crit_edge

if.end.if.end2_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end2

if.then1:                                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  tail call void @d_set_d_op(ptr noundef %dentry, ptr noundef nonnull @simple_dentry_operations) #16
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %if.end.if.end2_crit_edge
  tail call void @d_add(ptr noundef %dentry, ptr noundef null) #16
  br label %return

return:                                           ; preds = %if.end2, %entry.return_crit_edge
  %retval.0 = phi ptr [ null, %if.end2 ], [ inttoptr (i32 -36 to ptr), %entry.return_crit_edge ]
  ret ptr %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @d_set_d_op(ptr noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @d_add(ptr noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @dcache_dir_open(ptr nocapture readnone %inode, ptr nocapture noundef %file) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %dentry = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 1, i32 1
  %0 = ptrtoint ptr %dentry to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %dentry, align 4
  %call = tail call ptr @d_alloc_cursor(ptr noundef %1) #16
  %private_data = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 16
  %2 = ptrtoint ptr %private_data to i32
  call void @__asan_store4_noabort(i32 %2)
  store ptr %call, ptr %private_data, align 4
  %tobool.not = icmp eq ptr %call, null
  %cond = select i1 %tobool.not, i32 -12, i32 0
  ret i32 %cond
}

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @d_alloc_cursor(ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @dcache_dir_close(ptr nocapture readnone %inode, ptr nocapture noundef readonly %file) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %private_data = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 16
  %0 = ptrtoint ptr %private_data to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private_data, align 4
  tail call void @dput(ptr noundef %1) #16
  ret i32 0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @dput(ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i64 @dcache_dir_lseek(ptr nocapture noundef %file, i64 noundef %offset, i32 noundef %whence) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %dentry1 = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 1, i32 1
  %0 = ptrtoint ptr %dentry1 to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %dentry1, align 4
  %2 = zext i32 %whence to i64
  call void @__sanitizer_cov_trace_switch(i64 %2, ptr @__sancov_gen_cov_switch_values)
  switch i32 %whence, label %entry.cleanup_crit_edge [
    i32 1, label %sw.bb
    i32 0, label %entry.sw.bb2_crit_edge
  ]

entry.sw.bb2_crit_edge:                           ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %sw.bb2

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

sw.bb:                                            ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  %f_pos = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 10
  %3 = ptrtoint ptr %f_pos to i32
  call void @__asan_load8_noabort(i32 %3)
  %4 = load i64, ptr %f_pos, align 8
  %add = add i64 %4, %offset
  br label %sw.bb2

sw.bb2:                                           ; preds = %sw.bb, %entry.sw.bb2_crit_edge
  %offset.addr.0 = phi i64 [ %offset, %entry.sw.bb2_crit_edge ], [ %add, %sw.bb ]
  call void @__sanitizer_cov_trace_const_cmp8(i64 -1, i64 %offset.addr.0)
  %cmp = icmp sgt i64 %offset.addr.0, -1
  br i1 %cmp, label %sw.epilog, label %sw.bb2.cleanup_crit_edge

sw.bb2.cleanup_crit_edge:                         ; preds = %sw.bb2
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

sw.epilog:                                        ; preds = %sw.bb2
  %f_pos3 = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 10
  %5 = ptrtoint ptr %f_pos3 to i32
  call void @__asan_load8_noabort(i32 %5)
  %6 = load i64, ptr %f_pos3, align 8
  call void @__sanitizer_cov_trace_cmp8(i64 %offset.addr.0, i64 %6)
  %cmp4.not = icmp eq i64 %offset.addr.0, %6
  br i1 %cmp4.not, label %sw.epilog.cleanup_crit_edge, label %if.then5

sw.epilog.cleanup_crit_edge:                      ; preds = %sw.epilog
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.then5:                                         ; preds = %sw.epilog
  %private_data = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 16
  %7 = ptrtoint ptr %private_data to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %private_data, align 4
  %d_inode = getelementptr inbounds %struct.dentry, ptr %1, i32 0, i32 5
  %9 = ptrtoint ptr %d_inode to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %d_inode, align 8
  %i_rwsem.i = getelementptr inbounds %struct.inode, ptr %10, i32 0, i32 25
  tail call void @down_read(ptr noundef %i_rwsem.i) #16
  call void @__sanitizer_cov_trace_const_cmp8(i64 2, i64 %offset.addr.0)
  %cmp6 = icmp ugt i64 %offset.addr.0, 2
  br i1 %cmp6, label %if.end8, label %if.end8.thread

if.end8.thread:                                   ; preds = %if.then5
  call void @__sanitizer_cov_trace_pc() #18
  %d_lockref43 = getelementptr inbounds %struct.dentry, ptr %1, i32 0, i32 7
  tail call void @_raw_spin_lock(ptr noundef %d_lockref43) #16
  br label %if.else

if.end8:                                          ; preds = %if.then5
  %d_subdirs = getelementptr inbounds %struct.dentry, ptr %1, i32 0, i32 14
  %sub = add nsw i64 %offset.addr.0, -2
  %call = tail call fastcc ptr @scan_positives(ptr noundef %8, ptr noundef %d_subdirs, i64 noundef %sub, ptr noundef null)
  %d_lockref = getelementptr inbounds %struct.dentry, ptr %1, i32 0, i32 7
  tail call void @_raw_spin_lock(ptr noundef %d_lockref) #16
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %if.end8.if.else_crit_edge, label %if.then9

if.end8.if.else_crit_edge:                        ; preds = %if.end8
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.else

if.then9:                                         ; preds = %if.end8
  %d_child = getelementptr inbounds %struct.dentry, ptr %8, i32 0, i32 13
  %d_child10 = getelementptr inbounds %struct.dentry, ptr %call, i32 0, i32 13
  %call.i.i = tail call zeroext i1 @__list_del_entry_valid(ptr noundef %d_child) #16
  br i1 %call.i.i, label %if.end.i.i, label %if.then9.__list_del_entry.exit.i_crit_edge

if.then9.__list_del_entry.exit.i_crit_edge:       ; preds = %if.then9
  call void @__sanitizer_cov_trace_pc() #18
  br label %__list_del_entry.exit.i

if.end.i.i:                                       ; preds = %if.then9
  call void @__sanitizer_cov_trace_pc() #18
  %prev.i.i = getelementptr inbounds %struct.dentry, ptr %8, i32 0, i32 13, i32 1
  %11 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %prev.i.i, align 4
  %13 = ptrtoint ptr %d_child to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %d_child, align 4
  %prev1.i.i.i = getelementptr inbounds %struct.list_head, ptr %14, i32 0, i32 1
  %15 = ptrtoint ptr %prev1.i.i.i to i32
  call void @__asan_store4_noabort(i32 %15)
  store ptr %12, ptr %prev1.i.i.i, align 4
  %16 = ptrtoint ptr %12 to i32
  call void @__asan_store4_noabort(i32 %16)
  store volatile ptr %14, ptr %12, align 4
  br label %__list_del_entry.exit.i

__list_del_entry.exit.i:                          ; preds = %if.end.i.i, %if.then9.__list_del_entry.exit.i_crit_edge
  %17 = ptrtoint ptr %d_child10 to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %d_child10, align 4
  %call.i.i.i = tail call zeroext i1 @__list_add_valid(ptr noundef %d_child, ptr noundef %d_child10, ptr noundef %18) #16
  br i1 %call.i.i.i, label %if.end.i.i.i, label %__list_del_entry.exit.i.if.end12_crit_edge

__list_del_entry.exit.i.if.end12_crit_edge:       ; preds = %__list_del_entry.exit.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end12

if.end.i.i.i:                                     ; preds = %__list_del_entry.exit.i
  call void @__sanitizer_cov_trace_pc() #18
  %prev1.i.i2.i = getelementptr inbounds %struct.list_head, ptr %18, i32 0, i32 1
  %19 = ptrtoint ptr %prev1.i.i2.i to i32
  call void @__asan_store4_noabort(i32 %19)
  store ptr %d_child, ptr %prev1.i.i2.i, align 4
  %20 = ptrtoint ptr %d_child to i32
  call void @__asan_store4_noabort(i32 %20)
  store ptr %18, ptr %d_child, align 4
  %prev3.i.i.i = getelementptr inbounds %struct.dentry, ptr %8, i32 0, i32 13, i32 1
  %21 = ptrtoint ptr %prev3.i.i.i to i32
  call void @__asan_store4_noabort(i32 %21)
  store ptr %d_child10, ptr %prev3.i.i.i, align 4
  %22 = ptrtoint ptr %d_child10 to i32
  call void @__asan_store4_noabort(i32 %22)
  store volatile ptr %d_child, ptr %d_child10, align 4
  br label %if.end12

if.else:                                          ; preds = %if.end8.if.else_crit_edge, %if.end8.thread
  %d_lockref48 = phi ptr [ %d_lockref43, %if.end8.thread ], [ %d_lockref, %if.end8.if.else_crit_edge ]
  %d_child11 = getelementptr inbounds %struct.dentry, ptr %8, i32 0, i32 13
  %call.i.i36 = tail call zeroext i1 @__list_del_entry_valid(ptr noundef %d_child11) #16
  br i1 %call.i.i36, label %if.end.i.i39, label %if.else.list_del_init.exit_crit_edge

if.else.list_del_init.exit_crit_edge:             ; preds = %if.else
  call void @__sanitizer_cov_trace_pc() #18
  br label %list_del_init.exit

if.end.i.i39:                                     ; preds = %if.else
  call void @__sanitizer_cov_trace_pc() #18
  %prev.i.i37 = getelementptr inbounds %struct.dentry, ptr %8, i32 0, i32 13, i32 1
  %23 = ptrtoint ptr %prev.i.i37 to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %prev.i.i37, align 4
  %25 = ptrtoint ptr %d_child11 to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load ptr, ptr %d_child11, align 4
  %prev1.i.i.i38 = getelementptr inbounds %struct.list_head, ptr %26, i32 0, i32 1
  %27 = ptrtoint ptr %prev1.i.i.i38 to i32
  call void @__asan_store4_noabort(i32 %27)
  store ptr %24, ptr %prev1.i.i.i38, align 4
  %28 = ptrtoint ptr %24 to i32
  call void @__asan_store4_noabort(i32 %28)
  store volatile ptr %26, ptr %24, align 4
  br label %list_del_init.exit

list_del_init.exit:                               ; preds = %if.end.i.i39, %if.else.list_del_init.exit_crit_edge
  %29 = ptrtoint ptr %d_child11 to i32
  call void @__asan_store4_noabort(i32 %29)
  store volatile ptr %d_child11, ptr %d_child11, align 4
  %prev.i3.i = getelementptr inbounds %struct.dentry, ptr %8, i32 0, i32 13, i32 1
  %30 = ptrtoint ptr %prev.i3.i to i32
  call void @__asan_store4_noabort(i32 %30)
  store ptr %d_child11, ptr %prev.i3.i, align 4
  br label %if.end12

if.end12:                                         ; preds = %list_del_init.exit, %if.end.i.i.i, %__list_del_entry.exit.i.if.end12_crit_edge
  %d_lockref47 = phi ptr [ %d_lockref48, %list_del_init.exit ], [ %d_lockref, %__list_del_entry.exit.i.if.end12_crit_edge ], [ %d_lockref, %if.end.i.i.i ]
  %to.045 = phi ptr [ null, %list_del_init.exit ], [ %call, %__list_del_entry.exit.i.if.end12_crit_edge ], [ %call, %if.end.i.i.i ]
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref47) #16
  tail call void @dput(ptr noundef %to.045) #16
  %31 = ptrtoint ptr %f_pos3 to i32
  call void @__asan_store8_noabort(i32 %31)
  store i64 %offset.addr.0, ptr %f_pos3, align 8
  %32 = ptrtoint ptr %d_inode to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load ptr, ptr %d_inode, align 8
  %i_rwsem.i41 = getelementptr inbounds %struct.inode, ptr %33, i32 0, i32 25
  tail call void @up_read(ptr noundef %i_rwsem.i41) #16
  br label %cleanup

cleanup:                                          ; preds = %if.end12, %sw.epilog.cleanup_crit_edge, %sw.bb2.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i64 [ -22, %sw.bb2.cleanup_crit_edge ], [ -22, %entry.cleanup_crit_edge ], [ %offset.addr.0, %if.end12 ], [ %offset.addr.0, %sw.epilog.cleanup_crit_edge ]
  ret i64 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc ptr @scan_positives(ptr noundef %cursor, ptr nocapture noundef readonly %p, i64 noundef %count, ptr noundef %last) unnamed_addr #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %d_parent = getelementptr inbounds %struct.dentry, ptr %cursor, i32 0, i32 3
  %0 = ptrtoint ptr %d_parent to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %d_parent, align 8
  %d_lockref = getelementptr inbounds %struct.dentry, ptr %1, i32 0, i32 7
  tail call void @_raw_spin_lock(ptr noundef %d_lockref) #16
  %d_subdirs = getelementptr inbounds %struct.dentry, ptr %1, i32 0, i32 14
  %2 = ptrtoint ptr %p to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %p, align 4
  %cmp.not69 = icmp eq ptr %3, %d_subdirs
  br i1 %cmp.not69, label %entry.while.end_crit_edge, label %while.body.lr.ph

entry.while.end_crit_edge:                        ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %while.end

while.body.lr.ph:                                 ; preds = %entry
  %d_child = getelementptr inbounds %struct.dentry, ptr %cursor, i32 0, i32 13
  %prev.i.i = getelementptr inbounds %struct.dentry, ptr %cursor, i32 0, i32 13, i32 1
  br label %while.body

while.body:                                       ; preds = %cleanup.while.body_crit_edge, %while.body.lr.ph
  %4 = phi ptr [ %3, %while.body.lr.ph ], [ %35, %cleanup.while.body_crit_edge ]
  %count.addr.070 = phi i64 [ %count, %while.body.lr.ph ], [ %count.addr.2, %cleanup.while.body_crit_edge ]
  %add.ptr = getelementptr i8, ptr %4, i32 -184
  %5 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %add.ptr, align 8
  %and = and i32 %6, 536870912
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and)
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %while.body.cleanup_crit_edge

while.body.cleanup_crit_edge:                     ; preds = %while.body
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %while.body
  %d_inode.i.i = getelementptr i8, ptr %4, i32 -112
  %7 = ptrtoint ptr %d_inode.i.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %d_inode.i.i, align 8
  %cmp.i.not.i = icmp eq ptr %8, null
  br i1 %cmp.i.not.i, label %if.end.if.end19_crit_edge, label %simple_positive.exit

if.end.if.end19_crit_edge:                        ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end19

simple_positive.exit:                             ; preds = %if.end
  %pprev.i.i.i = getelementptr i8, ptr %4, i32 -140
  %9 = ptrtoint ptr %pprev.i.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %pprev.i.i.i, align 4
  %tobool.not.i.i.i.not = icmp eq ptr %10, null
  br i1 %tobool.not.i.i.i.not, label %simple_positive.exit.if.end19_crit_edge, label %land.lhs.true

simple_positive.exit.if.end19_crit_edge:          ; preds = %simple_positive.exit
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end19

land.lhs.true:                                    ; preds = %simple_positive.exit
  %dec = add i64 %count.addr.070, -1
  call void @__sanitizer_cov_trace_const_cmp8(i64 0, i64 %dec)
  %tobool2.not = icmp eq i64 %dec, 0
  br i1 %tobool2.not, label %do.body, label %land.lhs.true.if.end19_crit_edge

land.lhs.true.if.end19_crit_edge:                 ; preds = %land.lhs.true
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end19

do.body:                                          ; preds = %land.lhs.true
  %d_lockref4 = getelementptr i8, ptr %4, i32 -72
  tail call void @_raw_spin_lock_nested(ptr noundef %d_lockref4, i32 noundef 1) #16
  %11 = ptrtoint ptr %d_inode.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %d_inode.i.i, align 8
  %cmp.i.not.i49 = icmp eq ptr %12, null
  br i1 %cmp.i.not.i49, label %do.body.if.end19.sink.split_crit_edge, label %simple_positive.exit54

do.body.if.end19.sink.split_crit_edge:            ; preds = %do.body
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end19.sink.split

simple_positive.exit54:                           ; preds = %do.body
  %13 = ptrtoint ptr %pprev.i.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %pprev.i.i.i, align 4
  %tobool.not.i.i.i51.not = icmp eq ptr %14, null
  %tobool.not.i = icmp eq ptr %add.ptr, null
  %or.cond = or i1 %tobool.not.i.i.i51.not, %tobool.not.i
  br i1 %or.cond, label %simple_positive.exit54.if.end19.sink.split_crit_edge, label %if.end11.thread59

simple_positive.exit54.if.end19.sink.split_crit_edge: ; preds = %simple_positive.exit54
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end19.sink.split

if.end11.thread59:                                ; preds = %simple_positive.exit54
  call void @__sanitizer_cov_trace_pc() #18
  %count.i = getelementptr i8, ptr %4, i32 -28
  %15 = ptrtoint ptr %count.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %count.i, align 4
  %inc.i = add i32 %16, 1
  store i32 %inc.i, ptr %count.i, align 4
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref4) #16
  br label %while.end

if.end19.sink.split:                              ; preds = %simple_positive.exit54.if.end19.sink.split_crit_edge, %do.body.if.end19.sink.split_crit_edge
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref4) #16
  br label %if.end19

if.end19:                                         ; preds = %if.end19.sink.split, %land.lhs.true.if.end19_crit_edge, %simple_positive.exit.if.end19_crit_edge, %if.end.if.end19_crit_edge
  %count.addr.1 = phi i64 [ %dec, %land.lhs.true.if.end19_crit_edge ], [ %count.addr.070, %simple_positive.exit.if.end19_crit_edge ], [ %count.addr.070, %if.end.if.end19_crit_edge ], [ 1, %if.end19.sink.split ]
  %17 = tail call i32 @llvm.read_register.i32(metadata !174) #16
  %and.i.i = and i32 %17, -16384
  %18 = inttoptr i32 %and.i.i to ptr
  %19 = ptrtoint ptr %18 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load volatile i32, ptr %18, align 16384
  %21 = and i32 %20, 2
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %21)
  %tobool.i.not = icmp eq i32 %21, 0
  br i1 %tobool.i.not, label %if.end19.cleanup_crit_edge, label %if.then21

if.end19.cleanup_crit_edge:                       ; preds = %if.end19
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.then21:                                        ; preds = %if.end19
  %call.i.i = tail call zeroext i1 @__list_del_entry_valid(ptr noundef %d_child) #16
  br i1 %call.i.i, label %if.end.i.i, label %if.then21.__list_del_entry.exit.i_crit_edge

if.then21.__list_del_entry.exit.i_crit_edge:      ; preds = %if.then21
  call void @__sanitizer_cov_trace_pc() #18
  br label %__list_del_entry.exit.i

if.end.i.i:                                       ; preds = %if.then21
  call void @__sanitizer_cov_trace_pc() #18
  %22 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %prev.i.i, align 4
  %24 = ptrtoint ptr %d_child to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %d_child, align 4
  %prev1.i.i.i = getelementptr inbounds %struct.list_head, ptr %25, i32 0, i32 1
  %26 = ptrtoint ptr %prev1.i.i.i to i32
  call void @__asan_store4_noabort(i32 %26)
  store ptr %23, ptr %prev1.i.i.i, align 4
  %27 = ptrtoint ptr %23 to i32
  call void @__asan_store4_noabort(i32 %27)
  store volatile ptr %25, ptr %23, align 4
  br label %__list_del_entry.exit.i

__list_del_entry.exit.i:                          ; preds = %if.end.i.i, %if.then21.__list_del_entry.exit.i_crit_edge
  %28 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load ptr, ptr %4, align 4
  %call.i.i.i = tail call zeroext i1 @__list_add_valid(ptr noundef %d_child, ptr noundef %4, ptr noundef %29) #16
  br i1 %call.i.i.i, label %if.end.i.i.i, label %__list_del_entry.exit.i.list_move.exit_crit_edge

__list_del_entry.exit.i.list_move.exit_crit_edge: ; preds = %__list_del_entry.exit.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %list_move.exit

if.end.i.i.i:                                     ; preds = %__list_del_entry.exit.i
  call void @__sanitizer_cov_trace_pc() #18
  %prev1.i.i2.i = getelementptr inbounds %struct.list_head, ptr %29, i32 0, i32 1
  %30 = ptrtoint ptr %prev1.i.i2.i to i32
  call void @__asan_store4_noabort(i32 %30)
  store ptr %d_child, ptr %prev1.i.i2.i, align 4
  %31 = ptrtoint ptr %d_child to i32
  call void @__asan_store4_noabort(i32 %31)
  store ptr %29, ptr %d_child, align 4
  %32 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_store4_noabort(i32 %32)
  store ptr %4, ptr %prev.i.i, align 4
  %33 = ptrtoint ptr %4 to i32
  call void @__asan_store4_noabort(i32 %33)
  store volatile ptr %d_child, ptr %4, align 4
  br label %list_move.exit

list_move.exit:                                   ; preds = %if.end.i.i.i, %__list_del_entry.exit.i.list_move.exit_crit_edge
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref) #16
  tail call void @__might_resched(ptr noundef nonnull @.str.2, i32 noundef 128, i32 noundef 0) #16
  %call.i = tail call i32 @__cond_resched() #16
  tail call void @_raw_spin_lock(ptr noundef %d_lockref) #16
  br label %cleanup

cleanup:                                          ; preds = %list_move.exit, %if.end19.cleanup_crit_edge, %while.body.cleanup_crit_edge
  %count.addr.2 = phi i64 [ %count.addr.070, %while.body.cleanup_crit_edge ], [ %count.addr.1, %list_move.exit ], [ %count.addr.1, %if.end19.cleanup_crit_edge ]
  %p.addr.2 = phi ptr [ %4, %while.body.cleanup_crit_edge ], [ %d_child, %list_move.exit ], [ %4, %if.end19.cleanup_crit_edge ]
  %34 = ptrtoint ptr %p.addr.2 to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load ptr, ptr %p.addr.2, align 4
  %cmp.not = icmp eq ptr %35, %d_subdirs
  br i1 %cmp.not, label %cleanup.while.end_crit_edge, label %cleanup.while.body_crit_edge

cleanup.while.body_crit_edge:                     ; preds = %cleanup
  call void @__sanitizer_cov_trace_pc() #18
  br label %while.body

cleanup.while.end_crit_edge:                      ; preds = %cleanup
  call void @__sanitizer_cov_trace_pc() #18
  br label %while.end

while.end:                                        ; preds = %cleanup.while.end_crit_edge, %if.end11.thread59, %entry.while.end_crit_edge
  %found.4 = phi ptr [ %add.ptr, %if.end11.thread59 ], [ null, %entry.while.end_crit_edge ], [ null, %cleanup.while.end_crit_edge ]
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref) #16
  tail call void @dput(ptr noundef %last) #16
  ret ptr %found.4
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @dcache_readdir(ptr nocapture noundef readonly %file, ptr noundef %ctx) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %dentry1 = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 1, i32 1
  %0 = ptrtoint ptr %dentry1 to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %dentry1, align 4
  %private_data = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 16
  %2 = ptrtoint ptr %private_data to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %private_data, align 4
  %d_subdirs = getelementptr inbounds %struct.dentry, ptr %1, i32 0, i32 14
  %pos.i = getelementptr inbounds %struct.dir_context, ptr %ctx, i32 0, i32 1
  %4 = ptrtoint ptr %pos.i to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %pos.i, align 8
  call void @__sanitizer_cov_trace_switch(i64 %5, ptr @__sancov_gen_cov_switch_values.17)
  switch i64 %5, label %if.else [
    i64 0, label %if.then.i
    i64 1, label %entry.if.then6.i_crit_edge
    i64 2, label %entry.if.end8_crit_edge
  ]

entry.if.end8_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end8

entry.if.then6.i_crit_edge:                       ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.then6.i

if.then.i:                                        ; preds = %entry
  %6 = ptrtoint ptr %ctx to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %ctx, align 8
  %d_inode.i.i = getelementptr inbounds %struct.dentry, ptr %1, i32 0, i32 5
  %8 = ptrtoint ptr %d_inode.i.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %d_inode.i.i, align 8
  %i_ino.i.i = getelementptr inbounds %struct.inode, ptr %9, i32 0, i32 11
  %10 = ptrtoint ptr %i_ino.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %i_ino.i.i, align 8
  %conv.i.i = zext i32 %11 to i64
  %call.i.i = tail call i32 %7(ptr noundef %ctx, ptr noundef nonnull @.str.6, i32 noundef 1, i64 noundef 0, i64 noundef %conv.i.i, i32 noundef 4) #16
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call.i.i)
  %cmp.i.i = icmp eq i32 %call.i.i, 0
  br i1 %cmp.i.i, label %if.end3.thread.i, label %if.then.i.cleanup_crit_edge

if.then.i.cleanup_crit_edge:                      ; preds = %if.then.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end3.thread.i:                                 ; preds = %if.then.i
  call void @__sanitizer_cov_trace_pc() #18
  %12 = ptrtoint ptr %pos.i to i32
  call void @__asan_store8_noabort(i32 %12)
  store i64 1, ptr %pos.i, align 8
  br label %if.then6.i

if.then6.i:                                       ; preds = %if.end3.thread.i, %entry.if.then6.i_crit_edge
  %13 = ptrtoint ptr %ctx to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %ctx, align 8
  %15 = ptrtoint ptr %dentry1 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %dentry1, align 4
  %d_lockref.i.i.i = getelementptr inbounds %struct.dentry, ptr %16, i32 0, i32 7
  tail call void @_raw_spin_lock(ptr noundef %d_lockref.i.i.i) #16
  %d_parent.i.i.i = getelementptr inbounds %struct.dentry, ptr %16, i32 0, i32 3
  %17 = ptrtoint ptr %d_parent.i.i.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %d_parent.i.i.i, align 8
  %d_inode.i.i.i = getelementptr inbounds %struct.dentry, ptr %18, i32 0, i32 5
  %19 = ptrtoint ptr %d_inode.i.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %d_inode.i.i.i, align 8
  %i_ino.i.i.i = getelementptr inbounds %struct.inode, ptr %20, i32 0, i32 11
  %21 = ptrtoint ptr %i_ino.i.i.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load i32, ptr %i_ino.i.i.i, align 8
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref.i.i.i) #16
  %conv.i20.i = zext i32 %22 to i64
  %call1.i.i = tail call i32 %14(ptr noundef %ctx, ptr noundef nonnull @.str.7, i32 noundef 2, i64 noundef 1, i64 noundef %conv.i20.i, i32 noundef 4) #16
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call1.i.i)
  %cmp.i21.i = icmp eq i32 %call1.i.i, 0
  br i1 %cmp.i21.i, label %if.end.thread, label %if.then6.i.cleanup_crit_edge

if.then6.i.cleanup_crit_edge:                     ; preds = %if.then6.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end.thread:                                    ; preds = %if.then6.i
  call void @__sanitizer_cov_trace_pc() #18
  %23 = ptrtoint ptr %pos.i to i32
  call void @__asan_store8_noabort(i32 %23)
  store i64 2, ptr %pos.i, align 8
  br label %if.end8

if.else:                                          ; preds = %entry
  %d_child = getelementptr inbounds %struct.dentry, ptr %3, i32 0, i32 13
  %24 = ptrtoint ptr %d_child to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load volatile ptr, ptr %d_child, align 4
  %cmp.i.not = icmp eq ptr %25, %d_child
  br i1 %cmp.i.not, label %if.else.cleanup_crit_edge, label %if.else.if.end8_crit_edge

if.else.if.end8_crit_edge:                        ; preds = %if.else
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end8

if.else.cleanup_crit_edge:                        ; preds = %if.else
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end8:                                          ; preds = %if.else.if.end8_crit_edge, %if.end.thread, %entry.if.end8_crit_edge
  %p.0 = phi ptr [ %d_child, %if.else.if.end8_crit_edge ], [ %d_subdirs, %if.end.thread ], [ %d_subdirs, %entry.if.end8_crit_edge ]
  %call969 = tail call fastcc ptr @scan_positives(ptr noundef %3, ptr noundef %p.0, i64 noundef 1, ptr noundef null)
  %cmp10.not70 = icmp eq ptr %call969, null
  br i1 %cmp10.not70, label %if.end8.if.else25_crit_edge, label %if.end8.while.body_crit_edge

if.end8.while.body_crit_edge:                     ; preds = %if.end8
  br label %while.body

if.end8.if.else25_crit_edge:                      ; preds = %if.end8
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.else25

while.body:                                       ; preds = %if.end18.while.body_crit_edge, %if.end8.while.body_crit_edge
  %call971 = phi ptr [ %call9, %if.end18.while.body_crit_edge ], [ %call969, %if.end8.while.body_crit_edge ]
  %d_name = getelementptr inbounds %struct.dentry, ptr %call971, i32 0, i32 4
  %name = getelementptr inbounds %struct.dentry, ptr %call971, i32 0, i32 4, i32 1
  %26 = ptrtoint ptr %name to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load ptr, ptr %name, align 8
  %28 = ptrtoint ptr %d_name to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %d_name, align 8
  %d_inode.i = getelementptr inbounds %struct.dentry, ptr %call971, i32 0, i32 5
  %30 = ptrtoint ptr %d_inode.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %d_inode.i, align 8
  %i_ino = getelementptr inbounds %struct.inode, ptr %31, i32 0, i32 11
  %32 = ptrtoint ptr %i_ino to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %i_ino, align 8
  %conv = zext i32 %33 to i64
  %34 = ptrtoint ptr %31 to i32
  call void @__asan_load2_noabort(i32 %34)
  %35 = load i16, ptr %31, align 8
  %36 = lshr i16 %35, 12
  %conv1.i = zext i16 %36 to i32
  %37 = ptrtoint ptr %ctx to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load ptr, ptr %ctx, align 8
  %39 = ptrtoint ptr %pos.i to i32
  call void @__asan_load8_noabort(i32 %39)
  %40 = load i64, ptr %pos.i, align 8
  %call.i = tail call i32 %38(ptr noundef %ctx, ptr noundef %27, i32 noundef %29, i64 noundef %40, i64 noundef %conv, i32 noundef %conv1.i) #16
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call.i)
  %cmp.i55 = icmp eq i32 %call.i, 0
  br i1 %cmp.i55, label %if.end18, label %if.then22

if.end18:                                         ; preds = %while.body
  %41 = ptrtoint ptr %pos.i to i32
  call void @__asan_load8_noabort(i32 %41)
  %42 = load i64, ptr %pos.i, align 8
  %inc = add i64 %42, 1
  store i64 %inc, ptr %pos.i, align 8
  %d_child20 = getelementptr inbounds %struct.dentry, ptr %call971, i32 0, i32 13
  %call9 = tail call fastcc ptr @scan_positives(ptr noundef %3, ptr noundef %d_child20, i64 noundef 1, ptr noundef nonnull %call971)
  %cmp10.not = icmp eq ptr %call9, null
  br i1 %cmp10.not, label %if.end18.if.else25_crit_edge, label %if.end18.while.body_crit_edge

if.end18.while.body_crit_edge:                    ; preds = %if.end18
  call void @__sanitizer_cov_trace_pc() #18
  br label %while.body

if.end18.if.else25_crit_edge:                     ; preds = %if.end18
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.else25

if.then22:                                        ; preds = %while.body
  %d_lockref = getelementptr inbounds %struct.dentry, ptr %1, i32 0, i32 7
  tail call void @_raw_spin_lock(ptr noundef %d_lockref) #16
  %d_child23 = getelementptr inbounds %struct.dentry, ptr %3, i32 0, i32 13
  %d_child24 = getelementptr inbounds %struct.dentry, ptr %call971, i32 0, i32 13
  %call.i.i56 = tail call zeroext i1 @__list_del_entry_valid(ptr noundef %d_child23) #16
  br i1 %call.i.i56, label %if.end.i.i, label %if.then22.__list_del_entry.exit.i_crit_edge

if.then22.__list_del_entry.exit.i_crit_edge:      ; preds = %if.then22
  call void @__sanitizer_cov_trace_pc() #18
  br label %__list_del_entry.exit.i

if.end.i.i:                                       ; preds = %if.then22
  call void @__sanitizer_cov_trace_pc() #18
  %prev.i.i = getelementptr inbounds %struct.dentry, ptr %3, i32 0, i32 13, i32 1
  %43 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load ptr, ptr %prev.i.i, align 4
  %45 = ptrtoint ptr %d_child23 to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load ptr, ptr %d_child23, align 4
  %prev1.i.i.i = getelementptr inbounds %struct.list_head, ptr %46, i32 0, i32 1
  %47 = ptrtoint ptr %prev1.i.i.i to i32
  call void @__asan_store4_noabort(i32 %47)
  store ptr %44, ptr %prev1.i.i.i, align 4
  %48 = ptrtoint ptr %44 to i32
  call void @__asan_store4_noabort(i32 %48)
  store volatile ptr %46, ptr %44, align 4
  br label %__list_del_entry.exit.i

__list_del_entry.exit.i:                          ; preds = %if.end.i.i, %if.then22.__list_del_entry.exit.i_crit_edge
  %prev.i2.i = getelementptr inbounds %struct.dentry, ptr %call971, i32 0, i32 13, i32 1
  %49 = ptrtoint ptr %prev.i2.i to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load ptr, ptr %prev.i2.i, align 4
  %call.i.i.i = tail call zeroext i1 @__list_add_valid(ptr noundef %d_child23, ptr noundef %50, ptr noundef %d_child24) #16
  br i1 %call.i.i.i, label %if.end.i.i.i, label %__list_del_entry.exit.i.if.end27_crit_edge

__list_del_entry.exit.i.if.end27_crit_edge:       ; preds = %__list_del_entry.exit.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end27

if.end.i.i.i:                                     ; preds = %__list_del_entry.exit.i
  call void @__sanitizer_cov_trace_pc() #18
  %51 = ptrtoint ptr %prev.i2.i to i32
  call void @__asan_store4_noabort(i32 %51)
  store ptr %d_child23, ptr %prev.i2.i, align 4
  %52 = ptrtoint ptr %d_child23 to i32
  call void @__asan_store4_noabort(i32 %52)
  store ptr %d_child24, ptr %d_child23, align 4
  %prev3.i.i.i = getelementptr inbounds %struct.dentry, ptr %3, i32 0, i32 13, i32 1
  %53 = ptrtoint ptr %prev3.i.i.i to i32
  call void @__asan_store4_noabort(i32 %53)
  store ptr %50, ptr %prev3.i.i.i, align 4
  %54 = ptrtoint ptr %50 to i32
  call void @__asan_store4_noabort(i32 %54)
  store volatile ptr %d_child23, ptr %50, align 4
  br label %if.end27

if.else25:                                        ; preds = %if.end18.if.else25_crit_edge, %if.end8.if.else25_crit_edge
  %d_lockref64 = getelementptr inbounds %struct.dentry, ptr %1, i32 0, i32 7
  tail call void @_raw_spin_lock(ptr noundef %d_lockref64) #16
  %d_child26 = getelementptr inbounds %struct.dentry, ptr %3, i32 0, i32 13
  %call.i.i57 = tail call zeroext i1 @__list_del_entry_valid(ptr noundef %d_child26) #16
  br i1 %call.i.i57, label %if.end.i.i60, label %if.else25.list_del_init.exit_crit_edge

if.else25.list_del_init.exit_crit_edge:           ; preds = %if.else25
  call void @__sanitizer_cov_trace_pc() #18
  br label %list_del_init.exit

if.end.i.i60:                                     ; preds = %if.else25
  call void @__sanitizer_cov_trace_pc() #18
  %prev.i.i58 = getelementptr inbounds %struct.dentry, ptr %3, i32 0, i32 13, i32 1
  %55 = ptrtoint ptr %prev.i.i58 to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load ptr, ptr %prev.i.i58, align 4
  %57 = ptrtoint ptr %d_child26 to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load ptr, ptr %d_child26, align 4
  %prev1.i.i.i59 = getelementptr inbounds %struct.list_head, ptr %58, i32 0, i32 1
  %59 = ptrtoint ptr %prev1.i.i.i59 to i32
  call void @__asan_store4_noabort(i32 %59)
  store ptr %56, ptr %prev1.i.i.i59, align 4
  %60 = ptrtoint ptr %56 to i32
  call void @__asan_store4_noabort(i32 %60)
  store volatile ptr %58, ptr %56, align 4
  br label %list_del_init.exit

list_del_init.exit:                               ; preds = %if.end.i.i60, %if.else25.list_del_init.exit_crit_edge
  %61 = ptrtoint ptr %d_child26 to i32
  call void @__asan_store4_noabort(i32 %61)
  store volatile ptr %d_child26, ptr %d_child26, align 4
  %prev.i3.i = getelementptr inbounds %struct.dentry, ptr %3, i32 0, i32 13, i32 1
  %62 = ptrtoint ptr %prev.i3.i to i32
  call void @__asan_store4_noabort(i32 %62)
  store ptr %d_child26, ptr %prev.i3.i, align 4
  br label %if.end27

if.end27:                                         ; preds = %list_del_init.exit, %if.end.i.i.i, %__list_del_entry.exit.i.if.end27_crit_edge
  %call968 = phi ptr [ null, %list_del_init.exit ], [ %call971, %__list_del_entry.exit.i.if.end27_crit_edge ], [ %call971, %if.end.i.i.i ]
  %d_lockref65 = phi ptr [ %d_lockref64, %list_del_init.exit ], [ %d_lockref, %__list_del_entry.exit.i.if.end27_crit_edge ], [ %d_lockref, %if.end.i.i.i ]
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref65) #16
  tail call void @dput(ptr noundef %call968) #16
  br label %cleanup

cleanup:                                          ; preds = %if.end27, %if.else.cleanup_crit_edge, %if.then6.i.cleanup_crit_edge, %if.then.i.cleanup_crit_edge
  ret i32 0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync)
define dso_local i32 @generic_read_dir(ptr nocapture readnone %filp, ptr nocapture readnone %buf, i32 %siz, ptr nocapture readnone %ppos) #4 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  ret i32 -21
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync)
define dso_local i32 @noop_fsync(ptr nocapture readnone %file, i64 %start, i64 %end, i32 %datasync) #4 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @simple_recursive_removal(ptr noundef %dentry, ptr noundef readonly %callback) #0 align 64 {
entry:
  %tmp = alloca %struct.timespec64, align 8
  %tmp18 = alloca %struct.timespec64, align 8
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %tobool.not.i = icmp eq ptr %dentry, null
  br i1 %tobool.not.i, label %entry.dget.exit_crit_edge, label %if.then.i

entry.dget.exit_crit_edge:                        ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %dget.exit

if.then.i:                                        ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  %d_lockref.i = getelementptr inbounds %struct.dentry, ptr %dentry, i32 0, i32 7
  tail call void @lockref_get(ptr noundef %d_lockref.i) #16
  br label %dget.exit

dget.exit:                                        ; preds = %if.then.i, %entry.dget.exit_crit_edge
  %tobool11.not = icmp eq ptr %callback, null
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %dget.exit
  %this.0 = phi ptr [ %dentry, %dget.exit ], [ %child.4.i, %cleanup ]
  %d_inode = getelementptr inbounds %struct.dentry, ptr %this.0, i32 0, i32 5
  %0 = ptrtoint ptr %d_inode to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %d_inode, align 8
  %i_rwsem.i = getelementptr inbounds %struct.inode, ptr %1, i32 0, i32 25
  call void @down_write(ptr noundef %i_rwsem.i) #16
  %2 = ptrtoint ptr %this.0 to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %this.0, align 8
  %4 = and i32 %3, 6291456
  call void @__sanitizer_cov_trace_const_cmp4(i32 2097152, i32 %4)
  %5 = icmp eq i32 %4, 2097152
  br i1 %5, label %if.then, label %while.cond.while.cond2.preheader_crit_edge

while.cond.while.cond2.preheader_crit_edge:       ; preds = %while.cond
  call void @__sanitizer_cov_trace_pc() #18
  br label %while.cond2.preheader

if.then:                                          ; preds = %while.cond
  call void @__sanitizer_cov_trace_pc() #18
  %i_flags = getelementptr inbounds %struct.inode, ptr %1, i32 0, i32 4
  %6 = ptrtoint ptr %i_flags to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %i_flags, align 4
  %or = or i32 %7, 16
  store i32 %or, ptr %i_flags, align 4
  br label %while.cond2.preheader

while.cond2.preheader:                            ; preds = %if.then, %while.cond.while.cond2.preheader_crit_edge
  br label %while.cond2

while.cond2:                                      ; preds = %if.end14.while.cond2_crit_edge, %while.cond2.preheader
  %this.1 = phi ptr [ %25, %if.end14.while.cond2_crit_edge ], [ %this.0, %while.cond2.preheader ]
  %victim.0 = phi ptr [ %this.1, %if.end14.while.cond2_crit_edge ], [ null, %while.cond2.preheader ]
  %inode.0 = phi ptr [ %27, %if.end14.while.cond2_crit_edge ], [ %1, %while.cond2.preheader ]
  %tobool.not.i57 = icmp eq ptr %victim.0, null
  %d_child.i = getelementptr inbounds %struct.dentry, ptr %victim.0, i32 0, i32 13
  %d_subdirs.i = getelementptr inbounds %struct.dentry, ptr %this.1, i32 0, i32 14
  %cond.i = select i1 %tobool.not.i57, ptr %d_subdirs.i, ptr %d_child.i
  %d_lockref.i58 = getelementptr inbounds %struct.dentry, ptr %this.1, i32 0, i32 7
  call void @_raw_spin_lock(ptr noundef %d_lockref.i58) #16
  %8 = ptrtoint ptr %cond.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %cond.i, align 4
  %cmp.not51.i = icmp eq ptr %9, %d_subdirs.i
  br i1 %cmp.not51.i, label %while.cond2.find_next_child.exit_crit_edge, label %while.cond2.while.body.i_crit_edge

while.cond2.while.body.i_crit_edge:               ; preds = %while.cond2
  br label %while.body.i

while.cond2.find_next_child.exit_crit_edge:       ; preds = %while.cond2
  call void @__sanitizer_cov_trace_pc() #18
  br label %find_next_child.exit

while.body.i:                                     ; preds = %cleanup.i.while.body.i_crit_edge, %while.cond2.while.body.i_crit_edge
  %10 = phi ptr [ %22, %cleanup.i.while.body.i_crit_edge ], [ %9, %while.cond2.while.body.i_crit_edge ]
  %add.ptr.i = getelementptr i8, ptr %10, i32 -184
  %d_inode.i.i.i = getelementptr i8, ptr %10, i32 -112
  %11 = ptrtoint ptr %d_inode.i.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %d_inode.i.i.i, align 8
  %cmp.i.not.i.i = icmp eq ptr %12, null
  br i1 %cmp.i.not.i.i, label %while.body.i.cleanup.i_crit_edge, label %simple_positive.exit.i

while.body.i.cleanup.i_crit_edge:                 ; preds = %while.body.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup.i

simple_positive.exit.i:                           ; preds = %while.body.i
  %pprev.i.i.i.i = getelementptr i8, ptr %10, i32 -140
  %13 = ptrtoint ptr %pprev.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %pprev.i.i.i.i, align 4
  %tobool.not.i.i.i.not.i = icmp eq ptr %14, null
  br i1 %tobool.not.i.i.i.not.i, label %simple_positive.exit.i.cleanup.i_crit_edge, label %do.body.i

simple_positive.exit.i.cleanup.i_crit_edge:       ; preds = %simple_positive.exit.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup.i

do.body.i:                                        ; preds = %simple_positive.exit.i
  %d_lockref3.i = getelementptr i8, ptr %10, i32 -72
  call void @_raw_spin_lock_nested(ptr noundef %d_lockref3.i, i32 noundef 1) #16
  %15 = ptrtoint ptr %d_inode.i.i.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %d_inode.i.i.i, align 8
  %cmp.i.not.i34.i = icmp eq ptr %16, null
  br i1 %cmp.i.not.i34.i, label %do.body.i.cleanup.sink.split.i_crit_edge, label %simple_positive.exit39.i

do.body.i.cleanup.sink.split.i_crit_edge:         ; preds = %do.body.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup.sink.split.i

simple_positive.exit39.i:                         ; preds = %do.body.i
  %17 = ptrtoint ptr %pprev.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %pprev.i.i.i.i, align 4
  %tobool.not.i.i.i36.not.i = icmp eq ptr %18, null
  %tobool.not.i.i = icmp eq ptr %add.ptr.i, null
  %or.cond.i = select i1 %tobool.not.i.i.i36.not.i, i1 true, i1 %tobool.not.i.i
  br i1 %or.cond.i, label %simple_positive.exit39.i.cleanup.sink.split.i_crit_edge, label %if.end.thread44.i

simple_positive.exit39.i.cleanup.sink.split.i_crit_edge: ; preds = %simple_positive.exit39.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup.sink.split.i

if.end.thread44.i:                                ; preds = %simple_positive.exit39.i
  call void @__sanitizer_cov_trace_pc() #18
  %count.i.i = getelementptr i8, ptr %10, i32 -28
  %19 = ptrtoint ptr %count.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %count.i.i, align 4
  %inc.i.i = add i32 %20, 1
  store i32 %inc.i.i, ptr %count.i.i, align 4
  call void @_raw_spin_unlock(ptr noundef %d_lockref3.i) #16
  br label %find_next_child.exit

cleanup.sink.split.i:                             ; preds = %simple_positive.exit39.i.cleanup.sink.split.i_crit_edge, %do.body.i.cleanup.sink.split.i_crit_edge
  call void @_raw_spin_unlock(ptr noundef %d_lockref3.i) #16
  br label %cleanup.i

cleanup.i:                                        ; preds = %cleanup.sink.split.i, %simple_positive.exit.i.cleanup.i_crit_edge, %while.body.i.cleanup.i_crit_edge
  %21 = ptrtoint ptr %10 to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %10, align 4
  %cmp.not.i = icmp eq ptr %22, %d_subdirs.i
  br i1 %cmp.not.i, label %cleanup.i.find_next_child.exit_crit_edge, label %cleanup.i.while.body.i_crit_edge

cleanup.i.while.body.i_crit_edge:                 ; preds = %cleanup.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %while.body.i

cleanup.i.find_next_child.exit_crit_edge:         ; preds = %cleanup.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %find_next_child.exit

find_next_child.exit:                             ; preds = %cleanup.i.find_next_child.exit_crit_edge, %if.end.thread44.i, %while.cond2.find_next_child.exit_crit_edge
  %child.4.i = phi ptr [ %add.ptr.i, %if.end.thread44.i ], [ null, %while.cond2.find_next_child.exit_crit_edge ], [ null, %cleanup.i.find_next_child.exit_crit_edge ]
  call void @_raw_spin_unlock(ptr noundef %d_lockref.i58) #16
  call void @dput(ptr noundef %victim.0) #16
  %cmp = icmp eq ptr %child.4.i, null
  br i1 %cmp, label %while.body4, label %cleanup

while.body4:                                      ; preds = %find_next_child.exit
  %i_ctime = getelementptr inbounds %struct.inode, ptr %inode.0, i32 0, i32 17
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tmp) #16
  call void @current_time(ptr nonnull sret(%struct.timespec64) align 8 %tmp, ptr noundef %inode.0) #16
  %23 = call ptr @memcpy(ptr %i_ctime, ptr %tmp, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tmp) #16
  call void @clear_nlink(ptr noundef %inode.0) #16
  %i_rwsem.i59 = getelementptr inbounds %struct.inode, ptr %inode.0, i32 0, i32 25
  call void @up_write(ptr noundef %i_rwsem.i59) #16
  %d_parent = getelementptr inbounds %struct.dentry, ptr %this.1, i32 0, i32 3
  %24 = ptrtoint ptr %d_parent to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %d_parent, align 8
  %d_inode5 = getelementptr inbounds %struct.dentry, ptr %25, i32 0, i32 5
  %26 = ptrtoint ptr %d_inode5 to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load ptr, ptr %d_inode5, align 8
  %i_rwsem.i60 = getelementptr inbounds %struct.inode, ptr %27, i32 0, i32 25
  call void @down_write(ptr noundef %i_rwsem.i60) #16
  %d_inode.i.i = getelementptr inbounds %struct.dentry, ptr %this.1, i32 0, i32 5
  %28 = ptrtoint ptr %d_inode.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load ptr, ptr %d_inode.i.i, align 8
  %cmp.i.not.i = icmp eq ptr %29, null
  br i1 %cmp.i.not.i, label %while.body4.if.end14_crit_edge, label %simple_positive.exit

while.body4.if.end14_crit_edge:                   ; preds = %while.body4
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end14

simple_positive.exit:                             ; preds = %while.body4
  %pprev.i.i.i = getelementptr inbounds %struct.dentry, ptr %this.1, i32 0, i32 2, i32 1
  %30 = ptrtoint ptr %pprev.i.i.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %pprev.i.i.i, align 4
  %tobool.not.i.i.i.not = icmp eq ptr %31, null
  br i1 %tobool.not.i.i.i.not, label %simple_positive.exit.if.end14_crit_edge, label %if.then7

simple_positive.exit.if.end14_crit_edge:          ; preds = %simple_positive.exit
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end14

if.then7:                                         ; preds = %simple_positive.exit
  call void @d_invalidate(ptr noundef %this.1) #16
  %32 = ptrtoint ptr %this.1 to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %this.1, align 8
  %34 = and i32 %33, 6291456
  call void @__sanitizer_cov_trace_const_cmp4(i32 2097152, i32 %34)
  %35 = icmp eq i32 %34, 2097152
  %and.i.i.i.i = and i32 %33, 7340032
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and.i.i.i.i)
  %cmp.i.i.i = icmp eq i32 %and.i.i.i.i, 0
  br i1 %35, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then7
  br i1 %cmp.i.i.i, label %land.rhs.i61, label %if.end37.critedge.i

land.rhs.i61:                                     ; preds = %if.then9
  %.b43.i = load i1, ptr @fsnotify_rmdir.__already_done, align 1
  br i1 %.b43.i, label %land.rhs.i61.if.end10_crit_edge, label %if.then.i62, !prof !184

land.rhs.i61.if.end10_crit_edge:                  ; preds = %land.rhs.i61
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end10

if.then.i62:                                      ; preds = %land.rhs.i61
  call void @__sanitizer_cov_trace_pc() #18
  store i1 true, ptr @fsnotify_rmdir.__already_done, align 1
  call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.8, i32 noundef 298, i32 noundef 9, ptr noundef null) #16
  br label %if.end10

if.end37.critedge.i:                              ; preds = %if.then9
  %36 = ptrtoint ptr %d_inode.i.i to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load ptr, ptr %d_inode.i.i, align 8
  %38 = ptrtoint ptr %37 to i32
  call void @__asan_load2_noabort(i32 %38)
  %39 = load i16, ptr %37, align 8
  %i_sb.i.i.i = getelementptr inbounds %struct.inode, ptr %27, i32 0, i32 8
  %40 = ptrtoint ptr %i_sb.i.i.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load ptr, ptr %i_sb.i.i.i, align 4
  %s_fsnotify_connectors.i.i.i = getelementptr inbounds %struct.super_block, ptr %41, i32 0, i32 48
  %call.i.i.i.i.i = call zeroext i1 @__kasan_check_read(ptr noundef %s_fsnotify_connectors.i.i.i, i32 noundef 4) #16
  %42 = ptrtoint ptr %s_fsnotify_connectors.i.i.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load volatile i32, ptr %s_fsnotify_connectors.i.i.i, align 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %43)
  %cmp.i.i45.i = icmp eq i32 %43, 0
  br i1 %cmp.i.i45.i, label %if.end37.critedge.i.if.end10_crit_edge, label %if.end.i.i.i

if.end37.critedge.i.if.end10_crit_edge:           ; preds = %if.end37.critedge.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end10

if.end.i.i.i:                                     ; preds = %if.end37.critedge.i
  call void @__sanitizer_cov_trace_pc() #18
  %d_name.i.i = getelementptr inbounds %struct.dentry, ptr %this.1, i32 0, i32 4
  %44 = and i16 %39, -4096
  call void @__sanitizer_cov_trace_const_cmp2(i16 16384, i16 %44)
  %cmp.i.i = icmp eq i16 %44, 16384
  %spec.select.i.i = select i1 %cmp.i.i, i32 1073742336, i32 512
  %call1.i.i.i = call i32 @fsnotify(i32 noundef %spec.select.i.i, ptr noundef %37, i32 noundef 2, ptr noundef %27, ptr noundef %d_name.i.i, ptr noundef null, i32 noundef 0) #16
  br label %if.end10

if.else:                                          ; preds = %if.then7
  br i1 %cmp.i.i.i, label %land.rhs.i67, label %if.end37.critedge.i74

land.rhs.i67:                                     ; preds = %if.else
  %.b43.i66 = load i1, ptr @fsnotify_unlink.__already_done, align 1
  br i1 %.b43.i66, label %land.rhs.i67.if.end10_crit_edge, label %if.then.i68, !prof !184

land.rhs.i67.if.end10_crit_edge:                  ; preds = %land.rhs.i67
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end10

if.then.i68:                                      ; preds = %land.rhs.i67
  call void @__sanitizer_cov_trace_pc() #18
  store i1 true, ptr @fsnotify_unlink.__already_done, align 1
  call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.8, i32 noundef 271, i32 noundef 9, ptr noundef null) #16
  br label %if.end10

if.end37.critedge.i74:                            ; preds = %if.else
  %45 = ptrtoint ptr %d_inode.i.i to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load ptr, ptr %d_inode.i.i, align 8
  %47 = ptrtoint ptr %46 to i32
  call void @__asan_load2_noabort(i32 %47)
  %48 = load i16, ptr %46, align 8
  %i_sb.i.i.i70 = getelementptr inbounds %struct.inode, ptr %27, i32 0, i32 8
  %49 = ptrtoint ptr %i_sb.i.i.i70 to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load ptr, ptr %i_sb.i.i.i70, align 4
  %s_fsnotify_connectors.i.i.i71 = getelementptr inbounds %struct.super_block, ptr %50, i32 0, i32 48
  %call.i.i.i.i.i72 = call zeroext i1 @__kasan_check_read(ptr noundef %s_fsnotify_connectors.i.i.i71, i32 noundef 4) #16
  %51 = ptrtoint ptr %s_fsnotify_connectors.i.i.i71 to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load volatile i32, ptr %s_fsnotify_connectors.i.i.i71, align 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %52)
  %cmp.i.i45.i73 = icmp eq i32 %52, 0
  br i1 %cmp.i.i45.i73, label %if.end37.critedge.i74.if.end10_crit_edge, label %if.end.i.i.i79

if.end37.critedge.i74.if.end10_crit_edge:         ; preds = %if.end37.critedge.i74
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end10

if.end.i.i.i79:                                   ; preds = %if.end37.critedge.i74
  call void @__sanitizer_cov_trace_pc() #18
  %d_name.i.i75 = getelementptr inbounds %struct.dentry, ptr %this.1, i32 0, i32 4
  %53 = and i16 %48, -4096
  call void @__sanitizer_cov_trace_const_cmp2(i16 16384, i16 %53)
  %cmp.i.i76 = icmp eq i16 %53, 16384
  %spec.select.i.i77 = select i1 %cmp.i.i76, i32 1073742336, i32 512
  %call1.i.i.i78 = call i32 @fsnotify(i32 noundef %spec.select.i.i77, ptr noundef %46, i32 noundef 2, ptr noundef %27, ptr noundef %d_name.i.i75, ptr noundef null, i32 noundef 0) #16
  br label %if.end10

if.end10:                                         ; preds = %if.end.i.i.i79, %if.end37.critedge.i74.if.end10_crit_edge, %if.then.i68, %land.rhs.i67.if.end10_crit_edge, %if.end.i.i.i, %if.end37.critedge.i.if.end10_crit_edge, %if.then.i62, %land.rhs.i61.if.end10_crit_edge
  br i1 %tobool11.not, label %if.end10.if.end13_crit_edge, label %if.then12

if.end10.if.end13_crit_edge:                      ; preds = %if.end10
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end13

if.then12:                                        ; preds = %if.end10
  call void @__sanitizer_cov_trace_pc() #18
  call void %callback(ptr noundef %this.1) #16
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end10.if.end13_crit_edge
  call void @dput(ptr noundef %this.1) #16
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %simple_positive.exit.if.end14_crit_edge, %while.body4.if.end14_crit_edge
  %cmp15 = icmp eq ptr %this.1, %dentry
  br i1 %cmp15, label %if.then16, label %if.end14.while.cond2_crit_edge

if.end14.while.cond2_crit_edge:                   ; preds = %if.end14
  call void @__sanitizer_cov_trace_pc() #18
  br label %while.cond2

if.then16:                                        ; preds = %if.end14
  %i_ctime17 = getelementptr inbounds %struct.inode, ptr %27, i32 0, i32 17
  %i_mtime = getelementptr inbounds %struct.inode, ptr %27, i32 0, i32 16
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tmp18) #16
  call void @current_time(ptr nonnull sret(%struct.timespec64) align 8 %tmp18, ptr noundef %27) #16
  %54 = call ptr @memcpy(ptr %i_mtime, ptr %tmp18, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tmp18) #16
  %55 = call ptr @memcpy(ptr %i_ctime17, ptr %i_mtime, i32 16)
  %56 = ptrtoint ptr %dentry to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load i32, ptr %dentry, align 8
  %58 = and i32 %57, 6291456
  call void @__sanitizer_cov_trace_const_cmp4(i32 2097152, i32 %58)
  %59 = icmp eq i32 %58, 2097152
  br i1 %59, label %if.then20, label %if.then16.cleanup25_crit_edge

if.then16.cleanup25_crit_edge:                    ; preds = %if.then16
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup25

if.then20:                                        ; preds = %if.then16
  call void @__sanitizer_cov_trace_pc() #18
  call void @drop_nlink(ptr noundef %27) #16
  br label %cleanup25

cleanup:                                          ; preds = %find_next_child.exit
  call void @__sanitizer_cov_trace_pc() #18
  %i_rwsem.i81 = getelementptr inbounds %struct.inode, ptr %inode.0, i32 0, i32 25
  call void @up_write(ptr noundef %i_rwsem.i81) #16
  br label %while.cond

cleanup25:                                        ; preds = %if.then20, %if.then16.cleanup25_crit_edge
  call void @up_write(ptr noundef %i_rwsem.i60) #16
  call void @dput(ptr noundef %dentry) #16
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @current_time(ptr sret(%struct.timespec64) align 8, ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @clear_nlink(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @d_invalidate(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @drop_nlink(ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @init_pseudo(ptr nocapture noundef %fc, i32 noundef %magic) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 7) to i32))
  %0 = load ptr, ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 7), align 4
  %call7.i.i = tail call noalias align 8 ptr @kmem_cache_alloc_trace(ptr noundef %0, i32 noundef 3520, i32 noundef 16) #19
  %tobool.not = icmp eq ptr %call7.i.i, null
  br i1 %tobool.not, label %entry.if.end_crit_edge, label %if.then, !prof !185

entry.if.end_crit_edge:                           ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end

if.then:                                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  %magic3 = getelementptr inbounds %struct.pseudo_fs_context, ptr %call7.i.i, i32 0, i32 3
  %1 = ptrtoint ptr %magic3 to i32
  call void @__asan_store4_noabort(i32 %1)
  store i32 %magic, ptr %magic3, align 4
  %fs_private = getelementptr inbounds %struct.fs_context, ptr %fc, i32 0, i32 3
  %2 = ptrtoint ptr %fs_private to i32
  call void @__asan_store4_noabort(i32 %2)
  store ptr %call7.i.i, ptr %fs_private, align 4
  %3 = ptrtoint ptr %fc to i32
  call void @__asan_store4_noabort(i32 %3)
  store ptr @pseudo_fs_context_ops, ptr %fc, align 4
  %sb_flags = getelementptr inbounds %struct.fs_context, ptr %fc, i32 0, i32 13
  %4 = ptrtoint ptr %sb_flags to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %sb_flags, align 4
  %or = or i32 %5, -2147483648
  store i32 %or, ptr %sb_flags, align 4
  %global = getelementptr inbounds %struct.fs_context, ptr %fc, i32 0, i32 17
  %6 = ptrtoint ptr %global to i32
  call void @__asan_load4_noabort(i32 %6)
  %bf.load = load i32, ptr %global, align 4
  %bf.set = or i32 %bf.load, 16384
  store i32 %bf.set, ptr %global, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry.if.end_crit_edge
  ret ptr %call7.i.i
}

; Function Attrs: argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid sanitize_address sspstrong willreturn uwtable(sync)
define dso_local i32 @simple_open(ptr nocapture noundef readonly %inode, ptr nocapture noundef writeonly %file) #5 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %i_private = getelementptr inbounds %struct.inode, ptr %inode, i32 0, i32 54
  %0 = ptrtoint ptr %i_private to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %i_private, align 4
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %entry.if.end_crit_edge, label %if.then

entry.if.end_crit_edge:                           ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end

if.then:                                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  %private_data = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 16
  %2 = ptrtoint ptr %private_data to i32
  call void @__asan_store4_noabort(i32 %2)
  store ptr %1, ptr %private_data, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry.if.end_crit_edge
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_link(ptr nocapture noundef readonly %old_dentry, ptr nocapture noundef %dir, ptr noundef %dentry) #0 align 64 {
entry:
  %tmp = alloca %struct.timespec64, align 8
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %d_inode.i = getelementptr inbounds %struct.dentry, ptr %old_dentry, i32 0, i32 5
  %0 = ptrtoint ptr %d_inode.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %d_inode.i, align 8
  %i_ctime = getelementptr inbounds %struct.inode, ptr %1, i32 0, i32 17
  %i_ctime1 = getelementptr inbounds %struct.inode, ptr %dir, i32 0, i32 17
  %i_mtime = getelementptr inbounds %struct.inode, ptr %dir, i32 0, i32 16
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tmp) #16
  call void @current_time(ptr nonnull sret(%struct.timespec64) align 8 %tmp, ptr noundef %1) #16
  %2 = call ptr @memcpy(ptr %i_mtime, ptr %tmp, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tmp) #16
  %3 = call ptr @memcpy(ptr %i_ctime1, ptr %i_mtime, i32 16)
  %4 = call ptr @memmove(ptr %i_ctime, ptr %i_mtime, i32 16)
  call void @inc_nlink(ptr noundef %1) #16
  call void @ihold(ptr noundef %1) #16
  %tobool.not.i = icmp eq ptr %dentry, null
  br i1 %tobool.not.i, label %entry.dget.exit_crit_edge, label %if.then.i

entry.dget.exit_crit_edge:                        ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %dget.exit

if.then.i:                                        ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  %d_lockref.i = getelementptr inbounds %struct.dentry, ptr %dentry, i32 0, i32 7
  call void @lockref_get(ptr noundef %d_lockref.i) #16
  br label %dget.exit

dget.exit:                                        ; preds = %if.then.i, %entry.dget.exit_crit_edge
  call void @d_instantiate(ptr noundef %dentry, ptr noundef %1) #16
  ret i32 0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @inc_nlink(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @ihold(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @d_instantiate(ptr noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_empty(ptr noundef %dentry) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %d_lockref = getelementptr inbounds %struct.dentry, ptr %dentry, i32 0, i32 7
  tail call void @_raw_spin_lock(ptr noundef %d_lockref) #16
  %d_subdirs = getelementptr inbounds %struct.dentry, ptr %dentry, i32 0, i32 14
  %0 = ptrtoint ptr %d_subdirs to i32
  call void @__asan_load4_noabort(i32 %0)
  %.pn25 = load ptr, ptr %d_subdirs, align 8
  %cmp.not26 = icmp eq ptr %.pn25, %d_subdirs
  br i1 %cmp.not26, label %entry.out_crit_edge, label %entry.do.body_crit_edge

entry.do.body_crit_edge:                          ; preds = %entry
  br label %do.body

entry.out_crit_edge:                              ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %out

do.body:                                          ; preds = %if.end.do.body_crit_edge, %entry.do.body_crit_edge
  %.pn27 = phi ptr [ %.pn, %if.end.do.body_crit_edge ], [ %.pn25, %entry.do.body_crit_edge ]
  %d_lockref2 = getelementptr i8, ptr %.pn27, i32 -72
  tail call void @_raw_spin_lock_nested(ptr noundef %d_lockref2, i32 noundef 1) #16
  %d_inode.i.i = getelementptr i8, ptr %.pn27, i32 -112
  %1 = ptrtoint ptr %d_inode.i.i to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %d_inode.i.i, align 8
  %cmp.i.not.i = icmp eq ptr %2, null
  br i1 %cmp.i.not.i, label %do.body.if.end_crit_edge, label %simple_positive.exit

do.body.if.end_crit_edge:                         ; preds = %do.body
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end

simple_positive.exit:                             ; preds = %do.body
  %pprev.i.i.i = getelementptr i8, ptr %.pn27, i32 -140
  %3 = ptrtoint ptr %pprev.i.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %pprev.i.i.i, align 4
  %tobool.not.i.i.i.not = icmp eq ptr %4, null
  br i1 %tobool.not.i.i.i.not, label %simple_positive.exit.if.end_crit_edge, label %if.then

simple_positive.exit.if.end_crit_edge:            ; preds = %simple_positive.exit
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end

if.then:                                          ; preds = %simple_positive.exit
  call void @__sanitizer_cov_trace_pc() #18
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref2) #16
  br label %out

if.end:                                           ; preds = %simple_positive.exit.if.end_crit_edge, %do.body.if.end_crit_edge
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref2) #16
  %5 = ptrtoint ptr %.pn27 to i32
  call void @__asan_load4_noabort(i32 %5)
  %.pn = load ptr, ptr %.pn27, align 8
  %cmp.not = icmp eq ptr %.pn, %d_subdirs
  br i1 %cmp.not, label %if.end.out_crit_edge, label %if.end.do.body_crit_edge

if.end.do.body_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %do.body

if.end.out_crit_edge:                             ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %out

out:                                              ; preds = %if.end.out_crit_edge, %if.then, %entry.out_crit_edge
  %ret.0 = phi i32 [ 0, %if.then ], [ 1, %entry.out_crit_edge ], [ 1, %if.end.out_crit_edge ]
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref) #16
  ret i32 %ret.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @_raw_spin_lock_nested(ptr noundef, i32 noundef) local_unnamed_addr #2 section ".spinlock.text"

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_unlink(ptr nocapture noundef %dir, ptr noundef %dentry) #0 align 64 {
entry:
  %tmp = alloca %struct.timespec64, align 8
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %d_inode.i = getelementptr inbounds %struct.dentry, ptr %dentry, i32 0, i32 5
  %0 = ptrtoint ptr %d_inode.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %d_inode.i, align 8
  %i_ctime = getelementptr inbounds %struct.inode, ptr %1, i32 0, i32 17
  %i_ctime1 = getelementptr inbounds %struct.inode, ptr %dir, i32 0, i32 17
  %i_mtime = getelementptr inbounds %struct.inode, ptr %dir, i32 0, i32 16
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tmp) #16
  call void @current_time(ptr nonnull sret(%struct.timespec64) align 8 %tmp, ptr noundef %1) #16
  %2 = call ptr @memcpy(ptr %i_mtime, ptr %tmp, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tmp) #16
  %3 = call ptr @memcpy(ptr %i_ctime1, ptr %i_mtime, i32 16)
  %4 = call ptr @memmove(ptr %i_ctime, ptr %i_mtime, i32 16)
  call void @drop_nlink(ptr noundef %1) #16
  call void @dput(ptr noundef %dentry) #16
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_rmdir(ptr noundef %dir, ptr noundef %dentry) #0 align 64 {
entry:
  %tmp.i = alloca %struct.timespec64, align 8
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %d_lockref.i = getelementptr inbounds %struct.dentry, ptr %dentry, i32 0, i32 7
  tail call void @_raw_spin_lock(ptr noundef %d_lockref.i) #16
  %d_subdirs.i = getelementptr inbounds %struct.dentry, ptr %dentry, i32 0, i32 14
  %0 = ptrtoint ptr %d_subdirs.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %.pn25.i = load ptr, ptr %d_subdirs.i, align 8
  %cmp.not26.i = icmp eq ptr %.pn25.i, %d_subdirs.i
  br i1 %cmp.not26.i, label %entry.if.end_crit_edge, label %entry.do.body.i_crit_edge

entry.do.body.i_crit_edge:                        ; preds = %entry
  br label %do.body.i

entry.if.end_crit_edge:                           ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end

do.body.i:                                        ; preds = %if.end.i.do.body.i_crit_edge, %entry.do.body.i_crit_edge
  %.pn27.i = phi ptr [ %.pn.i, %if.end.i.do.body.i_crit_edge ], [ %.pn25.i, %entry.do.body.i_crit_edge ]
  %d_lockref2.i = getelementptr i8, ptr %.pn27.i, i32 -72
  tail call void @_raw_spin_lock_nested(ptr noundef %d_lockref2.i, i32 noundef 1) #16
  %d_inode.i.i.i = getelementptr i8, ptr %.pn27.i, i32 -112
  %1 = ptrtoint ptr %d_inode.i.i.i to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %d_inode.i.i.i, align 8
  %cmp.i.not.i.i = icmp eq ptr %2, null
  br i1 %cmp.i.not.i.i, label %do.body.i.if.end.i_crit_edge, label %simple_positive.exit.i

do.body.i.if.end.i_crit_edge:                     ; preds = %do.body.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end.i

simple_positive.exit.i:                           ; preds = %do.body.i
  %pprev.i.i.i.i = getelementptr i8, ptr %.pn27.i, i32 -140
  %3 = ptrtoint ptr %pprev.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %pprev.i.i.i.i, align 4
  %tobool.not.i.i.i.not.i = icmp eq ptr %4, null
  br i1 %tobool.not.i.i.i.not.i, label %simple_positive.exit.i.if.end.i_crit_edge, label %simple_empty.exit

simple_positive.exit.i.if.end.i_crit_edge:        ; preds = %simple_positive.exit.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end.i

if.end.i:                                         ; preds = %simple_positive.exit.i.if.end.i_crit_edge, %do.body.i.if.end.i_crit_edge
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref2.i) #16
  %5 = ptrtoint ptr %.pn27.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %.pn.i = load ptr, ptr %.pn27.i, align 8
  %cmp.not.i = icmp eq ptr %.pn.i, %d_subdirs.i
  br i1 %cmp.not.i, label %if.end.i.if.end_crit_edge, label %if.end.i.do.body.i_crit_edge

if.end.i.do.body.i_crit_edge:                     ; preds = %if.end.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %do.body.i

if.end.i.if.end_crit_edge:                        ; preds = %if.end.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end

simple_empty.exit:                                ; preds = %simple_positive.exit.i
  call void @__sanitizer_cov_trace_pc() #18
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref2.i) #16
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref.i) #16
  br label %return

if.end:                                           ; preds = %if.end.i.if.end_crit_edge, %entry.if.end_crit_edge
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref.i) #16
  %d_inode.i = getelementptr inbounds %struct.dentry, ptr %dentry, i32 0, i32 5
  %6 = ptrtoint ptr %d_inode.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %d_inode.i, align 8
  tail call void @drop_nlink(ptr noundef %7) #16
  %8 = ptrtoint ptr %d_inode.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %d_inode.i, align 8
  %i_ctime.i = getelementptr inbounds %struct.inode, ptr %9, i32 0, i32 17
  %i_ctime1.i = getelementptr inbounds %struct.inode, ptr %dir, i32 0, i32 17
  %i_mtime.i = getelementptr inbounds %struct.inode, ptr %dir, i32 0, i32 16
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tmp.i) #16
  call void @current_time(ptr nonnull sret(%struct.timespec64) align 8 %tmp.i, ptr noundef %9) #16
  %10 = call ptr @memcpy(ptr %i_mtime.i, ptr %tmp.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tmp.i) #16
  %11 = call ptr @memcpy(ptr %i_ctime1.i, ptr %i_mtime.i, i32 16)
  %12 = call ptr @memmove(ptr %i_ctime.i, ptr %i_mtime.i, i32 16)
  call void @drop_nlink(ptr noundef %9) #16
  call void @dput(ptr noundef %dentry) #16
  call void @drop_nlink(ptr noundef %dir) #16
  br label %return

return:                                           ; preds = %if.end, %simple_empty.exit
  %retval.0 = phi i32 [ 0, %if.end ], [ -39, %simple_empty.exit ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_rename_exchange(ptr noundef %old_dir, ptr nocapture noundef readonly %old_dentry, ptr noundef %new_dir, ptr nocapture noundef readonly %new_dentry) #0 align 64 {
entry:
  %tmp = alloca %struct.timespec64, align 8
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = ptrtoint ptr %old_dentry to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %old_dentry, align 8
  %2 = and i32 %1, 6291456
  call void @__sanitizer_cov_trace_const_cmp4(i32 2097152, i32 %2)
  %3 = icmp eq i32 %2, 2097152
  %4 = ptrtoint ptr %new_dentry to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %new_dentry, align 8
  %6 = and i32 %5, 6291456
  call void @__sanitizer_cov_trace_const_cmp4(i32 2097152, i32 %6)
  %7 = icmp eq i32 %6, 2097152
  %cmp.not = icmp ne ptr %old_dir, %new_dir
  %8 = xor i1 %3, %7
  %or.cond = select i1 %cmp.not, i1 %8, i1 false
  br i1 %or.cond, label %if.then, label %entry.if.end9_crit_edge

entry.if.end9_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end9

if.then:                                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  %old_dir.new_dir = select i1 %3, ptr %old_dir, ptr %new_dir
  %new_dir.old_dir = select i1 %3, ptr %new_dir, ptr %old_dir
  tail call void @drop_nlink(ptr noundef %old_dir.new_dir) #16
  tail call void @inc_nlink(ptr noundef %new_dir.old_dir) #16
  br label %if.end9

if.end9:                                          ; preds = %if.then, %entry.if.end9_crit_edge
  %i_ctime = getelementptr inbounds %struct.inode, ptr %old_dir, i32 0, i32 17
  %i_mtime = getelementptr inbounds %struct.inode, ptr %old_dir, i32 0, i32 16
  %i_ctime10 = getelementptr inbounds %struct.inode, ptr %new_dir, i32 0, i32 17
  %i_mtime11 = getelementptr inbounds %struct.inode, ptr %new_dir, i32 0, i32 16
  %d_inode.i = getelementptr inbounds %struct.dentry, ptr %old_dentry, i32 0, i32 5
  %9 = ptrtoint ptr %d_inode.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %d_inode.i, align 8
  %i_ctime13 = getelementptr inbounds %struct.inode, ptr %10, i32 0, i32 17
  %d_inode.i28 = getelementptr inbounds %struct.dentry, ptr %new_dentry, i32 0, i32 5
  %11 = ptrtoint ptr %d_inode.i28 to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %d_inode.i28, align 8
  %i_ctime15 = getelementptr inbounds %struct.inode, ptr %12, i32 0, i32 17
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tmp) #16
  call void @current_time(ptr nonnull sret(%struct.timespec64) align 8 %tmp, ptr noundef %old_dir) #16
  %13 = call ptr @memcpy(ptr %i_ctime15, ptr %tmp, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tmp) #16
  %14 = call ptr @memcpy(ptr %i_ctime13, ptr %i_ctime15, i32 16)
  %15 = call ptr @memmove(ptr %i_mtime11, ptr %i_ctime15, i32 16)
  %16 = call ptr @memcpy(ptr %i_ctime10, ptr %i_mtime11, i32 16)
  %17 = call ptr @memmove(ptr %i_mtime, ptr %i_mtime11, i32 16)
  %18 = call ptr @memcpy(ptr %i_ctime, ptr %i_mtime, i32 16)
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_rename(ptr nocapture readnone %mnt_userns, ptr noundef %old_dir, ptr nocapture noundef readonly %old_dentry, ptr noundef %new_dir, ptr noundef %new_dentry, i32 noundef %flags) #0 align 64 {
entry:
  %tmp.i46 = alloca %struct.timespec64, align 8
  %tmp.i = alloca %struct.timespec64, align 8
  %tmp = alloca %struct.timespec64, align 8
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %d_inode.i = getelementptr inbounds %struct.dentry, ptr %old_dentry, i32 0, i32 5
  %0 = ptrtoint ptr %d_inode.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %d_inode.i, align 8
  %2 = ptrtoint ptr %old_dentry to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %old_dentry, align 8
  %4 = and i32 %3, 6291456
  call void @__sanitizer_cov_trace_const_cmp4(i32 2097152, i32 %4)
  %5 = icmp eq i32 %4, 2097152
  call void @__sanitizer_cov_trace_const_cmp4(i32 4, i32 %flags)
  %tobool.not = icmp ult i32 %flags, 4
  br i1 %tobool.not, label %if.end, label %entry.cleanup_crit_edge

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  %and2 = and i32 %flags, 2
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and2)
  %tobool3.not = icmp eq i32 %and2, 0
  br i1 %tobool3.not, label %if.end6, label %if.then4

if.then4:                                         ; preds = %if.end
  %6 = ptrtoint ptr %new_dentry to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %new_dentry, align 8
  %8 = and i32 %7, 6291456
  call void @__sanitizer_cov_trace_const_cmp4(i32 2097152, i32 %8)
  %9 = icmp eq i32 %8, 2097152
  %cmp.not.i = icmp ne ptr %old_dir, %new_dir
  %10 = xor i1 %5, %9
  %or.cond.i = select i1 %cmp.not.i, i1 %10, i1 false
  br i1 %or.cond.i, label %if.then.i, label %if.then4.simple_rename_exchange.exit_crit_edge

if.then4.simple_rename_exchange.exit_crit_edge:   ; preds = %if.then4
  call void @__sanitizer_cov_trace_pc() #18
  br label %simple_rename_exchange.exit

if.then.i:                                        ; preds = %if.then4
  call void @__sanitizer_cov_trace_pc() #18
  %old_dir.new_dir.i = select i1 %5, ptr %old_dir, ptr %new_dir
  %new_dir.old_dir.i = select i1 %5, ptr %new_dir, ptr %old_dir
  tail call void @drop_nlink(ptr noundef %old_dir.new_dir.i) #16
  tail call void @inc_nlink(ptr noundef %new_dir.old_dir.i) #16
  br label %simple_rename_exchange.exit

simple_rename_exchange.exit:                      ; preds = %if.then.i, %if.then4.simple_rename_exchange.exit_crit_edge
  %i_ctime.i = getelementptr inbounds %struct.inode, ptr %old_dir, i32 0, i32 17
  %i_mtime.i = getelementptr inbounds %struct.inode, ptr %old_dir, i32 0, i32 16
  %i_ctime10.i = getelementptr inbounds %struct.inode, ptr %new_dir, i32 0, i32 17
  %i_mtime11.i = getelementptr inbounds %struct.inode, ptr %new_dir, i32 0, i32 16
  %11 = ptrtoint ptr %d_inode.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %d_inode.i, align 8
  %i_ctime13.i = getelementptr inbounds %struct.inode, ptr %12, i32 0, i32 17
  %d_inode.i28.i = getelementptr inbounds %struct.dentry, ptr %new_dentry, i32 0, i32 5
  %13 = ptrtoint ptr %d_inode.i28.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %d_inode.i28.i, align 8
  %i_ctime15.i = getelementptr inbounds %struct.inode, ptr %14, i32 0, i32 17
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tmp.i) #16
  call void @current_time(ptr nonnull sret(%struct.timespec64) align 8 %tmp.i, ptr noundef %old_dir) #16
  %15 = call ptr @memcpy(ptr %i_ctime15.i, ptr %tmp.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tmp.i) #16
  %16 = call ptr @memcpy(ptr %i_ctime13.i, ptr %i_ctime15.i, i32 16)
  %17 = call ptr @memmove(ptr %i_mtime11.i, ptr %i_ctime15.i, i32 16)
  %18 = call ptr @memcpy(ptr %i_ctime10.i, ptr %i_mtime11.i, i32 16)
  %19 = call ptr @memmove(ptr %i_mtime.i, ptr %i_mtime11.i, i32 16)
  %20 = call ptr @memcpy(ptr %i_ctime.i, ptr %i_mtime.i, i32 16)
  br label %cleanup

if.end6:                                          ; preds = %if.end
  %d_lockref.i = getelementptr inbounds %struct.dentry, ptr %new_dentry, i32 0, i32 7
  tail call void @_raw_spin_lock(ptr noundef %d_lockref.i) #16
  %d_subdirs.i = getelementptr inbounds %struct.dentry, ptr %new_dentry, i32 0, i32 14
  %21 = ptrtoint ptr %d_subdirs.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %.pn25.i = load ptr, ptr %d_subdirs.i, align 8
  %cmp.not26.i = icmp eq ptr %.pn25.i, %d_subdirs.i
  br i1 %cmp.not26.i, label %if.end6.if.end10_crit_edge, label %if.end6.do.body.i_crit_edge

if.end6.do.body.i_crit_edge:                      ; preds = %if.end6
  br label %do.body.i

if.end6.if.end10_crit_edge:                       ; preds = %if.end6
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end10

do.body.i:                                        ; preds = %if.end.i.do.body.i_crit_edge, %if.end6.do.body.i_crit_edge
  %.pn27.i = phi ptr [ %.pn.i, %if.end.i.do.body.i_crit_edge ], [ %.pn25.i, %if.end6.do.body.i_crit_edge ]
  %d_lockref2.i = getelementptr i8, ptr %.pn27.i, i32 -72
  tail call void @_raw_spin_lock_nested(ptr noundef %d_lockref2.i, i32 noundef 1) #16
  %d_inode.i.i.i = getelementptr i8, ptr %.pn27.i, i32 -112
  %22 = ptrtoint ptr %d_inode.i.i.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %d_inode.i.i.i, align 8
  %cmp.i.not.i.i = icmp eq ptr %23, null
  br i1 %cmp.i.not.i.i, label %do.body.i.if.end.i_crit_edge, label %simple_positive.exit.i

do.body.i.if.end.i_crit_edge:                     ; preds = %do.body.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end.i

simple_positive.exit.i:                           ; preds = %do.body.i
  %pprev.i.i.i.i = getelementptr i8, ptr %.pn27.i, i32 -140
  %24 = ptrtoint ptr %pprev.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %pprev.i.i.i.i, align 4
  %tobool.not.i.i.i.not.i = icmp eq ptr %25, null
  br i1 %tobool.not.i.i.i.not.i, label %simple_positive.exit.i.if.end.i_crit_edge, label %simple_empty.exit

simple_positive.exit.i.if.end.i_crit_edge:        ; preds = %simple_positive.exit.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end.i

if.end.i:                                         ; preds = %simple_positive.exit.i.if.end.i_crit_edge, %do.body.i.if.end.i_crit_edge
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref2.i) #16
  %26 = ptrtoint ptr %.pn27.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %.pn.i = load ptr, ptr %.pn27.i, align 8
  %cmp.not.i44 = icmp eq ptr %.pn.i, %d_subdirs.i
  br i1 %cmp.not.i44, label %if.end.i.if.end10_crit_edge, label %if.end.i.do.body.i_crit_edge

if.end.i.do.body.i_crit_edge:                     ; preds = %if.end.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %do.body.i

if.end.i.if.end10_crit_edge:                      ; preds = %if.end.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end10

simple_empty.exit:                                ; preds = %simple_positive.exit.i
  call void @__sanitizer_cov_trace_pc() #18
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref2.i) #16
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref.i) #16
  br label %cleanup

if.end10:                                         ; preds = %if.end.i.if.end10_crit_edge, %if.end6.if.end10_crit_edge
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref.i) #16
  %d_inode.i45 = getelementptr inbounds %struct.dentry, ptr %new_dentry, i32 0, i32 5
  %27 = ptrtoint ptr %d_inode.i45 to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %d_inode.i45, align 8
  %cmp.i.not = icmp eq ptr %28, null
  br i1 %cmp.i.not, label %if.else, label %if.then12

if.then12:                                        ; preds = %if.end10
  %i_ctime.i48 = getelementptr inbounds %struct.inode, ptr %28, i32 0, i32 17
  %i_ctime1.i = getelementptr inbounds %struct.inode, ptr %new_dir, i32 0, i32 17
  %i_mtime.i49 = getelementptr inbounds %struct.inode, ptr %new_dir, i32 0, i32 16
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tmp.i46) #16
  call void @current_time(ptr nonnull sret(%struct.timespec64) align 8 %tmp.i46, ptr noundef nonnull %28) #16
  %29 = call ptr @memcpy(ptr %i_mtime.i49, ptr %tmp.i46, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tmp.i46) #16
  %30 = call ptr @memcpy(ptr %i_ctime1.i, ptr %i_mtime.i49, i32 16)
  %31 = call ptr @memmove(ptr %i_ctime.i48, ptr %i_mtime.i49, i32 16)
  call void @drop_nlink(ptr noundef nonnull %28) #16
  call void @dput(ptr noundef %new_dentry) #16
  br i1 %5, label %if.then15, label %if.then12.if.end21_crit_edge

if.then12.if.end21_crit_edge:                     ; preds = %if.then12
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end21

if.then15:                                        ; preds = %if.then12
  call void @__sanitizer_cov_trace_pc() #18
  %32 = ptrtoint ptr %d_inode.i45 to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load ptr, ptr %d_inode.i45, align 8
  call void @drop_nlink(ptr noundef %33) #16
  call void @drop_nlink(ptr noundef %old_dir) #16
  br label %if.end21

if.else:                                          ; preds = %if.end10
  br i1 %5, label %if.then19, label %if.else.if.end21_crit_edge

if.else.if.end21_crit_edge:                       ; preds = %if.else
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end21

if.then19:                                        ; preds = %if.else
  call void @__sanitizer_cov_trace_pc() #18
  tail call void @drop_nlink(ptr noundef %old_dir) #16
  tail call void @inc_nlink(ptr noundef %new_dir) #16
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %if.else.if.end21_crit_edge, %if.then15, %if.then12.if.end21_crit_edge
  %i_ctime = getelementptr inbounds %struct.inode, ptr %old_dir, i32 0, i32 17
  %i_mtime = getelementptr inbounds %struct.inode, ptr %old_dir, i32 0, i32 16
  %i_ctime22 = getelementptr inbounds %struct.inode, ptr %new_dir, i32 0, i32 17
  %i_mtime23 = getelementptr inbounds %struct.inode, ptr %new_dir, i32 0, i32 16
  %i_ctime24 = getelementptr inbounds %struct.inode, ptr %1, i32 0, i32 17
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tmp) #16
  call void @current_time(ptr nonnull sret(%struct.timespec64) align 8 %tmp, ptr noundef %old_dir) #16
  %34 = call ptr @memcpy(ptr %i_ctime24, ptr %tmp, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tmp) #16
  %35 = call ptr @memcpy(ptr %i_mtime23, ptr %i_ctime24, i32 16)
  %36 = call ptr @memmove(ptr %i_ctime22, ptr %i_ctime24, i32 16)
  %37 = call ptr @memcpy(ptr %i_mtime, ptr %i_ctime22, i32 16)
  %38 = call ptr @memmove(ptr %i_ctime, ptr %i_ctime22, i32 16)
  br label %cleanup

cleanup:                                          ; preds = %if.end21, %simple_empty.exit, %simple_rename_exchange.exit, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ 0, %simple_rename_exchange.exit ], [ 0, %if.end21 ], [ -22, %entry.cleanup_crit_edge ], [ -39, %simple_empty.exit ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_setattr(ptr noundef %mnt_userns, ptr noundef %dentry, ptr noundef %iattr) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %d_inode.i = getelementptr inbounds %struct.dentry, ptr %dentry, i32 0, i32 5
  %0 = ptrtoint ptr %d_inode.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %d_inode.i, align 8
  %call1 = tail call i32 @setattr_prepare(ptr noundef %mnt_userns, ptr noundef %dentry, ptr noundef %iattr) #16
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call1)
  %tobool.not = icmp eq i32 %call1, 0
  br i1 %tobool.not, label %if.end, label %entry.cleanup_crit_edge

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  %2 = ptrtoint ptr %iattr to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %iattr, align 8
  %and = and i32 %3, 8
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and)
  %tobool2.not = icmp eq i32 %and, 0
  br i1 %tobool2.not, label %if.end.if.end4_crit_edge, label %if.then3

if.end.if.end4_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end4

if.then3:                                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  %ia_size = getelementptr inbounds %struct.iattr, ptr %iattr, i32 0, i32 4
  %4 = ptrtoint ptr %ia_size to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %ia_size, align 8
  tail call void @truncate_setsize(ptr noundef %1, i64 noundef %5) #16
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end.if.end4_crit_edge
  tail call void @setattr_copy(ptr noundef %mnt_userns, ptr noundef %1, ptr noundef %iattr) #16
  tail call void @__mark_inode_dirty(ptr noundef %1, i32 noundef 7) #16
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %entry.cleanup_crit_edge
  ret i32 %call1
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @setattr_prepare(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @truncate_setsize(ptr noundef, i64 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @setattr_copy(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_write_begin(ptr nocapture readnone %file, ptr noundef %mapping, i64 noundef %pos, i32 noundef %len, i32 noundef %flags, ptr nocapture noundef writeonly %pagep, ptr nocapture readnone %fsdata) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = lshr i64 %pos, 12
  %conv = trunc i64 %0 to i32
  %call = tail call ptr @grab_cache_page_write_begin(ptr noundef %mapping, i32 noundef %conv, i32 noundef %flags) #16
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  %1 = ptrtoint ptr %pagep to i32
  call void @__asan_store4_noabort(i32 %1)
  store ptr %call, ptr %pagep, align 4
  %2 = getelementptr inbounds %struct.page, ptr %call, i32 0, i32 1
  %3 = ptrtoint ptr %2 to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load volatile i32, ptr %2, align 4
  %and.i.i = and i32 %4, 1
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and.i.i)
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.end.i.i, label %if.then.i.i, !prof !184

if.then.i.i:                                      ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  %sub.i.i = add i32 %4, -1
  br label %_compound_head.exit.i

if.end.i.i:                                       ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  %5 = ptrtoint ptr %call to i32
  br label %_compound_head.exit.i

_compound_head.exit.i:                            ; preds = %if.end.i.i, %if.then.i.i
  %retval.0.i.i = phi i32 [ %sub.i.i, %if.then.i.i ], [ %5, %if.end.i.i ]
  %6 = inttoptr i32 %retval.0.i.i to ptr
  %7 = getelementptr inbounds %struct.page, ptr %6, i32 0, i32 1
  %8 = ptrtoint ptr %7 to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load volatile i32, ptr %7, align 4
  %and.i.i.i.i = and i32 %9, 1
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and.i.i.i.i)
  %tobool.not.i.i.i = icmp eq i32 %and.i.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %folio_flags.exit.i.i, label %if.then.i.i.i, !prof !184

if.then.i.i.i:                                    ; preds = %_compound_head.exit.i
  call void @__sanitizer_cov_trace_pc() #18
  tail call void @dump_page(ptr noundef %6, ptr noundef nonnull @.str.9) #16
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #16, !srcloc !186
  unreachable

folio_flags.exit.i.i:                             ; preds = %_compound_head.exit.i
  %10 = ptrtoint ptr %6 to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %6, align 4
  %12 = and i32 %11, 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %12)
  %tobool.i.not.i = icmp eq i32 %12, 0
  br i1 %tobool.i.not.i, label %PageUptodate.exit, label %PageUptodate.exit.thread

PageUptodate.exit.thread:                         ; preds = %folio_flags.exit.i.i
  call void @__sanitizer_cov_trace_pc() #18
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #16, !srcloc !187
  br label %cleanup

PageUptodate.exit:                                ; preds = %folio_flags.exit.i.i
  call void @__sanitizer_cov_trace_const_cmp4(i32 4096, i32 %len)
  %cmp.not = icmp eq i32 %len, 4096
  br i1 %cmp.not, label %PageUptodate.exit.cleanup_crit_edge, label %if.then4

PageUptodate.exit.cleanup_crit_edge:              ; preds = %PageUptodate.exit
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.then4:                                         ; preds = %PageUptodate.exit
  call void @__sanitizer_cov_trace_pc() #18
  %13 = trunc i64 %pos to i32
  %conv5 = and i32 %13, 4095
  %add = add i32 %conv5, %len
  tail call void @zero_user_segments(ptr noundef nonnull %call, i32 noundef 0, i32 noundef %conv5, i32 noundef %add, i32 noundef 4096) #16
  br label %cleanup

cleanup:                                          ; preds = %if.then4, %PageUptodate.exit.cleanup_crit_edge, %PageUptodate.exit.thread, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ -12, %entry.cleanup_crit_edge ], [ 0, %if.then4 ], [ 0, %PageUptodate.exit.cleanup_crit_edge ], [ 0, %PageUptodate.exit.thread ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @grab_cache_page_write_begin(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @zero_user_segments(ptr noundef, i32 noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @simple_readpage(ptr nocapture noundef readnone %file, ptr noundef %page) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @pgprot_kernel to i32))
  %0 = load i32, ptr @pgprot_kernel, align 4
  %or.i.i = or i32 %0, 512
  %call.i.i = tail call ptr @__kmap_local_page_prot(ptr noundef %page, i32 noundef %or.i.i) #16
  %1 = call ptr @memset(ptr %call.i.i, i32 0, i32 4096)
  tail call void @kunmap_local_indexed(ptr noundef %call.i.i) #16
  tail call void @flush_dcache_page(ptr noundef %page) #16
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #16, !srcloc !188
  %2 = getelementptr inbounds %struct.page, ptr %page, i32 0, i32 1
  %3 = ptrtoint ptr %2 to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load volatile i32, ptr %2, align 4
  %and.i.i.i.i = and i32 %4, 1
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and.i.i.i.i)
  %tobool.not.i.i.i = icmp eq i32 %and.i.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %SetPageUptodate.exit, label %if.then.i.i.i, !prof !184

if.then.i.i.i:                                    ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  tail call void @dump_page(ptr noundef %page, ptr noundef nonnull @.str.9) #16
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #16, !srcloc !186
  unreachable

SetPageUptodate.exit:                             ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  tail call void @_set_bit(i32 noundef 2, ptr noundef %page) #16
  tail call void @unlock_page(ptr noundef %page) #16
  ret i32 0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__set_page_dirty_no_writeback(ptr noundef) #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @simple_write_end(ptr nocapture noundef readnone %file, ptr nocapture noundef readnone %mapping, i64 noundef %pos, i32 noundef %len, i32 noundef returned %copied, ptr noundef %page, ptr nocapture noundef readnone %fsdata) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %mapping1 = getelementptr inbounds %struct.page, ptr %page, i32 0, i32 1, i32 0, i32 1
  %0 = ptrtoint ptr %mapping1 to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %mapping1, align 4
  %2 = ptrtoint ptr %1 to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %1, align 4
  %conv = zext i32 %copied to i64
  %add = add i64 %conv, %pos
  %4 = getelementptr inbounds %struct.page, ptr %page, i32 0, i32 1
  %5 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %4, align 4
  %and.i.i = and i32 %6, 1
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and.i.i)
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.end.i.i, label %if.then.i.i, !prof !184

if.then.i.i:                                      ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  %sub.i.i = add i32 %6, -1
  br label %_compound_head.exit.i

if.end.i.i:                                       ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  %7 = ptrtoint ptr %page to i32
  br label %_compound_head.exit.i

_compound_head.exit.i:                            ; preds = %if.end.i.i, %if.then.i.i
  %retval.0.i.i = phi i32 [ %sub.i.i, %if.then.i.i ], [ %7, %if.end.i.i ]
  %8 = inttoptr i32 %retval.0.i.i to ptr
  %9 = getelementptr inbounds %struct.page, ptr %8, i32 0, i32 1
  %10 = ptrtoint ptr %9 to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %9, align 4
  %and.i.i.i.i26 = and i32 %11, 1
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and.i.i.i.i26)
  %tobool.not.i.i.i27 = icmp eq i32 %and.i.i.i.i26, 0
  br i1 %tobool.not.i.i.i27, label %folio_flags.exit.i.i, label %if.then.i.i.i28, !prof !184

if.then.i.i.i28:                                  ; preds = %_compound_head.exit.i
  call void @__sanitizer_cov_trace_pc() #18
  tail call void @dump_page(ptr noundef %8, ptr noundef nonnull @.str.9) #16
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #16, !srcloc !186
  unreachable

folio_flags.exit.i.i:                             ; preds = %_compound_head.exit.i
  %12 = ptrtoint ptr %8 to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load volatile i32, ptr %8, align 4
  %14 = and i32 %13, 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %14)
  %tobool.i.not.i = icmp eq i32 %14, 0
  br i1 %tobool.i.not.i, label %if.then, label %PageUptodate.exit

PageUptodate.exit:                                ; preds = %folio_flags.exit.i.i
  call void @__sanitizer_cov_trace_pc() #18
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #16, !srcloc !187
  br label %if.end6

if.then:                                          ; preds = %folio_flags.exit.i.i
  call void @__sanitizer_cov_trace_cmp4(i32 %len, i32 %copied)
  %cmp = icmp ugt i32 %len, %copied
  br i1 %cmp, label %if.then3, label %if.then.if.end_crit_edge

if.then.if.end_crit_edge:                         ; preds = %if.then
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end

if.then3:                                         ; preds = %if.then
  call void @__sanitizer_cov_trace_pc() #18
  %15 = trunc i64 %pos to i32
  %conv4 = and i32 %15, 4095
  %add5 = add i32 %conv4, %copied
  %add.i = add i32 %conv4, %len
  tail call void @zero_user_segments(ptr noundef %page, i32 noundef %add5, i32 noundef %add.i, i32 noundef 0, i32 noundef 0) #16
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then.if.end_crit_edge
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #16, !srcloc !188
  %16 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load volatile i32, ptr %4, align 4
  %and.i.i.i.i = and i32 %17, 1
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and.i.i.i.i)
  %tobool.not.i.i.i = icmp eq i32 %and.i.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %SetPageUptodate.exit, label %if.then.i.i.i, !prof !184

if.then.i.i.i:                                    ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  tail call void @dump_page(ptr noundef %page, ptr noundef nonnull @.str.9) #16
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #16, !srcloc !186
  unreachable

SetPageUptodate.exit:                             ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  tail call void @_set_bit(i32 noundef 2, ptr noundef %page) #16
  br label %if.end6

if.end6:                                          ; preds = %SetPageUptodate.exit, %PageUptodate.exit
  %i_size = getelementptr inbounds %struct.inode, ptr %3, i32 0, i32 14
  %18 = ptrtoint ptr %i_size to i32
  call void @__asan_load8_noabort(i32 %18)
  %19 = load i64, ptr %i_size, align 8
  call void @__sanitizer_cov_trace_cmp8(i64 %add, i64 %19)
  %cmp7 = icmp sgt i64 %add, %19
  br i1 %cmp7, label %if.then9, label %if.end6.if.end10_crit_edge

if.end6.if.end10_crit_edge:                       ; preds = %if.end6
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end10

if.then9:                                         ; preds = %if.end6
  %20 = tail call i32 @llvm.read_register.i32(metadata !174) #16
  %and.i.i.i.i29 = and i32 %20, -16384
  %21 = inttoptr i32 %and.i.i.i.i29 to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %21, i32 0, i32 1
  %22 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %add.i.i = add i32 %23, 1
  store volatile i32 %add.i.i, ptr %preempt_count.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #16, !srcloc !189
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %24 = load i32, ptr @debug_locks, align 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %24)
  %tobool.not.i.i30 = icmp eq i32 %24, 0
  br i1 %tobool.not.i.i30, label %if.then9.i_size_write.exit_crit_edge, label %land.lhs.true.i.i

if.then9.i_size_write.exit_crit_edge:             ; preds = %if.then9
  call void @__sanitizer_cov_trace_pc() #18
  br label %i_size_write.exit

land.lhs.true.i.i:                                ; preds = %if.then9
  %25 = tail call i32 @llvm.read_register.i32(metadata !174) #16
  %and.i.i.i.i.i = and i32 %25, -16384
  %26 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %26, i32 0, i32 1
  %27 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %28, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #16, !srcloc !190
  %29 = tail call i32 @llvm.read_register.i32(metadata !174) #16
  %and.i.i.i = and i32 %29, -16384
  %30 = inttoptr i32 %and.i.i.i to ptr
  %cpu.i.i = getelementptr inbounds %struct.thread_info, ptr %30, i32 0, i32 3
  %31 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %cpu.i.i, align 4
  %arrayidx.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %32
  %33 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %arrayidx.i.i, align 4
  %add.i28.i = add i32 %34, ptrtoint (ptr @lockdep_recursion to i32)
  %35 = inttoptr i32 %add.i28.i to ptr
  %36 = ptrtoint ptr %35 to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load volatile i32, ptr %35, align 4
  tail call void asm sideeffect "", "~{memory}"() #16, !srcloc !191
  %38 = tail call i32 @llvm.read_register.i32(metadata !174) #16
  %and.i.i.i7.i.i = and i32 %38, -16384
  %39 = inttoptr i32 %and.i.i.i7.i.i to ptr
  %preempt_count.i.i8.i.i = getelementptr inbounds %struct.thread_info, ptr %39, i32 0, i32 1
  %40 = ptrtoint ptr %preempt_count.i.i8.i.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load volatile i32, ptr %preempt_count.i.i8.i.i, align 4
  %sub.i.i.i = add i32 %41, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i8.i.i, align 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %37)
  %tobool20.not.i.i = icmp eq i32 %37, 0
  br i1 %tobool20.not.i.i, label %land.rhs.i.i, label %land.lhs.true.i.i.i_size_write.exit_crit_edge

land.lhs.true.i.i.i_size_write.exit_crit_edge:    ; preds = %land.lhs.true.i.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %i_size_write.exit

land.rhs.i.i:                                     ; preds = %land.lhs.true.i.i
  %42 = tail call i32 @llvm.read_register.i32(metadata !174) #16
  %and.i.i.i29.i = and i32 %42, -16384
  %43 = inttoptr i32 %and.i.i.i29.i to ptr
  %preempt_count.i.i30.i = getelementptr inbounds %struct.thread_info, ptr %43, i32 0, i32 1
  %44 = ptrtoint ptr %preempt_count.i.i30.i to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load volatile i32, ptr %preempt_count.i.i30.i, align 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %45)
  %cmp.i.i = icmp eq i32 %45, 0
  br i1 %cmp.i.i, label %land.rhs22.i.i, label %land.rhs.i.i.i_size_write.exit_crit_edge

land.rhs.i.i.i_size_write.exit_crit_edge:         ; preds = %land.rhs.i.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %i_size_write.exit

land.rhs22.i.i:                                   ; preds = %land.rhs.i.i
  %46 = tail call i32 @llvm.read_register.i32(metadata !174) #16
  %and.i.i.i9.i.i = and i32 %46, -16384
  %47 = inttoptr i32 %and.i.i.i9.i.i to ptr
  %preempt_count.i.i10.i.i = getelementptr inbounds %struct.thread_info, ptr %47, i32 0, i32 1
  %48 = ptrtoint ptr %preempt_count.i.i10.i.i to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load volatile i32, ptr %preempt_count.i.i10.i.i, align 4
  %add.i11.i.i = add i32 %49, 1
  store volatile i32 %add.i11.i.i, ptr %preempt_count.i.i10.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #16, !srcloc !192
  %50 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load i32, ptr %cpu.i.i, align 4
  %arrayidx46.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %51
  %52 = ptrtoint ptr %arrayidx46.i.i to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load i32, ptr %arrayidx46.i.i, align 4
  %add47.i.i = add i32 %53, ptrtoint (ptr @hardirqs_enabled to i32)
  %54 = inttoptr i32 %add47.i.i to ptr
  %55 = ptrtoint ptr %54 to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load volatile i32, ptr %54, align 4
  tail call void asm sideeffect "", "~{memory}"() #16, !srcloc !193
  %57 = tail call i32 @llvm.read_register.i32(metadata !174) #16
  %and.i.i.i12.i.i = and i32 %57, -16384
  %58 = inttoptr i32 %and.i.i.i12.i.i to ptr
  %preempt_count.i.i13.i.i = getelementptr inbounds %struct.thread_info, ptr %58, i32 0, i32 1
  %59 = ptrtoint ptr %preempt_count.i.i13.i.i to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load volatile i32, ptr %preempt_count.i.i13.i.i, align 4
  %sub.i14.i.i = add i32 %60, -1
  store volatile i32 %sub.i14.i.i, ptr %preempt_count.i.i13.i.i, align 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %56)
  %tobool54.not.i.i = icmp eq i32 %56, 0
  br i1 %tobool54.not.i.i, label %land.rhs22.i.i.i_size_write.exit_crit_edge, label %land.rhs58.i.i

land.rhs22.i.i.i_size_write.exit_crit_edge:       ; preds = %land.rhs22.i.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %i_size_write.exit

land.rhs58.i.i:                                   ; preds = %land.rhs22.i.i
  %.b1.i.i = load i1, ptr @__seqprop_assert.__already_done, align 1
  br i1 %.b1.i.i, label %land.rhs58.i.i.i_size_write.exit_crit_edge, label %if.then.i.i31, !prof !184

land.rhs58.i.i.i_size_write.exit_crit_edge:       ; preds = %land.rhs58.i.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %i_size_write.exit

if.then.i.i31:                                    ; preds = %land.rhs58.i.i
  call void @__sanitizer_cov_trace_pc() #18
  store i1 true, ptr @__seqprop_assert.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.11, i32 noundef 271, i32 noundef 9, ptr noundef null) #16
  br label %i_size_write.exit

i_size_write.exit:                                ; preds = %if.then.i.i31, %land.rhs58.i.i.i_size_write.exit_crit_edge, %land.rhs22.i.i.i_size_write.exit_crit_edge, %land.rhs.i.i.i_size_write.exit_crit_edge, %land.lhs.true.i.i.i_size_write.exit_crit_edge, %if.then9.i_size_write.exit_crit_edge
  %i_size_seqcount.i = getelementptr inbounds %struct.inode, ptr %3, i32 0, i32 23
  %61 = ptrtoint ptr %i_size_seqcount.i to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load i32, ptr %i_size_seqcount.i, align 4
  %inc.i.i.i.i = add i32 %62, 1
  store i32 %inc.i.i.i.i, ptr %i_size_seqcount.i, align 4
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #16, !srcloc !194
  %dep_map.i.i.i = getelementptr inbounds %struct.inode, ptr %3, i32 0, i32 23, i32 1
  %63 = tail call ptr @llvm.returnaddress(i32 0) #16
  %64 = ptrtoint ptr %63 to i32
  tail call void @lock_acquire(ptr noundef %dep_map.i.i.i, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 1, ptr noundef null, i32 noundef %64) #16
  %65 = ptrtoint ptr %i_size to i32
  call void @__asan_store8_noabort(i32 %65)
  store i64 %add, ptr %i_size, align 8
  tail call void @lock_release(ptr noundef %dep_map.i.i.i, i32 noundef %64) #16
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #16, !srcloc !195
  %66 = ptrtoint ptr %i_size_seqcount.i to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load i32, ptr %i_size_seqcount.i, align 4
  %inc.i.i.i = add i32 %67, 1
  store i32 %inc.i.i.i, ptr %i_size_seqcount.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #16, !srcloc !196
  %68 = tail call i32 @llvm.read_register.i32(metadata !174) #16
  %and.i.i.i26.i = and i32 %68, -16384
  %69 = inttoptr i32 %and.i.i.i26.i to ptr
  %preempt_count.i.i27.i = getelementptr inbounds %struct.thread_info, ptr %69, i32 0, i32 1
  %70 = ptrtoint ptr %preempt_count.i.i27.i to i32
  call void @__asan_load4_noabort(i32 %70)
  %71 = load volatile i32, ptr %preempt_count.i.i27.i, align 4
  %sub.i.i32 = add i32 %71, -1
  store volatile i32 %sub.i.i32, ptr %preempt_count.i.i27.i, align 4
  br label %if.end10

if.end10:                                         ; preds = %i_size_write.exit, %if.end6.if.end10_crit_edge
  %call11 = tail call zeroext i1 @set_page_dirty(ptr noundef %page) #16
  tail call void @unlock_page(ptr noundef %page) #16
  %72 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %72)
  %73 = load volatile i32, ptr %4, align 4
  %and.i.i33 = and i32 %73, 1
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and.i.i33)
  %tobool.not.i.i34 = icmp eq i32 %and.i.i33, 0
  br i1 %tobool.not.i.i34, label %if.end.i.i37, label %if.then.i.i36, !prof !184

if.then.i.i36:                                    ; preds = %if.end10
  call void @__sanitizer_cov_trace_pc() #18
  %sub.i.i35 = add i32 %73, -1
  br label %_compound_head.exit.i39

if.end.i.i37:                                     ; preds = %if.end10
  call void @__sanitizer_cov_trace_pc() #18
  %74 = ptrtoint ptr %page to i32
  br label %_compound_head.exit.i39

_compound_head.exit.i39:                          ; preds = %if.end.i.i37, %if.then.i.i36
  %retval.0.i.i38 = phi i32 [ %sub.i.i35, %if.then.i.i36 ], [ %74, %if.end.i.i37 ]
  %75 = inttoptr i32 %retval.0.i.i38 to ptr
  %_refcount.i.i.i.i.i = getelementptr inbounds %struct.page, ptr %75, i32 0, i32 3
  %call.i.i.i.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %_refcount.i.i.i.i.i, i32 noundef 4) #16
  %76 = ptrtoint ptr %_refcount.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %76)
  %77 = load volatile i32, ptr %_refcount.i.i.i.i.i, align 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %77)
  %cmp.i.i.i.i = icmp eq i32 %77, 0
  br i1 %cmp.i.i.i.i, label %if.then.i.i.i.i, label %do.end5.i.i.i.i, !prof !185

if.then.i.i.i.i:                                  ; preds = %_compound_head.exit.i39
  call void @__sanitizer_cov_trace_pc() #18
  tail call void @dump_page(ptr noundef %75, ptr noundef nonnull @.str.12) #16
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/mm.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 717, 0\0A.popsection", ""() #16, !srcloc !197
  unreachable

do.end5.i.i.i.i:                                  ; preds = %_compound_head.exit.i39
  %call.i.i.i10.i.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %_refcount.i.i.i.i.i, i32 noundef 4) #16
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #16, !srcloc !198
  tail call void @llvm.prefetch.p0(ptr %_refcount.i.i.i.i.i, i32 1, i32 3, i32 1) #16
  %78 = tail call { i32, i32 } asm sideeffect "@ atomic_sub_return\0A1:\09ldrex\09$0, [$3]\0A\09sub\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %_refcount.i.i.i.i.i, ptr %_refcount.i.i.i.i.i, i32 1, ptr elementtype(i32) %_refcount.i.i.i.i.i) #16, !srcloc !199
  %asmresult.i.i.i.i.i.i.i.i.i.i = extractvalue { i32, i32 } %78, 0
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #16, !srcloc !200
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %asmresult.i.i.i.i.i.i.i.i.i.i)
  %cmp.i.i.i.i.i.i.i = icmp eq i32 %asmresult.i.i.i.i.i.i.i.i.i.i, 0
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_page_ref_mod_and_test, i32 0, i32 1), ptr blockaddress(@simple_write_end, %if.then.i.i.i.i.i)) #16
          to label %folio_put_testzero.exit.i.i [label %if.then.i.i.i.i.i], !srcloc !201

if.then.i.i.i.i.i:                                ; preds = %do.end5.i.i.i.i
  call void @__sanitizer_cov_trace_pc() #18
  %conv.i.i.i.i.i = zext i1 %cmp.i.i.i.i.i.i.i to i32
  tail call void @__page_ref_mod_and_test(ptr noundef %75, i32 noundef -1, i32 noundef %conv.i.i.i.i.i) #16
  br label %folio_put_testzero.exit.i.i

folio_put_testzero.exit.i.i:                      ; preds = %if.then.i.i.i.i.i, %do.end5.i.i.i.i
  br i1 %cmp.i.i.i.i.i.i.i, label %if.then.i4.i, label %folio_put_testzero.exit.i.i.put_page.exit_crit_edge

folio_put_testzero.exit.i.i.put_page.exit_crit_edge: ; preds = %folio_put_testzero.exit.i.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %put_page.exit

if.then.i4.i:                                     ; preds = %folio_put_testzero.exit.i.i
  call void @__sanitizer_cov_trace_pc() #18
  tail call void @__put_page(ptr noundef %75) #16
  br label %put_page.exit

put_page.exit:                                    ; preds = %if.then.i4.i, %folio_put_testzero.exit.i.i.put_page.exit_crit_edge
  ret i32 %copied
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_fill_super(ptr noundef %s, i32 noundef %magic, ptr nocapture noundef readonly %files) #0 align 64 {
entry:
  %tmp = alloca %struct.timespec64, align 8
  %tmp34 = alloca %struct.timespec64, align 8
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %s_blocksize = getelementptr inbounds %struct.super_block, ptr %s, i32 0, i32 3
  %0 = ptrtoint ptr %s_blocksize to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 4096, ptr %s_blocksize, align 16
  %s_blocksize_bits = getelementptr inbounds %struct.super_block, ptr %s, i32 0, i32 2
  %1 = ptrtoint ptr %s_blocksize_bits to i32
  call void @__asan_store1_noabort(i32 %1)
  store i8 12, ptr %s_blocksize_bits, align 4
  %s_magic = getelementptr inbounds %struct.super_block, ptr %s, i32 0, i32 12
  %2 = ptrtoint ptr %s_magic to i32
  call void @__asan_store4_noabort(i32 %2)
  store i32 %magic, ptr %s_magic, align 4
  %s_op = getelementptr inbounds %struct.super_block, ptr %s, i32 0, i32 6
  %3 = ptrtoint ptr %s_op to i32
  call void @__asan_store4_noabort(i32 %3)
  store ptr @simple_super_operations, ptr %s_op, align 4
  %s_time_gran = getelementptr inbounds %struct.super_block, ptr %s, i32 0, i32 34
  %4 = ptrtoint ptr %s_time_gran to i32
  call void @__asan_store4_noabort(i32 %4)
  store i32 1, ptr %s_time_gran, align 4
  %call = tail call ptr @new_inode(ptr noundef %s) #16
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  %i_ino = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 11
  %5 = ptrtoint ptr %i_ino to i32
  call void @__asan_store4_noabort(i32 %5)
  store i32 1, ptr %i_ino, align 8
  %6 = ptrtoint ptr %call to i32
  call void @__asan_store2_noabort(i32 %6)
  store i16 16877, ptr %call, align 8
  %i_atime = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 15
  %i_mtime = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 16
  %i_ctime = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 17
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tmp) #16
  call void @current_time(ptr nonnull sret(%struct.timespec64) align 8 %tmp, ptr noundef nonnull %call) #16
  %7 = call ptr @memcpy(ptr %i_ctime, ptr %tmp, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tmp) #16
  %8 = call ptr @memcpy(ptr %i_mtime, ptr %i_ctime, i32 16)
  %9 = call ptr @memcpy(ptr %i_atime, ptr %i_ctime, i32 16)
  %i_op = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 7
  %10 = ptrtoint ptr %i_op to i32
  call void @__asan_store4_noabort(i32 %10)
  store ptr @simple_dir_inode_operations, ptr %i_op, align 8
  %11 = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 44
  %12 = ptrtoint ptr %11 to i32
  call void @__asan_store4_noabort(i32 %12)
  store ptr @simple_dir_operations, ptr %11, align 8
  call void @set_nlink(ptr noundef nonnull %call, i32 noundef 2) #16
  %call1 = call ptr @d_make_root(ptr noundef nonnull %call) #16
  %tobool2.not = icmp eq ptr %call1, null
  br i1 %tobool2.not, label %if.end.cleanup_crit_edge, label %for.cond.preheader

if.end.cleanup_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

for.cond.preheader:                               ; preds = %if.end
  %s_type = getelementptr inbounds %struct.super_block, ptr %s, i32 0, i32 5
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %for.cond.preheader
  %files.addr.0 = phi ptr [ %incdec.ptr, %for.inc ], [ %files, %for.cond.preheader ]
  %i.0 = phi i32 [ %inc, %for.inc ], [ 0, %for.cond.preheader ]
  %13 = ptrtoint ptr %files.addr.0 to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %files.addr.0, align 4
  %tobool5.not = icmp eq ptr %14, null
  br i1 %tobool5.not, label %for.cond.for.inc_crit_edge, label %lor.rhs

for.cond.for.inc_crit_edge:                       ; preds = %for.cond
  call void @__sanitizer_cov_trace_pc() #18
  br label %for.inc

lor.rhs:                                          ; preds = %for.cond
  %15 = ptrtoint ptr %14 to i32
  call void @__asan_load1_noabort(i32 %15)
  %16 = load i8, ptr %14, align 1
  call void @__sanitizer_cov_trace_const_cmp1(i8 0, i8 %16)
  %tobool7.not = icmp eq i8 %16, 0
  br i1 %tobool7.not, label %for.end, label %if.end11

if.end11:                                         ; preds = %lor.rhs
  call void @__sanitizer_cov_trace_const_cmp4(i32 1, i32 %i.0)
  %cmp = icmp eq i32 %i.0, 1
  br i1 %cmp, label %do.end, label %if.end11.if.end19_crit_edge, !prof !185

if.end11.if.end19_crit_edge:                      ; preds = %if.end11
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end19

do.end:                                           ; preds = %if.end11
  call void @__sanitizer_cov_trace_pc() #18
  %17 = ptrtoint ptr %s_type to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %s_type, align 32
  %19 = ptrtoint ptr %18 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %18, align 4
  %call18 = call i32 (ptr, ...) @_printk(ptr noundef nonnull @.str, ptr noundef nonnull @.str.1, ptr noundef %20) #20
  br label %if.end19

if.end19:                                         ; preds = %do.end, %if.end11.if.end19_crit_edge
  %21 = ptrtoint ptr %files.addr.0 to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %files.addr.0, align 4
  %call21 = call ptr @d_alloc_name(ptr noundef nonnull %call1, ptr noundef %22) #16
  %tobool22.not = icmp eq ptr %call21, null
  br i1 %tobool22.not, label %if.end19.out_crit_edge, label %if.end24

if.end19.out_crit_edge:                           ; preds = %if.end19
  call void @__sanitizer_cov_trace_pc() #18
  br label %out

if.end24:                                         ; preds = %if.end19
  %call25 = call ptr @new_inode(ptr noundef %s) #16
  %tobool26.not = icmp eq ptr %call25, null
  br i1 %tobool26.not, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end24
  call void @__sanitizer_cov_trace_pc() #18
  call void @dput(ptr noundef nonnull %call21) #16
  br label %out

if.end28:                                         ; preds = %if.end24
  call void @__sanitizer_cov_trace_pc() #18
  %mode = getelementptr inbounds %struct.tree_descr, ptr %files.addr.0, i32 0, i32 2
  %23 = ptrtoint ptr %mode to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %mode, align 4
  %25 = trunc i32 %24 to i16
  %conv29 = or i16 %25, -32768
  %26 = ptrtoint ptr %call25 to i32
  call void @__asan_store2_noabort(i32 %26)
  store i16 %conv29, ptr %call25, align 8
  %i_atime31 = getelementptr inbounds %struct.inode, ptr %call25, i32 0, i32 15
  %i_mtime32 = getelementptr inbounds %struct.inode, ptr %call25, i32 0, i32 16
  %i_ctime33 = getelementptr inbounds %struct.inode, ptr %call25, i32 0, i32 17
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tmp34) #16
  call void @current_time(ptr nonnull sret(%struct.timespec64) align 8 %tmp34, ptr noundef nonnull %call25) #16
  %27 = call ptr @memcpy(ptr %i_ctime33, ptr %tmp34, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tmp34) #16
  %28 = call ptr @memcpy(ptr %i_mtime32, ptr %i_ctime33, i32 16)
  %29 = call ptr @memcpy(ptr %i_atime31, ptr %i_ctime33, i32 16)
  %ops = getelementptr inbounds %struct.tree_descr, ptr %files.addr.0, i32 0, i32 1
  %30 = ptrtoint ptr %ops to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %ops, align 4
  %32 = getelementptr inbounds %struct.inode, ptr %call25, i32 0, i32 44
  %33 = ptrtoint ptr %32 to i32
  call void @__asan_store4_noabort(i32 %33)
  store ptr %31, ptr %32, align 8
  %i_ino35 = getelementptr inbounds %struct.inode, ptr %call25, i32 0, i32 11
  %34 = ptrtoint ptr %i_ino35 to i32
  call void @__asan_store4_noabort(i32 %34)
  store i32 %i.0, ptr %i_ino35, align 8
  call void @d_add(ptr noundef nonnull %call21, ptr noundef nonnull %call25) #16
  br label %for.inc

for.inc:                                          ; preds = %if.end28, %for.cond.for.inc_crit_edge
  %inc = add i32 %i.0, 1
  %incdec.ptr = getelementptr %struct.tree_descr, ptr %files.addr.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %lor.rhs
  call void @__sanitizer_cov_trace_pc() #18
  %s_root = getelementptr inbounds %struct.super_block, ptr %s, i32 0, i32 13
  %35 = ptrtoint ptr %s_root to i32
  call void @__asan_store4_noabort(i32 %35)
  store ptr %call1, ptr %s_root, align 64
  br label %cleanup

out:                                              ; preds = %if.then27, %if.end19.out_crit_edge
  call void @d_genocide(ptr noundef nonnull %call1) #16
  call void @shrink_dcache_parent(ptr noundef nonnull %call1) #16
  call void @dput(ptr noundef nonnull %call1) #16
  br label %cleanup

cleanup:                                          ; preds = %out, %for.end, %if.end.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ -12, %out ], [ 0, %for.end ], [ -12, %entry.cleanup_crit_edge ], [ -12, %if.end.cleanup_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @new_inode(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @set_nlink(ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @d_make_root(ptr noundef) local_unnamed_addr #2

; Function Attrs: cold null_pointer_is_valid
declare dso_local i32 @_printk(ptr noundef, ...) local_unnamed_addr #6

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @d_alloc_name(ptr noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @d_genocide(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @shrink_dcache_parent(ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_pin_fs(ptr noundef %type, ptr nocapture noundef %mount, ptr nocapture noundef %count) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  tail call void @_raw_spin_lock(ptr noundef nonnull @pin_fs_lock) #16
  %0 = ptrtoint ptr %mount to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %mount, align 4
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %if.then, label %entry.if.end10_crit_edge, !prof !185

entry.if.end10_crit_edge:                         ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end10

if.then:                                          ; preds = %entry
  tail call void @_raw_spin_unlock(ptr noundef nonnull @pin_fs_lock) #16
  %2 = ptrtoint ptr %type to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %type, align 4
  %call = tail call ptr @vfs_kern_mount(ptr noundef %type, i32 noundef 4194304, ptr noundef %3, ptr noundef null) #16
  %cmp.i = icmp ugt ptr %call, inttoptr (i32 -4096 to ptr)
  br i1 %cmp.i, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  call void @__sanitizer_cov_trace_pc() #18
  %4 = ptrtoint ptr %call to i32
  br label %cleanup

if.end:                                           ; preds = %if.then
  tail call void @_raw_spin_lock(ptr noundef nonnull @pin_fs_lock) #16
  %5 = ptrtoint ptr %mount to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %mount, align 4
  %tobool7.not = icmp eq ptr %6, null
  br i1 %tobool7.not, label %if.then8, label %if.end.if.end10_crit_edge

if.end.if.end10_crit_edge:                        ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end10

if.then8:                                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  %7 = ptrtoint ptr %mount to i32
  call void @__asan_store4_noabort(i32 %7)
  store ptr %call, ptr %mount, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end.if.end10_crit_edge, %entry.if.end10_crit_edge
  %mnt.0 = phi ptr [ %call, %if.end.if.end10_crit_edge ], [ %call, %if.then8 ], [ null, %entry.if.end10_crit_edge ]
  %8 = ptrtoint ptr %mount to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %mount, align 4
  %call11 = tail call ptr @mntget(ptr noundef %9) #16
  %10 = ptrtoint ptr %count to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %count, align 4
  %inc = add i32 %11, 1
  store i32 %inc, ptr %count, align 4
  tail call void @_raw_spin_unlock(ptr noundef nonnull @pin_fs_lock) #16
  tail call void @mntput(ptr noundef %mnt.0) #16
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.then5
  %retval.0 = phi i32 [ %4, %if.then5 ], [ 0, %if.end10 ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @vfs_kern_mount(ptr noundef, i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @mntget(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @mntput(ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @simple_release_fs(ptr nocapture noundef %mount, ptr nocapture noundef %count) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  tail call void @_raw_spin_lock(ptr noundef nonnull @pin_fs_lock) #16
  %0 = ptrtoint ptr %mount to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %mount, align 4
  %2 = ptrtoint ptr %count to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %count, align 4
  %dec = add i32 %3, -1
  store i32 %dec, ptr %count, align 4
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %dec)
  %tobool.not = icmp eq i32 %dec, 0
  br i1 %tobool.not, label %if.then, label %entry.if.end_crit_edge

entry.if.end_crit_edge:                           ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end

if.then:                                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  %4 = ptrtoint ptr %mount to i32
  call void @__asan_store4_noabort(i32 %4)
  store ptr null, ptr %mount, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry.if.end_crit_edge
  tail call void @_raw_spin_unlock(ptr noundef nonnull @pin_fs_lock) #16
  tail call void @mntput(ptr noundef %1) #16
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_read_from_buffer(ptr noundef %to, i32 noundef %count, ptr nocapture noundef %ppos, ptr noundef %from, i32 noundef %available) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = ptrtoint ptr %ppos to i32
  call void @__asan_load8_noabort(i32 %0)
  %1 = load i64, ptr %ppos, align 8
  call void @__sanitizer_cov_trace_const_cmp8(i64 0, i64 %1)
  %cmp = icmp slt i64 %1, 0
  br i1 %cmp, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  %conv = zext i32 %available to i64
  call void @__sanitizer_cov_trace_cmp8(i64 %1, i64 %conv)
  %cmp1.not = icmp uge i64 %1, %conv
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %count)
  %tobool.not = icmp eq i32 %count, 0
  %or.cond = or i1 %tobool.not, %cmp1.not
  br i1 %or.cond, label %if.end.cleanup_crit_edge, label %if.end4

if.end.cleanup_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %conv5 = zext i32 %count to i64
  %sub = sub nsw i64 %conv, %1
  call void @__sanitizer_cov_trace_cmp8(i64 %sub, i64 %conv5)
  %cmp7 = icmp slt i64 %sub, %conv5
  %conv12 = trunc i64 %sub to i32
  %spec.select = select i1 %cmp7, i32 %conv12, i32 %count
  %idx.ext = trunc i64 %1 to i32
  %add.ptr = getelementptr i8, ptr %from, i32 %idx.ext
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %spec.select)
  %cmp9.i.i = icmp slt i32 %spec.select, 0
  br i1 %cmp9.i.i, label %land.rhs16.i.i, label %if.then.i.i.i

land.rhs16.i.i:                                   ; preds = %if.end4
  %.b71.i.i = load i1, ptr @check_copy_size.__already_done, align 1
  br i1 %.b71.i.i, label %land.rhs16.i.i.cleanup_crit_edge, label %if.then27.i.i, !prof !184

land.rhs16.i.i.cleanup_crit_edge:                 ; preds = %land.rhs16.i.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.then27.i.i:                                    ; preds = %land.rhs16.i.i
  call void @__sanitizer_cov_trace_pc() #18
  store i1 true, ptr @check_copy_size.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.14, i32 noundef 230, i32 noundef 9, ptr noundef null) #16
  br label %cleanup

if.then.i.i.i:                                    ; preds = %if.end4
  tail call void @__check_object_size(ptr noundef %add.ptr, i32 noundef %spec.select, i1 noundef zeroext true) #16
  tail call void @__might_fault(ptr noundef nonnull @.str.16, i32 noundef 174) #16
  %call.i.i = tail call zeroext i1 @should_fail_usercopy() #16
  br i1 %call.i.i, label %if.then.i.i.i.cleanup_crit_edge, label %if.end.i.i

if.then.i.i.i.cleanup_crit_edge:                  ; preds = %if.then.i.i.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end.i.i:                                       ; preds = %if.then.i.i.i
  %2 = tail call { i32, i32 } asm ".syntax unified\0Aadds $1, $2, $3; sbcscc $1, $1, $0; movcc $0, #0", "=&r,=&r,r,Ir,0,~{cc}"(ptr %to, i32 %spec.select, i32 -1226833920) #21, !srcloc !202
  %asmresult.i.i = extractvalue { i32, i32 } %2, 0
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %asmresult.i.i)
  %cmp.i6.i = icmp eq i32 %asmresult.i.i, 0
  br i1 %cmp.i6.i, label %copy_to_user.exit, label %if.end.i.i.cleanup_crit_edge

if.end.i.i.cleanup_crit_edge:                     ; preds = %if.end.i.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

copy_to_user.exit:                                ; preds = %if.end.i.i
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %add.ptr, i32 noundef %spec.select) #16
  %call.i12.i.i = tail call i32 @arm_copy_to_user(ptr noundef %to, ptr noundef %add.ptr, i32 noundef %spec.select) #16
  call void @__sanitizer_cov_trace_cmp4(i32 %spec.select, i32 %call.i12.i.i)
  %cmp14 = icmp eq i32 %spec.select, %call.i12.i.i
  br i1 %cmp14, label %copy_to_user.exit.cleanup_crit_edge, label %if.end17

copy_to_user.exit.cleanup_crit_edge:              ; preds = %copy_to_user.exit
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end17:                                         ; preds = %copy_to_user.exit
  call void @__sanitizer_cov_trace_pc() #18
  %sub18 = sub i32 %spec.select, %call.i12.i.i
  %conv19 = zext i32 %sub18 to i64
  %add = add nuw i64 %1, %conv19
  %3 = ptrtoint ptr %ppos to i32
  call void @__asan_store8_noabort(i32 %3)
  store i64 %add, ptr %ppos, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end17, %copy_to_user.exit.cleanup_crit_edge, %if.end.i.i.cleanup_crit_edge, %if.then.i.i.i.cleanup_crit_edge, %if.then27.i.i, %land.rhs16.i.i.cleanup_crit_edge, %if.end.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ %sub18, %if.end17 ], [ -22, %entry.cleanup_crit_edge ], [ 0, %if.end.cleanup_crit_edge ], [ -14, %copy_to_user.exit.cleanup_crit_edge ], [ -14, %if.then.i.i.i.cleanup_crit_edge ], [ -14, %if.end.i.i.cleanup_crit_edge ], [ -14, %if.then27.i.i ], [ -14, %land.rhs16.i.i.cleanup_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_write_to_buffer(ptr noundef %to, i32 noundef %available, ptr nocapture noundef %ppos, ptr noundef %from, i32 noundef %count) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = ptrtoint ptr %ppos to i32
  call void @__asan_load8_noabort(i32 %0)
  %1 = load i64, ptr %ppos, align 8
  call void @__sanitizer_cov_trace_const_cmp8(i64 0, i64 %1)
  %cmp = icmp slt i64 %1, 0
  br i1 %cmp, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  %conv = zext i32 %available to i64
  call void @__sanitizer_cov_trace_cmp8(i64 %1, i64 %conv)
  %cmp1.not = icmp uge i64 %1, %conv
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %count)
  %tobool.not = icmp eq i32 %count, 0
  %or.cond = or i1 %tobool.not, %cmp1.not
  br i1 %or.cond, label %if.end.cleanup_crit_edge, label %if.end4

if.end.cleanup_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %conv5 = zext i32 %count to i64
  %sub = sub nsw i64 %conv, %1
  call void @__sanitizer_cov_trace_cmp8(i64 %sub, i64 %conv5)
  %cmp7 = icmp slt i64 %sub, %conv5
  %conv12 = trunc i64 %sub to i32
  %spec.select = select i1 %cmp7, i32 %conv12, i32 %count
  %idx.ext = trunc i64 %1 to i32
  %add.ptr = getelementptr i8, ptr %to, i32 %idx.ext
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %spec.select)
  %cmp9.i.i = icmp slt i32 %spec.select, 0
  br i1 %cmp9.i.i, label %land.rhs16.i.i, label %if.then.i.i.i

land.rhs16.i.i:                                   ; preds = %if.end4
  %.b71.i.i = load i1, ptr @check_copy_size.__already_done, align 1
  br i1 %.b71.i.i, label %land.rhs16.i.i.cleanup_crit_edge, label %if.then27.i.i, !prof !184

land.rhs16.i.i.cleanup_crit_edge:                 ; preds = %land.rhs16.i.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.then27.i.i:                                    ; preds = %land.rhs16.i.i
  call void @__sanitizer_cov_trace_pc() #18
  store i1 true, ptr @check_copy_size.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.14, i32 noundef 230, i32 noundef 9, ptr noundef null) #16
  br label %cleanup

if.then.i.i.i:                                    ; preds = %if.end4
  tail call void @__check_object_size(ptr noundef %add.ptr, i32 noundef %spec.select, i1 noundef zeroext false) #16
  tail call void @__might_fault(ptr noundef nonnull @.str.16, i32 noundef 156) #16
  %call.i.i = tail call zeroext i1 @should_fail_usercopy() #16
  br i1 %call.i.i, label %if.then.i.i.i.if.end.i.i_crit_edge, label %land.lhs.true.i.i

if.then.i.i.i.if.end.i.i_crit_edge:               ; preds = %if.then.i.i.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end.i.i

land.lhs.true.i.i:                                ; preds = %if.then.i.i.i
  %2 = tail call { i32, i32 } asm ".syntax unified\0Aadds $1, $2, $3; sbcscc $1, $1, $0; movcc $0, #0", "=&r,=&r,r,Ir,0,~{cc}"(ptr %from, i32 %spec.select, i32 -1226833920) #21, !srcloc !203
  %asmresult.i.i = extractvalue { i32, i32 } %2, 0
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %asmresult.i.i)
  %cmp.i6.i = icmp eq i32 %asmresult.i.i, 0
  br i1 %cmp.i6.i, label %if.then.i7.i, label %land.lhs.true.i.i.if.end.i.i_crit_edge, !prof !184

land.lhs.true.i.i.if.end.i.i_crit_edge:           ; preds = %land.lhs.true.i.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end.i.i

if.then.i7.i:                                     ; preds = %land.lhs.true.i.i
  call void @__sanitizer_cov_trace_pc() #18
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %add.ptr, i32 noundef %spec.select) #16
  %3 = tail call i32 @llvm.read_register.i32(metadata !174) #16
  %and.i.i.i.i.i.i = and i32 %3, -16384
  %4 = inttoptr i32 %and.i.i.i.i.i.i to ptr
  %cpu_domain.i.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %4, i32 0, i32 4
  %5 = tail call i32 asm "mrc\09p15, 0, $0, c3, c0\09@ get domain", "=r,*m"(ptr elementtype(i32) %cpu_domain.i.i.i.i.i) #13, !srcloc !204
  %and.i.i.i.i = and i32 %5, -13
  %or.i.i.i.i = or i32 %and.i.i.i.i, 4
  tail call void asm sideeffect "mcr\09p15, 0, $0, c3, c0\09@ set domain", "r,~{memory}"(i32 %or.i.i.i.i) #16, !srcloc !205
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c5, 4", "r,~{memory}"(i32 0) #16, !srcloc !206
  %call1.i.i.i = tail call i32 @arm_copy_from_user(ptr noundef %add.ptr, ptr noundef %from, i32 noundef %spec.select) #16
  tail call void asm sideeffect "mcr\09p15, 0, $0, c3, c0\09@ set domain", "r,~{memory}"(i32 %5) #16, !srcloc !205
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c5, 4", "r,~{memory}"(i32 0) #16, !srcloc !206
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i7.i, %land.lhs.true.i.i.if.end.i.i_crit_edge, %if.then.i.i.i.if.end.i.i_crit_edge
  %res.0.i.i = phi i32 [ %spec.select, %if.then.i.i.i.if.end.i.i_crit_edge ], [ %call1.i.i.i, %if.then.i7.i ], [ %spec.select, %land.lhs.true.i.i.if.end.i.i_crit_edge ]
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %res.0.i.i)
  %tobool4.not.i.i = icmp eq i32 %res.0.i.i, 0
  br i1 %tobool4.not.i.i, label %if.end.i.i.copy_from_user.exit_crit_edge, label %if.then11.i.i, !prof !184

if.end.i.i.copy_from_user.exit_crit_edge:         ; preds = %if.end.i.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %copy_from_user.exit

if.then11.i.i:                                    ; preds = %if.end.i.i
  call void @__sanitizer_cov_trace_pc() #18
  %sub.i.i = sub i32 %spec.select, %res.0.i.i
  %add.ptr.i.i = getelementptr i8, ptr %add.ptr, i32 %sub.i.i
  %6 = call ptr @memset(ptr %add.ptr.i.i, i32 0, i32 %res.0.i.i)
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.then11.i.i, %if.end.i.i.copy_from_user.exit_crit_edge
  call void @__sanitizer_cov_trace_cmp4(i32 %spec.select, i32 %res.0.i.i)
  %cmp14 = icmp eq i32 %spec.select, %res.0.i.i
  br i1 %cmp14, label %copy_from_user.exit.cleanup_crit_edge, label %if.end17

copy_from_user.exit.cleanup_crit_edge:            ; preds = %copy_from_user.exit
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end17:                                         ; preds = %copy_from_user.exit
  call void @__sanitizer_cov_trace_pc() #18
  %sub18 = sub i32 %spec.select, %res.0.i.i
  %conv19 = zext i32 %sub18 to i64
  %add = add nuw i64 %1, %conv19
  %7 = ptrtoint ptr %ppos to i32
  call void @__asan_store8_noabort(i32 %7)
  store i64 %add, ptr %ppos, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end17, %copy_from_user.exit.cleanup_crit_edge, %if.then27.i.i, %land.rhs16.i.i.cleanup_crit_edge, %if.end.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ %sub18, %if.end17 ], [ -22, %entry.cleanup_crit_edge ], [ 0, %if.end.cleanup_crit_edge ], [ -14, %copy_from_user.exit.cleanup_crit_edge ], [ -14, %if.then27.i.i ], [ -14, %land.rhs16.i.i.cleanup_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: argmemonly mustprogress nofree nosync nounwind null_pointer_is_valid sanitize_address sspstrong willreturn uwtable(sync)
define dso_local i32 @memory_read_from_buffer(ptr nocapture noundef writeonly %to, i32 noundef %count, ptr nocapture noundef %ppos, ptr nocapture noundef readonly %from, i32 noundef %available) #7 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = ptrtoint ptr %ppos to i32
  call void @__asan_load8_noabort(i32 %0)
  %1 = load i64, ptr %ppos, align 8
  call void @__sanitizer_cov_trace_const_cmp8(i64 0, i64 %1)
  %cmp = icmp slt i64 %1, 0
  br i1 %cmp, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  %conv = zext i32 %available to i64
  call void @__sanitizer_cov_trace_cmp8(i64 %1, i64 %conv)
  %cmp1.not = icmp ult i64 %1, %conv
  br i1 %cmp1.not, label %if.end4, label %if.end.cleanup_crit_edge

if.end.cleanup_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end4:                                          ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  %conv5 = zext i32 %count to i64
  %sub = sub nsw i64 %conv, %1
  call void @__sanitizer_cov_trace_cmp8(i64 %sub, i64 %conv5)
  %cmp7 = icmp slt i64 %sub, %conv5
  %conv12 = trunc i64 %sub to i32
  %spec.select = select i1 %cmp7, i32 %conv12, i32 %count
  %idx.ext = trunc i64 %1 to i32
  %add.ptr = getelementptr i8, ptr %from, i32 %idx.ext
  %2 = call ptr @memcpy(ptr %to, ptr %add.ptr, i32 %spec.select)
  %conv14 = zext i32 %spec.select to i64
  %add = add nuw i64 %1, %conv14
  %3 = ptrtoint ptr %ppos to i32
  call void @__asan_store8_noabort(i32 %3)
  store i64 %add, ptr %ppos, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.end.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ %spec.select, %if.end4 ], [ -22, %entry.cleanup_crit_edge ], [ 0, %if.end.cleanup_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @simple_transaction_set(ptr nocapture noundef readonly %file, i32 noundef %n) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  call void @__sanitizer_cov_trace_const_cmp4(i32 4092, i32 %n)
  %cmp = icmp ugt i32 %n, 4092
  br i1 %cmp, label %do.body2, label %do.end11, !prof !185

do.body2:                                         ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22fs/libfs.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 855, 0\0A.popsection", ""() #16, !srcloc !207
  unreachable

do.end11:                                         ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  %private_data = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 16
  %0 = ptrtoint ptr %private_data to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private_data, align 4
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #16, !srcloc !208
  %2 = ptrtoint ptr %1 to i32
  call void @__asan_store4_noabort(i32 %2)
  store i32 %n, ptr %1, align 4
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @simple_transaction_get(ptr nocapture noundef %file, ptr noundef %buf, i32 noundef %size) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  call void @__sanitizer_cov_trace_const_cmp4(i32 4091, i32 %size)
  %cmp = icmp ugt i32 %size, 4091
  br i1 %cmp, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  %call1 = tail call i32 @get_zeroed_page(i32 noundef 3264) #16
  %0 = inttoptr i32 %call1 to ptr
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call1)
  %tobool.not = icmp eq i32 %call1, 0
  br i1 %tobool.not, label %if.end.cleanup_crit_edge, label %if.end4

if.end.cleanup_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end4:                                          ; preds = %if.end
  tail call void @_raw_spin_lock(ptr noundef nonnull @simple_transaction_get.simple_transaction_lock) #16
  %private_data = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 16
  %1 = ptrtoint ptr %private_data to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %private_data, align 4
  %tobool5.not = icmp eq ptr %2, null
  br i1 %tobool5.not, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.end4
  call void @__sanitizer_cov_trace_pc() #18
  tail call void @_raw_spin_unlock(ptr noundef nonnull @simple_transaction_get.simple_transaction_lock) #16
  tail call void @free_pages(i32 noundef %call1, i32 noundef 0) #16
  br label %cleanup

if.end8:                                          ; preds = %if.end4
  %3 = ptrtoint ptr %private_data to i32
  call void @__asan_store4_noabort(i32 %3)
  store ptr %0, ptr %private_data, align 4
  tail call void @_raw_spin_unlock(ptr noundef nonnull @simple_transaction_get.simple_transaction_lock) #16
  %data = getelementptr inbounds %struct.simple_transaction_argresp, ptr %0, i32 0, i32 1
  tail call void @__check_object_size(ptr noundef %data, i32 noundef %size, i1 noundef zeroext false) #16
  tail call void @__might_fault(ptr noundef nonnull @.str.16, i32 noundef 156) #16
  %call.i.i = tail call zeroext i1 @should_fail_usercopy() #16
  br i1 %call.i.i, label %if.end8.if.end.i.i_crit_edge, label %land.lhs.true.i.i

if.end8.if.end.i.i_crit_edge:                     ; preds = %if.end8
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end.i.i

land.lhs.true.i.i:                                ; preds = %if.end8
  %4 = tail call { i32, i32 } asm ".syntax unified\0Aadds $1, $2, $3; sbcscc $1, $1, $0; movcc $0, #0", "=&r,=&r,r,Ir,0,~{cc}"(ptr %buf, i32 %size, i32 -1226833920) #21, !srcloc !203
  %asmresult.i.i = extractvalue { i32, i32 } %4, 0
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %asmresult.i.i)
  %cmp.i6.i = icmp eq i32 %asmresult.i.i, 0
  br i1 %cmp.i6.i, label %if.then.i7.i, label %land.lhs.true.i.i.if.end.i.i_crit_edge, !prof !184

land.lhs.true.i.i.if.end.i.i_crit_edge:           ; preds = %land.lhs.true.i.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end.i.i

if.then.i7.i:                                     ; preds = %land.lhs.true.i.i
  call void @__sanitizer_cov_trace_pc() #18
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %data, i32 noundef %size) #16
  %5 = tail call i32 @llvm.read_register.i32(metadata !174) #16
  %and.i.i.i.i.i.i = and i32 %5, -16384
  %6 = inttoptr i32 %and.i.i.i.i.i.i to ptr
  %cpu_domain.i.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %6, i32 0, i32 4
  %7 = tail call i32 asm "mrc\09p15, 0, $0, c3, c0\09@ get domain", "=r,*m"(ptr elementtype(i32) %cpu_domain.i.i.i.i.i) #13, !srcloc !204
  %and.i.i.i.i = and i32 %7, -13
  %or.i.i.i.i = or i32 %and.i.i.i.i, 4
  tail call void asm sideeffect "mcr\09p15, 0, $0, c3, c0\09@ set domain", "r,~{memory}"(i32 %or.i.i.i.i) #16, !srcloc !205
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c5, 4", "r,~{memory}"(i32 0) #16, !srcloc !206
  %call1.i.i.i = tail call i32 @arm_copy_from_user(ptr noundef %data, ptr noundef %buf, i32 noundef %size) #16
  tail call void asm sideeffect "mcr\09p15, 0, $0, c3, c0\09@ set domain", "r,~{memory}"(i32 %7) #16, !srcloc !205
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c5, 4", "r,~{memory}"(i32 0) #16, !srcloc !206
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i7.i, %land.lhs.true.i.i.if.end.i.i_crit_edge, %if.end8.if.end.i.i_crit_edge
  %res.0.i.i = phi i32 [ %size, %if.end8.if.end.i.i_crit_edge ], [ %call1.i.i.i, %if.then.i7.i ], [ %size, %land.lhs.true.i.i.if.end.i.i_crit_edge ]
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %res.0.i.i)
  %tobool4.not.i.i = icmp eq i32 %res.0.i.i, 0
  br i1 %tobool4.not.i.i, label %if.end.i.i.cleanup_crit_edge, label %if.then11.i.i, !prof !184

if.end.i.i.cleanup_crit_edge:                     ; preds = %if.end.i.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.then11.i.i:                                    ; preds = %if.end.i.i
  call void @__sanitizer_cov_trace_pc() #18
  %sub.i.i = sub i32 %size, %res.0.i.i
  %add.ptr.i.i = getelementptr i8, ptr %data, i32 %sub.i.i
  %8 = call ptr @memset(ptr %add.ptr.i.i, i32 0, i32 %res.0.i.i)
  br label %cleanup

cleanup:                                          ; preds = %if.then11.i.i, %if.end.i.i.cleanup_crit_edge, %if.then6, %if.end.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi ptr [ inttoptr (i32 -16 to ptr), %if.then6 ], [ inttoptr (i32 -27 to ptr), %entry.cleanup_crit_edge ], [ inttoptr (i32 -12 to ptr), %if.end.cleanup_crit_edge ], [ %data, %if.end.i.i.cleanup_crit_edge ], [ inttoptr (i32 -14 to ptr), %if.then11.i.i ]
  ret ptr %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @get_zeroed_page(i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @free_pages(i32 noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_transaction_read(ptr nocapture noundef readonly %file, ptr noundef %buf, i32 noundef %size, ptr nocapture noundef %pos) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %private_data = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 16
  %0 = ptrtoint ptr %private_data to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private_data, align 4
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  %data = getelementptr inbounds %struct.simple_transaction_argresp, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %1 to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %1, align 4
  %call = tail call i32 @simple_read_from_buffer(ptr noundef %buf, i32 noundef %size, ptr noundef %pos, ptr noundef %data, i32 noundef %3)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ %call, %if.end ], [ 0, %entry.cleanup_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_transaction_release(ptr nocapture readnone %inode, ptr nocapture noundef readonly %file) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %private_data = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 16
  %0 = ptrtoint ptr %private_data to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private_data, align 4
  %2 = ptrtoint ptr %1 to i32
  tail call void @free_pages(i32 noundef %2, i32 noundef 0) #16
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_attr_open(ptr noundef %inode, ptr noundef %file, ptr noundef %get, ptr noundef %set, ptr noundef %fmt) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 8) to i32))
  %0 = load ptr, ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 8), align 4
  %call7.i.i = tail call noalias align 8 ptr @kmem_cache_alloc_trace(ptr noundef %0, i32 noundef 3520, i32 noundef 156) #19
  %tobool.not = icmp eq ptr %call7.i.i, null
  br i1 %tobool.not, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  %1 = ptrtoint ptr %call7.i.i to i32
  call void @__asan_store4_noabort(i32 %1)
  store ptr %get, ptr %call7.i.i, align 8
  %set2 = getelementptr inbounds %struct.simple_attr, ptr %call7.i.i, i32 0, i32 1
  %2 = ptrtoint ptr %set2 to i32
  call void @__asan_store4_noabort(i32 %2)
  store ptr %set, ptr %set2, align 4
  %i_private = getelementptr inbounds %struct.inode, ptr %inode, i32 0, i32 54
  %3 = ptrtoint ptr %i_private to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %i_private, align 4
  %data = getelementptr inbounds %struct.simple_attr, ptr %call7.i.i, i32 0, i32 4
  %5 = ptrtoint ptr %data to i32
  call void @__asan_store4_noabort(i32 %5)
  store ptr %4, ptr %data, align 8
  %fmt3 = getelementptr inbounds %struct.simple_attr, ptr %call7.i.i, i32 0, i32 5
  %6 = ptrtoint ptr %fmt3 to i32
  call void @__asan_store4_noabort(i32 %6)
  store ptr %fmt, ptr %fmt3, align 4
  %mutex = getelementptr inbounds %struct.simple_attr, ptr %call7.i.i, i32 0, i32 6
  tail call void @__mutex_init(ptr noundef %mutex, ptr noundef nonnull @.str.4, ptr noundef nonnull @simple_attr_open.__key) #16
  %private_data = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 16
  %7 = ptrtoint ptr %private_data to i32
  call void @__asan_store4_noabort(i32 %7)
  store ptr %call7.i.i, ptr %private_data, align 4
  %call4 = tail call i32 @nonseekable_open(ptr noundef %inode, ptr noundef %file) #16
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ %call4, %if.end ], [ -12, %entry.cleanup_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @__mutex_init(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @nonseekable_open(ptr noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_attr_release(ptr nocapture readnone %inode, ptr nocapture noundef readonly %file) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %private_data = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 16
  %0 = ptrtoint ptr %private_data to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private_data, align 4
  tail call void @kfree(ptr noundef %1) #16
  ret i32 0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @kfree(ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_attr_read(ptr nocapture noundef readonly %file, ptr noundef %buf, i32 noundef %len, ptr nocapture noundef %ppos) #0 align 64 {
entry:
  %val = alloca i64, align 8
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %private_data = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 16
  %0 = ptrtoint ptr %private_data to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private_data, align 4
  %2 = ptrtoint ptr %1 to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %1, align 4
  %tobool.not = icmp eq ptr %3, null
  br i1 %tobool.not, label %entry.cleanup22_crit_edge, label %if.end

entry.cleanup22_crit_edge:                        ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup22

if.end:                                           ; preds = %entry
  %mutex = getelementptr inbounds %struct.simple_attr, ptr %1, i32 0, i32 6
  %call = tail call i32 @mutex_lock_interruptible_nested(ptr noundef %mutex, i32 noundef 0) #16
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call)
  %tobool1.not = icmp eq i32 %call, 0
  br i1 %tobool1.not, label %if.end3, label %if.end.cleanup22_crit_edge

if.end.cleanup22_crit_edge:                       ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup22

if.end3:                                          ; preds = %if.end
  %4 = ptrtoint ptr %ppos to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %ppos, align 8
  call void @__sanitizer_cov_trace_const_cmp8(i64 0, i64 %5)
  %tobool4.not = icmp eq i64 %5, 0
  br i1 %tobool4.not, label %if.end3.if.else_crit_edge, label %land.lhs.true

if.end3.if.else_crit_edge:                        ; preds = %if.end3
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.else

land.lhs.true:                                    ; preds = %if.end3
  %get_buf = getelementptr inbounds %struct.simple_attr, ptr %1, i32 0, i32 2
  %6 = ptrtoint ptr %get_buf to i32
  call void @__asan_load1_noabort(i32 %6)
  %7 = load i8, ptr %get_buf, align 4
  call void @__sanitizer_cov_trace_const_cmp1(i8 0, i8 %7)
  %tobool5.not = icmp eq i8 %7, 0
  br i1 %tobool5.not, label %land.lhs.true.if.else_crit_edge, label %if.then6

land.lhs.true.if.else_crit_edge:                  ; preds = %land.lhs.true
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.else

if.then6:                                         ; preds = %land.lhs.true
  call void @__sanitizer_cov_trace_pc() #18
  %call8 = tail call i32 @strlen(ptr noundef %get_buf) #22
  br label %if.end17

if.else:                                          ; preds = %land.lhs.true.if.else_crit_edge, %if.end3.if.else_crit_edge
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %val) #16
  %8 = ptrtoint ptr %val to i32
  call void @__asan_store8_noabort(i32 %8)
  store i64 -1, ptr %val, align 8, !annotation !209
  %9 = ptrtoint ptr %1 to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %1, align 4
  %data = getelementptr inbounds %struct.simple_attr, ptr %1, i32 0, i32 4
  %11 = ptrtoint ptr %data to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %data, align 4
  %call10 = call i32 %10(ptr noundef %12, ptr noundef nonnull %val) #16
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call10)
  %tobool11.not = icmp eq i32 %call10, 0
  br i1 %tobool11.not, label %cleanup.thread, label %cleanup

cleanup.thread:                                   ; preds = %if.else
  call void @__sanitizer_cov_trace_pc() #18
  %get_buf14 = getelementptr inbounds %struct.simple_attr, ptr %1, i32 0, i32 2
  %fmt = getelementptr inbounds %struct.simple_attr, ptr %1, i32 0, i32 5
  %13 = ptrtoint ptr %fmt to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %fmt, align 4
  %15 = ptrtoint ptr %val to i32
  call void @__asan_load8_noabort(i32 %15)
  %16 = load i64, ptr %val, align 8
  %call16 = call i32 (ptr, i32, ptr, ...) @scnprintf(ptr noundef %get_buf14, i32 noundef 24, ptr noundef %14, i64 noundef %16) #16
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %val) #16
  br label %if.end17

cleanup:                                          ; preds = %if.else
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %val) #16
  br label %out

if.end17:                                         ; preds = %cleanup.thread, %if.then6
  %size.1 = phi i32 [ %call8, %if.then6 ], [ %call16, %cleanup.thread ]
  %get_buf18 = getelementptr inbounds %struct.simple_attr, ptr %1, i32 0, i32 2
  %call20 = call i32 @simple_read_from_buffer(ptr noundef %buf, i32 noundef %len, ptr noundef %ppos, ptr noundef %get_buf18, i32 noundef %size.1)
  br label %out

out:                                              ; preds = %if.end17, %cleanup
  %ret.0 = phi i32 [ %call20, %if.end17 ], [ %call10, %cleanup ]
  call void @mutex_unlock(ptr noundef %mutex) #16
  br label %cleanup22

cleanup22:                                        ; preds = %out, %if.end.cleanup22_crit_edge, %entry.cleanup22_crit_edge
  %retval.0 = phi i32 [ %ret.0, %out ], [ -13, %entry.cleanup22_crit_edge ], [ %call, %if.end.cleanup22_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @mutex_lock_interruptible_nested(ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: argmemonly mustprogress nofree nounwind null_pointer_is_valid readonly willreturn
declare dso_local i32 @strlen(ptr nocapture noundef) local_unnamed_addr #8

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @scnprintf(ptr noundef, i32 noundef, ptr noundef, ...) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @mutex_unlock(ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @simple_attr_write(ptr nocapture noundef readonly %file, ptr noundef %buf, i32 noundef %len, ptr nocapture readnone %ppos) #0 align 64 {
entry:
  %val = alloca i64, align 8
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %val) #16
  %0 = ptrtoint ptr %val to i32
  call void @__asan_store8_noabort(i32 %0)
  store i64 -1, ptr %val, align 8, !annotation !209
  %private_data = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 16
  %1 = ptrtoint ptr %private_data to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %private_data, align 4
  %set = getelementptr inbounds %struct.simple_attr, ptr %2, i32 0, i32 1
  %3 = ptrtoint ptr %set to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %set, align 4
  %tobool.not = icmp eq ptr %4, null
  br i1 %tobool.not, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  %mutex = getelementptr inbounds %struct.simple_attr, ptr %2, i32 0, i32 6
  %call = tail call i32 @mutex_lock_interruptible_nested(ptr noundef %mutex, i32 noundef 0) #16
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call)
  %tobool1.not = icmp eq i32 %call, 0
  br i1 %tobool1.not, label %if.end3, label %if.end.cleanup_crit_edge

if.end.cleanup_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end3:                                          ; preds = %if.end
  %5 = tail call i32 @llvm.umin.i32(i32 %len, i32 23)
  %set_buf = getelementptr inbounds %struct.simple_attr, ptr %2, i32 0, i32 3
  tail call void @__check_object_size(ptr noundef %set_buf, i32 noundef %5, i1 noundef zeroext false) #16
  tail call void @__might_fault(ptr noundef nonnull @.str.16, i32 noundef 156) #16
  %call.i.i = tail call zeroext i1 @should_fail_usercopy() #16
  br i1 %call.i.i, label %if.end3.if.end.i.i_crit_edge, label %land.lhs.true.i.i

if.end3.if.end.i.i_crit_edge:                     ; preds = %if.end3
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end.i.i

land.lhs.true.i.i:                                ; preds = %if.end3
  %6 = tail call { i32, i32 } asm ".syntax unified\0Aadds $1, $2, $3; sbcscc $1, $1, $0; movcc $0, #0", "=&r,=&r,r,Ir,0,~{cc}"(ptr %buf, i32 %5, i32 -1226833920) #21, !srcloc !203
  %asmresult.i.i = extractvalue { i32, i32 } %6, 0
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %asmresult.i.i)
  %cmp.i6.i = icmp eq i32 %asmresult.i.i, 0
  br i1 %cmp.i6.i, label %if.then.i7.i, label %land.lhs.true.i.i.if.end.i.i_crit_edge, !prof !184

land.lhs.true.i.i.if.end.i.i_crit_edge:           ; preds = %land.lhs.true.i.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end.i.i

if.then.i7.i:                                     ; preds = %land.lhs.true.i.i
  call void @__sanitizer_cov_trace_pc() #18
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %set_buf, i32 noundef %5) #16
  %7 = tail call i32 @llvm.read_register.i32(metadata !174) #16
  %and.i.i.i.i.i.i = and i32 %7, -16384
  %8 = inttoptr i32 %and.i.i.i.i.i.i to ptr
  %cpu_domain.i.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %8, i32 0, i32 4
  %9 = tail call i32 asm "mrc\09p15, 0, $0, c3, c0\09@ get domain", "=r,*m"(ptr elementtype(i32) %cpu_domain.i.i.i.i.i) #13, !srcloc !204
  %and.i.i.i.i = and i32 %9, -13
  %or.i.i.i.i = or i32 %and.i.i.i.i, 4
  tail call void asm sideeffect "mcr\09p15, 0, $0, c3, c0\09@ set domain", "r,~{memory}"(i32 %or.i.i.i.i) #16, !srcloc !205
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c5, 4", "r,~{memory}"(i32 0) #16, !srcloc !206
  %call1.i.i.i = tail call i32 @arm_copy_from_user(ptr noundef %set_buf, ptr noundef %buf, i32 noundef %5) #16
  tail call void asm sideeffect "mcr\09p15, 0, $0, c3, c0\09@ set domain", "r,~{memory}"(i32 %9) #16, !srcloc !205
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c5, 4", "r,~{memory}"(i32 0) #16, !srcloc !206
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i7.i, %land.lhs.true.i.i.if.end.i.i_crit_edge, %if.end3.if.end.i.i_crit_edge
  %res.0.i.i = phi i32 [ %5, %if.end3.if.end.i.i_crit_edge ], [ %call1.i.i.i, %if.then.i7.i ], [ %5, %land.lhs.true.i.i.if.end.i.i_crit_edge ]
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %res.0.i.i)
  %tobool4.not.i.i = icmp eq i32 %res.0.i.i, 0
  br i1 %tobool4.not.i.i, label %if.end7, label %if.then11.i.i, !prof !184

if.then11.i.i:                                    ; preds = %if.end.i.i
  call void @__sanitizer_cov_trace_pc() #18
  %sub.i.i = sub i32 %5, %res.0.i.i
  %add.ptr.i.i = getelementptr i8, ptr %set_buf, i32 %sub.i.i
  %10 = call ptr @memset(ptr %add.ptr.i.i, i32 0, i32 %res.0.i.i)
  br label %out

if.end7:                                          ; preds = %if.end.i.i
  %arrayidx = getelementptr %struct.simple_attr, ptr %2, i32 0, i32 3, i32 %5
  %11 = ptrtoint ptr %arrayidx to i32
  call void @__asan_store1_noabort(i32 %11)
  store i8 0, ptr %arrayidx, align 1
  %call11 = call i32 @kstrtoull(ptr noundef %set_buf, i32 noundef 0, ptr noundef nonnull %val) #16
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call11)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %if.end7.out_crit_edge

if.end7.out_crit_edge:                            ; preds = %if.end7
  call void @__sanitizer_cov_trace_pc() #18
  br label %out

if.end14:                                         ; preds = %if.end7
  call void @__sanitizer_cov_trace_pc() #18
  %12 = ptrtoint ptr %set to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %set, align 4
  %data = getelementptr inbounds %struct.simple_attr, ptr %2, i32 0, i32 4
  %14 = ptrtoint ptr %data to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %data, align 4
  %16 = ptrtoint ptr %val to i32
  call void @__asan_load8_noabort(i32 %16)
  %17 = load i64, ptr %val, align 8
  %call16 = call i32 %13(ptr noundef %15, i64 noundef %17) #16
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call16)
  %cmp17 = icmp eq i32 %call16, 0
  %spec.select = select i1 %cmp17, i32 %len, i32 %call16
  br label %out

out:                                              ; preds = %if.end14, %if.end7.out_crit_edge, %if.then11.i.i
  %ret.0 = phi i32 [ %call11, %if.end7.out_crit_edge ], [ %spec.select, %if.end14 ], [ -14, %if.then11.i.i ]
  call void @mutex_unlock(ptr noundef %mutex) #16
  br label %cleanup

cleanup:                                          ; preds = %out, %if.end.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ %ret.0, %out ], [ -13, %entry.cleanup_crit_edge ], [ %call, %if.end.cleanup_crit_edge ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %val) #16
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @kstrtoull(ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @generic_fh_to_dentry(ptr noundef %sb, ptr nocapture noundef readonly %fid, i32 noundef %fh_len, i32 noundef %fh_type, ptr nocapture noundef readonly %get_inode) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  call void @__sanitizer_cov_trace_const_cmp4(i32 2, i32 %fh_len)
  %cmp = icmp slt i32 %fh_len, 2
  br i1 %cmp, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  %fh_type.off = add i32 %fh_type, -1
  call void @__sanitizer_cov_trace_const_cmp4(i32 2, i32 %fh_type.off)
  %switch = icmp ult i32 %fh_type.off, 2
  br i1 %switch, label %sw.bb, label %if.end.sw.epilog_crit_edge

if.end.sw.epilog_crit_edge:                       ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %sw.epilog

sw.bb:                                            ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  %0 = ptrtoint ptr %fid to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %fid, align 4
  %conv = zext i32 %1 to i64
  %gen = getelementptr inbounds %struct.anon.73, ptr %fid, i32 0, i32 1
  %2 = ptrtoint ptr %gen to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %gen, align 4
  %call = tail call ptr %get_inode(ptr noundef %sb, i64 noundef %conv, i32 noundef %3) #16
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb, %if.end.sw.epilog_crit_edge
  %inode.0 = phi ptr [ null, %if.end.sw.epilog_crit_edge ], [ %call, %sw.bb ]
  %call1 = tail call ptr @d_obtain_alias(ptr noundef %inode.0) #16
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %entry.cleanup_crit_edge
  %retval.0 = phi ptr [ %call1, %sw.epilog ], [ null, %entry.cleanup_crit_edge ]
  ret ptr %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @d_obtain_alias(ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @generic_fh_to_parent(ptr noundef %sb, ptr nocapture noundef readonly %fid, i32 noundef %fh_len, i32 noundef %fh_type, ptr nocapture noundef readonly %get_inode) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  call void @__sanitizer_cov_trace_const_cmp4(i32 3, i32 %fh_len)
  %cmp = icmp slt i32 %fh_len, 3
  br i1 %cmp, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @__sanitizer_cov_trace_const_cmp4(i32 2, i32 %fh_type)
  %cond4 = icmp eq i32 %fh_type, 2
  br i1 %cond4, label %sw.bb, label %if.end.sw.epilog_crit_edge

if.end.sw.epilog_crit_edge:                       ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %sw.epilog

sw.bb:                                            ; preds = %if.end
  %parent_ino = getelementptr inbounds %struct.anon.73, ptr %fid, i32 0, i32 2
  %0 = ptrtoint ptr %parent_ino to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %parent_ino, align 4
  %conv = zext i32 %1 to i64
  call void @__sanitizer_cov_trace_const_cmp4(i32 3, i32 %fh_len)
  %cmp1 = icmp ugt i32 %fh_len, 3
  br i1 %cmp1, label %cond.true, label %sw.bb.cond.end_crit_edge

sw.bb.cond.end_crit_edge:                         ; preds = %sw.bb
  call void @__sanitizer_cov_trace_pc() #18
  br label %cond.end

cond.true:                                        ; preds = %sw.bb
  call void @__sanitizer_cov_trace_pc() #18
  %parent_gen = getelementptr inbounds %struct.anon.73, ptr %fid, i32 0, i32 3
  %2 = ptrtoint ptr %parent_gen to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %parent_gen, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %sw.bb.cond.end_crit_edge
  %cond = phi i32 [ %3, %cond.true ], [ 0, %sw.bb.cond.end_crit_edge ]
  %call = tail call ptr %get_inode(ptr noundef %sb, i64 noundef %conv, i32 noundef %cond) #16
  br label %sw.epilog

sw.epilog:                                        ; preds = %cond.end, %if.end.sw.epilog_crit_edge
  %inode.0 = phi ptr [ %call, %cond.end ], [ null, %if.end.sw.epilog_crit_edge ]
  %call3 = tail call ptr @d_obtain_alias(ptr noundef %inode.0) #16
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %entry.cleanup_crit_edge
  %retval.0 = phi ptr [ %call3, %sw.epilog ], [ null, %entry.cleanup_crit_edge ]
  ret ptr %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @__generic_file_fsync(ptr noundef %file, i64 noundef %start, i64 noundef %end, i32 noundef %datasync) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %f_mapping = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 18
  %0 = ptrtoint ptr %f_mapping to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %f_mapping, align 4
  %2 = ptrtoint ptr %1 to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %1, align 4
  %call = tail call i32 @file_write_and_wait_range(ptr noundef %file, i64 noundef %start, i64 noundef %end) #16
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %entry.cleanup_crit_edge

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  %i_rwsem.i = getelementptr inbounds %struct.inode, ptr %3, i32 0, i32 25
  tail call void @down_write(ptr noundef %i_rwsem.i) #16
  %i_mapping = getelementptr inbounds %struct.inode, ptr %3, i32 0, i32 9
  %4 = ptrtoint ptr %i_mapping to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %i_mapping, align 8
  %call1 = tail call i32 @sync_mapping_buffers(ptr noundef %5) #16
  %i_state = getelementptr inbounds %struct.inode, ptr %3, i32 0, i32 24
  %6 = ptrtoint ptr %i_state to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %i_state, align 8
  %and = and i32 %7, 2055
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and)
  %tobool2.not = icmp eq i32 %and, 0
  br i1 %tobool2.not, label %if.end.out_crit_edge, label %if.end4

if.end.out_crit_edge:                             ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %out

if.end4:                                          ; preds = %if.end
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %datasync)
  %tobool5.not = icmp ne i32 %datasync, 0
  %and7 = and i32 %7, 2
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and7)
  %tobool8.not = icmp eq i32 %and7, 0
  %or.cond = select i1 %tobool5.not, i1 %tobool8.not, i1 false
  br i1 %or.cond, label %if.end4.out_crit_edge, label %if.end10

if.end4.out_crit_edge:                            ; preds = %if.end4
  call void @__sanitizer_cov_trace_pc() #18
  br label %out

if.end10:                                         ; preds = %if.end4
  call void @__sanitizer_cov_trace_pc() #18
  %call11 = tail call i32 @sync_inode_metadata(ptr noundef %3, i32 noundef 1) #16
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call1)
  %cmp = icmp eq i32 %call1, 0
  %spec.select = select i1 %cmp, i32 %call11, i32 %call1
  br label %out

out:                                              ; preds = %if.end10, %if.end4.out_crit_edge, %if.end.out_crit_edge
  %ret.0 = phi i32 [ %call1, %if.end.out_crit_edge ], [ %call1, %if.end4.out_crit_edge ], [ %spec.select, %if.end10 ]
  tail call void @up_write(ptr noundef %i_rwsem.i) #16
  %call14 = tail call i32 @file_check_and_advance_wb_err(ptr noundef %file) #16
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %ret.0)
  %cmp15 = icmp eq i32 %ret.0, 0
  %spec.select32 = select i1 %cmp15, i32 %call14, i32 %ret.0
  br label %cleanup

cleanup:                                          ; preds = %out, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ %spec.select32, %out ], [ %call, %entry.cleanup_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @file_write_and_wait_range(ptr noundef, i64 noundef, i64 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @sync_mapping_buffers(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @sync_inode_metadata(ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @file_check_and_advance_wb_err(ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @generic_file_fsync(ptr noundef %file, i64 noundef %start, i64 noundef %end, i32 noundef %datasync) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %f_mapping = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 18
  %0 = ptrtoint ptr %f_mapping to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %f_mapping, align 4
  %2 = ptrtoint ptr %1 to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %1, align 4
  %call = tail call i32 @__generic_file_fsync(ptr noundef %file, i64 noundef %start, i64 noundef %end, i32 noundef %datasync)
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %entry.cleanup_crit_edge

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  %i_sb = getelementptr inbounds %struct.inode, ptr %3, i32 0, i32 8
  %4 = ptrtoint ptr %i_sb to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %i_sb, align 4
  %s_bdev = getelementptr inbounds %struct.super_block, ptr %5, i32 0, i32 26
  %6 = ptrtoint ptr %s_bdev to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %s_bdev, align 4
  %call1 = tail call i32 @blkdev_issue_flush(ptr noundef %7) #16
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ %call1, %if.end ], [ %call, %entry.cleanup_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @blkdev_issue_flush(ptr noundef) local_unnamed_addr #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync)
define dso_local i32 @generic_check_addressable(i32 noundef %blocksize_bits, i64 noundef %num_blocks) #4 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %sub = add i64 %num_blocks, -1
  %sub1 = sub i32 12, %blocksize_bits
  %sh_prom = zext i32 %sub1 to i64
  %shr = lshr i64 %sub, %sh_prom
  call void @__sanitizer_cov_trace_const_cmp8(i64 0, i64 %num_blocks)
  %cmp = icmp eq i64 %num_blocks, 0
  br i1 %cmp, label %entry.cleanup_crit_edge, label %if.end, !prof !185

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  %0 = add i32 %blocksize_bits, -13
  call void @__sanitizer_cov_trace_const_cmp4(i32 -4, i32 %0)
  %1 = icmp ult i32 %0, -4
  br i1 %1, label %if.end.cleanup_crit_edge, label %if.end6

if.end.cleanup_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end6:                                          ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  %sub7 = add nsw i32 %blocksize_bits, -9
  %sh_prom8 = zext i32 %sub7 to i64
  %shr9 = lshr i64 -1, %sh_prom8
  call void @__sanitizer_cov_trace_cmp8(i64 %sub, i64 %shr9)
  %cmp10 = icmp ugt i64 %sub, %shr9
  call void @__sanitizer_cov_trace_const_cmp8(i64 4294967295, i64 %shr)
  %cmp12 = icmp ugt i64 %shr, 4294967295
  %or.cond21 = select i1 %cmp10, i1 true, i1 %cmp12
  %spec.select = select i1 %or.cond21, i32 -27, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.end.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ 0, %entry.cleanup_crit_edge ], [ -22, %if.end.cleanup_crit_edge ], [ %spec.select, %if.end6 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync)
define dso_local void @noop_invalidatepage(ptr nocapture %page, i32 %offset, i32 %length) #4 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync)
define dso_local i32 @noop_direct_IO(ptr nocapture readnone %iocb, ptr nocapture readnone %iter) #4 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  ret i32 -22
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @kfree_link(ptr noundef %p) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  tail call void @kfree(ptr noundef %p) #16
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @alloc_anon_inode(ptr noundef %s) #0 align 64 {
entry:
  %tmp11 = alloca %struct.timespec64, align 8
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call ptr @new_inode_pseudo(ptr noundef %s) #16
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  %call2 = tail call i32 @get_next_ino() #16
  %i_ino = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 11
  %0 = ptrtoint ptr %i_ino to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 %call2, ptr %i_ino, align 8
  %i_mapping = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 9
  %1 = ptrtoint ptr %i_mapping to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %i_mapping, align 8
  %a_ops = getelementptr inbounds %struct.address_space, ptr %2, i32 0, i32 9
  %3 = ptrtoint ptr %a_ops to i32
  call void @__asan_store4_noabort(i32 %3)
  store ptr @alloc_anon_inode.anon_aops, ptr %a_ops, align 4
  %i_state = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 24
  %4 = ptrtoint ptr %i_state to i32
  call void @__asan_store4_noabort(i32 %4)
  store i32 7, ptr %i_state, align 8
  %5 = ptrtoint ptr %call to i32
  call void @__asan_store2_noabort(i32 %5)
  store i16 384, ptr %call, align 8
  %i_uid = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 2
  %6 = tail call i32 @llvm.read_register.i32(metadata !174) #16
  %and.i = and i32 %6, -16384
  %7 = inttoptr i32 %and.i to ptr
  %task = getelementptr inbounds %struct.thread_info, ptr %7, i32 0, i32 2
  %8 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %task, align 8
  %cred = getelementptr inbounds %struct.task_struct, ptr %9, i32 0, i32 99
  %10 = ptrtoint ptr %cred to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %cred, align 16
  %fsuid = getelementptr inbounds %struct.cred, ptr %11, i32 0, i32 10
  %12 = ptrtoint ptr %fsuid to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %fsuid, align 4
  %14 = ptrtoint ptr %i_uid to i32
  call void @__asan_store4_noabort(i32 %14)
  store i32 %13, ptr %i_uid, align 4
  %i_gid = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 3
  %15 = load ptr, ptr %task, align 8
  %cred10 = getelementptr inbounds %struct.task_struct, ptr %15, i32 0, i32 99
  %16 = ptrtoint ptr %cred10 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %cred10, align 16
  %fsgid = getelementptr inbounds %struct.cred, ptr %17, i32 0, i32 11
  %18 = ptrtoint ptr %fsgid to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %fsgid, align 4
  %20 = ptrtoint ptr %i_gid to i32
  call void @__asan_store4_noabort(i32 %20)
  store i32 %19, ptr %i_gid, align 8
  %i_flags = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 4
  %21 = ptrtoint ptr %i_flags to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load i32, ptr %i_flags, align 4
  %or = or i32 %22, 512
  store i32 %or, ptr %i_flags, align 4
  %i_atime = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 15
  %i_mtime = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 16
  %i_ctime = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 17
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tmp11) #16
  call void @current_time(ptr nonnull sret(%struct.timespec64) align 8 %tmp11, ptr noundef nonnull %call) #16
  %23 = call ptr @memcpy(ptr %i_ctime, ptr %tmp11, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tmp11) #16
  %24 = call ptr @memcpy(ptr %i_mtime, ptr %i_ctime, i32 16)
  %25 = call ptr @memcpy(ptr %i_atime, ptr %i_ctime, i32 16)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry.cleanup_crit_edge
  %retval.0 = phi ptr [ %call, %if.end ], [ inttoptr (i32 -12 to ptr), %entry.cleanup_crit_edge ]
  ret ptr %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @new_inode_pseudo(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @get_next_ino() local_unnamed_addr #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync)
define dso_local i32 @simple_nosetlease(ptr nocapture readnone %filp, i32 %arg, ptr nocapture readnone %flp, ptr nocapture readnone %priv) #4 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  ret i32 -22
}

; Function Attrs: argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync)
define dso_local ptr @simple_get_link(ptr nocapture readnone %dentry, ptr nocapture noundef readonly %inode, ptr nocapture readnone %done) #9 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = getelementptr inbounds %struct.inode, ptr %inode, i32 0, i32 48
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %0, align 4
  ret ptr %2
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @make_empty_dir_inode(ptr noundef %inode) local_unnamed_addr #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  tail call void @set_nlink(ptr noundef %inode, i32 noundef 2) #16
  %0 = ptrtoint ptr %inode to i32
  call void @__asan_store2_noabort(i32 %0)
  store i16 16749, ptr %inode, align 8
  %i_uid = getelementptr inbounds %struct.inode, ptr %inode, i32 0, i32 2
  %1 = ptrtoint ptr %i_uid to i32
  call void @__asan_store4_noabort(i32 %1)
  store i32 0, ptr %i_uid, align 4
  %i_gid = getelementptr inbounds %struct.inode, ptr %inode, i32 0, i32 3
  %2 = ptrtoint ptr %i_gid to i32
  call void @__asan_store4_noabort(i32 %2)
  store i32 0, ptr %i_gid, align 8
  %i_rdev = getelementptr inbounds %struct.inode, ptr %inode, i32 0, i32 13
  %3 = ptrtoint ptr %i_rdev to i32
  call void @__asan_store4_noabort(i32 %3)
  store i32 0, ptr %i_rdev, align 8
  %i_size = getelementptr inbounds %struct.inode, ptr %inode, i32 0, i32 14
  %4 = ptrtoint ptr %i_size to i32
  call void @__asan_store8_noabort(i32 %4)
  store i64 0, ptr %i_size, align 8
  %i_blkbits = getelementptr inbounds %struct.inode, ptr %inode, i32 0, i32 20
  %5 = ptrtoint ptr %i_blkbits to i32
  call void @__asan_store1_noabort(i32 %5)
  store i8 12, ptr %i_blkbits, align 2
  %i_blocks = getelementptr inbounds %struct.inode, ptr %inode, i32 0, i32 22
  %6 = ptrtoint ptr %i_blocks to i32
  call void @__asan_store8_noabort(i32 %6)
  store i64 0, ptr %i_blocks, align 8
  %i_op = getelementptr inbounds %struct.inode, ptr %inode, i32 0, i32 7
  %7 = ptrtoint ptr %i_op to i32
  call void @__asan_store4_noabort(i32 %7)
  store ptr @empty_dir_inode_operations, ptr %i_op, align 8
  %i_opflags = getelementptr inbounds %struct.inode, ptr %inode, i32 0, i32 1
  %8 = ptrtoint ptr %i_opflags to i32
  call void @__asan_load2_noabort(i32 %8)
  %9 = load i16, ptr %i_opflags, align 2
  %10 = and i16 %9, -9
  store i16 %10, ptr %i_opflags, align 2
  %11 = getelementptr inbounds %struct.inode, ptr %inode, i32 0, i32 44
  %12 = ptrtoint ptr %11 to i32
  call void @__asan_store4_noabort(i32 %12)
  store ptr @empty_dir_operations, ptr %11, align 8
  ret void
}

; Function Attrs: argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync)
define dso_local zeroext i1 @is_empty_dir_inode(ptr nocapture noundef readonly %inode) local_unnamed_addr #9 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = getelementptr inbounds %struct.inode, ptr %inode, i32 0, i32 44
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %0, align 8
  %cmp = icmp eq ptr %2, @empty_dir_operations
  br i1 %cmp, label %land.rhs, label %entry.land.end_crit_edge

entry.land.end_crit_edge:                         ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %land.end

land.rhs:                                         ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  %i_op = getelementptr inbounds %struct.inode, ptr %inode, i32 0, i32 7
  %3 = ptrtoint ptr %i_op to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %i_op, align 8
  %cmp1 = icmp eq ptr %4, @empty_dir_inode_operations
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry.land.end_crit_edge
  %5 = phi i1 [ false, %entry.land.end_crit_edge ], [ %cmp1, %land.rhs ]
  ret i1 %5
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @generic_set_encrypted_ci_d_ops(ptr noundef %dentry) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = ptrtoint ptr %dentry to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %dentry, align 8
  %and = and i32 %1, 33554432
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and)
  %tobool.not = icmp eq i32 %and, 0
  %d_sb = getelementptr inbounds %struct.dentry, ptr %dentry, i32 0, i32 9
  %2 = ptrtoint ptr %d_sb to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %d_sb, align 4
  %s_encoding = getelementptr inbounds %struct.super_block, ptr %3, i32 0, i32 22
  %4 = ptrtoint ptr %s_encoding to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %s_encoding, align 64
  %tobool1.not = icmp eq ptr %5, null
  %6 = select i1 %tobool.not, i1 %tobool1.not, i1 false
  br i1 %6, label %entry.cleanup_crit_edge, label %cleanup.sink.split

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

cleanup.sink.split:                               ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  %brmerge = select i1 %tobool.not, i1 true, i1 %tobool1.not
  %generic_encrypted_ci_dentry_ops.mux = select i1 %brmerge, ptr @generic_encrypted_dentry_ops, ptr @generic_encrypted_ci_dentry_ops
  %generic_encrypted_ci_dentry_ops.mux.mux = select i1 %tobool.not, ptr @generic_ci_dentry_ops, ptr %generic_encrypted_ci_dentry_ops.mux
  tail call void @d_set_d_op(ptr noundef %dentry, ptr noundef nonnull %generic_encrypted_ci_dentry_ops.mux.mux) #16
  br label %cleanup

cleanup:                                          ; preds = %cleanup.sink.split, %entry.cleanup_crit_edge
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @down_read(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @__might_resched(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__cond_resched() local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @_raw_spin_lock(ptr noundef) local_unnamed_addr #2 section ".spinlock.text"

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @__list_del_entry_valid(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @__list_add_valid(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @_raw_spin_unlock(ptr noundef) local_unnamed_addr #2 section ".spinlock.text"

; Function Attrs: null_pointer_is_valid
declare dso_local void @up_read(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @lockref_get(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @down_write(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @up_write(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @warn_slowpath_fmt(ptr noundef, i32 noundef, i32 noundef, ptr noundef, ...) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @fsnotify(i32 noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @__kasan_check_read(ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid allocsize(2)
declare dso_local noalias ptr @kmem_cache_alloc_trace(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #10

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @pseudo_fs_free(ptr nocapture noundef readonly %fc) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %fs_private = getelementptr inbounds %struct.fs_context, ptr %fc, i32 0, i32 3
  %0 = ptrtoint ptr %fs_private to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %fs_private, align 4
  tail call void @kfree(ptr noundef %1) #16
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @pseudo_fs_get_tree(ptr noundef %fc) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call i32 @get_tree_nodev(ptr noundef %fc, ptr noundef nonnull @pseudo_fs_fill_super) #16
  ret i32 %call
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @get_tree_nodev(ptr noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @pseudo_fs_fill_super(ptr noundef %s, ptr nocapture noundef readonly %fc) #0 align 64 {
entry:
  %tmp = alloca %struct.timespec64, align 8
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %fs_private = getelementptr inbounds %struct.fs_context, ptr %fc, i32 0, i32 3
  %0 = ptrtoint ptr %fs_private to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %fs_private, align 4
  %s_maxbytes = getelementptr inbounds %struct.super_block, ptr %s, i32 0, i32 4
  %2 = ptrtoint ptr %s_maxbytes to i32
  call void @__asan_store8_noabort(i32 %2)
  store i64 17592186040320, ptr %s_maxbytes, align 8
  %s_blocksize = getelementptr inbounds %struct.super_block, ptr %s, i32 0, i32 3
  %3 = ptrtoint ptr %s_blocksize to i32
  call void @__asan_store4_noabort(i32 %3)
  store i32 4096, ptr %s_blocksize, align 16
  %s_blocksize_bits = getelementptr inbounds %struct.super_block, ptr %s, i32 0, i32 2
  %4 = ptrtoint ptr %s_blocksize_bits to i32
  call void @__asan_store1_noabort(i32 %4)
  store i8 12, ptr %s_blocksize_bits, align 4
  %magic = getelementptr inbounds %struct.pseudo_fs_context, ptr %1, i32 0, i32 3
  %5 = ptrtoint ptr %magic to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %magic, align 4
  %s_magic = getelementptr inbounds %struct.super_block, ptr %s, i32 0, i32 12
  %7 = ptrtoint ptr %s_magic to i32
  call void @__asan_store4_noabort(i32 %7)
  store i32 %6, ptr %s_magic, align 4
  %8 = ptrtoint ptr %1 to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %1, align 4
  %tobool.not = icmp eq ptr %9, null
  %.simple_super_operations = select i1 %tobool.not, ptr @simple_super_operations, ptr %9
  %s_op = getelementptr inbounds %struct.super_block, ptr %s, i32 0, i32 6
  %10 = ptrtoint ptr %s_op to i32
  call void @__asan_store4_noabort(i32 %10)
  store ptr %.simple_super_operations, ptr %s_op, align 4
  %xattr = getelementptr inbounds %struct.pseudo_fs_context, ptr %1, i32 0, i32 1
  %11 = ptrtoint ptr %xattr to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %xattr, align 4
  %s_xattr = getelementptr inbounds %struct.super_block, ptr %s, i32 0, i32 18
  %13 = ptrtoint ptr %s_xattr to i32
  call void @__asan_store4_noabort(i32 %13)
  store ptr %12, ptr %s_xattr, align 16
  %s_time_gran = getelementptr inbounds %struct.super_block, ptr %s, i32 0, i32 34
  %14 = ptrtoint ptr %s_time_gran to i32
  call void @__asan_store4_noabort(i32 %14)
  store i32 1, ptr %s_time_gran, align 4
  %call = tail call ptr @new_inode(ptr noundef %s) #16
  %tobool1.not = icmp eq ptr %call, null
  br i1 %tobool1.not, label %entry.cleanup_crit_edge, label %if.end

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %entry
  %i_ino = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 11
  %15 = ptrtoint ptr %i_ino to i32
  call void @__asan_store4_noabort(i32 %15)
  store i32 1, ptr %i_ino, align 8
  %16 = ptrtoint ptr %call to i32
  call void @__asan_store2_noabort(i32 %16)
  store i16 16768, ptr %call, align 8
  %i_atime = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 15
  %i_mtime = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 16
  %i_ctime = getelementptr inbounds %struct.inode, ptr %call, i32 0, i32 17
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tmp) #16
  call void @current_time(ptr nonnull sret(%struct.timespec64) align 8 %tmp, ptr noundef nonnull %call) #16
  %17 = call ptr @memcpy(ptr %i_ctime, ptr %tmp, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tmp) #16
  %18 = call ptr @memcpy(ptr %i_mtime, ptr %i_ctime, i32 16)
  %19 = call ptr @memcpy(ptr %i_atime, ptr %i_ctime, i32 16)
  %call2 = call ptr @d_make_root(ptr noundef nonnull %call) #16
  %s_root = getelementptr inbounds %struct.super_block, ptr %s, i32 0, i32 13
  %20 = ptrtoint ptr %s_root to i32
  call void @__asan_store4_noabort(i32 %20)
  store ptr %call2, ptr %s_root, align 64
  %tobool4.not = icmp eq ptr %call2, null
  br i1 %tobool4.not, label %if.end.cleanup_crit_edge, label %if.end6

if.end.cleanup_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end6:                                          ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  %dops = getelementptr inbounds %struct.pseudo_fs_context, ptr %1, i32 0, i32 2
  %21 = ptrtoint ptr %dops to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %dops, align 4
  %s_d_op = getelementptr inbounds %struct.super_block, ptr %s, i32 0, i32 45
  %23 = ptrtoint ptr %s_d_op to i32
  call void @__asan_store4_noabort(i32 %23)
  store ptr %22, ptr %s_d_op, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.end.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ 0, %if.end6 ], [ -12, %entry.cleanup_crit_edge ], [ -12, %if.end.cleanup_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @__mark_inode_dirty(ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @dump_page(ptr noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @flush_dcache_page(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @unlock_page(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @__kmap_local_page_prot(ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @kunmap_local_indexed(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @_set_bit(i32 noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @set_page_dirty(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @lock_acquire(ptr noundef, i32 noundef, i32 noundef, i32 noundef, i32 noundef, ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: nocallback nofree nosync nounwind readnone willreturn
declare ptr @llvm.returnaddress(i32 immarg) #11

; Function Attrs: null_pointer_is_valid
declare dso_local void @lock_release(ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @__put_page(ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @__page_ref_mod_and_test(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @__kasan_check_write(ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: inaccessiblemem_or_argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.prefetch.p0(ptr nocapture readonly, i32 immarg, i32 immarg, i32) #12

; Function Attrs: null_pointer_is_valid
declare dso_local void @__check_object_size(ptr noundef, i32 noundef, i1 noundef zeroext) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local void @__might_fault(ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @should_fail_usercopy() local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @arm_copy_to_user(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @arm_copy_from_user(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #2

; Function Attrs: nounwind readonly
declare i32 @llvm.read_register.i32(metadata) #13

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync)
define internal nonnull ptr @empty_dir_lookup(ptr nocapture noundef readnone %dir, ptr nocapture noundef readnone %dentry, i32 noundef %flags) #4 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  ret ptr inttoptr (i32 -2 to ptr)
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @generic_permission(ptr noundef, ptr noundef, i32 noundef) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync)
define internal i32 @empty_dir_setattr(ptr nocapture noundef readnone %mnt_userns, ptr nocapture noundef readnone %dentry, ptr nocapture noundef readnone %attr) #4 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  ret i32 -1
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @empty_dir_getattr(ptr nocapture noundef readnone %mnt_userns, ptr nocapture noundef readonly %path, ptr noundef %stat, i32 noundef %request_mask, i32 noundef %query_flags) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %dentry = getelementptr inbounds %struct.path, ptr %path, i32 0, i32 1
  %0 = ptrtoint ptr %dentry to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %dentry, align 4
  %d_inode.i = getelementptr inbounds %struct.dentry, ptr %1, i32 0, i32 5
  %2 = ptrtoint ptr %d_inode.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %d_inode.i, align 8
  tail call void @generic_fillattr(ptr noundef nonnull @init_user_ns, ptr noundef %3, ptr noundef %stat) #16
  ret i32 0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync)
define internal i32 @empty_dir_listxattr(ptr nocapture noundef readnone %dentry, ptr nocapture noundef readnone %list, i32 noundef %size) #4 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  ret i32 -95
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i64 @empty_dir_llseek(ptr noundef %file, i64 noundef %offset, i32 noundef %whence) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call i64 @generic_file_llseek_size(ptr noundef %file, i64 noundef %offset, i32 noundef %whence, i64 noundef 2, i64 noundef 2) #16
  ret i64 %call
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @empty_dir_readdir(ptr nocapture noundef readonly %file, ptr noundef %ctx) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %pos.i = getelementptr inbounds %struct.dir_context, ptr %ctx, i32 0, i32 1
  %0 = ptrtoint ptr %pos.i to i32
  call void @__asan_load8_noabort(i32 %0)
  %1 = load i64, ptr %pos.i, align 8
  call void @__sanitizer_cov_trace_switch(i64 %1, ptr @__sancov_gen_cov_switch_values.18)
  switch i64 %1, label %entry.dir_emit_dots.exit_crit_edge [
    i64 0, label %if.then.i
    i64 1, label %entry.if.then6.i_crit_edge
  ]

entry.if.then6.i_crit_edge:                       ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.then6.i

entry.dir_emit_dots.exit_crit_edge:               ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %dir_emit_dots.exit

if.then.i:                                        ; preds = %entry
  %2 = ptrtoint ptr %ctx to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %ctx, align 8
  %dentry.i.i = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 1, i32 1
  %4 = ptrtoint ptr %dentry.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %dentry.i.i, align 4
  %d_inode.i.i = getelementptr inbounds %struct.dentry, ptr %5, i32 0, i32 5
  %6 = ptrtoint ptr %d_inode.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %d_inode.i.i, align 8
  %i_ino.i.i = getelementptr inbounds %struct.inode, ptr %7, i32 0, i32 11
  %8 = ptrtoint ptr %i_ino.i.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %i_ino.i.i, align 8
  %conv.i.i = zext i32 %9 to i64
  %call.i.i = tail call i32 %3(ptr noundef %ctx, ptr noundef nonnull @.str.6, i32 noundef 1, i64 noundef 0, i64 noundef %conv.i.i, i32 noundef 4) #16
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call.i.i)
  %cmp.i.i = icmp eq i32 %call.i.i, 0
  br i1 %cmp.i.i, label %if.end3.thread.i, label %if.then.i.dir_emit_dots.exit_crit_edge

if.then.i.dir_emit_dots.exit_crit_edge:           ; preds = %if.then.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %dir_emit_dots.exit

if.end3.thread.i:                                 ; preds = %if.then.i
  call void @__sanitizer_cov_trace_pc() #18
  %10 = ptrtoint ptr %pos.i to i32
  call void @__asan_store8_noabort(i32 %10)
  store i64 1, ptr %pos.i, align 8
  br label %if.then6.i

if.then6.i:                                       ; preds = %if.end3.thread.i, %entry.if.then6.i_crit_edge
  %11 = ptrtoint ptr %ctx to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %ctx, align 8
  %dentry.i19.i = getelementptr inbounds %struct.file, ptr %file, i32 0, i32 1, i32 1
  %13 = ptrtoint ptr %dentry.i19.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %dentry.i19.i, align 4
  %d_lockref.i.i.i = getelementptr inbounds %struct.dentry, ptr %14, i32 0, i32 7
  tail call void @_raw_spin_lock(ptr noundef %d_lockref.i.i.i) #16
  %d_parent.i.i.i = getelementptr inbounds %struct.dentry, ptr %14, i32 0, i32 3
  %15 = ptrtoint ptr %d_parent.i.i.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %d_parent.i.i.i, align 8
  %d_inode.i.i.i = getelementptr inbounds %struct.dentry, ptr %16, i32 0, i32 5
  %17 = ptrtoint ptr %d_inode.i.i.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %d_inode.i.i.i, align 8
  %i_ino.i.i.i = getelementptr inbounds %struct.inode, ptr %18, i32 0, i32 11
  %19 = ptrtoint ptr %i_ino.i.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %i_ino.i.i.i, align 8
  tail call void @_raw_spin_unlock(ptr noundef %d_lockref.i.i.i) #16
  %conv.i20.i = zext i32 %20 to i64
  %call1.i.i = tail call i32 %12(ptr noundef %ctx, ptr noundef nonnull @.str.7, i32 noundef 2, i64 noundef 1, i64 noundef %conv.i20.i, i32 noundef 4) #16
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call1.i.i)
  %cmp.i21.i = icmp eq i32 %call1.i.i, 0
  br i1 %cmp.i21.i, label %if.end9.i, label %if.then6.i.dir_emit_dots.exit_crit_edge

if.then6.i.dir_emit_dots.exit_crit_edge:          ; preds = %if.then6.i
  call void @__sanitizer_cov_trace_pc() #18
  br label %dir_emit_dots.exit

if.end9.i:                                        ; preds = %if.then6.i
  call void @__sanitizer_cov_trace_pc() #18
  %21 = ptrtoint ptr %pos.i to i32
  call void @__asan_store8_noabort(i32 %21)
  store i64 2, ptr %pos.i, align 8
  br label %dir_emit_dots.exit

dir_emit_dots.exit:                               ; preds = %if.end9.i, %if.then6.i.dir_emit_dots.exit_crit_edge, %if.then.i.dir_emit_dots.exit_crit_edge, %entry.dir_emit_dots.exit_crit_edge
  ret i32 0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @generic_file_llseek_size(ptr noundef, i64 noundef, i32 noundef, i64 noundef, i64 noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @fscrypt_d_revalidate(ptr noundef, i32 noundef) #2

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @generic_ci_d_hash(ptr noundef %dentry, ptr noundef %str) #0 align 64 {
entry:
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %d_inode = getelementptr inbounds %struct.dentry, ptr %dentry, i32 0, i32 5
  %0 = ptrtoint ptr %d_inode to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile ptr, ptr %d_inode, align 8
  %d_sb = getelementptr inbounds %struct.dentry, ptr %dentry, i32 0, i32 9
  %2 = ptrtoint ptr %d_sb to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %d_sb, align 4
  %s_encoding = getelementptr inbounds %struct.super_block, ptr %3, i32 0, i32 22
  %4 = ptrtoint ptr %s_encoding to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %s_encoding, align 64
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %entry.cleanup_crit_edge, label %lor.lhs.false

entry.cleanup_crit_edge:                          ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %i_flags.i = getelementptr inbounds %struct.inode, ptr %1, i32 0, i32 4
  %6 = ptrtoint ptr %i_flags.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %i_flags.i, align 4
  %and.i = and i32 %7, 32768
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and.i)
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %lor.lhs.false.cleanup_crit_edge, label %needs_casefold.exit

lor.lhs.false.cleanup_crit_edge:                  ; preds = %lor.lhs.false
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

needs_casefold.exit:                              ; preds = %lor.lhs.false
  %i_sb.i = getelementptr inbounds %struct.inode, ptr %1, i32 0, i32 8
  %8 = ptrtoint ptr %i_sb.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %i_sb.i, align 4
  %s_encoding.i = getelementptr inbounds %struct.super_block, ptr %9, i32 0, i32 22
  %10 = ptrtoint ptr %s_encoding.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %s_encoding.i, align 64
  %tobool1.i.not = icmp eq ptr %11, null
  br i1 %tobool1.i.not, label %needs_casefold.exit.cleanup_crit_edge, label %if.end

needs_casefold.exit.cleanup_crit_edge:            ; preds = %needs_casefold.exit
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end:                                           ; preds = %needs_casefold.exit
  %call1 = tail call i32 @utf8_casefold_hash(ptr noundef %5, ptr noundef %dentry, ptr noundef %str) #16
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %call1)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %land.lhs.true, label %if.end.if.end4_crit_edge

if.end.if.end4_crit_edge:                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end4

land.lhs.true:                                    ; preds = %if.end
  %s_encoding_flags = getelementptr inbounds %struct.super_block, ptr %3, i32 0, i32 23
  %12 = ptrtoint ptr %s_encoding_flags to i32
  call void @__asan_load2_noabort(i32 %12)
  %13 = load i16, ptr %s_encoding_flags, align 4
  %14 = and i16 %13, 1
  call void @__sanitizer_cov_trace_const_cmp2(i16 0, i16 %14)
  %tobool2.not = icmp eq i16 %14, 0
  br i1 %tobool2.not, label %land.lhs.true.if.end4_crit_edge, label %land.lhs.true.cleanup_crit_edge

land.lhs.true.cleanup_crit_edge:                  ; preds = %land.lhs.true
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

land.lhs.true.if.end4_crit_edge:                  ; preds = %land.lhs.true
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end4

if.end4:                                          ; preds = %land.lhs.true.if.end4_crit_edge, %if.end.if.end4_crit_edge
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %land.lhs.true.cleanup_crit_edge, %needs_casefold.exit.cleanup_crit_edge, %lor.lhs.false.cleanup_crit_edge, %entry.cleanup_crit_edge
  %retval.0 = phi i32 [ 0, %if.end4 ], [ 0, %needs_casefold.exit.cleanup_crit_edge ], [ 0, %entry.cleanup_crit_edge ], [ -22, %land.lhs.true.cleanup_crit_edge ], [ 0, %lor.lhs.false.cleanup_crit_edge ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @generic_ci_d_compare(ptr noundef %dentry, i32 noundef %len, ptr noundef %str, ptr noundef %name) #0 align 64 {
entry:
  %qstr = alloca %struct.qstr, align 8
  %strbuf = alloca [36 x i8], align 1
  call void @__sanitizer_cov_trace_pc() #18
  call void @llvm.arm.gnu.eabi.mcount()
  %d_parent = getelementptr inbounds %struct.dentry, ptr %dentry, i32 0, i32 3
  %0 = ptrtoint ptr %d_parent to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile ptr, ptr %d_parent, align 8
  %d_inode = getelementptr inbounds %struct.dentry, ptr %1, i32 0, i32 5
  %2 = ptrtoint ptr %d_inode to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile ptr, ptr %d_inode, align 8
  %d_sb = getelementptr inbounds %struct.dentry, ptr %dentry, i32 0, i32 9
  %4 = ptrtoint ptr %d_sb to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %d_sb, align 4
  %s_encoding = getelementptr inbounds %struct.super_block, ptr %5, i32 0, i32 22
  %6 = ptrtoint ptr %s_encoding to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %s_encoding, align 64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %qstr) #16
  %8 = getelementptr inbounds i8, ptr %qstr, i32 8
  %9 = ptrtoint ptr %8 to i32
  call void @__asan_store8_noabort(i32 %9)
  store i64 -1, ptr %8, align 8
  %10 = ptrtoint ptr %qstr to i32
  call void @__asan_store4_noabort(i32 %10)
  store i32 %len, ptr %qstr, align 8
  %hash = getelementptr inbounds %struct.anon.15, ptr %qstr, i32 0, i32 1
  %11 = ptrtoint ptr %hash to i32
  call void @__asan_store4_noabort(i32 %11)
  store i32 0, ptr %hash, align 4
  %name6 = getelementptr inbounds %struct.qstr, ptr %qstr, i32 0, i32 1
  %12 = ptrtoint ptr %name6 to i32
  call void @__asan_store4_noabort(i32 %12)
  store ptr %str, ptr %name6, align 8
  call void @llvm.lifetime.start.p0(i64 36, ptr nonnull %strbuf) #16
  %13 = call ptr @memset(ptr %strbuf, i32 255, i32 36)
  %tobool.not = icmp eq ptr %3, null
  br i1 %tobool.not, label %entry.fallback_crit_edge, label %lor.lhs.false

entry.fallback_crit_edge:                         ; preds = %entry
  call void @__sanitizer_cov_trace_pc() #18
  br label %fallback

lor.lhs.false:                                    ; preds = %entry
  %i_flags.i = getelementptr inbounds %struct.inode, ptr %3, i32 0, i32 4
  %14 = ptrtoint ptr %i_flags.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %i_flags.i, align 4
  %and.i = and i32 %15, 32768
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %and.i)
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %lor.lhs.false.fallback_crit_edge, label %needs_casefold.exit

lor.lhs.false.fallback_crit_edge:                 ; preds = %lor.lhs.false
  call void @__sanitizer_cov_trace_pc() #18
  br label %fallback

needs_casefold.exit:                              ; preds = %lor.lhs.false
  %i_sb.i = getelementptr inbounds %struct.inode, ptr %3, i32 0, i32 8
  %16 = ptrtoint ptr %i_sb.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %i_sb.i, align 4
  %s_encoding.i = getelementptr inbounds %struct.super_block, ptr %17, i32 0, i32 22
  %18 = ptrtoint ptr %s_encoding.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load ptr, ptr %s_encoding.i, align 64
  %tobool1.i.not = icmp eq ptr %19, null
  br i1 %tobool1.i.not, label %needs_casefold.exit.fallback_crit_edge, label %if.end

needs_casefold.exit.fallback_crit_edge:           ; preds = %needs_casefold.exit
  call void @__sanitizer_cov_trace_pc() #18
  br label %fallback

if.end:                                           ; preds = %needs_casefold.exit
  call void @__sanitizer_cov_trace_const_cmp4(i32 36, i32 %len)
  %cmp = icmp ult i32 %len, 36
  br i1 %cmp, label %if.then7, label %if.end.if.end10_crit_edge

if.end.if.end10_crit_edge:                        ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  br label %if.end10

if.then7:                                         ; preds = %if.end
  call void @__sanitizer_cov_trace_pc() #18
  %20 = call ptr @memcpy(ptr %strbuf, ptr %str, i32 %len)
  %arrayidx = getelementptr [36 x i8], ptr %strbuf, i32 0, i32 %len
  %21 = ptrtoint ptr %arrayidx to i32
  call void @__asan_store1_noabort(i32 %21)
  store i8 0, ptr %arrayidx, align 1
  %22 = ptrtoint ptr %name6 to i32
  call void @__asan_store4_noabort(i32 %22)
  store ptr %strbuf, ptr %name6, align 8
  call void asm sideeffect "", "~{memory}"() #16, !srcloc !210
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end.if.end10_crit_edge
  %call11 = call i32 @utf8_strncasecmp(ptr noundef %7, ptr noundef %name, ptr noundef nonnull %qstr) #16
  call void @__sanitizer_cov_trace_const_cmp4(i32 -1, i32 %call11)
  %cmp12 = icmp sgt i32 %call11, -1
  br i1 %cmp12, label %if.end10.cleanup_crit_edge, label %if.end14

if.end10.cleanup_crit_edge:                       ; preds = %if.end10
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end14:                                         ; preds = %if.end10
  %s_encoding_flags = getelementptr inbounds %struct.super_block, ptr %5, i32 0, i32 23
  %23 = ptrtoint ptr %s_encoding_flags to i32
  call void @__asan_load2_noabort(i32 %23)
  %24 = load i16, ptr %s_encoding_flags, align 4
  %25 = and i16 %24, 1
  call void @__sanitizer_cov_trace_const_cmp2(i16 0, i16 %25)
  %tobool15.not = icmp eq i16 %25, 0
  br i1 %tobool15.not, label %if.end14.fallback_crit_edge, label %if.end14.cleanup_crit_edge

if.end14.cleanup_crit_edge:                       ; preds = %if.end14
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end14.fallback_crit_edge:                      ; preds = %if.end14
  call void @__sanitizer_cov_trace_pc() #18
  br label %fallback

fallback:                                         ; preds = %if.end14.fallback_crit_edge, %needs_casefold.exit.fallback_crit_edge, %lor.lhs.false.fallback_crit_edge, %entry.fallback_crit_edge
  %26 = ptrtoint ptr %name to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %name, align 8
  call void @__sanitizer_cov_trace_cmp4(i32 %27, i32 %len)
  %cmp19.not = icmp eq i32 %27, %len
  br i1 %cmp19.not, label %if.end22, label %fallback.cleanup_crit_edge

fallback.cleanup_crit_edge:                       ; preds = %fallback
  call void @__sanitizer_cov_trace_pc() #18
  br label %cleanup

if.end22:                                         ; preds = %fallback
  call void @__sanitizer_cov_trace_pc() #18
  %name23 = getelementptr inbounds %struct.qstr, ptr %name, i32 0, i32 1
  %28 = ptrtoint ptr %name23 to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load ptr, ptr %name23, align 8
  %bcmp = call i32 @bcmp(ptr %str, ptr %29, i32 %len) #22
  call void @__sanitizer_cov_trace_const_cmp4(i32 0, i32 %bcmp)
  %tobool25 = icmp ne i32 %bcmp, 0
  %lnot.ext = zext i1 %tobool25 to i32
  br label %cleanup

cleanup:                                          ; preds = %if.end22, %fallback.cleanup_crit_edge, %if.end14.cleanup_crit_edge, %if.end10.cleanup_crit_edge
  %retval.0 = phi i32 [ %lnot.ext, %if.end22 ], [ %call11, %if.end10.cleanup_crit_edge ], [ -22, %if.end14.cleanup_crit_edge ], [ 1, %fallback.cleanup_crit_edge ]
  call void @llvm.lifetime.end.p0(i64 36, ptr nonnull %strbuf) #16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %qstr) #16
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @utf8_casefold_hash(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @utf8_strncasecmp(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: argmemonly nofree nounwind readonly willreturn
declare i32 @bcmp(ptr nocapture, ptr nocapture, i32) local_unnamed_addr #14

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.umin.i32(i32, i32) #15

; Function Attrs: nounwind
declare void @llvm.arm.gnu.eabi.mcount() #16

declare void @__sanitizer_cov_trace_cmp4(i32 zeroext, i32 zeroext)

declare void @__sanitizer_cov_trace_cmp8(i64, i64)

declare void @__sanitizer_cov_trace_const_cmp1(i8 zeroext, i8 zeroext)

declare void @__sanitizer_cov_trace_const_cmp2(i16 zeroext, i16 zeroext)

declare void @__sanitizer_cov_trace_const_cmp4(i32 zeroext, i32 zeroext)

declare void @__sanitizer_cov_trace_const_cmp8(i64, i64)

declare void @__sanitizer_cov_trace_switch(i64, ptr)

declare void @__sanitizer_cov_trace_pc()

declare void @__asan_load1_noabort(i32)

declare void @__asan_load2_noabort(i32)

declare void @__asan_load4_noabort(i32)

declare void @__asan_load8_noabort(i32)

declare void @__asan_store1_noabort(i32)

declare void @__asan_store2_noabort(i32)

declare void @__asan_store4_noabort(i32)

declare void @__asan_store8_noabort(i32)

declare ptr @memmove(ptr, ptr, i32)

declare ptr @memcpy(ptr, ptr, i32)

declare ptr @memset(ptr, i32, i32)

declare void @__asan_register_globals(i32, i32)

declare void @__asan_unregister_globals(i32, i32)

; Function Attrs: nounwind uwtable(sync)
define internal void @asan.module_ctor() #17 {
  call void @__asan_register_globals(i32 ptrtoint (ptr @0 to i32), i32 25)
  ret void
}

; Function Attrs: nounwind uwtable(sync)
define internal void @asan.module_dtor() #17 {
  call void @__asan_unregister_globals(i32 ptrtoint (ptr @0 to i32), i32 25)
  ret void
}

attributes #0 = { nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #1 = { argmemonly nocallback nofree nosync nounwind willreturn }
attributes #2 = { null_pointer_is_valid "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #3 = { mustprogress nofree norecurse nosync nounwind null_pointer_is_valid sanitize_address sspstrong willreturn uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #4 = { mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #5 = { argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid sanitize_address sspstrong willreturn uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #6 = { cold null_pointer_is_valid "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #7 = { argmemonly mustprogress nofree nosync nounwind null_pointer_is_valid sanitize_address sspstrong willreturn uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #8 = { argmemonly mustprogress nofree nounwind null_pointer_is_valid readonly willreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #9 = { argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #10 = { null_pointer_is_valid allocsize(2) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #11 = { nocallback nofree nosync nounwind readnone willreturn }
attributes #12 = { inaccessiblemem_or_argmemonly nocallback nofree nosync nounwind willreturn }
attributes #13 = { nounwind readonly }
attributes #14 = { argmemonly nofree nounwind readonly willreturn }
attributes #15 = { nocallback nofree nosync nounwind readnone speculatable willreturn }
attributes #16 = { nounwind }
attributes #17 = { nounwind uwtable(sync) "frame-pointer"="all" }
attributes #18 = { nomerge }
attributes #19 = { nounwind allocsize(2) }
attributes #20 = { cold nounwind }
attributes #21 = { nounwind readnone }
attributes #22 = { nobuiltin }

!llvm.asan.globals = !{!0, !2, !4, !6, !8, !10, !12, !14, !16, !18, !20, !22, !24, !26, !28, !30, !32, !34, !36, !38, !40, !42, !44, !46, !48, !50, !52, !54, !56, !58, !59, !60, !61, !62, !64, !66, !68, !70, !72, !74, !76, !78, !79, !81, !83, !85, !87, !88, !90, !92, !94, !96, !98, !100, !102, !104, !106, !108, !110, !112, !114, !116, !118, !120, !122, !124, !126, !128, !130, !132, !134, !136, !138, !139, !141, !143, !145, !147, !149, !150, !152, !154, !156, !157, !159, !160, !162, !164, !166, !168, !170, !172}
!llvm.named.register.sp = !{!174}
!llvm.module.flags = !{!175, !176, !177, !178, !179, !180, !181, !182}
!llvm.ident = !{!183}

!0 = !{ptr @__ksymtab_simple_getattr, !1, !"__ksymtab_simple_getattr", i1 false, i1 false}
!1 = !{!"../fs/libfs.c", i32 39, i32 1}
!2 = !{ptr @__ksymtab_simple_statfs, !3, !"__ksymtab_simple_statfs", i1 false, i1 false}
!3 = !{!"../fs/libfs.c", i32 48, i32 1}
!4 = !{ptr @__ksymtab_always_delete_dentry, !5, !"__ksymtab_always_delete_dentry", i1 false, i1 false}
!5 = !{!"../fs/libfs.c", i32 58, i32 1}
!6 = !{ptr @simple_dentry_operations, !7, !"simple_dentry_operations", i1 false, i1 false}
!7 = !{!"../fs/libfs.c", i32 60, i32 32}
!8 = !{ptr @__ksymtab_simple_dentry_operations, !9, !"__ksymtab_simple_dentry_operations", i1 false, i1 false}
!9 = !{!"../fs/libfs.c", i32 63, i32 1}
!10 = !{ptr @__ksymtab_simple_lookup, !11, !"__ksymtab_simple_lookup", i1 false, i1 false}
!11 = !{!"../fs/libfs.c", i32 78, i32 1}
!12 = !{ptr @__ksymtab_dcache_dir_open, !13, !"__ksymtab_dcache_dir_open", i1 false, i1 false}
!13 = !{!"../fs/libfs.c", i32 86, i32 1}
!14 = !{ptr @__ksymtab_dcache_dir_close, !15, !"__ksymtab_dcache_dir_close", i1 false, i1 false}
!15 = !{!"../fs/libfs.c", i32 93, i32 1}
!16 = !{ptr @__ksymtab_dcache_dir_lseek, !17, !"__ksymtab_dcache_dir_lseek", i1 false, i1 false}
!17 = !{!"../fs/libfs.c", i32 174, i32 1}
!18 = !{ptr @__ksymtab_dcache_readdir, !19, !"__ksymtab_dcache_readdir", i1 false, i1 false}
!19 = !{!"../fs/libfs.c", i32 223, i32 1}
!20 = !{ptr @__ksymtab_generic_read_dir, !21, !"__ksymtab_generic_read_dir", i1 false, i1 false}
!21 = !{!"../fs/libfs.c", i32 229, i32 1}
!22 = !{ptr @simple_dir_operations, !23, !"simple_dir_operations", i1 false, i1 false}
!23 = !{!"../fs/libfs.c", i32 231, i32 30}
!24 = !{ptr @__ksymtab_simple_dir_operations, !25, !"__ksymtab_simple_dir_operations", i1 false, i1 false}
!25 = !{!"../fs/libfs.c", i32 239, i32 1}
!26 = !{ptr @simple_dir_inode_operations, !27, !"simple_dir_inode_operations", i1 false, i1 false}
!27 = !{!"../fs/libfs.c", i32 241, i32 31}
!28 = !{ptr @__ksymtab_simple_dir_inode_operations, !29, !"__ksymtab_simple_dir_inode_operations", i1 false, i1 false}
!29 = !{!"../fs/libfs.c", i32 244, i32 1}
!30 = !{ptr @__ksymtab_simple_recursive_removal, !31, !"__ksymtab_simple_recursive_removal", i1 false, i1 false}
!31 = !{!"../fs/libfs.c", i32 313, i32 1}
!32 = !{ptr @__ksymtab_init_pseudo, !33, !"__ksymtab_init_pseudo", i1 false, i1 false}
!33 = !{!"../fs/libfs.c", i32 384, i32 1}
!34 = !{ptr @__ksymtab_simple_open, !35, !"__ksymtab_simple_open", i1 false, i1 false}
!35 = !{!"../fs/libfs.c", i32 392, i32 1}
!36 = !{ptr @__ksymtab_simple_link, !37, !"__ksymtab_simple_link", i1 false, i1 false}
!37 = !{!"../fs/libfs.c", i32 405, i32 1}
!38 = !{ptr @__ksymtab_simple_empty, !39, !"__ksymtab_simple_empty", i1 false, i1 false}
!39 = !{!"../fs/libfs.c", i32 426, i32 1}
!40 = !{ptr @__ksymtab_simple_unlink, !41, !"__ksymtab_simple_unlink", i1 false, i1 false}
!41 = !{!"../fs/libfs.c", i32 437, i32 1}
!42 = !{ptr @__ksymtab_simple_rmdir, !43, !"__ksymtab_simple_rmdir", i1 false, i1 false}
!43 = !{!"../fs/libfs.c", i32 449, i32 1}
!44 = !{ptr @__ksymtab_simple_rename_exchange, !45, !"__ksymtab_simple_rename_exchange", i1 false, i1 false}
!45 = !{!"../fs/libfs.c", i32 473, i32 1}
!46 = !{ptr @__ksymtab_simple_rename, !47, !"__ksymtab_simple_rename", i1 false, i1 false}
!47 = !{!"../fs/libfs.c", i32 507, i32 1}
!48 = !{ptr @__ksymtab_simple_setattr, !49, !"__ksymtab_simple_setattr", i1 false, i1 false}
!49 = !{!"../fs/libfs.c", i32 540, i32 1}
!50 = !{ptr @__ksymtab_simple_write_begin, !51, !"__ksymtab_simple_write_begin", i1 false, i1 false}
!51 = !{!"../fs/libfs.c", i32 573, i32 1}
!52 = !{ptr @ram_aops, !53, !"ram_aops", i1 false, i1 false}
!53 = !{!"../fs/libfs.c", i32 630, i32 39}
!54 = !{ptr @__ksymtab_ram_aops, !55, !"__ksymtab_ram_aops", i1 false, i1 false}
!55 = !{!"../fs/libfs.c", i32 636, i32 1}
!56 = !{ptr @.str, !57, !"<string literal>", i1 false, i1 false}
!57 = !{!"../fs/libfs.c", i32 679, i32 4}
!58 = !{ptr @.str.1, !57, !"<string literal>", i1 false, i1 false}
!59 = !{ptr @.str.2, !57, !"<string literal>", i1 false, i1 false}
!60 = !{ptr @simple_fill_super._entry, !57, !"_entry", i1 false, i1 false}
!61 = !{ptr @simple_fill_super._entry_ptr, !57, !"_entry_ptr", i1 false, i1 false}
!62 = !{ptr @__ksymtab_simple_fill_super, !63, !"__ksymtab_simple_fill_super", i1 false, i1 false}
!63 = !{!"../fs/libfs.c", i32 705, i32 1}
!64 = !{ptr @__ksymtab_simple_pin_fs, !65, !"__ksymtab_simple_pin_fs", i1 false, i1 false}
!65 = !{!"../fs/libfs.c", i32 728, i32 1}
!66 = !{ptr @__ksymtab_simple_release_fs, !67, !"__ksymtab_simple_release_fs", i1 false, i1 false}
!67 = !{!"../fs/libfs.c", i32 740, i32 1}
!68 = !{ptr @__ksymtab_simple_read_from_buffer, !69, !"__ksymtab_simple_read_from_buffer", i1 false, i1 false}
!69 = !{!"../fs/libfs.c", i32 775, i32 1}
!70 = !{ptr @__ksymtab_simple_write_to_buffer, !71, !"__ksymtab_simple_write_to_buffer", i1 false, i1 false}
!71 = !{!"../fs/libfs.c", i32 810, i32 1}
!72 = !{ptr @__ksymtab_memory_read_from_buffer, !73, !"__ksymtab_memory_read_from_buffer", i1 false, i1 false}
!73 = !{!"../fs/libfs.c", i32 842, i32 1}
!74 = !{ptr @__ksymtab_simple_transaction_set, !75, !"__ksymtab_simple_transaction_set", i1 false, i1 false}
!75 = !{!"../fs/libfs.c", i32 864, i32 1}
!76 = !{ptr @.str.3, !77, !"<string literal>", i1 false, i1 false}
!77 = !{!"../fs/libfs.c", i32 869, i32 9}
!78 = !{ptr @simple_transaction_get.simple_transaction_lock, !77, !"simple_transaction_lock", i1 false, i1 false}
!79 = !{ptr @__ksymtab_simple_transaction_get, !80, !"__ksymtab_simple_transaction_get", i1 false, i1 false}
!80 = !{!"../fs/libfs.c", i32 896, i32 1}
!81 = !{ptr @__ksymtab_simple_transaction_read, !82, !"__ksymtab_simple_transaction_read", i1 false, i1 false}
!82 = !{!"../fs/libfs.c", i32 906, i32 1}
!83 = !{ptr @__ksymtab_simple_transaction_release, !84, !"__ksymtab_simple_transaction_release", i1 false, i1 false}
!84 = !{!"../fs/libfs.c", i32 913, i32 1}
!85 = !{ptr @simple_attr_open.__key, !86, !"__key", i1 false, i1 false}
!86 = !{!"../fs/libfs.c", i32 943, i32 2}
!87 = !{ptr @.str.4, !86, !"<string literal>", i1 false, i1 false}
!88 = !{ptr @__ksymtab_simple_attr_open, !89, !"__ksymtab_simple_attr_open", i1 false, i1 false}
!89 = !{!"../fs/libfs.c", i32 949, i32 1}
!90 = !{ptr @__ksymtab_simple_attr_release, !91, !"__ksymtab_simple_attr_release", i1 false, i1 false}
!91 = !{!"../fs/libfs.c", i32 956, i32 1}
!92 = !{ptr @__ksymtab_simple_attr_read, !93, !"__ksymtab_simple_attr_read", i1 false, i1 false}
!93 = !{!"../fs/libfs.c", i32 994, i32 1}
!94 = !{ptr @__ksymtab_simple_attr_write, !95, !"__ksymtab_simple_attr_write", i1 false, i1 false}
!95 = !{!"../fs/libfs.c", i32 1029, i32 1}
!96 = !{ptr @__ksymtab_generic_fh_to_dentry, !97, !"__ksymtab_generic_fh_to_dentry", i1 false, i1 false}
!97 = !{!"../fs/libfs.c", i32 1061, i32 1}
!98 = !{ptr @__ksymtab_generic_fh_to_parent, !99, !"__ksymtab_generic_fh_to_parent", i1 false, i1 false}
!99 = !{!"../fs/libfs.c", i32 1094, i32 1}
!100 = !{ptr @__ksymtab___generic_file_fsync, !101, !"__ksymtab___generic_file_fsync", i1 false, i1 false}
!101 = !{!"../fs/libfs.c", i32 1138, i32 1}
!102 = !{ptr @__ksymtab_generic_file_fsync, !103, !"__ksymtab_generic_file_fsync", i1 false, i1 false}
!103 = !{!"../fs/libfs.c", i32 1161, i32 1}
!104 = !{ptr @__ksymtab_generic_check_addressable, !105, !"__ksymtab_generic_check_addressable", i1 false, i1 false}
!105 = !{!"../fs/libfs.c", i32 1190, i32 1}
!106 = !{ptr @__ksymtab_noop_fsync, !107, !"__ksymtab_noop_fsync", i1 false, i1 false}
!107 = !{!"../fs/libfs.c", i32 1199, i32 1}
!108 = !{ptr @__ksymtab_noop_invalidatepage, !109, !"__ksymtab_noop_invalidatepage", i1 false, i1 false}
!109 = !{!"../fs/libfs.c", i32 1210, i32 1}
!110 = !{ptr @__ksymtab_noop_direct_IO, !111, !"__ksymtab_noop_direct_IO", i1 false, i1 false}
!111 = !{!"../fs/libfs.c", i32 1222, i32 1}
!112 = !{ptr @__ksymtab_kfree_link, !113, !"__ksymtab_kfree_link", i1 false, i1 false}
!113 = !{!"../fs/libfs.c", i32 1229, i32 1}
!114 = !{ptr @alloc_anon_inode.anon_aops, !115, !"anon_aops", i1 false, i1 false}
!115 = !{!"../fs/libfs.c", i32 1233, i32 47}
!116 = distinct !{null, !117, !"__warned", i1 false, i1 false}
!117 = !{!"../fs/libfs.c", i32 1252, i32 17}
!118 = distinct !{null, !119, !"__warned", i1 false, i1 false}
!119 = !{!"../fs/libfs.c", i32 1253, i32 17}
!120 = !{ptr @__ksymtab_alloc_anon_inode, !121, !"__ksymtab_alloc_anon_inode", i1 false, i1 false}
!121 = !{!"../fs/libfs.c", i32 1258, i32 1}
!122 = !{ptr @__ksymtab_simple_nosetlease, !123, !"__ksymtab_simple_nosetlease", i1 false, i1 false}
!123 = !{!"../fs/libfs.c", i32 1276, i32 1}
!124 = !{ptr @__ksymtab_simple_get_link, !125, !"__ksymtab_simple_get_link", i1 false, i1 false}
!125 = !{!"../fs/libfs.c", i32 1297, i32 1}
!126 = !{ptr @simple_symlink_inode_operations, !127, !"simple_symlink_inode_operations", i1 false, i1 false}
!127 = !{!"../fs/libfs.c", i32 1299, i32 31}
!128 = !{ptr @__ksymtab_simple_symlink_inode_operations, !129, !"__ksymtab_simple_symlink_inode_operations", i1 false, i1 false}
!129 = !{!"../fs/libfs.c", i32 1302, i32 1}
!130 = !{ptr @__ksymtab_generic_set_encrypted_ci_d_ops, !131, !"__ksymtab_generic_set_encrypted_ci_d_ops", i1 false, i1 false}
!131 = !{!"../fs/libfs.c", i32 1533, i32 1}
!132 = !{ptr @.str.6, !133, !"<string literal>", i1 false, i1 false}
!133 = !{!"../include/linux/fs.h", i32 3566, i32 25}
!134 = !{ptr @.str.7, !135, !"<string literal>", i1 false, i1 false}
!135 = !{!"../include/linux/fs.h", i32 3571, i32 25}
!136 = distinct !{null, !137, !"__already_done", i1 false, i1 false}
!137 = !{!"../include/linux/fsnotify.h", i32 298, i32 6}
!138 = !{ptr @.str.8, !137, !"<string literal>", i1 false, i1 false}
!139 = distinct !{null, !140, !"__already_done", i1 false, i1 false}
!140 = !{!"../include/linux/fsnotify.h", i32 271, i32 6}
!141 = !{ptr @pseudo_fs_context_ops, !142, !"pseudo_fs_context_ops", i1 false, i1 false}
!142 = !{!"../fs/libfs.c", i32 360, i32 43}
!143 = !{ptr @.str.9, !144, !"<string literal>", i1 false, i1 false}
!144 = !{!"../include/linux/page-flags.h", i32 260, i32 2}
!145 = distinct !{null, !146, !"<string literal>", i1 false, i1 false}
!146 = !{!"../include/linux/page-flags.h", i32 261, i32 2}
!147 = distinct !{null, !148, !"__already_done", i1 false, i1 false}
!148 = !{!"../include/linux/seqlock.h", i32 271, i32 2}
!149 = !{ptr @.str.11, !148, !"<string literal>", i1 false, i1 false}
!150 = !{ptr @.str.12, !151, !"<string literal>", i1 false, i1 false}
!151 = !{!"../include/linux/mm.h", i32 717, i32 2}
!152 = !{ptr @simple_super_operations, !153, !"simple_super_operations", i1 false, i1 false}
!153 = !{!"../fs/libfs.c", i32 315, i32 38}
!154 = !{ptr @.str.13, !155, !"<string literal>", i1 false, i1 false}
!155 = !{!"../fs/libfs.c", i32 707, i32 8}
!156 = !{ptr @pin_fs_lock, !155, !"pin_fs_lock", i1 false, i1 false}
!157 = distinct !{null, !158, !"__already_done", i1 false, i1 false}
!158 = !{!"../include/linux/thread_info.h", i32 230, i32 6}
!159 = !{ptr @.str.14, !158, !"<string literal>", i1 false, i1 false}
!160 = !{ptr @.str.15, !161, !"<string literal>", i1 false, i1 false}
!161 = !{!"../include/linux/thread_info.h", i32 214, i32 2}
!162 = !{ptr @.str.16, !163, !"<string literal>", i1 false, i1 false}
!163 = !{!"../include/linux/uaccess.h", i32 174, i32 2}
!164 = !{ptr @empty_dir_inode_operations, !165, !"empty_dir_inode_operations", i1 false, i1 false}
!165 = !{!"../fs/libfs.c", i32 1332, i32 38}
!166 = !{ptr @empty_dir_operations, !167, !"empty_dir_operations", i1 false, i1 false}
!167 = !{!"../fs/libfs.c", i32 1352, i32 37}
!168 = !{ptr @generic_encrypted_ci_dentry_ops, !169, !"generic_encrypted_ci_dentry_ops", i1 false, i1 false}
!169 = !{!"../fs/libfs.c", i32 1477, i32 39}
!170 = !{ptr @generic_encrypted_dentry_ops, !171, !"generic_encrypted_dentry_ops", i1 false, i1 false}
!171 = !{!"../fs/libfs.c", i32 1471, i32 39}
!172 = !{ptr @generic_ci_dentry_ops, !173, !"generic_ci_dentry_ops", i1 false, i1 false}
!173 = !{!"../fs/libfs.c", i32 1464, i32 39}
!174 = !{!"sp"}
!175 = !{i32 1, !"wchar_size", i32 2}
!176 = !{i32 1, !"min_enum_size", i32 4}
!177 = !{i32 8, !"branch-target-enforcement", i32 0}
!178 = !{i32 8, !"sign-return-address", i32 0}
!179 = !{i32 8, !"sign-return-address-all", i32 0}
!180 = !{i32 8, !"sign-return-address-with-bkey", i32 0}
!181 = !{i32 7, !"uwtable", i32 1}
!182 = !{i32 7, !"frame-pointer", i32 2}
!183 = !{!"clang version 15.0.0 (git@github.com:linkeLi0421/llvm-project15-IRDumperPass.git 23ab625cb005cd08da083f9b643a7feed9af8abe)"}
!184 = !{!"branch_weights", i32 2000, i32 1}
!185 = !{!"branch_weights", i32 1, i32 2000}
!186 = !{i64 2151038272, i64 2151038763, i64 2151038309, i64 2151038365, i64 2151038399, i64 2151038423, i64 2151038464, i64 2151038485, i64 2151038513, i64 2151038547}
!187 = !{i64 2151788164}
!188 = !{i64 2151789235}
!189 = !{i64 2152617806}
!190 = !{i64 2150145383}
!191 = !{i64 2150150317}
!192 = !{i64 2150172035}
!193 = !{i64 2150176929}
!194 = !{i64 2150253456}
!195 = !{i64 2150253781}
!196 = !{i64 2152629668}
!197 = !{i64 2153248330, i64 2153248813, i64 2153248367, i64 2153248423, i64 2153248457, i64 2153248481, i64 2153248522, i64 2153248543, i64 2153248571, i64 2153248605}
!198 = !{i64 2148586538}
!199 = !{i64 2148501271, i64 2148501303, i64 2148501332, i64 2148501366, i64 2148501397, i64 2148501420}
!200 = !{i64 2148586767}
!201 = !{i64 2148311479, i64 2148311484, i64 2148311497, i64 2148311541, i64 2148311575, i64 2148311596}
!202 = !{i64 2152291515, i64 2152291540}
!203 = !{i64 2152290834, i64 2152290859}
!204 = !{i64 4786389}
!205 = !{i64 4786586}
!206 = !{i64 2152271819}
!207 = !{i64 2155237167, i64 2155237642, i64 2155237204, i64 2155237260, i64 2155237294, i64 2155237318, i64 2155237359, i64 2155237380, i64 2155237408, i64 2155237442}
!208 = !{i64 2155238554}
!209 = !{!"auto-init"}
!210 = !{i64 2155290629}
