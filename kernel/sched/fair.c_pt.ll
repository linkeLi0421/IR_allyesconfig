; ModuleID = '/llk/IR_all_yes/kernel/sched/fair.c_pt.bc'
source_filename = "../kernel/sched/fair.c"
target datalayout = "E-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64"
target triple = "armebv6k-unknown-linux-gnueabi"

module asm ".syntax unified"
module asm "\09.section \22___kcrctab_gpl+sched_smt_present\22, \22a\22\09"
module asm "\09.weak\09__crc_sched_smt_present\09\09\09\09"
module asm "\09.long\09__crc_sched_smt_present\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_sched_smt_present:\09\09\09\09\09"
module asm "\09.asciz \09\22sched_smt_present\22\09\09\09\09\09"
module asm "__kstrtabns_sched_smt_present:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+sched_trace_cfs_rq_avg\22, \22a\22\09"
module asm "\09.weak\09__crc_sched_trace_cfs_rq_avg\09\09\09\09"
module asm "\09.long\09__crc_sched_trace_cfs_rq_avg\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_sched_trace_cfs_rq_avg:\09\09\09\09\09"
module asm "\09.asciz \09\22sched_trace_cfs_rq_avg\22\09\09\09\09\09"
module asm "__kstrtabns_sched_trace_cfs_rq_avg:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+sched_trace_cfs_rq_path\22, \22a\22\09"
module asm "\09.weak\09__crc_sched_trace_cfs_rq_path\09\09\09\09"
module asm "\09.long\09__crc_sched_trace_cfs_rq_path\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_sched_trace_cfs_rq_path:\09\09\09\09\09"
module asm "\09.asciz \09\22sched_trace_cfs_rq_path\22\09\09\09\09\09"
module asm "__kstrtabns_sched_trace_cfs_rq_path:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+sched_trace_cfs_rq_cpu\22, \22a\22\09"
module asm "\09.weak\09__crc_sched_trace_cfs_rq_cpu\09\09\09\09"
module asm "\09.long\09__crc_sched_trace_cfs_rq_cpu\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_sched_trace_cfs_rq_cpu:\09\09\09\09\09"
module asm "\09.asciz \09\22sched_trace_cfs_rq_cpu\22\09\09\09\09\09"
module asm "__kstrtabns_sched_trace_cfs_rq_cpu:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+sched_trace_rq_avg_rt\22, \22a\22\09"
module asm "\09.weak\09__crc_sched_trace_rq_avg_rt\09\09\09\09"
module asm "\09.long\09__crc_sched_trace_rq_avg_rt\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_sched_trace_rq_avg_rt:\09\09\09\09\09"
module asm "\09.asciz \09\22sched_trace_rq_avg_rt\22\09\09\09\09\09"
module asm "__kstrtabns_sched_trace_rq_avg_rt:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+sched_trace_rq_avg_dl\22, \22a\22\09"
module asm "\09.weak\09__crc_sched_trace_rq_avg_dl\09\09\09\09"
module asm "\09.long\09__crc_sched_trace_rq_avg_dl\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_sched_trace_rq_avg_dl:\09\09\09\09\09"
module asm "\09.asciz \09\22sched_trace_rq_avg_dl\22\09\09\09\09\09"
module asm "__kstrtabns_sched_trace_rq_avg_dl:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+sched_trace_rq_avg_irq\22, \22a\22\09"
module asm "\09.weak\09__crc_sched_trace_rq_avg_irq\09\09\09\09"
module asm "\09.long\09__crc_sched_trace_rq_avg_irq\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_sched_trace_rq_avg_irq:\09\09\09\09\09"
module asm "\09.asciz \09\22sched_trace_rq_avg_irq\22\09\09\09\09\09"
module asm "__kstrtabns_sched_trace_rq_avg_irq:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+sched_trace_rq_cpu\22, \22a\22\09"
module asm "\09.weak\09__crc_sched_trace_rq_cpu\09\09\09\09"
module asm "\09.long\09__crc_sched_trace_rq_cpu\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_sched_trace_rq_cpu:\09\09\09\09\09"
module asm "\09.asciz \09\22sched_trace_rq_cpu\22\09\09\09\09\09"
module asm "__kstrtabns_sched_trace_rq_cpu:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+sched_trace_rq_cpu_capacity\22, \22a\22\09"
module asm "\09.weak\09__crc_sched_trace_rq_cpu_capacity\09\09\09\09"
module asm "\09.long\09__crc_sched_trace_rq_cpu_capacity\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_sched_trace_rq_cpu_capacity:\09\09\09\09\09"
module asm "\09.asciz \09\22sched_trace_rq_cpu_capacity\22\09\09\09\09\09"
module asm "__kstrtabns_sched_trace_rq_cpu_capacity:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+sched_trace_rd_span\22, \22a\22\09"
module asm "\09.weak\09__crc_sched_trace_rd_span\09\09\09\09"
module asm "\09.long\09__crc_sched_trace_rd_span\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_sched_trace_rd_span:\09\09\09\09\09"
module asm "\09.asciz \09\22sched_trace_rd_span\22\09\09\09\09\09"
module asm "__kstrtabns_sched_trace_rd_span:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+sched_trace_rq_nr_running\22, \22a\22\09"
module asm "\09.weak\09__crc_sched_trace_rq_nr_running\09\09\09\09"
module asm "\09.long\09__crc_sched_trace_rq_nr_running\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_sched_trace_rq_nr_running:\09\09\09\09\09"
module asm "\09.asciz \09\22sched_trace_rq_nr_running\22\09\09\09\09\09"
module asm "__kstrtabns_sched_trace_rq_nr_running:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"

%struct.obs_kernel_param = type { ptr, ptr, i32 }
%struct.sched_class = type { i32, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.static_key = type { %struct.atomic_t, %union.anon.55 }
%struct.atomic_t = type { i32 }
%union.anon.55 = type { i32 }
%struct.lock_class_key = type { %union.anon.0 }
%union.anon.0 = type { %struct.hlist_node }
%struct.hlist_node = type { ptr, ptr }
%struct.kernel_symbol = type { i32, ptr, ptr }
%struct.rq = type { %struct.raw_spinlock, i32, i32, i32, [8 x i8], %struct.__call_single_data, i32, %struct.atomic_t, i32, i64, [24 x i8], [2 x %struct.uclamp_rq], i32, [76 x i8], %struct.cfs_rq, %struct.rt_rq, %struct.dl_rq, %struct.list_head, ptr, i32, ptr, ptr, ptr, i32, ptr, i32, i64, [88 x i8], i64, i64, i32, %struct.atomic_t, i64, i32, i32, ptr, ptr, i32, i32, ptr, i8, i8, i32, i32, i32, %struct.cpu_stop_work, i32, i32, %struct.list_head, [12 x i8], %struct.sched_avg, %struct.sched_avg, %struct.sched_avg, %struct.sched_avg, i64, i64, i32, i64, i64, %struct.rcuwait, i64, i64, i64, i32, i32, %struct.__call_single_data, %struct.hrtimer, i64, %struct.sched_info, i64, i32, i32, i32, i32, i32, ptr, i32, i32, %struct.cpu_stop_work, ptr, ptr, i32, i32, %struct.rb_root, i32, i32, i32, i32, i32, i32, i64, [80 x i8] }
%struct.raw_spinlock = type { %struct.arch_spinlock_t, i32, i32, ptr, %struct.lockdep_map }
%struct.arch_spinlock_t = type { %union.anon }
%union.anon = type { i32 }
%struct.lockdep_map = type { ptr, [2 x ptr], ptr, i8, i8, i8, i32, i32 }
%struct.uclamp_rq = type { i32, [5 x %struct.uclamp_bucket] }
%struct.uclamp_bucket = type { i32 }
%struct.cfs_rq = type { %struct.load_weight, i32, i32, i32, i32, i64, i64, i32, i64, i64, %struct.rb_root_cached, ptr, ptr, ptr, ptr, i32, [36 x i8], %struct.sched_avg, i64, [120 x i8], %struct.anon, i32, i32, i32, i32, i64, ptr, ptr, i32, %struct.list_head, ptr, i32, i32, i64, i64, i64, i64, i32, i32, %struct.list_head, [24 x i8] }
%struct.load_weight = type { i32, i32 }
%struct.rb_root_cached = type { %struct.rb_root, ptr }
%struct.anon = type { %struct.raw_spinlock, i32, i32, i32, i32, [68 x i8] }
%struct.rt_rq = type { %struct.rt_prio_array, i32, i32, %struct.anon.93, i32, i32, i32, %struct.plist_head, i32, i32, i64, i64, %struct.raw_spinlock, i32, ptr, ptr }
%struct.rt_prio_array = type { [4 x i32], [100 x %struct.list_head] }
%struct.anon.93 = type { i32, i32 }
%struct.plist_head = type { %struct.list_head }
%struct.dl_rq = type { %struct.rb_root_cached, i32, %struct.anon.94, i32, i32, %struct.rb_root_cached, i64, i64, i64, i64 }
%struct.anon.94 = type { i64, i64 }
%struct.list_head = type { ptr, ptr }
%struct.sched_avg = type { i64, i64, i64, i32, i32, i32, i32, i32, [4 x i8], %struct.util_est, [72 x i8] }
%struct.util_est = type { i32, i32 }
%struct.rcuwait = type { ptr }
%struct.__call_single_data = type { %struct.__call_single_node, ptr, ptr }
%struct.__call_single_node = type { %struct.llist_node, %union.anon.76 }
%struct.llist_node = type { ptr }
%union.anon.76 = type { i32 }
%struct.hrtimer = type { %struct.timerqueue_node, i64, ptr, ptr, i8, i8, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.rb_node = type { i32, ptr, ptr }
%struct.sched_info = type { i32, i64, i64, i64 }
%struct.cpu_stop_work = type { %struct.list_head, ptr, i32, ptr, ptr }
%struct.rb_root = type { ptr }
%struct.anon.138 = type { ptr, %struct.atomic_t, i32, i32, i32, i32 }
%struct.cpumask = type { [1 x i32] }
%struct.mutex = type { %struct.atomic_t, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.list_head, ptr, %struct.lockdep_map }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.task_group = type { %struct.cgroup_subsys_state, ptr, ptr, i32, i32, [72 x i8], %struct.atomic_t, ptr, ptr, %struct.rt_bandwidth, %struct.callback_head, %struct.list_head, ptr, %struct.list_head, %struct.list_head, ptr, %struct.cfs_bandwidth, [2 x i32], [2 x %struct.uclamp_se], [2 x %struct.uclamp_se], [72 x i8] }
%struct.cgroup_subsys_state = type { ptr, ptr, %struct.percpu_ref, %struct.list_head, %struct.list_head, %struct.list_head, i32, i32, i64, %struct.atomic_t, %struct.work_struct, %struct.rcu_work, ptr }
%struct.percpu_ref = type { i32, ptr }
%struct.work_struct = type { %struct.atomic_t, %struct.list_head, ptr, %struct.lockdep_map }
%struct.rcu_work = type { %struct.work_struct, %struct.callback_head, ptr }
%struct.rt_bandwidth = type { %struct.raw_spinlock, i64, i64, %struct.hrtimer, i32 }
%struct.callback_head = type { ptr, ptr }
%struct.cfs_bandwidth = type { %struct.raw_spinlock, i64, i64, i64, i64, i64, i64, i8, i8, i8, %struct.hrtimer, %struct.hrtimer, %struct.list_head, i32, i32, i32, i64, i64 }
%struct.uclamp_se = type { i16, [2 x i8] }
%struct.pi_entry = type { ptr, ptr, ptr, i32, ptr, ptr }
%struct.static_key_false = type { %struct.static_key }
%struct.tracepoint = type { ptr, %struct.static_key, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.ratelimit_state = type { %struct.raw_spinlock, i32, i32, i32, i32, i32, i32 }
%struct.cpu_topology = type { i32, i32, i32, i32, i32, %struct.cpumask, %struct.cpumask, %struct.cpumask, %struct.cpumask }
%struct.spinlock = type { %union.anon.2 }
%union.anon.2 = type { %struct.raw_spinlock }
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, i32, ptr, ptr, ptr, i32, [36 x i8], %struct.sched_avg }
%struct.task_struct = type { i32, ptr, %struct.refcount_struct, i32, i32, i32, %struct.__call_single_node, i32, i32, ptr, i32, i32, i32, i32, i32, i32, i32, [56 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.sched_dl_entity, ptr, %struct.rb_node, i32, i32, ptr, [2 x %struct.uclamp_se], [2 x %struct.uclamp_se], [116 x i8], %struct.sched_statistics, i32, i32, i32, ptr, ptr, %struct.cpumask, ptr, i16, i16, i32, i8, i8, i32, %struct.list_head, i32, i32, %union.rcu_special, i8, %struct.list_head, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, ptr, ptr, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i32, i32, i8, [3 x i8], i16, i32, %struct.restart_block, i32, i32, i32, ptr, ptr, %struct.list_head, %struct.list_head, ptr, %struct.list_head, %struct.list_head, ptr, [4 x %struct.hlist_node], %struct.list_head, %struct.list_head, ptr, ptr, ptr, ptr, i64, i64, i64, %struct.prev_cputime, i32, i32, i64, i64, i32, i32, %struct.posix_cputimers, ptr, ptr, ptr, ptr, [16 x i8], ptr, %struct.sysv_sem, %struct.sysv_shm, i32, i32, ptr, ptr, ptr, ptr, ptr, ptr, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i32, i32, i32, ptr, %struct.kuid_t, i32, %struct.seccomp, %struct.syscall_user_dispatch, i64, i64, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root_cached, ptr, ptr, ptr, i32, %struct.irqtrace_events, i32, i64, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, %struct.task_io_accounting, i32, i64, i64, i64, %struct.nodemask_t, %struct.seqcount_spinlock, i32, i32, ptr, %struct.list_head, ptr, %struct.list_head, ptr, %struct.mutex, i32, [2 x ptr], %struct.mutex, %struct.list_head, ptr, i32, i32, %struct.tlbflush_unmap_batch, %union.anon.131, ptr, %struct.page_frag, ptr, i32, i32, i32, i32, i32, i32, [32 x %struct.latency_record], i64, i64, i32, ptr, i32, i32, i32, i32, ptr, ptr, i64, i32, i32, ptr, i32, i32, i32, ptr, ptr, ptr, i32, i32, %struct.kmap_ctrl, i32, i32, ptr, ptr, ptr, ptr, %struct.llist_head, %struct.thread_struct, [84 x i8] }
%struct.refcount_struct = type { %struct.atomic_t }
%struct.sched_rt_entity = type { %struct.list_head, i32, i32, i32, i16, i16, ptr, ptr, ptr, ptr }
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i64, i32, i8, %struct.hrtimer, %struct.hrtimer, ptr }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [24 x i8] }
%union.rcu_special = type { i32 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.vmacache = type { i64, [4 x ptr] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i32, ptr, %union.anon.96 }
%union.anon.96 = type { %struct.anon.97 }
%struct.anon.97 = type { ptr, i32, i32, i32, i64, ptr }
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.posix_cputimers = type { [3 x %struct.posix_cputimer_base], i32, i32 }
%struct.posix_cputimer_base = type { i64, %struct.timerqueue_head }
%struct.timerqueue_head = type { %struct.rb_root_cached }
%struct.sysv_sem = type { ptr }
%struct.sysv_shm = type { %struct.list_head }
%struct.sigset_t = type { [2 x i32] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.kuid_t = type { i32 }
%struct.seccomp = type { i32, %struct.atomic_t, ptr }
%struct.syscall_user_dispatch = type {}
%struct.wake_q_node = type { ptr }
%struct.irqtrace_events = type { i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.held_lock = type { i64, i32, ptr, ptr, i64, i64, i32, i32 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i32] }
%struct.seqcount_spinlock = type { %struct.seqcount, ptr }
%struct.seqcount = type { i32, %struct.lockdep_map }
%struct.tlbflush_unmap_batch = type {}
%union.anon.131 = type { %struct.callback_head }
%struct.page_frag = type { ptr, i16, i16 }
%struct.latency_record = type { [12 x i32], i32, i32, i32 }
%struct.kmap_ctrl = type { i32, [33 x i32] }
%struct.llist_head = type { ptr }
%struct.thread_struct = type { i32, i32, i32, %struct.debug_info }
%struct.debug_info = type { [32 x ptr] }
%struct.root_domain = type { %struct.atomic_t, %struct.atomic_t, %struct.callback_head, ptr, ptr, i32, i32, ptr, %struct.atomic_t, %struct.dl_bw, %struct.cpudl, i64, %struct.irq_work, %struct.raw_spinlock, i32, i32, %struct.atomic_t, %struct.atomic_t, ptr, %struct.cpupri, i32, ptr }
%struct.dl_bw = type { %struct.raw_spinlock, i64, i64 }
%struct.cpudl = type { %struct.raw_spinlock, i32, ptr, ptr }
%struct.irq_work = type { %struct.__call_single_node, ptr, %struct.rcuwait }
%struct.cpupri = type { [101 x %struct.cpupri_vec], ptr }
%struct.cpupri_vec = type { %struct.atomic_t, ptr }
%struct.sched_entity_stats = type { %struct.sched_entity, %struct.sched_statistics }
%struct.hrtimer_clock_base = type { ptr, i32, i32, %struct.seqcount_raw_spinlock, ptr, %struct.timerqueue_head, ptr, i64 }
%struct.seqcount_raw_spinlock = type { %struct.seqcount, ptr }
%struct.thread_info = type { i32, i32, ptr, i32, i32, %struct.cpu_context_save, i32, [16 x i8], [2 x i32], %union.fp_state, %union.vfp_state, i32 }
%struct.cpu_context_save = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [2 x i32] }
%union.fp_state = type { %struct.iwmmxt_struct }
%struct.iwmmxt_struct = type { [38 x i32] }
%union.vfp_state = type { %struct.vfp_hard_struct }
%struct.vfp_hard_struct = type { [32 x i64], i32, i32, i32, i32, i32 }
%struct.sched_domain_shared = type { %struct.atomic_t, %struct.atomic_t, i32 }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, i32, i8, i32, i16, i16, i32, i64, ptr, i64, ptr, [8 x %struct.hrtimer_clock_base], [88 x i8] }
%struct.css_set = type { [14 x ptr], %struct.refcount_struct, ptr, ptr, i32, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, [14 x %struct.list_head], %struct.list_head, %struct.list_head, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, ptr, ptr, ptr, i8, %struct.callback_head }
%struct.signal_struct = type { %struct.refcount_struct, %struct.atomic_t, i32, %struct.list_head, %struct.wait_queue_head, ptr, %struct.sigpending, %struct.hlist_head, i32, i32, ptr, i32, i32, ptr, i8, i32, %struct.list_head, %struct.hrtimer, i64, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.posix_cputimers, [4 x ptr], ptr, i32, ptr, ptr, %struct.seqlock_t, i64, i64, i64, i64, i64, i64, %struct.prev_cputime, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, ptr, i32, ptr, i8, i16, i16, ptr, %struct.mutex, %struct.rw_semaphore }
%struct.wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.hlist_head = type { ptr }
%struct.cpu_itimer = type { i64, i64 }
%struct.thread_group_cputimer = type { %struct.task_cputime_atomic }
%struct.task_cputime_atomic = type { %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t }
%struct.atomic64_t = type { i64 }
%struct.seqlock_t = type { %struct.seqcount_spinlock, %struct.spinlock }
%struct.rlimit = type { i32, i32 }
%struct.pacct_struct = type { i32, i32, i32, i64, i64, i32, i32 }
%struct.rw_semaphore = type { %struct.atomic_t, %struct.atomic_t, %struct.optimistic_spin_queue, %struct.raw_spinlock, %struct.list_head, ptr, %struct.lockdep_map }
%struct.rq_flags = type { i32, %struct.pin_cookie, i32 }
%struct.pin_cookie = type { i32 }
%struct.sched_domain = type { ptr, ptr, ptr, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i32, i64, [3 x i32], [3 x i32], [3 x i32], [3 x i32], [3 x i32], [3 x i32], [3 x i32], [3 x i32], i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, ptr, %union.anon.137, ptr, i32, [0 x i32] }
%union.anon.137 = type { %struct.callback_head }
%struct.sched_group = type { ptr, %struct.atomic_t, i32, ptr, i32, i32, [0 x i32] }
%struct.sched_group_capacity = type { %struct.atomic_t, i32, i32, i32, i32, i32, i32, [0 x i32] }
%struct.cgroup = type { %struct.cgroup_subsys_state, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, ptr, %struct.cgroup_file, %struct.cgroup_file, i16, i16, i16, i16, [14 x ptr], ptr, %struct.list_head, [14 x %struct.list_head], ptr, ptr, ptr, %struct.list_head, %struct.cgroup_base_stat, %struct.cgroup_base_stat, %struct.prev_cputime, %struct.list_head, %struct.mutex, %struct.wait_queue_head, %struct.work_struct, %struct.psi_group, %struct.cgroup_bpf, %struct.atomic_t, %struct.cgroup_freezer_state, [0 x i64] }
%struct.cgroup_file = type { ptr, i32, %struct.timer_list }
%struct.timer_list = type { %struct.hlist_node, i32, ptr, i32, %struct.lockdep_map }
%struct.cgroup_base_stat = type { %struct.task_cputime }
%struct.task_cputime = type { i64, i64, i64 }
%struct.psi_group = type { %struct.mutex, ptr, [6 x i64], i64, i64, %struct.delayed_work, [2 x [6 x i64]], [6 x [3 x i32]], ptr, %struct.timer_list, %struct.wait_queue_head, %struct.atomic_t, %struct.mutex, %struct.list_head, [6 x i32], i32, i64, [6 x i64], i64, i64 }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, ptr, i32 }
%struct.cgroup_bpf = type { [23 x ptr], [23 x %struct.list_head], [23 x i32], %struct.list_head, ptr, %struct.percpu_ref, %struct.work_struct }
%struct.cgroup_freezer_state = type { i8, i32, i32, i32 }
%struct.lb_env = type { ptr, ptr, i32, i32, ptr, ptr, i32, i32, i32, ptr, i32, i32, i32, i32, i32, i32, %struct.list_head }
%struct.sg_lb_stats = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.sd_lb_stats = type { ptr, ptr, i32, i32, i32, i32, %struct.sg_lb_stats, %struct.sg_lb_stats }
%struct.em_perf_domain = type { ptr, i32, i32, [0 x i32] }
%struct.perf_domain = type { ptr, ptr, %struct.callback_head }
%struct.em_perf_state = type { i32, i32, i32, i32 }
%struct.cpuidle_state = type { [16 x i8], [32 x i8], i64, i64, i32, i32, i32, i32, ptr, ptr, ptr }

@sysctl_sched_latency = dso_local global { i32, [28 x i8] } { i32 6000000, [28 x i8] zeroinitializer }, align 32
@sysctl_sched_tunable_scaling = dso_local global { i32, [28 x i8] } { i32 1, [28 x i8] zeroinitializer }, align 32
@sysctl_sched_min_granularity = dso_local global { i32, [28 x i8] } { i32 750000, [28 x i8] zeroinitializer }, align 32
@sysctl_sched_idle_min_granularity = dso_local global { i32, [28 x i8] } { i32 750000, [28 x i8] zeroinitializer }, align 32
@sysctl_sched_wakeup_granularity = dso_local global { i32, [28 x i8] } { i32 1000000, [28 x i8] zeroinitializer }, align 32
@sysctl_sched_migration_cost = dso_local local_unnamed_addr global i32 500000, section ".data..read_mostly", align 4
@__setup_str_setup_sched_thermal_decay_shift = internal constant [27 x i8] c"sched_thermal_decay_shift=\00", section ".init.rodata", align 1
@__setup_setup_sched_thermal_decay_shift = internal global %struct.obs_kernel_param { ptr @__setup_str_setup_sched_thermal_decay_shift, ptr @setup_sched_thermal_decay_shift, i32 0 }, section ".init.setup", align 4
@sysctl_sched_cfs_bandwidth_slice = dso_local global { i32, [28 x i8] } { i32 5000, [28 x i8] zeroinitializer }, align 32
@sched_nr_latency = internal global { i32, [28 x i8] } { i32 8, [28 x i8] zeroinitializer }, align 32
@normalized_sysctl_sched_min_granularity = internal global { i32, [28 x i8] } { i32 750000, [28 x i8] zeroinitializer }, align 32
@normalized_sysctl_sched_latency = internal global { i32, [28 x i8] } { i32 6000000, [28 x i8] zeroinitializer }, align 32
@normalized_sysctl_sched_wakeup_granularity = internal global { i32, [28 x i8] } { i32 1000000, [28 x i8] zeroinitializer }, align 32
@fair_sched_class = dso_local constant %struct.sched_class { i32 1, ptr @enqueue_task_fair, ptr @dequeue_task_fair, ptr @yield_task_fair, ptr @yield_to_task_fair, ptr @check_preempt_wakeup, ptr @__pick_next_task_fair, ptr @put_prev_task_fair, ptr @set_next_task_fair, ptr @balance_fair, ptr @select_task_rq_fair, ptr @pick_task_fair, ptr @migrate_task_rq_fair, ptr null, ptr @set_cpus_allowed_common, ptr @rq_online_fair, ptr @rq_offline_fair, ptr null, ptr @task_tick_fair, ptr @task_fork_fair, ptr @task_dead_fair, ptr @switched_from_fair, ptr @switched_to_fair, ptr @prio_changed_fair, ptr @get_rr_interval_fair, ptr @update_curr_fair, ptr @task_change_group_fair }, section "__fair_sched_class", align 4
@sched_prio_to_weight = external dso_local local_unnamed_addr constant [40 x i32], align 4
@sched_prio_to_wmult = external dso_local local_unnamed_addr constant [40 x i32], align 4
@sched_feat_keys = external dso_local global [25 x %struct.static_key], align 4
@__cfs_bandwidth_used = internal global %struct.static_key zeroinitializer, align 4
@init_cfs_bandwidth.__key = internal global { %struct.lock_class_key, [24 x i8] } zeroinitializer, align 32
@.str = internal constant { [13 x i8], [19 x i8] } { [13 x i8] c"&cfs_b->lock\00", [19 x i8] zeroinitializer }, align 32
@debug_locks = external dso_local local_unnamed_addr global i32, section ".data..read_mostly", align 4
@.str.1 = internal constant { [20 x i8], [44 x i8] } { [20 x i8] c"kernel/sched/fair.c\00", [44 x i8] zeroinitializer }, align 32
@sched_smt_present = dso_local global { { { %struct.atomic_t, { ptr } } }, [24 x i8] } zeroinitializer, align 32
@__kstrtab_sched_smt_present = external dso_local constant [0 x i8], align 1
@__kstrtabns_sched_smt_present = external dso_local constant [0 x i8], align 1
@__ksymtab_sched_smt_present = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @sched_smt_present to i32), ptr @__kstrtab_sched_smt_present, ptr @__kstrtabns_sched_smt_present }, section "___ksymtab_gpl+sched_smt_present", align 4
@nr_cpu_ids = external dso_local local_unnamed_addr global i32, align 4
@max_load_balance_interval = internal unnamed_addr global i32 10, section ".data..read_mostly", align 4
@jiffies = external dso_local global i32, section ".data..cacheline_aligned", align 128
@nohz_balance_exit_idle.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@runqueues = external dso_local global %struct.rq, section ".data..percpu..shared_aligned", align 128
@__per_cpu_offset = external dso_local local_unnamed_addr global [4 x i32], align 4
@.str.2 = internal constant { [16 x i8], [16 x i8] } { [16 x i8] c"rq != this_rq()\00", [16 x i8] zeroinitializer }, align 32
@nohz = internal global %struct.anon.138 zeroinitializer, align 128
@nohz_balance_enter_idle.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.3 = internal constant { [26 x i8], [38 x i8] } { [26 x i8] c"cpu != smp_processor_id()\00", [38 x i8] zeroinitializer }, align 32
@cfs_prio_less.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.4 = internal constant { [29 x i8], [35 x i8] } { [29 x i8] c"task_rq(b)->core != rq->core\00", [35 x i8] zeroinitializer }, align 32
@init_cfs_rq.__key = internal global { %struct.lock_class_key, [24 x i8] } zeroinitializer, align 32
@.str.5 = internal constant { [22 x i8], [42 x i8] } { [22 x i8] c"&cfs_rq->removed.lock\00", [42 x i8] zeroinitializer }, align 32
@__cpu_possible_mask = external dso_local global %struct.cpumask, align 4
@shares_mutex = internal global { %struct.mutex, [36 x i8] } { %struct.mutex { %struct.atomic_t zeroinitializer, %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.40, i8 0, i8 2, i8 0, i32 0, i32 0 } }, %struct.optimistic_spin_queue zeroinitializer, %struct.list_head { ptr getelementptr (i8, ptr @shares_mutex, i64 52), ptr getelementptr (i8, ptr @shares_mutex, i64 52) }, ptr @shares_mutex, %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.41, i8 0, i8 4, i8 0, i32 0, i32 0 } }, [36 x i8] zeroinitializer }, align 32
@root_task_group = external dso_local global %struct.task_group, align 128
@sched_group_set_idle.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@__kstrtab_sched_trace_cfs_rq_avg = external dso_local constant [0 x i8], align 1
@__kstrtabns_sched_trace_cfs_rq_avg = external dso_local constant [0 x i8], align 1
@__ksymtab_sched_trace_cfs_rq_avg = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @sched_trace_cfs_rq_avg to i32), ptr @__kstrtab_sched_trace_cfs_rq_avg, ptr @__kstrtabns_sched_trace_cfs_rq_avg }, section "___ksymtab_gpl+sched_trace_cfs_rq_avg", align 4
@.str.6 = internal constant { [7 x i8], [25 x i8] } { [7 x i8] c"(null)\00", [25 x i8] zeroinitializer }, align 32
@__kstrtab_sched_trace_cfs_rq_path = external dso_local constant [0 x i8], align 1
@__kstrtabns_sched_trace_cfs_rq_path = external dso_local constant [0 x i8], align 1
@__ksymtab_sched_trace_cfs_rq_path = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @sched_trace_cfs_rq_path to i32), ptr @__kstrtab_sched_trace_cfs_rq_path, ptr @__kstrtabns_sched_trace_cfs_rq_path }, section "___ksymtab_gpl+sched_trace_cfs_rq_path", align 4
@__kstrtab_sched_trace_cfs_rq_cpu = external dso_local constant [0 x i8], align 1
@__kstrtabns_sched_trace_cfs_rq_cpu = external dso_local constant [0 x i8], align 1
@__ksymtab_sched_trace_cfs_rq_cpu = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @sched_trace_cfs_rq_cpu to i32), ptr @__kstrtab_sched_trace_cfs_rq_cpu, ptr @__kstrtabns_sched_trace_cfs_rq_cpu }, section "___ksymtab_gpl+sched_trace_cfs_rq_cpu", align 4
@__kstrtab_sched_trace_rq_avg_rt = external dso_local constant [0 x i8], align 1
@__kstrtabns_sched_trace_rq_avg_rt = external dso_local constant [0 x i8], align 1
@__ksymtab_sched_trace_rq_avg_rt = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @sched_trace_rq_avg_rt to i32), ptr @__kstrtab_sched_trace_rq_avg_rt, ptr @__kstrtabns_sched_trace_rq_avg_rt }, section "___ksymtab_gpl+sched_trace_rq_avg_rt", align 4
@__kstrtab_sched_trace_rq_avg_dl = external dso_local constant [0 x i8], align 1
@__kstrtabns_sched_trace_rq_avg_dl = external dso_local constant [0 x i8], align 1
@__ksymtab_sched_trace_rq_avg_dl = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @sched_trace_rq_avg_dl to i32), ptr @__kstrtab_sched_trace_rq_avg_dl, ptr @__kstrtabns_sched_trace_rq_avg_dl }, section "___ksymtab_gpl+sched_trace_rq_avg_dl", align 4
@__kstrtab_sched_trace_rq_avg_irq = external dso_local constant [0 x i8], align 1
@__kstrtabns_sched_trace_rq_avg_irq = external dso_local constant [0 x i8], align 1
@__ksymtab_sched_trace_rq_avg_irq = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @sched_trace_rq_avg_irq to i32), ptr @__kstrtab_sched_trace_rq_avg_irq, ptr @__kstrtabns_sched_trace_rq_avg_irq }, section "___ksymtab_gpl+sched_trace_rq_avg_irq", align 4
@__kstrtab_sched_trace_rq_cpu = external dso_local constant [0 x i8], align 1
@__kstrtabns_sched_trace_rq_cpu = external dso_local constant [0 x i8], align 1
@__ksymtab_sched_trace_rq_cpu = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @sched_trace_rq_cpu to i32), ptr @__kstrtab_sched_trace_rq_cpu, ptr @__kstrtabns_sched_trace_rq_cpu }, section "___ksymtab_gpl+sched_trace_rq_cpu", align 4
@__kstrtab_sched_trace_rq_cpu_capacity = external dso_local constant [0 x i8], align 1
@__kstrtabns_sched_trace_rq_cpu_capacity = external dso_local constant [0 x i8], align 1
@__ksymtab_sched_trace_rq_cpu_capacity = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @sched_trace_rq_cpu_capacity to i32), ptr @__kstrtab_sched_trace_rq_cpu_capacity, ptr @__kstrtabns_sched_trace_rq_cpu_capacity }, section "___ksymtab_gpl+sched_trace_rq_cpu_capacity", align 4
@__kstrtab_sched_trace_rd_span = external dso_local constant [0 x i8], align 1
@__kstrtabns_sched_trace_rd_span = external dso_local constant [0 x i8], align 1
@__ksymtab_sched_trace_rd_span = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @sched_trace_rd_span to i32), ptr @__kstrtab_sched_trace_rd_span, ptr @__kstrtabns_sched_trace_rd_span }, section "___ksymtab_gpl+sched_trace_rd_span", align 4
@__kstrtab_sched_trace_rq_nr_running = external dso_local constant [0 x i8], align 1
@__kstrtabns_sched_trace_rq_nr_running = external dso_local constant [0 x i8], align 1
@__ksymtab_sched_trace_rq_nr_running = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @sched_trace_rq_nr_running to i32), ptr @__kstrtab_sched_trace_rq_nr_running, ptr @__kstrtabns_sched_trace_rq_nr_running }, section "___ksymtab_gpl+sched_trace_rq_nr_running", align 4
@sysctl_sched_child_runs_first = dso_local local_unnamed_addr global i32 0, section ".data..read_mostly", align 4
@sched_thermal_decay_shift = dso_local global { i32, [28 x i8] } zeroinitializer, align 32
@__pcpu_scope_load_balance_mask = dso_local local_unnamed_addr global i8 0, section ".discard", align 1
@__pcpu_unique_load_balance_mask = dso_local local_unnamed_addr global i8 0, section ".discard", align 1
@load_balance_mask = weak dso_local global ptr null, section ".data..percpu", align 4
@__pcpu_scope_select_idle_mask = dso_local local_unnamed_addr global i8 0, section ".discard", align 1
@__pcpu_unique_select_idle_mask = dso_local local_unnamed_addr global i8 0, section ".discard", align 1
@select_idle_mask = weak dso_local global ptr null, section ".data..percpu", align 4
@setup_sched_thermal_decay_shift._entry = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str.7, ptr @.str.8, ptr @.str.1, i32 101, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str.7 = internal constant { [66 x i8], [62 x i8] } { [66 x i8] c"\014Unable to set scheduler thermal pressure decay shift parameter\0A\00", [62 x i8] zeroinitializer }, align 32
@.str.8 = internal constant { [32 x i8], [32 x i8] } { [32 x i8] c"setup_sched_thermal_decay_shift\00", [32 x i8] zeroinitializer }, align 32
@setup_sched_thermal_decay_shift._entry_ptr = internal global ptr @setup_sched_thermal_decay_shift._entry, section ".printk_index", align 4
@cpu_scale = external dso_local global i32, section ".data..percpu", align 4
@.str.9 = internal constant { [21 x i8], [43 x i8] } { [21 x i8] c"kernel/sched/sched.h\00", [43 x i8] zeroinitializer }, align 32
@assert_clock_updated.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.10 = internal constant { [39 x i8], [57 x i8] } { [39 x i8] c"rq->clock_update_flags < RQCF_ACT_SKIP\00", [57 x i8] zeroinitializer }, align 32
@cfs_rq_is_decayed.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.11 = internal constant { [73 x i8], [55 x i8] } { [73 x i8] c"cfs_rq->avg.load_avg || cfs_rq->avg.util_avg || cfs_rq->avg.runnable_avg\00", [55 x i8] zeroinitializer }, align 32
@sched_schedstats = external dso_local global %struct.static_key_false, align 4
@check_schedstat_required.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@check_schedstat_required._entry = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str.12, ptr @.str.13, ptr @.str.14, i32 65, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str.12 = internal constant { [154 x i8], [38 x i8] } { [154 x i8] c"Scheduler tracepoints stat_sleep, stat_iowait, stat_blocked and stat_runtime require the kernel parameter schedstats=enable or kernel.sched_schedstats=1\0A\00", [38 x i8] zeroinitializer }, align 32
@.str.13 = internal constant { [25 x i8], [39 x i8] } { [25 x i8] c"check_schedstat_required\00", [39 x i8] zeroinitializer }, align 32
@.str.14 = internal constant { [21 x i8], [43 x i8] } { [21 x i8] c"kernel/sched/stats.h\00", [43 x i8] zeroinitializer }, align 32
@check_schedstat_required._entry_ptr = internal global ptr @check_schedstat_required._entry, section ".printk_index", align 4
@__tracepoint_sched_stat_wait = external dso_local global %struct.tracepoint, align 4
@__tracepoint_sched_stat_sleep = external dso_local global %struct.tracepoint, align 4
@__tracepoint_sched_stat_iowait = external dso_local global %struct.tracepoint, align 4
@__tracepoint_sched_stat_blocked = external dso_local global %struct.tracepoint, align 4
@__tracepoint_sched_stat_runtime = external dso_local global %struct.tracepoint, align 4
@__tracepoint_sched_update_nr_running_tp = external dso_local global %struct.tracepoint, align 4
@__tracepoint_pelt_cfs_tp = external dso_local global %struct.tracepoint, align 4
@.str.15 = internal constant { [29 x i8], [35 x i8] } { [29 x i8] c"include/trace/events/sched.h\00", [35 x i8] zeroinitializer }, align 32
@trace_pelt_cfs_tp.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@.str.16 = internal constant { [41 x i8], [55 x i8] } { [41 x i8] c"suspicious rcu_dereference_check() usage\00", [55 x i8] zeroinitializer }, align 32
@__cpu_online_mask = external dso_local global %struct.cpumask, align 4
@cpu_max_bits_warn.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.17 = internal constant { [24 x i8], [40 x i8] } { [24 x i8] c"include/linux/cpumask.h\00", [40 x i8] zeroinitializer }, align 32
@__tracepoint_pelt_se_tp = external dso_local global %struct.tracepoint, align 4
@trace_pelt_se_tp.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@cpufreq_update_util_data = external dso_local global ptr, section ".data..percpu", align 4
@cpufreq_update_util.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@assert_list_leaf_cfs_rq.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.18 = internal constant { [46 x i8], [50 x i8] } { [46 x i8] c"rq->tmp_alone_branch != &rq->leaf_cfs_rq_list\00", [50 x i8] zeroinitializer }, align 32
@max_cfs_quota_period = external dso_local local_unnamed_addr constant i64, align 8
@sched_cfs_period_timer._rs = internal global { %struct.ratelimit_state, [60 x i8] } { %struct.ratelimit_state { %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.19, i8 0, i8 2, i8 0, i32 0, i32 0 } }, i32 500, i32 10, i32 0, i32 0, i32 0, i32 0 }, [60 x i8] zeroinitializer }, align 32
@.str.19 = internal constant { [9 x i8], [23 x i8] } { [9 x i8] c"_rs.lock\00", [23 x i8] zeroinitializer }, align 32
@__func__.sched_cfs_period_timer = private unnamed_addr constant [23 x i8] c"sched_cfs_period_timer\00", align 1
@sched_cfs_period_timer._entry = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str.20, ptr @__func__.sched_cfs_period_timer, ptr @.str.1, i32 5327, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str.20 = internal constant { [105 x i8], [55 x i8] } { [105 x i8] c"\014cfs_period_timer[cpu%d]: period too short, scaling up (new cfs_period_us = %lld, cfs_quota_us = %lld)\0A\00", [55 x i8] zeroinitializer }, align 32
@sched_cfs_period_timer._entry_ptr = internal global ptr @sched_cfs_period_timer._entry, section ".printk_index", align 4
@sched_cfs_period_timer._rs.21 = internal global { %struct.ratelimit_state, [60 x i8] } { %struct.ratelimit_state { %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.19, i8 0, i8 2, i8 0, i32 0, i32 0 } }, i32 500, i32 10, i32 0, i32 0, i32 0, i32 0 }, [60 x i8] zeroinitializer }, align 32
@sched_cfs_period_timer._entry.22 = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str.23, ptr @__func__.sched_cfs_period_timer, ptr @.str.1, i32 5333, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str.23 = internal constant { [135 x i8], [57 x i8] } { [135 x i8] c"\014cfs_period_timer[cpu%d]: period too short, but cannot scale up without losing precision (cfs_period_us = %lld, cfs_quota_us = %lld)\0A\00", [57 x i8] zeroinitializer }, align 32
@sched_cfs_period_timer._entry_ptr.24 = internal global ptr @sched_cfs_period_timer._entry.22, section ".printk_index", align 4
@distribute_cfs_runtime.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@.str.25 = internal constant { [42 x i8], [54 x i8] } { [42 x i8] c"RCU-list traversed in non-reader section!\00", [54 x i8] zeroinitializer }, align 32
@distribute_cfs_runtime.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.26 = internal constant { [30 x i8], [34 x i8] } { [30 x i8] c"cfs_rq->runtime_remaining > 0\00", [34 x i8] zeroinitializer }, align 32
@rcu_lock_map = external dso_local global %struct.lockdep_map, align 4
@rcu_read_lock.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@.str.27 = internal constant { [25 x i8], [39 x i8] } { [25 x i8] c"include/linux/rcupdate.h\00", [39 x i8] zeroinitializer }, align 32
@.str.28 = internal constant { [42 x i8], [54 x i8] } { [42 x i8] c"rcu_read_lock() used illegally while idle\00", [54 x i8] zeroinitializer }, align 32
@sd_llc_shared = external dso_local global ptr, section ".data..percpu", align 4
@test_idle_cores.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@cpu_topology = external dso_local global [4 x %struct.cpu_topology], align 4
@set_idle_cores.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@rcu_read_unlock.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@.str.29 = internal constant { [44 x i8], [52 x i8] } { [44 x i8] c"rcu_read_unlock() used illegally while idle\00", [52 x i8] zeroinitializer }, align 32
@trace_sched_stat_runtime.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@task_css_set.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@cgroup_mutex = external dso_local global %struct.mutex, align 4
@css_set_lock = external dso_local global %struct.spinlock, align 4
@.str.30 = internal constant { [23 x i8], [41 x i8] } { [23 x i8] c"include/linux/cgroup.h\00", [41 x i8] zeroinitializer }, align 32
@task_of.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.31 = internal constant { [20 x i8], [44 x i8] } { [20 x i8] c"!entity_is_task(se)\00", [44 x i8] zeroinitializer }, align 32
@put_prev_task.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@hrtick_start_fair.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.32 = internal constant { [17 x i8], [47 x i8] } { [17 x i8] c"task_rq(p) != rq\00", [47 x i8] zeroinitializer }, align 32
@sched_asym_cpucapacity = external dso_local global %struct.static_key_false, align 4
@__tracepoint_sched_cpu_capacity_tp = external dso_local global %struct.tracepoint, align 4
@trace_sched_cpu_capacity_tp.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@__num_online_cpus = external dso_local global %struct.atomic_t, align 4
@sd_llc = external dso_local global ptr, section ".data..percpu", align 4
@set_cpu_sd_state_busy.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@__cpu_active_mask = external dso_local global %struct.cpumask, align 4
@housekeeping_overridden = external dso_local global %struct.static_key_false, align 4
@on_null_domain.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@set_cpu_sd_state_idle.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@_nohz_idle_balance.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.33 = internal constant { [46 x i8], [50 x i8] } { [46 x i8] c"(flags & NOHZ_KICK_MASK) == NOHZ_BALANCE_KICK\00", [50 x i8] zeroinitializer }, align 32
@rt_sched_class = external dso_local constant %struct.sched_class, align 4
@dl_sched_class = external dso_local constant %struct.sched_class, align 4
@thermal_pressure = external dso_local global i32, section ".data..percpu", align 4
@rebalance_domains.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@sched_domains_mutex = external dso_local global %struct.mutex, align 4
@balancing = internal global { %struct.spinlock, [52 x i8] } { %struct.spinlock { %union.anon.2 { %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.34, i8 0, i8 3, i8 0, i32 0, i32 0 } } } }, [52 x i8] zeroinitializer }, align 32
@.str.34 = internal constant { [10 x i8], [22 x i8] } { [10 x i8] c"balancing\00", [22 x i8] zeroinitializer }, align 32
@sysctl_sched_nr_migrate = external dso_local local_unnamed_addr global i32, section ".data..read_mostly", align 4
@find_busiest_group.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@__tracepoint_sched_overutilized_tp = external dso_local global %struct.tracepoint, align 4
@trace_sched_overutilized_tp.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@sched_energy_present = external dso_local global %struct.static_key_false, align 4
@__sched_core_enabled = external dso_local global %struct.static_key_false, align 4
@rq_pin_lock.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@balance_push_callback = external dso_local global %struct.callback_head, align 4
@.str.35 = internal constant { [71 x i8], [57 x i8] } { [71 x i8] c"rq->balance_callback && rq->balance_callback != &balance_push_callback\00", [57 x i8] zeroinitializer }, align 32
@active_load_balance_cpu_stop.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@newidle_balance.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@newidle_balance.__warned.36 = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@nohz_balancer_kick.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@sd_asym_packing = external dso_local global ptr, section ".data..percpu", align 4
@nohz_balancer_kick.__warned.37 = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@sd_asym_cpucapacity = external dso_local global ptr, section ".data..percpu", align 4
@nohz_balancer_kick.__warned.38 = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@nohz_balancer_kick.__warned.39 = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@kmalloc_caches = external dso_local local_unnamed_addr global [4 x [14 x ptr]], align 4
@.str.40 = internal constant { [23 x i8], [41 x i8] } { [23 x i8] c"shares_mutex.wait_lock\00", [41 x i8] zeroinitializer }, align 32
@.str.41 = internal constant { [13 x i8], [19 x i8] } { [13 x i8] c"shares_mutex\00", [19 x i8] zeroinitializer }, align 32
@__tracepoint_sched_util_est_cfs_tp = external dso_local global %struct.tracepoint, align 4
@trace_sched_util_est_cfs_tp.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@set_next_buddy.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.42 = internal constant { [11 x i8], [21 x i8] } { [11 x i8] c"!se->on_rq\00", [21 x i8] zeroinitializer }, align 32
@__tracepoint_sched_util_est_se_tp = external dso_local global %struct.tracepoint, align 4
@trace_sched_util_est_se_tp.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@set_last_buddy.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@select_task_rq_fair.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@find_energy_efficient_cpu.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@find_energy_efficient_cpu.__warned.43 = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@sched_uclamp_used = external dso_local global %struct.static_key_false, align 4
@sd_llc_size = external dso_local global i32, section ".data..percpu", align 4
@find_idlest_cpu.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@idle_get_state.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.45 = internal constant { [22 x i8], [42 x i8] } { [22 x i8] c"!rcu_read_lock_held()\00", [42 x i8] zeroinitializer }, align 32
@select_idle_sibling.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@lockdep_recursion = external dso_local global i32, section ".data..percpu", align 4
@hardirqs_enabled = external dso_local global i32, section ".data..percpu", align 4
@select_idle_sibling.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@select_idle_sibling.__warned.46 = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@select_idle_cpu.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@update_runtime_enabled.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@task_groups = external dso_local global %struct.list_head, align 4
@unthrottle_offline_cfs_rqs.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@sched_numa_balancing = external dso_local global %struct.static_key_false, align 4
@___asan_gen_.47 = private unnamed_addr constant [21 x i8] c"sysctl_sched_latency\00", align 1
@___asan_gen_.49 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 38, i32 14 }
@___asan_gen_.50 = private unnamed_addr constant [29 x i8] c"sysctl_sched_tunable_scaling\00", align 1
@___asan_gen_.52 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 52, i32 14 }
@___asan_gen_.53 = private unnamed_addr constant [29 x i8] c"sysctl_sched_min_granularity\00", align 1
@___asan_gen_.55 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 59, i32 14 }
@___asan_gen_.56 = private unnamed_addr constant [34 x i8] c"sysctl_sched_idle_min_granularity\00", align 1
@___asan_gen_.58 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 68, i32 14 }
@___asan_gen_.59 = private unnamed_addr constant [32 x i8] c"sysctl_sched_wakeup_granularity\00", align 1
@___asan_gen_.61 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 90, i32 14 }
@___asan_gen_.62 = private unnamed_addr constant [33 x i8] c"sysctl_sched_cfs_bandwidth_slice\00", align 1
@___asan_gen_.64 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 144, i32 14 }
@___asan_gen_.65 = private unnamed_addr constant [17 x i8] c"sched_nr_latency\00", align 1
@___asan_gen_.67 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 73, i32 21 }
@___asan_gen_.68 = private unnamed_addr constant [40 x i8] c"normalized_sysctl_sched_min_granularity\00", align 1
@___asan_gen_.70 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 60, i32 21 }
@___asan_gen_.71 = private unnamed_addr constant [32 x i8] c"normalized_sysctl_sched_latency\00", align 1
@___asan_gen_.73 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 39, i32 21 }
@___asan_gen_.74 = private unnamed_addr constant [43 x i8] c"normalized_sysctl_sched_wakeup_granularity\00", align 1
@___asan_gen_.76 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 91, i32 21 }
@___asan_gen_.82 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 5349, i32 2 }
@___asan_gen_.85 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 5371, i32 2 }
@___asan_gen_.86 = private unnamed_addr constant [18 x i8] c"sched_smt_present\00", align 1
@___asan_gen_.88 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 6136, i32 1 }
@___asan_gen_.91 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 10549, i32 2 }
@___asan_gen_.94 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 10585, i32 2 }
@___asan_gen_.97 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 11102, i32 2 }
@___asan_gen_.98 = private unnamed_addr constant [6 x i8] c"__key\00", align 1
@___asan_gen_.103 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 11406, i32 2 }
@___asan_gen_.104 = private unnamed_addr constant [13 x i8] c"shares_mutex\00", align 1
@___asan_gen_.109 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 11849, i32 17 }
@___asan_gen_.110 = private unnamed_addr constant [26 x i8] c"sched_thermal_decay_shift\00", align 1
@___asan_gen_.112 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 95, i32 5 }
@___asan_gen_.121 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 101, i32 3 }
@___asan_gen_.124 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.222, i32 1309, i32 2 }
@___asan_gen_.127 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.222, i32 1459, i32 2 }
@___asan_gen_.130 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 3300, i32 2 }
@___asan_gen_.141 = private unnamed_addr constant [24 x i8] c"../kernel/sched/stats.h\00", align 1
@___asan_gen_.142 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.141, i32 65, i32 3 }
@___asan_gen_.147 = private unnamed_addr constant [32 x i8] c"../include/trace/events/sched.h\00", align 1
@___asan_gen_.148 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.147, i32 691, i32 1 }
@___asan_gen_.150 = private unnamed_addr constant [27 x i8] c"../include/linux/cpumask.h\00", align 1
@___asan_gen_.151 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.150, i32 108, i32 2 }
@___asan_gen_.154 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 387, i32 2 }
@___asan_gen_.166 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 5323, i32 5 }
@___asan_gen_.167 = private unnamed_addr constant [4 x i8] c"_rs\00", align 1
@___asan_gen_.170 = private unnamed_addr constant [7 x i8] c"_entry\00", align 1
@___asan_gen_.175 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 5329, i32 5 }
@___asan_gen_.178 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 5010, i32 2 }
@___asan_gen_.181 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 5020, i32 3 }
@___asan_gen_.187 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.189, i32 695, i32 2 }
@___asan_gen_.189 = private unnamed_addr constant [28 x i8] c"../include/linux/rcupdate.h\00", align 1
@___asan_gen_.190 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.189, i32 723, i32 2 }
@___asan_gen_.192 = private unnamed_addr constant [26 x i8] c"../include/linux/cgroup.h\00", align 1
@___asan_gen_.193 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.192, i32 481, i32 9 }
@___asan_gen_.196 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.222, i32 1376, i32 2 }
@___asan_gen_.199 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 5503, i32 2 }
@___asan_gen_.202 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 10673, i32 2 }
@___asan_gen_.203 = private unnamed_addr constant [10 x i8] c"balancing\00", align 1
@___asan_gen_.208 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 10220, i32 8 }
@___asan_gen_.211 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.222, i32 1545, i32 2 }
@___asan_gen_.217 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 11576, i32 8 }
@___asan_gen_.219 = private constant [23 x i8] c"../kernel/sched/fair.c\00", align 1
@___asan_gen_.220 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.219, i32 7065, i32 7 }
@___asan_gen_.221 = private unnamed_addr constant [17 x i8] c"<string literal>\00", align 1
@___asan_gen_.222 = private unnamed_addr constant [24 x i8] c"../kernel/sched/sched.h\00", align 1
@___asan_gen_.223 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.222, i32 2300, i32 2 }
@llvm.compiler.used = appending global [75 x ptr] [ptr @__ksymtab_sched_smt_present, ptr @__ksymtab_sched_trace_cfs_rq_avg, ptr @__ksymtab_sched_trace_cfs_rq_cpu, ptr @__ksymtab_sched_trace_cfs_rq_path, ptr @__ksymtab_sched_trace_rd_span, ptr @__ksymtab_sched_trace_rq_avg_dl, ptr @__ksymtab_sched_trace_rq_avg_irq, ptr @__ksymtab_sched_trace_rq_avg_rt, ptr @__ksymtab_sched_trace_rq_cpu, ptr @__ksymtab_sched_trace_rq_cpu_capacity, ptr @__ksymtab_sched_trace_rq_nr_running, ptr @__setup_setup_sched_thermal_decay_shift, ptr @check_schedstat_required._entry, ptr @check_schedstat_required._entry_ptr, ptr @sched_cfs_period_timer._entry, ptr @sched_cfs_period_timer._entry.22, ptr @sched_cfs_period_timer._entry_ptr, ptr @sched_cfs_period_timer._entry_ptr.24, ptr @setup_sched_thermal_decay_shift._entry, ptr @setup_sched_thermal_decay_shift._entry_ptr, ptr @sysctl_sched_latency, ptr @sysctl_sched_tunable_scaling, ptr @sysctl_sched_min_granularity, ptr @sysctl_sched_idle_min_granularity, ptr @sysctl_sched_wakeup_granularity, ptr @sysctl_sched_cfs_bandwidth_slice, ptr @sched_nr_latency, ptr @normalized_sysctl_sched_min_granularity, ptr @normalized_sysctl_sched_latency, ptr @normalized_sysctl_sched_wakeup_granularity, ptr @init_cfs_bandwidth.__key, ptr @.str, ptr @.str.1, ptr @sched_smt_present, ptr @.str.2, ptr @.str.3, ptr @.str.4, ptr @init_cfs_rq.__key, ptr @.str.5, ptr @shares_mutex, ptr @.str.6, ptr @sched_thermal_decay_shift, ptr @.str.7, ptr @.str.8, ptr @.str.9, ptr @.str.10, ptr @.str.11, ptr @.str.12, ptr @.str.13, ptr @.str.14, ptr @.str.15, ptr @.str.16, ptr @.str.17, ptr @.str.18, ptr @sched_cfs_period_timer._rs, ptr @.str.19, ptr @.str.20, ptr @sched_cfs_period_timer._rs.21, ptr @.str.23, ptr @.str.25, ptr @.str.26, ptr @.str.27, ptr @.str.28, ptr @.str.29, ptr @.str.30, ptr @.str.31, ptr @.str.32, ptr @.str.33, ptr @balancing, ptr @.str.34, ptr @.str.35, ptr @.str.40, ptr @.str.41, ptr @.str.42, ptr @.str.45], section "llvm.metadata"
@0 = internal global [59 x { i32, i32, i32, i32, i32, i32, i32, i32 }] [{ i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @sysctl_sched_latency to i32), i32 4, i32 32, i32 ptrtoint (ptr @___asan_gen_.47 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.49 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @sysctl_sched_tunable_scaling to i32), i32 4, i32 32, i32 ptrtoint (ptr @___asan_gen_.50 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.52 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @sysctl_sched_min_granularity to i32), i32 4, i32 32, i32 ptrtoint (ptr @___asan_gen_.53 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.55 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @sysctl_sched_idle_min_granularity to i32), i32 4, i32 32, i32 ptrtoint (ptr @___asan_gen_.56 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.58 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @sysctl_sched_wakeup_granularity to i32), i32 4, i32 32, i32 ptrtoint (ptr @___asan_gen_.59 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.61 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @sysctl_sched_cfs_bandwidth_slice to i32), i32 4, i32 32, i32 ptrtoint (ptr @___asan_gen_.62 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.64 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @sched_nr_latency to i32), i32 4, i32 32, i32 ptrtoint (ptr @___asan_gen_.65 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.67 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @normalized_sysctl_sched_min_granularity to i32), i32 4, i32 32, i32 ptrtoint (ptr @___asan_gen_.68 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.70 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @normalized_sysctl_sched_latency to i32), i32 4, i32 32, i32 ptrtoint (ptr @___asan_gen_.71 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.73 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @normalized_sysctl_sched_wakeup_granularity to i32), i32 4, i32 32, i32 ptrtoint (ptr @___asan_gen_.74 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.76 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @init_cfs_bandwidth.__key to i32), i32 8, i32 32, i32 ptrtoint (ptr @___asan_gen_.98 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.82 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str to i32), i32 13, i32 32, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.82 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.1 to i32), i32 20, i32 64, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.85 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @sched_smt_present to i32), i32 8, i32 32, i32 ptrtoint (ptr @___asan_gen_.86 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.88 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.2 to i32), i32 16, i32 32, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.91 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.3 to i32), i32 26, i32 64, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.94 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.4 to i32), i32 29, i32 64, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.97 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @init_cfs_rq.__key to i32), i32 8, i32 32, i32 ptrtoint (ptr @___asan_gen_.98 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.103 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.5 to i32), i32 22, i32 64, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.103 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @shares_mutex to i32), i32 92, i32 128, i32 ptrtoint (ptr @___asan_gen_.104 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.217 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.6 to i32), i32 7, i32 32, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.109 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @sched_thermal_decay_shift to i32), i32 4, i32 32, i32 ptrtoint (ptr @___asan_gen_.110 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.112 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @setup_sched_thermal_decay_shift._entry to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.170 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.121 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.7 to i32), i32 66, i32 128, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.121 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.8 to i32), i32 32, i32 64, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.121 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.9 to i32), i32 21, i32 64, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.124 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.10 to i32), i32 39, i32 96, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.127 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.11 to i32), i32 73, i32 128, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.130 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @check_schedstat_required._entry to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.170 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.142 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.12 to i32), i32 154, i32 192, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.142 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.13 to i32), i32 25, i32 64, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.142 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.14 to i32), i32 21, i32 64, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.142 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.15 to i32), i32 29, i32 64, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.148 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.16 to i32), i32 41, i32 96, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.148 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.17 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.151 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.18 to i32), i32 46, i32 96, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.154 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @sched_cfs_period_timer._rs to i32), i32 68, i32 128, i32 ptrtoint (ptr @___asan_gen_.167 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.166 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.19 to i32), i32 9, i32 32, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.166 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @sched_cfs_period_timer._entry to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.170 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.166 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.20 to i32), i32 105, i32 160, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.166 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @sched_cfs_period_timer._rs.21 to i32), i32 68, i32 128, i32 ptrtoint (ptr @___asan_gen_.167 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.175 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @sched_cfs_period_timer._entry.22 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.170 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.175 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.23 to i32), i32 135, i32 192, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.175 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.25 to i32), i32 42, i32 96, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.178 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.26 to i32), i32 30, i32 64, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.181 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.27 to i32), i32 25, i32 64, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.187 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.28 to i32), i32 42, i32 96, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.187 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.29 to i32), i32 44, i32 96, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.190 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.30 to i32), i32 23, i32 64, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.193 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.31 to i32), i32 20, i32 64, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.196 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.32 to i32), i32 17, i32 64, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.199 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.33 to i32), i32 46, i32 96, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.202 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @balancing to i32), i32 44, i32 96, i32 ptrtoint (ptr @___asan_gen_.203 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.208 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.34 to i32), i32 10, i32 32, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.208 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.35 to i32), i32 71, i32 128, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.211 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.40 to i32), i32 23, i32 64, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.217 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.41 to i32), i32 13, i32 32, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.217 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.42 to i32), i32 11, i32 32, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.220 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.45 to i32), i32 22, i32 64, i32 ptrtoint (ptr @___asan_gen_.221 to i32), i32 ptrtoint (ptr @___asan_gen_.219 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.223 to i32), i32 -1 }]
@llvm.used = appending global [2 x ptr] [ptr @asan.module_ctor, ptr @asan.module_dtor], section "llvm.metadata"
@llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 1, ptr @asan.module_ctor, ptr null }]
@llvm.global_dtors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 1, ptr @asan.module_dtor, ptr null }]

; Function Attrs: cold nounwind null_pointer_is_valid optsize sanitize_address sspstrong uwtable(sync)
define internal i32 @setup_sched_thermal_decay_shift(ptr noundef %str) #0 section ".init.text" align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %_shift = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %_shift) #20
  %0 = ptrtoint ptr %_shift to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 0, ptr %_shift, align 4
  %call = call i32 @kstrtoint(ptr noundef %str, i32 noundef 0, ptr noundef nonnull %_shift) #20
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %do.end

do.end:                                           ; preds = %entry
  %call1 = call i32 (ptr, ...) @_printk(ptr noundef nonnull @.str.7) #22
  br label %if.end

if.end:                                           ; preds = %do.end, %entry
  %1 = ptrtoint ptr %_shift to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %_shift, align 4
  %3 = call i32 @llvm.smax.i32(i32 %2, i32 0)
  %4 = call i32 @llvm.umin.i32(i32 %3, i32 10)
  store i32 %4, ptr @sched_thermal_decay_shift, align 4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %_shift) #20
  ret i32 1
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define weak dso_local i32 @arch_asym_cpu_priority(i32 noundef %cpu) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %sub = sub i32 0, %cpu
  ret i32 %sub
}

; Function Attrs: cold nounwind null_pointer_is_valid optsize sanitize_address sspstrong uwtable(sync)
define dso_local void @sched_init_granularity() local_unnamed_addr #0 section ".init.text" align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call fastcc void @update_sysctl()
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @update_sysctl() unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @__num_online_cpus, i32 noundef 4) #20
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__num_online_cpus to i32))
  %0 = load volatile i32, ptr @__num_online_cpus, align 4
  %1 = tail call i32 @llvm.umin.i32(i32 %0, i32 8) #20
  %2 = load i32, ptr @sysctl_sched_tunable_scaling, align 4
  switch i32 %2, label %cond.end11.i [
    i32 0, label %get_update_sysctl_factor.exit
    i32 2, label %sw.bb1.i
  ]

sw.bb1.i:                                         ; preds = %entry
  br label %get_update_sysctl_factor.exit

cond.end11.i:                                     ; preds = %entry
  %tobool.not.i.i.i = icmp eq i32 %1, 0
  %3 = tail call i32 @llvm.ctlz.i32(i32 %1, i1 true) #20, !range !258
  %sub.i.op.i.i.op = sub nuw nsw i32 32, %3
  %add.i = select i1 %tobool.not.i.i.i, i32 0, i32 %sub.i.op.i.i.op
  br label %get_update_sysctl_factor.exit

get_update_sysctl_factor.exit:                    ; preds = %cond.end11.i, %sw.bb1.i, %entry
  %factor.0.i = phi i32 [ %add.i, %cond.end11.i ], [ %1, %sw.bb1.i ], [ 1, %entry ]
  %4 = load i32, ptr @normalized_sysctl_sched_min_granularity, align 4
  %mul = mul i32 %4, %factor.0.i
  store i32 %mul, ptr @sysctl_sched_min_granularity, align 4
  %5 = load i32, ptr @normalized_sysctl_sched_latency, align 4
  %mul1 = mul i32 %5, %factor.0.i
  store i32 %mul1, ptr @sysctl_sched_latency, align 4
  %6 = load i32, ptr @normalized_sysctl_sched_wakeup_granularity, align 4
  %mul2 = mul i32 %6, %factor.0.i
  store i32 %mul2, ptr @sysctl_sched_wakeup_granularity, align 4
  ret void
}

; Function Attrs: argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync)
define dso_local ptr @__pick_first_entity(ptr nocapture noundef readonly %cfs_rq) local_unnamed_addr #2 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %rb_leftmost = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 10, i32 1
  %0 = ptrtoint ptr %rb_leftmost to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %rb_leftmost, align 4
  %tobool.not = icmp eq ptr %1, null
  %add.ptr = getelementptr i8, ptr %1, i32 -8
  %retval.0 = select i1 %tobool.not, ptr null, ptr %add.ptr
  ret ptr %retval.0
}

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @__pick_last_entity(ptr noundef %cfs_rq) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tasks_timeline = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 10
  %call = tail call ptr @rb_last(ptr noundef %tasks_timeline) #20
  %tobool.not = icmp eq ptr %call, null
  %add.ptr = getelementptr i8, ptr %call, i32 -8
  %retval.0 = select i1 %tobool.not, ptr null, ptr %add.ptr
  ret ptr %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @rb_last(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @sched_update_scaling() local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @__num_online_cpus, i32 noundef 4) #20
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__num_online_cpus to i32))
  %0 = load volatile i32, ptr @__num_online_cpus, align 4
  %1 = tail call i32 @llvm.umin.i32(i32 %0, i32 8) #20
  %2 = load i32, ptr @sysctl_sched_tunable_scaling, align 4
  switch i32 %2, label %cond.end11.i [
    i32 0, label %get_update_sysctl_factor.exit
    i32 2, label %sw.bb1.i
  ]

sw.bb1.i:                                         ; preds = %entry
  br label %get_update_sysctl_factor.exit

cond.end11.i:                                     ; preds = %entry
  %tobool.not.i.i.i = icmp eq i32 %1, 0
  %3 = tail call i32 @llvm.ctlz.i32(i32 %1, i1 true) #20, !range !258
  %sub.i.op.i.i.op = sub nuw nsw i32 32, %3
  %add.i = select i1 %tobool.not.i.i.i, i32 0, i32 %sub.i.op.i.i.op
  br label %get_update_sysctl_factor.exit

get_update_sysctl_factor.exit:                    ; preds = %cond.end11.i, %sw.bb1.i, %entry
  %factor.0.i = phi i32 [ %add.i, %cond.end11.i ], [ %1, %sw.bb1.i ], [ 1, %entry ]
  %4 = load i32, ptr @sysctl_sched_latency, align 4
  %5 = load i32, ptr @sysctl_sched_min_granularity, align 4
  %add = add i32 %4, -1
  %sub = add i32 %add, %5
  %div = udiv i32 %sub, %5
  store i32 %div, ptr @sched_nr_latency, align 4
  %div1 = udiv i32 %5, %factor.0.i
  store i32 %div1, ptr @normalized_sysctl_sched_min_granularity, align 4
  %div2 = udiv i32 %4, %factor.0.i
  store i32 %div2, ptr @normalized_sysctl_sched_latency, align 4
  %6 = load i32, ptr @sysctl_sched_wakeup_granularity, align 4
  %div3 = udiv i32 %6, %factor.0.i
  store i32 %div3, ptr @normalized_sysctl_sched_wakeup_granularity, align 4
  ret i32 0
}

; Function Attrs: argmemonly mustprogress nofree nosync nounwind null_pointer_is_valid sanitize_address sspstrong willreturn uwtable(sync)
define dso_local void @init_entity_runnable_average(ptr nocapture noundef %se) local_unnamed_addr #5 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %avg = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15
  %0 = call ptr @memset(ptr %avg, i32 0, i32 128)
  %my_q = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 12
  %1 = ptrtoint ptr %my_q to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %my_q, align 4
  %tobool.not = icmp eq ptr %2, null
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = ptrtoint ptr %se to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %se, align 128
  %load_avg = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 5
  %5 = ptrtoint ptr %load_avg to i32
  call void @__asan_store4_noabort(i32 %5)
  store i32 %4, ptr %load_avg, align 32
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @post_init_entity_util_avg(ptr noundef %p) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %se1 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %cfs_rq.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %0 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %cfs_rq.i, align 16
  %avg = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15
  %rq.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 27
  %2 = ptrtoint ptr %rq.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %rq.i, align 4
  %cpu.i = getelementptr inbounds %struct.rq, ptr %3, i32 0, i32 46
  %4 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %cpu.i, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %5
  %6 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %7, ptrtoint (ptr @cpu_scale to i32)
  %8 = inttoptr i32 %add.i to ptr
  %9 = ptrtoint ptr %8 to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %8, align 4
  %util_avg = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 17, i32 7
  %11 = ptrtoint ptr %util_avg to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %util_avg, align 8
  %sub = sub i32 %10, %12
  %div = sdiv i32 %sub, 2
  %cmp = icmp sgt i32 %sub, 1
  br i1 %cmp, label %if.then, label %if.end22

if.then:                                          ; preds = %entry
  %cmp8.not = icmp eq i32 %12, 0
  br i1 %cmp8.not, label %if.else, label %if.then9

if.then9:                                         ; preds = %if.then
  %13 = ptrtoint ptr %se1 to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %se1, align 128
  %mul = mul i32 %14, %12
  %util_avg12 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 7
  %15 = ptrtoint ptr %util_avg12 to i32
  call void @__asan_store4_noabort(i32 %15)
  store i32 %mul, ptr %util_avg12, align 8
  %load_avg = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 17, i32 5
  %16 = ptrtoint ptr %load_avg to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %load_avg, align 32
  %add = add i32 %17, 1
  %div15 = udiv i32 %mul, %add
  %18 = tail call i32 @llvm.umin.i32(i32 %div15, i32 %div)
  %19 = ptrtoint ptr %util_avg12 to i32
  call void @__asan_store4_noabort(i32 %19)
  store i32 %18, ptr %util_avg12, align 8
  br label %if.end22

if.else:                                          ; preds = %if.then
  %util_avg20 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 7
  %20 = ptrtoint ptr %util_avg20 to i32
  call void @__asan_store4_noabort(i32 %20)
  store i32 %div, ptr %util_avg20, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then9, %entry
  %util_avg23 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 7
  %21 = ptrtoint ptr %util_avg23 to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load i32, ptr %util_avg23, align 8
  %runnable_avg = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 6
  %23 = ptrtoint ptr %runnable_avg to i32
  call void @__asan_store4_noabort(i32 %23)
  store i32 %22, ptr %runnable_avg, align 4
  %sched_class = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 21
  %24 = ptrtoint ptr %sched_class to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %sched_class, align 32
  %cmp24.not = icmp eq ptr %25, @fair_sched_class
  br i1 %cmp24.not, label %if.end28, label %if.then25

if.then25:                                        ; preds = %if.end22
  %throttle_count.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 38
  %26 = ptrtoint ptr %throttle_count.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %throttle_count.i, align 4
  %tobool.not.i = icmp eq i32 %27, 0
  br i1 %tobool.not.i, label %if.end.i, label %if.then.i, !prof !259

if.then.i:                                        ; preds = %if.then25
  %throttled_clock_task.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 35
  %28 = ptrtoint ptr %throttled_clock_task.i to i32
  call void @__asan_load8_noabort(i32 %28)
  %29 = load i64, ptr %throttled_clock_task.i, align 8
  %throttled_clock_task_time.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 36
  %30 = ptrtoint ptr %throttled_clock_task_time.i to i32
  call void @__asan_load8_noabort(i32 %30)
  %31 = load i64, ptr %throttled_clock_task_time.i, align 16
  %sub.i = sub i64 %29, %31
  br label %cfs_rq_clock_pelt.exit

if.end.i:                                         ; preds = %if.then25
  %32 = ptrtoint ptr %rq.i to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load ptr, ptr %rq.i, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %34 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i.i = icmp eq i32 %34, 0
  br i1 %tobool.not.i.i.i, label %lockdep_assert_rq_held.exit.i.i, label %land.rhs.i.i.i

land.rhs.i.i.i:                                   ; preds = %if.end.i
  %core_enabled.i.i.i.i = getelementptr inbounds %struct.rq, ptr %33, i32 0, i32 81
  %35 = ptrtoint ptr %core_enabled.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %core_enabled.i.i.i.i, align 128
  %tobool.not.i.i.i.i = icmp eq i32 %36, 0
  br i1 %tobool.not.i.i.i.i, label %__rq_lockp.exit.i.i.i, label %if.then.i.i.i.i

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i
  %core.i.i.i.i = getelementptr inbounds %struct.rq, ptr %33, i32 0, i32 79
  %37 = ptrtoint ptr %core.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load ptr, ptr %core.i.i.i.i, align 8
  br label %__rq_lockp.exit.i.i.i

__rq_lockp.exit.i.i.i:                            ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i
  %retval.0.i.i.i.i = phi ptr [ %38, %if.then.i.i.i.i ], [ %33, %land.rhs.i.i.i ]
  %dep_map.i.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i.i, i32 0, i32 4
  %call.i.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i.i, i32 noundef -1) #20
  %cmp.not.i.i.i = icmp eq i32 %call.i.i.i.i, 0
  br i1 %cmp.not.i.i.i, label %do.end.i.i.i, label %lockdep_assert_rq_held.exit.i.i, !prof !260

do.end.i.i.i:                                     ; preds = %__rq_lockp.exit.i.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i.i

lockdep_assert_rq_held.exit.i.i:                  ; preds = %do.end.i.i.i, %__rq_lockp.exit.i.i.i, %if.end.i
  %clock_update_flags.i.i.i = getelementptr inbounds %struct.rq, ptr %33, i32 0, i32 25
  %39 = ptrtoint ptr %clock_update_flags.i.i.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load i32, ptr %clock_update_flags.i.i.i, align 4
  %cmp.i.i.i = icmp ult i32 %40, 2
  br i1 %cmp.i.i.i, label %land.rhs.i4.i.i, label %rq_clock_pelt.exit.i

land.rhs.i4.i.i:                                  ; preds = %lockdep_assert_rq_held.exit.i.i
  %.b37.i.i.i = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i.i, label %rq_clock_pelt.exit.i, label %if.then.i.i.i, !prof !259

if.then.i.i.i:                                    ; preds = %land.rhs.i4.i.i
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %rq_clock_pelt.exit.i

rq_clock_pelt.exit.i:                             ; preds = %if.then.i.i.i, %land.rhs.i4.i.i, %lockdep_assert_rq_held.exit.i.i
  %clock_pelt.i.i = getelementptr inbounds %struct.rq, ptr %33, i32 0, i32 29
  %41 = ptrtoint ptr %clock_pelt.i.i to i32
  call void @__asan_load8_noabort(i32 %41)
  %42 = load i64, ptr %clock_pelt.i.i, align 8
  %lost_idle_time.i.i = getelementptr inbounds %struct.rq, ptr %33, i32 0, i32 30
  %43 = ptrtoint ptr %lost_idle_time.i.i to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load i32, ptr %lost_idle_time.i.i, align 16
  %conv.i.i = zext i32 %44 to i64
  %throttled_clock_task_time4.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 36
  %45 = ptrtoint ptr %throttled_clock_task_time4.i to i32
  call void @__asan_load8_noabort(i32 %45)
  %46 = load i64, ptr %throttled_clock_task_time4.i, align 16
  %47 = add i64 %46, %conv.i.i
  %sub5.i = sub i64 %42, %47
  br label %cfs_rq_clock_pelt.exit

cfs_rq_clock_pelt.exit:                           ; preds = %rq_clock_pelt.exit.i, %if.then.i
  %retval.0.i = phi i64 [ %sub.i, %if.then.i ], [ %sub5.i, %rq_clock_pelt.exit.i ]
  %48 = ptrtoint ptr %avg to i32
  call void @__asan_store8_noabort(i32 %48)
  store i64 %retval.0.i, ptr %avg, align 128
  br label %cleanup

if.end28:                                         ; preds = %if.end22
  tail call fastcc void @attach_entity_cfs_rq(ptr noundef %se1)
  br label %cleanup

cleanup:                                          ; preds = %if.end28, %cfs_rq_clock_pelt.exit
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @attach_entity_cfs_rq(ptr noundef %se) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %cfs_rq.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 11
  %0 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %cfs_rq.i, align 16
  %parent = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 10
  %2 = ptrtoint ptr %parent to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %parent, align 4
  %tobool.not = icmp eq ptr %3, null
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %depth = getelementptr inbounds %struct.sched_entity, ptr %3, i32 0, i32 9
  %4 = ptrtoint ptr %depth to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %depth, align 8
  %add = add i32 %5, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi i32 [ %add, %cond.true ], [ 0, %entry ]
  %depth2 = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 9
  %6 = ptrtoint ptr %depth2 to i32
  call void @__asan_store4_noabort(i32 %6)
  store i32 %cond, ptr %depth2, align 8
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 16), i32 1), ptr blockaddress(@attach_entity_cfs_rq, %static_branch_ATTACH_AGE_LOAD.exit.thread)) #20
          to label %static_branch_ATTACH_AGE_LOAD.exit [label %static_branch_ATTACH_AGE_LOAD.exit.thread], !srcloc !261

static_branch_ATTACH_AGE_LOAD.exit.thread:        ; preds = %cond.end
  br label %static_branch_ATTACH_AGE_LOAD.exit

static_branch_ATTACH_AGE_LOAD.exit:               ; preds = %static_branch_ATTACH_AGE_LOAD.exit.thread, %cond.end
  %7 = phi i32 [ 2, %static_branch_ATTACH_AGE_LOAD.exit.thread ], [ 0, %cond.end ]
  tail call fastcc void @update_load_avg(ptr noundef %1, ptr noundef %se, i32 noundef %7)
  tail call fastcc void @attach_entity_load_avg(ptr noundef %1, ptr noundef %se)
  %load_avg.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 17, i32 5
  %8 = ptrtoint ptr %load_avg.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %load_avg.i, align 32
  %tg_load_avg_contrib.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 21
  %10 = ptrtoint ptr %tg_load_avg_contrib.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %tg_load_avg_contrib.i, align 128
  %sub.i = sub i32 %9, %11
  %tg.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 30
  %12 = ptrtoint ptr %tg.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %tg.i, align 4
  %cmp.i = icmp ne ptr %13, @root_task_group
  %14 = tail call i32 @llvm.abs.i32(i32 %sub.i, i1 false) #20
  %div21.i = lshr i32 %11, 6
  %cmp4.i = icmp ugt i32 %14, %div21.i
  %or.cond.i = select i1 %cmp.i, i1 %cmp4.i, i1 false
  br i1 %or.cond.i, label %if.then5.i, label %update_tg_load_avg.exit

if.then5.i:                                       ; preds = %static_branch_ATTACH_AGE_LOAD.exit
  %load_avg7.i = getelementptr inbounds %struct.task_group, ptr %13, i32 0, i32 6
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %load_avg7.i, i32 noundef 4) #20
  tail call void @llvm.prefetch.p0(ptr %load_avg7.i, i32 1, i32 3, i32 1) #20
  %15 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %load_avg7.i, ptr %load_avg7.i, i32 %sub.i, ptr elementtype(i32) %load_avg7.i) #20, !srcloc !262
  %16 = ptrtoint ptr %load_avg.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %load_avg.i, align 32
  %18 = ptrtoint ptr %tg_load_avg_contrib.i to i32
  call void @__asan_store4_noabort(i32 %18)
  store i32 %17, ptr %tg_load_avg_contrib.i, align 128
  br label %update_tg_load_avg.exit

update_tg_load_avg.exit:                          ; preds = %if.then5.i, %static_branch_ATTACH_AGE_LOAD.exit
  %19 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %cfs_rq.i, align 16
  %call1.i = tail call fastcc zeroext i1 @list_add_leaf_cfs_rq(ptr noundef %20) #20
  %21 = ptrtoint ptr %parent to i32
  call void @__asan_load4_noabort(i32 %21)
  %se.addr.020.i = load ptr, ptr %parent, align 4
  %tobool.not21.i = icmp eq ptr %se.addr.020.i, null
  br i1 %tobool.not21.i, label %propagate_entity_cfs_rq.exit, label %for.body.i

for.body.i:                                       ; preds = %for.inc.i, %update_tg_load_avg.exit
  %se.addr.022.i = phi ptr [ %se.addr.0.i, %for.inc.i ], [ %se.addr.020.i, %update_tg_load_avg.exit ]
  %cfs_rq.i18.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.022.i, i32 0, i32 11
  %22 = ptrtoint ptr %cfs_rq.i18.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %cfs_rq.i18.i, align 16
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@attach_entity_cfs_rq, %land.rhs.i.i)) #20
          to label %cfs_rq_throttled.exit.i [label %land.rhs.i.i], !srcloc !261

land.rhs.i.i:                                     ; preds = %for.body.i
  %throttled.i.i = getelementptr inbounds %struct.cfs_rq, ptr %23, i32 0, i32 37
  %24 = ptrtoint ptr %throttled.i.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %throttled.i.i, align 8
  %tobool.i.i = icmp ne i32 %25, 0
  %phi.cast.i.i = zext i1 %tobool.i.i to i32
  br label %cfs_rq_throttled.exit.i

cfs_rq_throttled.exit.i:                          ; preds = %land.rhs.i.i, %for.body.i
  %26 = phi i32 [ %phi.cast.i.i, %land.rhs.i.i ], [ 0, %for.body.i ]
  %tobool4.not.i = icmp eq i32 %26, 0
  br i1 %tobool4.not.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %cfs_rq_throttled.exit.i
  tail call fastcc void @update_load_avg(ptr noundef %23, ptr noundef nonnull %se.addr.022.i, i32 noundef 1) #20
  %call5.i = tail call fastcc zeroext i1 @list_add_leaf_cfs_rq(ptr noundef %23) #20
  br label %for.inc.i

if.end.i:                                         ; preds = %cfs_rq_throttled.exit.i
  %call6.i = tail call fastcc zeroext i1 @list_add_leaf_cfs_rq(ptr noundef %23) #20
  br i1 %call6.i, label %propagate_entity_cfs_rq.exit, label %for.inc.i

for.inc.i:                                        ; preds = %if.end.i, %if.then.i
  %se.addr.0.in.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.022.i, i32 0, i32 10
  %27 = ptrtoint ptr %se.addr.0.in.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %se.addr.0.i = load ptr, ptr %se.addr.0.in.i, align 4
  %tobool.not.i = icmp eq ptr %se.addr.0.i, null
  br i1 %tobool.not.i, label %propagate_entity_cfs_rq.exit, label %for.body.i

propagate_entity_cfs_rq.exit:                     ; preds = %for.inc.i, %if.end.i, %update_tg_load_avg.exit
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @reweight_task(ptr noundef %p, i32 noundef %prio) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %se1 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %cfs_rq.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %0 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %cfs_rq.i, align 16
  %arrayidx = getelementptr [40 x i32], ptr @sched_prio_to_weight, i32 0, i32 %prio
  %2 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %arrayidx, align 4
  tail call fastcc void @reweight_entity(ptr noundef %1, ptr noundef %se1, i32 noundef %3)
  %arrayidx3 = getelementptr [40 x i32], ptr @sched_prio_to_wmult, i32 0, i32 %prio
  %4 = ptrtoint ptr %arrayidx3 to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %arrayidx3, align 4
  %inv_weight = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 0, i32 1
  %6 = ptrtoint ptr %inv_weight to i32
  call void @__asan_store4_noabort(i32 %6)
  store i32 %5, ptr %inv_weight, align 4
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @reweight_entity(ptr noundef %cfs_rq, ptr noundef %se, i32 noundef %weight) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %on_rq = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 3
  %0 = ptrtoint ptr %on_rq to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %on_rq, align 4
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %if.end4, label %if.then

if.then:                                          ; preds = %entry
  %curr = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 11
  %2 = ptrtoint ptr %curr to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %curr, align 8
  %cmp = icmp eq ptr %3, %se
  br i1 %cmp, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  tail call fastcc void @update_curr(ptr noundef %cfs_rq)
  br label %if.end

if.end:                                           ; preds = %if.then1, %if.then
  %4 = ptrtoint ptr %se to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %se, align 128
  %6 = ptrtoint ptr %cfs_rq to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %cfs_rq, align 4
  %sub.i = sub i32 %7, %5
  store i32 %sub.i, ptr %cfs_rq, align 4
  %inv_weight.i = getelementptr inbounds %struct.load_weight, ptr %cfs_rq, i32 0, i32 1
  %8 = ptrtoint ptr %inv_weight.i to i32
  call void @__asan_store4_noabort(i32 %8)
  store i32 0, ptr %inv_weight.i, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.end, %entry
  %load_avg.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 5
  %load_avg2.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 5
  %9 = ptrtoint ptr %load_avg2.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %load_avg2.i, align 32
  %11 = ptrtoint ptr %load_avg.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %load_avg.i, align 4
  %13 = tail call i32 @llvm.usub.sat.i32(i32 %12, i32 %10) #20
  %14 = ptrtoint ptr %load_avg.i to i32
  call void @__asan_store4_noabort(i32 %14)
  store volatile i32 %13, ptr %load_avg.i, align 4
  %load_sum.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 1
  %15 = ptrtoint ptr %se to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %se, align 128
  %conv.i = sext i32 %16 to i64
  %load_sum20.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 1
  %17 = ptrtoint ptr %load_sum20.i to i32
  call void @__asan_load8_noabort(i32 %17)
  %18 = load i64, ptr %load_sum20.i, align 8
  %mul.i = mul i64 %18, %conv.i
  %19 = ptrtoint ptr %load_sum.i to i32
  call void @__asan_load8_noabort(i32 %19)
  %20 = load volatile i64, ptr %load_sum.i, align 8
  %21 = tail call i64 @llvm.usub.sat.i64(i64 %20, i64 %mul.i) #20
  %22 = ptrtoint ptr %load_sum.i to i32
  call void @__asan_store8_noabort(i32 %22)
  store volatile i64 %21, ptr %load_sum.i, align 8
  %conv45.i = trunc i64 %21 to i32
  %mul48.i = mul i32 %13, 46718
  %23 = tail call i32 @llvm.umax.i32(i32 %mul48.i, i32 %conv45.i) #20
  %conv52.i = zext i32 %23 to i64
  %24 = ptrtoint ptr %load_sum.i to i32
  call void @__asan_store8_noabort(i32 %24)
  store i64 %conv52.i, ptr %load_sum.i, align 8
  %25 = ptrtoint ptr %se to i32
  call void @__asan_store4_noabort(i32 %25)
  store i32 %weight, ptr %se, align 4
  %inv_weight.i34 = getelementptr inbounds %struct.load_weight, ptr %se, i32 0, i32 1
  %26 = ptrtoint ptr %inv_weight.i34 to i32
  call void @__asan_store4_noabort(i32 %26)
  store i32 0, ptr %inv_weight.i34, align 4
  %period_contrib.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 4
  %27 = ptrtoint ptr %period_contrib.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load i32, ptr %period_contrib.i, align 4
  %add.i = add i32 %28, 46718
  %conv = sext i32 %weight to i64
  %29 = ptrtoint ptr %load_sum20.i to i32
  call void @__asan_load8_noabort(i32 %29)
  %30 = load i64, ptr %load_sum20.i, align 8
  %mul = mul i64 %30, %conv
  %cmp164.i.i = icmp ult i64 %mul, 4294967296
  br i1 %cmp164.i.i, label %if.then168.i.i, label %if.else174.i.i, !prof !259

if.then168.i.i:                                   ; preds = %if.end4
  %conv169.i.i = trunc i64 %mul to i32
  %div172.i.i = udiv i32 %conv169.i.i, %add.i
  br label %div_u64.exit

if.else174.i.i:                                   ; preds = %if.end4
  %31 = tail call { i64, i64 } asm ".ifnc $0,r0; .ifnc $0r0,fpr11; .ifnc $0r0,r11fp; .ifnc $0r0,ipr12; .ifnc $0r0,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09.ifnc $1,r2; .ifnc $1r2,fpr11; .ifnc $1r2,r11fp; .ifnc $1r2,ipr12; .ifnc $1r2,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09.ifnc $2,r4; .ifnc $2r4,fpr11; .ifnc $2r4,r11fp; .ifnc $2r4,ipr12; .ifnc $2r4,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09bl\09__do_div64", "={r0},={r2},{r4},{r0},~{r12},~{lr},~{cc}"(i32 %add.i, i64 %mul) #23, !srcloc !263
  %asmresult1.i.i.i = extractvalue { i64, i64 } %31, 1
  %extract.t44 = trunc i64 %asmresult1.i.i.i to i32
  br label %div_u64.exit

div_u64.exit:                                     ; preds = %if.else174.i.i, %if.then168.i.i
  %dividend.addr.0.i.i.off0 = phi i32 [ %div172.i.i, %if.then168.i.i ], [ %extract.t44, %if.else174.i.i ]
  %32 = ptrtoint ptr %load_avg2.i to i32
  call void @__asan_store4_noabort(i32 %32)
  store i32 %dividend.addr.0.i.i.off0, ptr %load_avg2.i, align 32
  %33 = ptrtoint ptr %load_avg.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %load_avg.i, align 32
  %add.i37 = add i32 %34, %dividend.addr.0.i.i.off0
  store i32 %add.i37, ptr %load_avg.i, align 32
  %35 = ptrtoint ptr %se to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %se, align 128
  %conv.i38 = sext i32 %36 to i64
  %37 = ptrtoint ptr %load_sum20.i to i32
  call void @__asan_load8_noabort(i32 %37)
  %38 = load i64, ptr %load_sum20.i, align 8
  %mul.i40 = mul i64 %38, %conv.i38
  %39 = ptrtoint ptr %load_sum.i to i32
  call void @__asan_load8_noabort(i32 %39)
  %40 = load i64, ptr %load_sum.i, align 8
  %add6.i = add i64 %40, %mul.i40
  store i64 %add6.i, ptr %load_sum.i, align 8
  %41 = ptrtoint ptr %on_rq to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load i32, ptr %on_rq, align 4
  %tobool12.not = icmp eq i32 %42, 0
  br i1 %tobool12.not, label %if.end17, label %if.then13

if.then13:                                        ; preds = %div_u64.exit
  %43 = ptrtoint ptr %se to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load i32, ptr %se, align 128
  %45 = ptrtoint ptr %cfs_rq to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load i32, ptr %cfs_rq, align 4
  %add.i41 = add i32 %46, %44
  store i32 %add.i41, ptr %cfs_rq, align 4
  %inv_weight.i42 = getelementptr inbounds %struct.load_weight, ptr %cfs_rq, i32 0, i32 1
  %47 = ptrtoint ptr %inv_weight.i42 to i32
  call void @__asan_store4_noabort(i32 %47)
  store i32 0, ptr %inv_weight.i42, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.then13, %div_u64.exit
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @set_task_rq_fair(ptr noundef %se, ptr noundef readonly %prev, ptr nocapture noundef readonly %next) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 16), i32 1), ptr blockaddress(@set_task_rq_fair, %cleanup)) #20
          to label %if.end [label %cleanup], !srcloc !261

if.end:                                           ; preds = %entry
  %avg = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15
  %0 = ptrtoint ptr %avg to i32
  call void @__asan_load8_noabort(i32 %0)
  %1 = load i64, ptr %avg, align 128
  %tobool.not = icmp eq i64 %1, 0
  %tobool1.not = icmp eq ptr %prev, null
  %or.cond = or i1 %tobool1.not, %tobool.not
  br i1 %or.cond, label %cleanup, label %do.body.preheader

do.body.preheader:                                ; preds = %if.end
  %load_last_update_time_copy = getelementptr inbounds %struct.cfs_rq, ptr %prev, i32 0, i32 18
  %load_last_update_time_copy4 = getelementptr inbounds %struct.cfs_rq, ptr %next, i32 0, i32 18
  %avg9 = getelementptr inbounds %struct.cfs_rq, ptr %prev, i32 0, i32 17
  %avg11 = getelementptr inbounds %struct.cfs_rq, ptr %next, i32 0, i32 17
  br label %do.body

do.body:                                          ; preds = %do.body, %do.body.preheader
  %2 = ptrtoint ptr %load_last_update_time_copy to i32
  call void @__asan_load8_noabort(i32 %2)
  %3 = load i64, ptr %load_last_update_time_copy, align 128
  %4 = ptrtoint ptr %load_last_update_time_copy4 to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %load_last_update_time_copy4, align 128
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !264
  %6 = ptrtoint ptr %avg9 to i32
  call void @__asan_load8_noabort(i32 %6)
  %7 = load i64, ptr %avg9, align 128
  %8 = ptrtoint ptr %avg11 to i32
  call void @__asan_load8_noabort(i32 %8)
  %9 = load i64, ptr %avg11, align 128
  %cmp.not = icmp eq i64 %7, %3
  %cmp14.not = icmp eq i64 %9, %5
  %or.cond28 = select i1 %cmp.not, i1 %cmp14.not, i1 false
  br i1 %or.cond28, label %do.end15, label %do.body

do.end15:                                         ; preds = %do.body
  %call16 = tail call i32 @__update_load_avg_blocked_se(i64 noundef %3, ptr noundef %se) #20
  %10 = ptrtoint ptr %avg to i32
  call void @__asan_store8_noabort(i32 %10)
  store i64 %5, ptr %avg, align 128
  br label %cleanup

cleanup:                                          ; preds = %do.end15, %if.end, %entry
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__update_load_avg_blocked_se(i64 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @cfs_bandwidth_usage_inc() local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call void @static_key_slow_inc_cpuslocked(ptr noundef nonnull @__cfs_bandwidth_used) #20
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @static_key_slow_inc_cpuslocked(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @cfs_bandwidth_usage_dec() local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call void @static_key_slow_dec_cpuslocked(ptr noundef nonnull @__cfs_bandwidth_used) #20
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @static_key_slow_dec_cpuslocked(ptr noundef) local_unnamed_addr #4

; Function Attrs: argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid sanitize_address sspstrong willreturn uwtable(sync)
define dso_local void @__refill_cfs_bandwidth_runtime(ptr nocapture noundef %cfs_b) local_unnamed_addr #6 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %quota = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 2
  %0 = ptrtoint ptr %quota to i32
  call void @__asan_load8_noabort(i32 %0)
  %1 = load i64, ptr %quota, align 8
  %cmp = icmp eq i64 %1, -1
  br i1 %cmp, label %cleanup, label %if.end, !prof !260

if.end:                                           ; preds = %entry
  %runtime3 = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 3
  %2 = ptrtoint ptr %runtime3 to i32
  call void @__asan_load8_noabort(i32 %2)
  %3 = load i64, ptr %runtime3, align 8
  %add = add i64 %3, %1
  %runtime_snap = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 5
  %4 = ptrtoint ptr %runtime_snap to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %runtime_snap, align 8
  %sub = sub i64 %5, %add
  %cmp5 = icmp sgt i64 %sub, 0
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %burst_time = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 17
  %6 = ptrtoint ptr %burst_time to i32
  call void @__asan_load8_noabort(i32 %6)
  %7 = load i64, ptr %burst_time, align 8
  %add7 = add i64 %7, %sub
  store i64 %add7, ptr %burst_time, align 8
  %nr_burst = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 15
  %8 = ptrtoint ptr %nr_burst to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %nr_burst, align 8
  %inc = add i32 %9, 1
  store i32 %inc, ptr %nr_burst, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  %burst = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 4
  %10 = ptrtoint ptr %burst to i32
  call void @__asan_load8_noabort(i32 %10)
  %11 = load i64, ptr %burst, align 8
  %add11 = add i64 %11, %1
  %12 = tail call i64 @llvm.umin.i64(i64 %add, i64 %add11)
  %13 = ptrtoint ptr %runtime3 to i32
  call void @__asan_store8_noabort(i32 %13)
  store i64 %12, ptr %runtime3, align 8
  %14 = ptrtoint ptr %runtime_snap to i32
  call void @__asan_store8_noabort(i32 %14)
  store i64 %12, ptr %runtime_snap, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @unthrottle_cfs_rq(ptr noundef %cfs_rq) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %rq.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %0 = ptrtoint ptr %rq.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %rq.i, align 4
  %tg = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 30
  %2 = ptrtoint ptr %tg to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %tg, align 4
  %cfs_bandwidth.i = getelementptr inbounds %struct.task_group, ptr %3, i32 0, i32 16
  %se3 = getelementptr inbounds %struct.task_group, ptr %3, i32 0, i32 1
  %4 = ptrtoint ptr %se3 to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %se3, align 8
  %cpu.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 46
  %6 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %cpu.i, align 4
  %arrayidx = getelementptr ptr, ptr %5, i32 %7
  %8 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %arrayidx, align 4
  %throttled = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 37
  %10 = ptrtoint ptr %throttled to i32
  call void @__asan_store4_noabort(i32 %10)
  store i32 0, ptr %throttled, align 8
  tail call void @update_rq_clock(ptr noundef %1) #20
  tail call void @_raw_spin_lock(ptr noundef %cfs_bandwidth.i) #20
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %11 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i = icmp eq i32 %11, 0
  br i1 %tobool.not.i.i, label %lockdep_assert_rq_held.exit.i, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %entry
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 81
  %12 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %13, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.rhs.i.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 79
  %14 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %land.rhs.i.i
  %retval.0.i.i.i = phi ptr [ %15, %if.then.i.i.i ], [ %1, %land.rhs.i.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i, i32 noundef -1) #20
  %cmp.not.i.i = icmp eq i32 %call.i.i.i, 0
  br i1 %cmp.not.i.i, label %do.end.i.i, label %lockdep_assert_rq_held.exit.i, !prof !260

do.end.i.i:                                       ; preds = %__rq_lockp.exit.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i

lockdep_assert_rq_held.exit.i:                    ; preds = %do.end.i.i, %__rq_lockp.exit.i.i, %entry
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 25
  %16 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %clock_update_flags.i.i, align 4
  %cmp.i.i = icmp ult i32 %17, 2
  br i1 %cmp.i.i, label %land.rhs.i3.i, label %rq_clock.exit

land.rhs.i3.i:                                    ; preds = %lockdep_assert_rq_held.exit.i
  %.b37.i.i = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i, label %rq_clock.exit, label %if.then.i.i, !prof !259

if.then.i.i:                                      ; preds = %land.rhs.i3.i
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %rq_clock.exit

rq_clock.exit:                                    ; preds = %if.then.i.i, %land.rhs.i3.i, %lockdep_assert_rq_held.exit.i
  %clock.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 26
  %18 = ptrtoint ptr %clock.i to i32
  call void @__asan_load8_noabort(i32 %18)
  %19 = load i64, ptr %clock.i, align 32
  %throttled_clock = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 34
  %20 = ptrtoint ptr %throttled_clock to i32
  call void @__asan_load8_noabort(i32 %20)
  %21 = load i64, ptr %throttled_clock, align 64
  %sub = sub i64 %19, %21
  %throttled_time = getelementptr inbounds %struct.task_group, ptr %3, i32 0, i32 16, i32 16
  %22 = ptrtoint ptr %throttled_time to i32
  call void @__asan_load8_noabort(i32 %22)
  %23 = load i64, ptr %throttled_time, align 8
  %add = add i64 %sub, %23
  store i64 %add, ptr %throttled_time, align 8
  %throttled_list = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 39
  %call.i.i = tail call zeroext i1 @__list_del_entry_valid(ptr noundef %throttled_list) #20
  br i1 %call.i.i, label %if.end.i.i, label %list_del_rcu.exit

if.end.i.i:                                       ; preds = %rq_clock.exit
  %prev.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 39, i32 1
  %24 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %prev.i.i, align 4
  %26 = ptrtoint ptr %throttled_list to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load ptr, ptr %throttled_list, align 4
  %prev1.i.i.i = getelementptr inbounds %struct.list_head, ptr %27, i32 0, i32 1
  %28 = ptrtoint ptr %prev1.i.i.i to i32
  call void @__asan_store4_noabort(i32 %28)
  store ptr %25, ptr %prev1.i.i.i, align 4
  %29 = ptrtoint ptr %25 to i32
  call void @__asan_store4_noabort(i32 %29)
  store volatile ptr %27, ptr %25, align 4
  br label %list_del_rcu.exit

list_del_rcu.exit:                                ; preds = %if.end.i.i, %rq_clock.exit
  %prev.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 39, i32 1
  %30 = ptrtoint ptr %prev.i to i32
  call void @__asan_store4_noabort(i32 %30)
  store ptr inttoptr (i32 290 to ptr), ptr %prev.i, align 4
  tail call void @_raw_spin_unlock(ptr noundef %cfs_bandwidth.i) #20
  %31 = ptrtoint ptr %tg to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %tg, align 4
  %call8 = tail call i32 @walk_tg_tree_from(ptr noundef %32, ptr noundef nonnull @tg_nop, ptr noundef nonnull @tg_unthrottle_up, ptr noundef %1) #20
  %33 = ptrtoint ptr %cfs_rq to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %cfs_rq, align 128
  %tobool.not = icmp eq i32 %34, 0
  br i1 %tobool.not, label %if.then, label %if.end11

if.then:                                          ; preds = %list_del_rcu.exit
  %on_list = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 28
  %35 = ptrtoint ptr %on_list to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %on_list, align 32
  %tobool9.not = icmp eq i32 %36, 0
  br i1 %tobool9.not, label %cleanup78, label %unthrottle_throttle

if.end11:                                         ; preds = %list_del_rcu.exit
  %h_nr_running = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 2
  %37 = ptrtoint ptr %h_nr_running to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %h_nr_running, align 4
  %tobool12.not169 = icmp eq ptr %9, null
  br i1 %tobool12.not169, label %for.end60, label %for.body.preheader

for.body.preheader:                               ; preds = %if.end11
  %idle_h_nr_running = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 4
  %39 = ptrtoint ptr %idle_h_nr_running to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load i32, ptr %idle_h_nr_running, align 4
  br label %for.body

for.body:                                         ; preds = %for.inc, %for.body.preheader
  %idle_task_delta.0171 = phi i32 [ %idle_task_delta.1, %for.inc ], [ %40, %for.body.preheader ]
  %se.0170 = phi ptr [ %59, %for.inc ], [ %9, %for.body.preheader ]
  %cfs_rq.i = getelementptr inbounds %struct.sched_entity, ptr %se.0170, i32 0, i32 11
  %41 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load ptr, ptr %cfs_rq.i, align 16
  %on_rq = getelementptr inbounds %struct.sched_entity, ptr %se.0170, i32 0, i32 3
  %43 = ptrtoint ptr %on_rq to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load i32, ptr %on_rq, align 4
  %tobool14.not = icmp eq i32 %44, 0
  br i1 %tobool14.not, label %if.end16, label %for.body33

if.end16:                                         ; preds = %for.body
  tail call fastcc void @enqueue_entity(ptr noundef %42, ptr noundef nonnull %se.0170, i32 noundef 1)
  %my_q.i = getelementptr inbounds %struct.sched_entity, ptr %se.0170, i32 0, i32 12
  %45 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load ptr, ptr %my_q.i, align 4
  %idle.i = getelementptr inbounds %struct.cfs_rq, ptr %46, i32 0, i32 31
  %47 = ptrtoint ptr %idle.i to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load i32, ptr %idle.i, align 16
  %cmp.i = icmp slt i32 %48, 1
  br i1 %cmp.i, label %if.end22, label %if.then20

if.then20:                                        ; preds = %if.end16
  %49 = ptrtoint ptr %h_nr_running to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load i32, ptr %h_nr_running, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.then20, %if.end16
  %idle_task_delta.1 = phi i32 [ %50, %if.then20 ], [ %idle_task_delta.0171, %if.end16 ]
  %h_nr_running23 = getelementptr inbounds %struct.cfs_rq, ptr %42, i32 0, i32 2
  %51 = ptrtoint ptr %h_nr_running23 to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load i32, ptr %h_nr_running23, align 4
  %add24 = add i32 %52, %38
  store i32 %add24, ptr %h_nr_running23, align 4
  %idle_h_nr_running25 = getelementptr inbounds %struct.cfs_rq, ptr %42, i32 0, i32 4
  %53 = ptrtoint ptr %idle_h_nr_running25 to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load i32, ptr %idle_h_nr_running25, align 4
  %add26 = add i32 %54, %idle_task_delta.1
  store i32 %add26, ptr %idle_h_nr_running25, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@unthrottle_cfs_rq, %land.rhs.i)) #20
          to label %cfs_rq_throttled.exit [label %land.rhs.i], !srcloc !261

land.rhs.i:                                       ; preds = %if.end22
  %throttled.i = getelementptr inbounds %struct.cfs_rq, ptr %42, i32 0, i32 37
  %55 = ptrtoint ptr %throttled.i to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load i32, ptr %throttled.i, align 8
  %tobool.i = icmp ne i32 %56, 0
  %phi.cast.i = zext i1 %tobool.i to i32
  br label %cfs_rq_throttled.exit

cfs_rq_throttled.exit:                            ; preds = %land.rhs.i, %if.end22
  %57 = phi i32 [ %phi.cast.i, %land.rhs.i ], [ 0, %if.end22 ]
  %tobool28.not = icmp eq i32 %57, 0
  br i1 %tobool28.not, label %for.inc, label %for.body63.preheader

for.inc:                                          ; preds = %cfs_rq_throttled.exit
  %parent = getelementptr inbounds %struct.sched_entity, ptr %se.0170, i32 0, i32 10
  %58 = ptrtoint ptr %parent to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load ptr, ptr %parent, align 4
  %tobool12.not = icmp eq ptr %59, null
  br i1 %tobool12.not, label %for.end60, label %for.body

for.body33:                                       ; preds = %for.inc58, %for.body
  %idle_task_delta.4177 = phi i32 [ %idle_task_delta.5, %for.inc58 ], [ %idle_task_delta.0171, %for.body ]
  %se.1176 = phi ptr [ %84, %for.inc58 ], [ %se.0170, %for.body ]
  %cfs_rq.i137 = getelementptr inbounds %struct.sched_entity, ptr %se.1176, i32 0, i32 11
  %60 = ptrtoint ptr %cfs_rq.i137 to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load ptr, ptr %cfs_rq.i137, align 16
  tail call fastcc void @update_load_avg(ptr noundef %61, ptr noundef nonnull %se.1176, i32 noundef 1)
  %my_q.i138 = getelementptr inbounds %struct.sched_entity, ptr %se.1176, i32 0, i32 12
  %62 = ptrtoint ptr %my_q.i138 to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load ptr, ptr %my_q.i138, align 4
  %tobool.not.i = icmp eq ptr %63, null
  br i1 %tobool.not.i, label %se_update_runnable.exit, label %if.then.i

if.then.i:                                        ; preds = %for.body33
  %h_nr_running.i = getelementptr inbounds %struct.cfs_rq, ptr %63, i32 0, i32 2
  %64 = ptrtoint ptr %h_nr_running.i to i32
  call void @__asan_load4_noabort(i32 %64)
  %65 = load i32, ptr %h_nr_running.i, align 4
  %runnable_weight.i = getelementptr inbounds %struct.sched_entity, ptr %se.1176, i32 0, i32 13
  %66 = ptrtoint ptr %runnable_weight.i to i32
  call void @__asan_store4_noabort(i32 %66)
  store i32 %65, ptr %runnable_weight.i, align 8
  br label %se_update_runnable.exit

se_update_runnable.exit:                          ; preds = %if.then.i, %for.body33
  %67 = ptrtoint ptr %my_q.i138 to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load ptr, ptr %my_q.i138, align 4
  %idle.i140 = getelementptr inbounds %struct.cfs_rq, ptr %68, i32 0, i32 31
  %69 = ptrtoint ptr %idle.i140 to i32
  call void @__asan_load4_noabort(i32 %69)
  %70 = load i32, ptr %idle.i140, align 16
  %cmp.i141 = icmp slt i32 %70, 1
  br i1 %cmp.i141, label %if.end41, label %if.then39

if.then39:                                        ; preds = %se_update_runnable.exit
  %71 = ptrtoint ptr %h_nr_running to i32
  call void @__asan_load4_noabort(i32 %71)
  %72 = load i32, ptr %h_nr_running, align 4
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %se_update_runnable.exit
  %idle_task_delta.5 = phi i32 [ %72, %if.then39 ], [ %idle_task_delta.4177, %se_update_runnable.exit ]
  %h_nr_running42 = getelementptr inbounds %struct.cfs_rq, ptr %61, i32 0, i32 2
  %73 = ptrtoint ptr %h_nr_running42 to i32
  call void @__asan_load4_noabort(i32 %73)
  %74 = load i32, ptr %h_nr_running42, align 4
  %add43 = add i32 %74, %38
  store i32 %add43, ptr %h_nr_running42, align 4
  %idle_h_nr_running44 = getelementptr inbounds %struct.cfs_rq, ptr %61, i32 0, i32 4
  %75 = ptrtoint ptr %idle_h_nr_running44 to i32
  call void @__asan_load4_noabort(i32 %75)
  %76 = load i32, ptr %idle_h_nr_running44, align 4
  %add45 = add i32 %76, %idle_task_delta.5
  store i32 %add45, ptr %idle_h_nr_running44, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@unthrottle_cfs_rq, %land.rhs.i146)) #20
          to label %cfs_rq_throttled.exit147 [label %land.rhs.i146], !srcloc !261

land.rhs.i146:                                    ; preds = %if.end41
  %throttled.i143 = getelementptr inbounds %struct.cfs_rq, ptr %61, i32 0, i32 37
  %77 = ptrtoint ptr %throttled.i143 to i32
  call void @__asan_load4_noabort(i32 %77)
  %78 = load i32, ptr %throttled.i143, align 8
  %tobool.i144 = icmp ne i32 %78, 0
  %phi.cast.i145 = zext i1 %tobool.i144 to i32
  br label %cfs_rq_throttled.exit147

cfs_rq_throttled.exit147:                         ; preds = %land.rhs.i146, %if.end41
  %79 = phi i32 [ %phi.cast.i145, %land.rhs.i146 ], [ 0, %if.end41 ]
  %tobool47.not = icmp eq i32 %79, 0
  br i1 %tobool47.not, label %if.end49, label %for.body63.preheader

if.end49:                                         ; preds = %cfs_rq_throttled.exit147
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@unthrottle_cfs_rq, %land.rhs.i150)) #20
          to label %throttled_hierarchy.exit [label %land.rhs.i150], !srcloc !261

land.rhs.i150:                                    ; preds = %if.end49
  %throttle_count.i = getelementptr inbounds %struct.cfs_rq, ptr %61, i32 0, i32 38
  %80 = ptrtoint ptr %throttle_count.i to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load i32, ptr %throttle_count.i, align 4
  %tobool.i148 = icmp ne i32 %81, 0
  %phi.cast.i149 = zext i1 %tobool.i148 to i32
  br label %throttled_hierarchy.exit

throttled_hierarchy.exit:                         ; preds = %land.rhs.i150, %if.end49
  %82 = phi i32 [ %phi.cast.i149, %land.rhs.i150 ], [ 0, %if.end49 ]
  %tobool51.not = icmp eq i32 %82, 0
  br i1 %tobool51.not, label %for.inc58, label %if.then52

if.then52:                                        ; preds = %throttled_hierarchy.exit
  %call53 = tail call fastcc zeroext i1 @list_add_leaf_cfs_rq(ptr noundef %61)
  br label %for.inc58

for.inc58:                                        ; preds = %if.then52, %throttled_hierarchy.exit
  %parent59 = getelementptr inbounds %struct.sched_entity, ptr %se.1176, i32 0, i32 10
  %83 = ptrtoint ptr %parent59 to i32
  call void @__asan_load4_noabort(i32 %83)
  %84 = load ptr, ptr %parent59, align 4
  %tobool32.not = icmp eq ptr %84, null
  br i1 %tobool32.not, label %for.end60, label %for.body33

for.end60:                                        ; preds = %for.inc58, %for.inc, %if.end11
  %nr_running.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 1
  %85 = ptrtoint ptr %nr_running.i to i32
  call void @__asan_load4_noabort(i32 %85)
  %86 = load i32, ptr %nr_running.i, align 4
  %add.i = add i32 %86, %38
  store i32 %add.i, ptr %nr_running.i, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_update_nr_running_tp, i32 0, i32 1), ptr blockaddress(@unthrottle_cfs_rq, %if.then.i151)) #20
          to label %if.end.i [label %if.then.i151], !srcloc !261

if.then.i151:                                     ; preds = %for.end60
  tail call void @call_trace_sched_update_nr_running(ptr noundef %1, i32 noundef %38) #20
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i151, %for.end60
  %cmp.i152 = icmp ult i32 %86, 2
  br i1 %cmp.i152, label %land.lhs.true.i, label %for.end74

land.lhs.true.i:                                  ; preds = %if.end.i
  %87 = ptrtoint ptr %nr_running.i to i32
  call void @__asan_load4_noabort(i32 %87)
  %88 = load i32, ptr %nr_running.i, align 4
  %cmp3.i = icmp ugt i32 %88, 1
  br i1 %cmp3.i, label %do.end.i, label %for.end74

do.end.i:                                         ; preds = %land.lhs.true.i
  %rd.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 35
  %89 = ptrtoint ptr %rd.i to i32
  call void @__asan_load4_noabort(i32 %89)
  %90 = load ptr, ptr %rd.i, align 8
  %overload.i = getelementptr inbounds %struct.root_domain, ptr %90, i32 0, i32 5
  %91 = ptrtoint ptr %overload.i to i32
  call void @__asan_load4_noabort(i32 %91)
  %92 = load volatile i32, ptr %overload.i, align 8
  %tobool.not.i153 = icmp eq i32 %92, 0
  br i1 %tobool.not.i153, label %do.body10.i, label %for.end74

do.body10.i:                                      ; preds = %do.end.i
  %93 = ptrtoint ptr %overload.i to i32
  call void @__asan_store4_noabort(i32 %93)
  store volatile i32 1, ptr %overload.i, align 8
  br label %for.end74

unthrottle_throttle:                              ; preds = %if.then
  %tobool62.not178 = icmp eq ptr %9, null
  br i1 %tobool62.not178, label %for.end74, label %for.body63.preheader

for.body63.preheader:                             ; preds = %unthrottle_throttle, %cfs_rq_throttled.exit147, %cfs_rq_throttled.exit
  %se.3179.ph = phi ptr [ %9, %unthrottle_throttle ], [ %se.1176, %cfs_rq_throttled.exit147 ], [ %se.0170, %cfs_rq_throttled.exit ]
  br label %for.body63

for.body63:                                       ; preds = %for.inc72, %for.body63.preheader
  %se.3179 = phi ptr [ %97, %for.inc72 ], [ %se.3179.ph, %for.body63.preheader ]
  %cfs_rq.i154 = getelementptr inbounds %struct.sched_entity, ptr %se.3179, i32 0, i32 11
  %94 = ptrtoint ptr %cfs_rq.i154 to i32
  call void @__asan_load4_noabort(i32 %94)
  %95 = load ptr, ptr %cfs_rq.i154, align 16
  %call66 = tail call fastcc zeroext i1 @list_add_leaf_cfs_rq(ptr noundef %95)
  br i1 %call66, label %for.end74, label %for.inc72

for.inc72:                                        ; preds = %for.body63
  %parent73 = getelementptr inbounds %struct.sched_entity, ptr %se.3179, i32 0, i32 10
  %96 = ptrtoint ptr %parent73 to i32
  call void @__asan_load4_noabort(i32 %96)
  %97 = load ptr, ptr %parent73, align 4
  %tobool62.not = icmp eq ptr %97, null
  br i1 %tobool62.not, label %for.end74, label %for.body63

for.end74:                                        ; preds = %for.inc72, %for.body63, %unthrottle_throttle, %do.body10.i, %do.end.i, %land.lhs.true.i, %if.end.i
  %tmp_alone_branch.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 18
  %98 = ptrtoint ptr %tmp_alone_branch.i to i32
  call void @__asan_load4_noabort(i32 %98)
  %99 = load ptr, ptr %tmp_alone_branch.i, align 128
  %leaf_cfs_rq_list.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 17
  %cmp.not.i = icmp eq ptr %99, %leaf_cfs_rq_list.i
  br i1 %cmp.not.i, label %assert_list_leaf_cfs_rq.exit, label %land.rhs.i155

land.rhs.i155:                                    ; preds = %for.end74
  %.b38.i = load i1, ptr @assert_list_leaf_cfs_rq.__already_done, align 1
  br i1 %.b38.i, label %assert_list_leaf_cfs_rq.exit, label %if.then.i156, !prof !259

if.then.i156:                                     ; preds = %land.rhs.i155
  store i1 true, ptr @assert_list_leaf_cfs_rq.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 387, i32 noundef 9, ptr noundef nonnull @.str.18) #20
  br label %assert_list_leaf_cfs_rq.exit

assert_list_leaf_cfs_rq.exit:                     ; preds = %if.then.i156, %land.rhs.i155, %for.end74
  %curr = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 20
  %100 = ptrtoint ptr %curr to i32
  call void @__asan_load4_noabort(i32 %100)
  %101 = load ptr, ptr %curr, align 8
  %idle = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 21
  %102 = ptrtoint ptr %idle to i32
  call void @__asan_load4_noabort(i32 %102)
  %103 = load ptr, ptr %idle, align 4
  %cmp = icmp eq ptr %101, %103
  br i1 %cmp, label %land.lhs.true, label %cleanup78

land.lhs.true:                                    ; preds = %assert_list_leaf_cfs_rq.exit
  %nr_running = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 14, i32 1
  %104 = ptrtoint ptr %nr_running to i32
  call void @__asan_load4_noabort(i32 %104)
  %105 = load i32, ptr %nr_running, align 8
  %tobool75.not = icmp eq i32 %105, 0
  br i1 %tobool75.not, label %cleanup78, label %if.then76

if.then76:                                        ; preds = %land.lhs.true
  tail call void @resched_curr(ptr noundef %1) #20
  br label %cleanup78

cleanup78:                                        ; preds = %if.then76, %land.lhs.true, %assert_list_leaf_cfs_rq.exit, %if.then
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @update_rq_clock(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @_raw_spin_lock(ptr noundef) local_unnamed_addr #4 section ".spinlock.text"

; Function Attrs: null_pointer_is_valid
declare dso_local void @_raw_spin_unlock(ptr noundef) local_unnamed_addr #4 section ".spinlock.text"

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @walk_tg_tree_from(ptr noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @tg_nop(ptr noundef, ptr noundef) #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @tg_unthrottle_up(ptr nocapture noundef readonly %tg, ptr noundef %data) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %cfs_rq1 = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 2
  %0 = ptrtoint ptr %cfs_rq1 to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %cfs_rq1, align 4
  %cpu.i = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 46
  %2 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu.i, align 4
  %arrayidx = getelementptr ptr, ptr %1, i32 %3
  %4 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %arrayidx, align 4
  %throttle_count = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 38
  %6 = ptrtoint ptr %throttle_count to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %throttle_count, align 4
  %dec = add i32 %7, -1
  store i32 %dec, ptr %throttle_count, align 4
  %tobool.not = icmp eq i32 %dec, 0
  br i1 %tobool.not, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %8 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i = icmp eq i32 %8, 0
  br i1 %tobool.not.i.i, label %lockdep_assert_rq_held.exit.i, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %if.then
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 81
  %9 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %10, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.rhs.i.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 79
  %11 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %land.rhs.i.i
  %retval.0.i.i.i = phi ptr [ %12, %if.then.i.i.i ], [ %data, %land.rhs.i.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i, i32 noundef -1) #20
  %cmp.not.i.i = icmp eq i32 %call.i.i.i, 0
  br i1 %cmp.not.i.i, label %do.end.i.i, label %lockdep_assert_rq_held.exit.i, !prof !260

do.end.i.i:                                       ; preds = %__rq_lockp.exit.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i

lockdep_assert_rq_held.exit.i:                    ; preds = %do.end.i.i, %__rq_lockp.exit.i.i, %if.then
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 25
  %13 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %clock_update_flags.i.i, align 4
  %cmp.i.i = icmp ult i32 %14, 2
  br i1 %cmp.i.i, label %land.rhs.i3.i, label %rq_clock_task.exit

land.rhs.i3.i:                                    ; preds = %lockdep_assert_rq_held.exit.i
  %.b37.i.i = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i, label %rq_clock_task.exit, label %if.then.i.i, !prof !259

if.then.i.i:                                      ; preds = %land.rhs.i3.i
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %rq_clock_task.exit

rq_clock_task.exit:                               ; preds = %if.then.i.i, %land.rhs.i3.i, %lockdep_assert_rq_held.exit.i
  %clock_task.i = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 28
  %15 = ptrtoint ptr %clock_task.i to i32
  call void @__asan_load8_noabort(i32 %15)
  %16 = load i64, ptr %clock_task.i, align 128
  %throttled_clock_task = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 35
  %17 = ptrtoint ptr %throttled_clock_task to i32
  call void @__asan_load8_noabort(i32 %17)
  %18 = load i64, ptr %throttled_clock_task, align 8
  %sub = sub i64 %16, %18
  %throttled_clock_task_time = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 36
  %19 = ptrtoint ptr %throttled_clock_task_time to i32
  call void @__asan_load8_noabort(i32 %19)
  %20 = load i64, ptr %throttled_clock_task_time, align 16
  %add = add i64 %sub, %20
  store i64 %add, ptr %throttled_clock_task_time, align 16
  %21 = ptrtoint ptr %5 to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load i32, ptr %5, align 128
  %tobool.not.i = icmp eq i32 %22, 0
  br i1 %tobool.not.i, label %if.end.i, label %if.then6

if.end.i:                                         ; preds = %rq_clock_task.exit
  %load_sum.i = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 17, i32 1
  %23 = ptrtoint ptr %load_sum.i to i32
  call void @__asan_load8_noabort(i32 %23)
  %24 = load i64, ptr %load_sum.i, align 8
  %tobool1.not.i = icmp eq i64 %24, 0
  br i1 %tobool1.not.i, label %if.end3.i, label %if.then6

if.end3.i:                                        ; preds = %if.end.i
  %util_sum.i = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 17, i32 3
  %25 = ptrtoint ptr %util_sum.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %util_sum.i, align 8
  %tobool5.not.i = icmp eq i32 %26, 0
  br i1 %tobool5.not.i, label %if.end7.i, label %if.then6

if.end7.i:                                        ; preds = %if.end3.i
  %runnable_sum.i = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 17, i32 2
  %27 = ptrtoint ptr %runnable_sum.i to i32
  call void @__asan_load8_noabort(i32 %27)
  %28 = load i64, ptr %runnable_sum.i, align 16
  %tobool9.not.i = icmp eq i64 %28, 0
  br i1 %tobool9.not.i, label %if.end11.i, label %if.then6

if.end11.i:                                       ; preds = %if.end7.i
  %on_list.i.i = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 28
  %29 = ptrtoint ptr %on_list.i.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %on_list.i.i, align 32
  %tobool.not.i.i16 = icmp eq i32 %30, 0
  br i1 %tobool.not.i.i16, label %if.else.i.i, label %if.then.i.i17

if.then.i.i17:                                    ; preds = %if.end11.i
  %prev1.i.i = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 29, i32 1
  br label %child_cfs_rq_on_list.exit.i

if.else.i.i:                                      ; preds = %if.end11.i
  %rq.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 27
  %31 = ptrtoint ptr %rq.i.i.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %rq.i.i.i, align 4
  %tmp_alone_branch.i.i = getelementptr inbounds %struct.rq, ptr %32, i32 0, i32 18
  br label %child_cfs_rq_on_list.exit.i

child_cfs_rq_on_list.exit.i:                      ; preds = %if.else.i.i, %if.then.i.i17
  %prev.0.in.i.i = phi ptr [ %prev1.i.i, %if.then.i.i17 ], [ %tmp_alone_branch.i.i, %if.else.i.i ]
  %33 = ptrtoint ptr %prev.0.in.i.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %prev.0.i.i = load ptr, ptr %prev.0.in.i.i, align 4
  %tg.i.i = getelementptr i8, ptr %prev.0.i.i, i32 8
  %34 = ptrtoint ptr %tg.i.i to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load ptr, ptr %tg.i.i, align 4
  %parent.i.i = getelementptr inbounds %struct.task_group, ptr %35, i32 0, i32 12
  %36 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load ptr, ptr %parent.i.i, align 8
  %tg2.i.i = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 30
  %38 = ptrtoint ptr %tg2.i.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load ptr, ptr %tg2.i.i, align 4
  %cmp.i.i18 = icmp eq ptr %37, %39
  br i1 %cmp.i.i18, label %if.then6, label %if.end13.i

if.end13.i:                                       ; preds = %child_cfs_rq_on_list.exit.i
  %load_avg.i = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 17, i32 5
  %40 = ptrtoint ptr %load_avg.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %load_avg.i, align 32
  %tobool15.not.i = icmp eq i32 %41, 0
  br i1 %tobool15.not.i, label %lor.lhs.false.i, label %land.rhs.i

lor.lhs.false.i:                                  ; preds = %if.end13.i
  %util_avg.i = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 17, i32 7
  %42 = ptrtoint ptr %util_avg.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load i32, ptr %util_avg.i, align 8
  %tobool17.not.i = icmp eq i32 %43, 0
  br i1 %tobool17.not.i, label %lor.rhs.i, label %land.rhs.i

lor.rhs.i:                                        ; preds = %lor.lhs.false.i
  %runnable_avg.i = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 17, i32 6
  %44 = ptrtoint ptr %runnable_avg.i to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load i32, ptr %runnable_avg.i, align 4
  %tobool19.not.i = icmp eq i32 %45, 0
  br i1 %tobool19.not.i, label %lor.lhs.false, label %land.rhs.i

land.rhs.i:                                       ; preds = %lor.rhs.i, %lor.lhs.false.i, %if.end13.i
  %.b66.i = load i1, ptr @cfs_rq_is_decayed.__already_done, align 1
  br i1 %.b66.i, label %lor.lhs.false, label %if.then27.i, !prof !259

if.then27.i:                                      ; preds = %land.rhs.i
  store i1 true, ptr @cfs_rq_is_decayed.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 3302, i32 noundef 9, ptr noundef nonnull @.str.11) #20
  br label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then27.i, %land.rhs.i, %lor.rhs.i
  %nr_running = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 1
  %46 = ptrtoint ptr %nr_running to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load i32, ptr %nr_running, align 8
  %tobool5.not = icmp eq i32 %47, 0
  br i1 %tobool5.not, label %if.end8, label %if.then6

if.then6:                                         ; preds = %lor.lhs.false, %child_cfs_rq_on_list.exit.i, %if.end7.i, %if.end3.i, %if.end.i, %rq_clock_task.exit
  %call7 = tail call fastcc zeroext i1 @list_add_leaf_cfs_rq(ptr noundef %5)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %lor.lhs.false, %entry
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @enqueue_entity(ptr noundef %cfs_rq, ptr noundef %se, i32 noundef %flags) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %and = and i32 %flags, 1
  %tobool.not = icmp eq i32 %and, 0
  %0 = and i32 %flags, 65
  %.not88 = icmp eq i32 %0, 1
  %curr3 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 11
  %1 = ptrtoint ptr %curr3 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %curr3, align 8
  %cmp = icmp eq ptr %2, %se
  %cmp.not = xor i1 %cmp, true
  %brmerge = select i1 %.not88, i1 true, i1 %cmp.not
  br i1 %brmerge, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %min_vruntime = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 6
  %3 = ptrtoint ptr %min_vruntime to i32
  call void @__asan_load8_noabort(i32 %3)
  %4 = load i64, ptr %min_vruntime, align 32
  %vruntime = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 6
  %5 = ptrtoint ptr %vruntime to i32
  call void @__asan_load8_noabort(i32 %5)
  %6 = load i64, ptr %vruntime, align 16
  %add = add i64 %6, %4
  store i64 %add, ptr %vruntime, align 16
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  tail call fastcc void @update_curr(ptr noundef %cfs_rq)
  %brmerge61 = select i1 %.not88, i1 true, i1 %cmp
  br i1 %brmerge61, label %if.end14, label %if.then10

if.then10:                                        ; preds = %if.end
  %min_vruntime11 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 6
  %7 = ptrtoint ptr %min_vruntime11 to i32
  call void @__asan_load8_noabort(i32 %7)
  %8 = load i64, ptr %min_vruntime11, align 32
  %vruntime12 = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 6
  %9 = ptrtoint ptr %vruntime12 to i32
  call void @__asan_load8_noabort(i32 %9)
  %10 = load i64, ptr %vruntime12, align 16
  %add13 = add i64 %10, %8
  store i64 %add13, ptr %vruntime12, align 16
  br label %if.end14

if.end14:                                         ; preds = %if.then10, %if.end
  tail call fastcc void @update_load_avg(ptr noundef %cfs_rq, ptr noundef %se, i32 noundef 5)
  %my_q.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 12
  %11 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i = icmp eq ptr %12, null
  br i1 %tobool.not.i, label %update_cfs_group.exit, label %if.end.i

if.end.i:                                         ; preds = %if.end14
  %h_nr_running.i = getelementptr inbounds %struct.cfs_rq, ptr %12, i32 0, i32 2
  %13 = ptrtoint ptr %h_nr_running.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %h_nr_running.i, align 4
  %runnable_weight.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 13
  %15 = ptrtoint ptr %runnable_weight.i to i32
  call void @__asan_store4_noabort(i32 %15)
  store i32 %14, ptr %runnable_weight.i, align 8
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@enqueue_entity, %land.rhs.i.i)) #20
          to label %if.end4.i [label %land.rhs.i.i], !srcloc !261

land.rhs.i.i:                                     ; preds = %if.end.i
  %throttle_count.i.i = getelementptr inbounds %struct.cfs_rq, ptr %12, i32 0, i32 38
  %16 = ptrtoint ptr %throttle_count.i.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %throttle_count.i.i, align 4
  %tobool.i.not.i = icmp eq i32 %17, 0
  br i1 %tobool.i.not.i, label %if.end4.i, label %update_cfs_group.exit

if.end4.i:                                        ; preds = %land.rhs.i.i, %if.end.i
  %tg1.i.i = getelementptr inbounds %struct.cfs_rq, ptr %12, i32 0, i32 30
  %18 = ptrtoint ptr %tg1.i.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load ptr, ptr %tg1.i.i, align 4
  %shares2.i.i = getelementptr inbounds %struct.task_group, ptr %19, i32 0, i32 3
  %20 = ptrtoint ptr %shares2.i.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load volatile i32, ptr %shares2.i.i, align 16
  %22 = ptrtoint ptr %12 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load i32, ptr %12, align 128
  %load_avg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %12, i32 0, i32 17, i32 5
  %24 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %load_avg.i.i, align 32
  %26 = tail call i32 @llvm.umax.i32(i32 %23, i32 %25) #20
  %load_avg5.i.i = getelementptr inbounds %struct.task_group, ptr %19, i32 0, i32 6
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %load_avg5.i.i, i32 noundef 4) #20
  %27 = ptrtoint ptr %load_avg5.i.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load volatile i32, ptr %load_avg5.i.i, align 4
  %tg_load_avg_contrib.i.i = getelementptr inbounds %struct.cfs_rq, ptr %12, i32 0, i32 21
  %29 = ptrtoint ptr %tg_load_avg_contrib.i.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %tg_load_avg_contrib.i.i, align 128
  %sub.i.i = sub i32 %28, %30
  %add.i.i = add i32 %sub.i.i, %26
  %mul.i.i = mul i32 %26, %21
  %tobool.not.i.i = icmp eq i32 %add.i.i, 0
  br i1 %tobool.not.i.i, label %calc_group_shares.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.end4.i
  %div.i.i = sdiv i32 %mul.i.i, %add.i.i
  br label %calc_group_shares.exit.i

calc_group_shares.exit.i:                         ; preds = %if.then.i.i, %if.end4.i
  %shares.0.i.i = phi i32 [ %div.i.i, %if.then.i.i ], [ %mul.i.i, %if.end4.i ]
  %31 = tail call i32 @llvm.smax.i32(i32 %shares.0.i.i, i32 2) #20
  %32 = tail call i32 @llvm.smin.i32(i32 %31, i32 %21) #20
  %cfs_rq.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 11
  %33 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load ptr, ptr %cfs_rq.i.i, align 16
  tail call fastcc void @reweight_entity(ptr noundef %34, ptr noundef %se, i32 noundef %32) #20
  br label %update_cfs_group.exit

update_cfs_group.exit:                            ; preds = %calc_group_shares.exit.i, %land.rhs.i.i, %if.end14
  %35 = ptrtoint ptr %se to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %se, align 128
  %37 = ptrtoint ptr %cfs_rq to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %cfs_rq, align 4
  %add.i.i63 = add i32 %38, %36
  store i32 %add.i.i63, ptr %cfs_rq, align 4
  %inv_weight.i.i = getelementptr inbounds %struct.load_weight, ptr %cfs_rq, i32 0, i32 1
  %39 = ptrtoint ptr %inv_weight.i.i to i32
  call void @__asan_store4_noabort(i32 %39)
  store i32 0, ptr %inv_weight.i.i, align 4
  %40 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i65 = icmp eq ptr %41, null
  br i1 %tobool.not.i65, label %task_of.exit.i, label %if.end.i66

task_of.exit.i:                                   ; preds = %update_cfs_group.exit
  %rq.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %42 = ptrtoint ptr %rq.i.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load ptr, ptr %rq.i.i, align 4
  %group_node.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 2
  %cfs_tasks.i = getelementptr inbounds %struct.rq, ptr %43, i32 0, i32 48
  %44 = ptrtoint ptr %cfs_tasks.i to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load ptr, ptr %cfs_tasks.i, align 4
  %call.i.i.i = tail call zeroext i1 @__list_add_valid(ptr noundef %group_node.i, ptr noundef %cfs_tasks.i, ptr noundef %45) #20
  br i1 %call.i.i.i, label %if.end.i.i.i, label %if.end.i66

if.end.i.i.i:                                     ; preds = %task_of.exit.i
  %prev1.i.i.i = getelementptr inbounds %struct.list_head, ptr %45, i32 0, i32 1
  %46 = ptrtoint ptr %prev1.i.i.i to i32
  call void @__asan_store4_noabort(i32 %46)
  store ptr %group_node.i, ptr %prev1.i.i.i, align 4
  %47 = ptrtoint ptr %group_node.i to i32
  call void @__asan_store4_noabort(i32 %47)
  store ptr %45, ptr %group_node.i, align 4
  %prev3.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 2, i32 1
  %48 = ptrtoint ptr %prev3.i.i.i to i32
  call void @__asan_store4_noabort(i32 %48)
  store ptr %cfs_tasks.i, ptr %prev3.i.i.i, align 4
  %49 = ptrtoint ptr %cfs_tasks.i to i32
  call void @__asan_store4_noabort(i32 %49)
  store volatile ptr %group_node.i, ptr %cfs_tasks.i, align 4
  br label %if.end.i66

if.end.i66:                                       ; preds = %if.end.i.i.i, %task_of.exit.i, %update_cfs_group.exit
  %nr_running.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 1
  %50 = ptrtoint ptr %nr_running.i to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load i32, ptr %nr_running.i, align 8
  %inc.i = add i32 %51, 1
  store i32 %inc.i, ptr %nr_running.i, align 8
  %52 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i17.i = icmp eq ptr %53, null
  br i1 %tobool.not.i17.i, label %se_is_idle.exit.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.end.i66
  %idle.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %53, i32 0, i32 31
  %54 = ptrtoint ptr %idle.i.i.i to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load i32, ptr %idle.i.i.i, align 16
  %cmp.i.i.i = icmp sgt i32 %55, 0
  br i1 %cmp.i.i.i, label %if.then5.i, label %account_entity_enqueue.exit

se_is_idle.exit.i:                                ; preds = %if.end.i66
  %policy.i.i.i = getelementptr i8, ptr %se, i32 900
  %56 = ptrtoint ptr %policy.i.i.i to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load i32, ptr %policy.i.i.i, align 4
  %cmp.i.i.i.i = icmp eq i32 %57, 5
  br i1 %cmp.i.i.i.i, label %if.then5.i, label %account_entity_enqueue.exit

if.then5.i:                                       ; preds = %se_is_idle.exit.i, %if.end.i.i
  %idle_nr_running.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 3
  %58 = ptrtoint ptr %idle_nr_running.i to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load i32, ptr %idle_nr_running.i, align 16
  %inc6.i = add i32 %59, 1
  store i32 %inc6.i, ptr %idle_nr_running.i, align 16
  br label %account_entity_enqueue.exit

account_entity_enqueue.exit:                      ; preds = %if.then5.i, %se_is_idle.exit.i, %if.end.i.i
  br i1 %tobool.not, label %if.end18, label %if.then17

if.then17:                                        ; preds = %account_entity_enqueue.exit
  %min_vruntime.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 6
  %60 = ptrtoint ptr %min_vruntime.i to i32
  call void @__asan_load8_noabort(i32 %60)
  %61 = load i64, ptr %min_vruntime.i, align 32
  %62 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i.i68 = icmp eq ptr %63, null
  br i1 %tobool.not.i.i68, label %task_of.exit.i.i, label %if.end.i.i73

task_of.exit.i.i:                                 ; preds = %if.then17
  %policy.i.i.i69 = getelementptr i8, ptr %se, i32 900
  %64 = ptrtoint ptr %policy.i.i.i69 to i32
  call void @__asan_load4_noabort(i32 %64)
  %65 = load i32, ptr %policy.i.i.i69, align 4
  %cmp.i.i.i.i70 = icmp eq i32 %65, 5
  br label %se_is_idle.exit.i74

if.end.i.i73:                                     ; preds = %if.then17
  %idle.i.i.i71 = getelementptr inbounds %struct.cfs_rq, ptr %63, i32 0, i32 31
  %66 = ptrtoint ptr %idle.i.i.i71 to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load i32, ptr %idle.i.i.i71, align 16
  %cmp.i.i.i72 = icmp sgt i32 %67, 0
  br label %se_is_idle.exit.i74

se_is_idle.exit.i74:                              ; preds = %if.end.i.i73, %task_of.exit.i.i
  %retval.0.in.i.i = phi i1 [ %cmp.i.i.i72, %if.end.i.i73 ], [ %cmp.i.i.i.i70, %task_of.exit.i.i ]
  %sysctl_sched_min_granularity.val.i = load i32, ptr @sysctl_sched_min_granularity, align 4
  %sysctl_sched_latency.val.i = load i32, ptr @sysctl_sched_latency, align 4
  %thresh.0.i = select i1 %retval.0.in.i.i, i32 %sysctl_sched_min_granularity.val.i, i32 %sysctl_sched_latency.val.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @sched_feat_keys, i32 1), ptr blockaddress(@enqueue_entity, %place_entity.exit)) #20
          to label %68 [label %place_entity.exit], !srcloc !261

68:                                               ; preds = %se_is_idle.exit.i74
  %shr.i = lshr i32 %thresh.0.i, 1
  br label %place_entity.exit

place_entity.exit:                                ; preds = %68, %se_is_idle.exit.i74
  %69 = phi i32 [ %shr.i, %68 ], [ %thresh.0.i, %se_is_idle.exit.i74 ]
  %conv.i = zext i32 %69 to i64
  %sub.i = sub i64 %61, %conv.i
  %vruntime12.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 6
  %70 = ptrtoint ptr %vruntime12.i to i32
  call void @__asan_load8_noabort(i32 %70)
  %71 = load i64, ptr %vruntime12.i, align 16
  %sub.i.i75 = sub i64 %sub.i, %71
  %cmp.i.i = icmp sgt i64 %sub.i.i75, 0
  %spec.select.i.i = select i1 %cmp.i.i, i64 %sub.i, i64 %71
  store i64 %spec.select.i.i, ptr %vruntime12.i, align 16
  br label %if.end18

if.end18:                                         ; preds = %place_entity.exit, %account_entity_enqueue.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@enqueue_entity, %check_schedstat_required.exit)) #20
          to label %if.end.i76 [label %check_schedstat_required.exit], !srcloc !261

if.end.i76:                                       ; preds = %if.end18
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_stat_wait, i32 0, i32 1), ptr blockaddress(@enqueue_entity, %land.end.i)) #20
          to label %lor.lhs.false.i [label %land.end.i], !srcloc !261

lor.lhs.false.i:                                  ; preds = %if.end.i76
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_stat_sleep, i32 0, i32 1), ptr blockaddress(@enqueue_entity, %land.end.i)) #20
          to label %lor.lhs.false5.i [label %land.end.i], !srcloc !261

lor.lhs.false5.i:                                 ; preds = %lor.lhs.false.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_stat_iowait, i32 0, i32 1), ptr blockaddress(@enqueue_entity, %land.end.i)) #20
          to label %lor.lhs.false7.i [label %land.end.i], !srcloc !261

lor.lhs.false7.i:                                 ; preds = %lor.lhs.false5.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_stat_blocked, i32 0, i32 1), ptr blockaddress(@enqueue_entity, %land.end.i)) #20
          to label %lor.lhs.false9.i [label %land.end.i], !srcloc !261

lor.lhs.false9.i:                                 ; preds = %lor.lhs.false7.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_stat_runtime, i32 0, i32 1), ptr blockaddress(@enqueue_entity, %land.end.i)) #20
          to label %check_schedstat_required.exit [label %land.end.i], !srcloc !261

land.end.i:                                       ; preds = %lor.lhs.false9.i, %lor.lhs.false7.i, %lor.lhs.false5.i, %lor.lhs.false.i, %if.end.i76
  %.b35.i = load i1, ptr @check_schedstat_required.__already_done, align 1
  br i1 %.b35.i, label %check_schedstat_required.exit, label %if.then22.i, !prof !259

if.then22.i:                                      ; preds = %land.end.i
  store i1 true, ptr @check_schedstat_required.__already_done, align 1
  %call24.i = tail call i32 (ptr, ...) @_printk_deferred(ptr noundef nonnull @.str.12) #22
  br label %check_schedstat_required.exit

check_schedstat_required.exit:                    ; preds = %if.then22.i, %land.end.i, %lor.lhs.false9.i, %if.end18
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@enqueue_entity, %if.end.i77)) #20
          to label %update_stats_enqueue_fair.exit [label %if.end.i77], !srcloc !261

if.end.i77:                                       ; preds = %check_schedstat_required.exit
  %72 = ptrtoint ptr %curr3 to i32
  call void @__asan_load4_noabort(i32 %72)
  %73 = load ptr, ptr %curr3, align 8
  %cmp.not.i = icmp eq ptr %73, %se
  br i1 %cmp.not.i, label %if.end4.i80, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i77
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@enqueue_entity, %if.end.i.i79)) #20
          to label %if.end4.i80 [label %if.end.i.i79], !srcloc !261

if.end.i.i79:                                     ; preds = %if.then3.i
  %74 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %74)
  %75 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i.i.i = icmp eq ptr %75, null
  %stats.i.i.i = getelementptr inbounds %struct.sched_entity_stats, ptr %se, i32 0, i32 1
  %stats1.i.i.i = getelementptr i8, ptr %se, i32 640
  %retval.0.i12.i.i = select i1 %tobool.not.i.i.i, ptr %stats1.i.i.i, ptr %stats.i.i.i
  %add.ptr.i.i.i = getelementptr i8, ptr %se, i32 -128
  %spec.select.i.i78 = select i1 %tobool.not.i.i.i, ptr %add.ptr.i.i.i, ptr null
  %rq.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %76 = ptrtoint ptr %rq.i.i.i to i32
  call void @__asan_load4_noabort(i32 %76)
  %77 = load ptr, ptr %rq.i.i.i, align 4
  tail call void @__update_stats_wait_start(ptr noundef %77, ptr noundef %spec.select.i.i78, ptr noundef %retval.0.i12.i.i) #20
  br label %if.end4.i80

if.end4.i80:                                      ; preds = %if.end.i.i79, %if.then3.i, %if.end.i77
  br i1 %tobool.not, label %update_stats_enqueue_fair.exit, label %if.then6.i

if.then6.i:                                       ; preds = %if.end4.i80
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@enqueue_entity, %if.end.i20.i)) #20
          to label %update_stats_enqueue_fair.exit [label %if.end.i20.i], !srcloc !261

if.end.i20.i:                                     ; preds = %if.then6.i
  %78 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %78)
  %79 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i.i13.i = icmp eq ptr %79, null
  %stats.i.i14.i = getelementptr inbounds %struct.sched_entity_stats, ptr %se, i32 0, i32 1
  %stats1.i.i15.i = getelementptr i8, ptr %se, i32 640
  %retval.0.i12.i16.i = select i1 %tobool.not.i.i13.i, ptr %stats1.i.i15.i, ptr %stats.i.i14.i
  %add.ptr.i.i17.i = getelementptr i8, ptr %se, i32 -128
  %spec.select.i18.i = select i1 %tobool.not.i.i13.i, ptr %add.ptr.i.i17.i, ptr null
  %rq.i.i19.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %80 = ptrtoint ptr %rq.i.i19.i to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load ptr, ptr %rq.i.i19.i, align 4
  tail call void @__update_stats_enqueue_sleeper(ptr noundef %81, ptr noundef %spec.select.i18.i, ptr noundef %retval.0.i12.i16.i) #20
  br label %update_stats_enqueue_fair.exit

update_stats_enqueue_fair.exit:                   ; preds = %if.end.i20.i, %if.then6.i, %if.end4.i80, %check_schedstat_required.exit
  %vruntime.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 6
  %82 = ptrtoint ptr %vruntime.i to i32
  call void @__asan_load8_noabort(i32 %82)
  %83 = load i64, ptr %vruntime.i, align 16
  %min_vruntime.i81 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 6
  %84 = ptrtoint ptr %min_vruntime.i81 to i32
  call void @__asan_load8_noabort(i32 %84)
  %85 = load i64, ptr %min_vruntime.i81, align 32
  %sub.i82 = sub i64 %83, %85
  %86 = tail call i64 @llvm.abs.i64(i64 %sub.i82, i1 false) #20
  %87 = load i32, ptr @sysctl_sched_latency, align 4
  %mul.i = mul i32 %87, 3
  %conv.i83 = zext i32 %mul.i to i64
  %cmp2.i = icmp sgt i64 %86, %conv.i83
  br i1 %cmp2.i, label %do.body.i, label %check_spread.exit

do.body.i:                                        ; preds = %update_stats_enqueue_fair.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@enqueue_entity, %if.then7.i)) #20
          to label %check_spread.exit [label %if.then7.i], !srcloc !261

if.then7.i:                                       ; preds = %do.body.i
  %nr_spread_over.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 15
  %88 = ptrtoint ptr %nr_spread_over.i to i32
  call void @__asan_load4_noabort(i32 %88)
  %89 = load i32, ptr %nr_spread_over.i, align 8
  %inc.i84 = add i32 %89, 1
  store i32 %inc.i84, ptr %nr_spread_over.i, align 8
  br label %check_spread.exit

check_spread.exit:                                ; preds = %if.then7.i, %do.body.i, %update_stats_enqueue_fair.exit
  br i1 %cmp, label %if.end21, label %if.then20

if.then20:                                        ; preds = %check_spread.exit
  %run_node.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 1
  %tasks_timeline.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 10
  %90 = ptrtoint ptr %tasks_timeline.i to i32
  call void @__asan_load4_noabort(i32 %90)
  %91 = load ptr, ptr %tasks_timeline.i, align 4
  %tobool.not2.i.i = icmp eq ptr %91, null
  br i1 %tobool.not2.i.i, label %if.then.i.critedge.i.i, label %while.body.lr.ph.i.i

while.body.lr.ph.i.i:                             ; preds = %if.then20
  %92 = ptrtoint ptr %vruntime.i to i32
  call void @__asan_load8_noabort(i32 %92)
  %93 = load i64, ptr %vruntime.i, align 16
  br label %while.body.i.i

while.body.i.i:                                   ; preds = %while.body.i.i, %while.body.lr.ph.i.i
  %94 = phi ptr [ %91, %while.body.lr.ph.i.i ], [ %98, %while.body.i.i ]
  %leftmost.0.off03.i.i = phi i1 [ true, %while.body.lr.ph.i.i ], [ %leftmost.1.off0.i.i, %while.body.i.i ]
  %vruntime1.i.i.i.i = getelementptr i8, ptr %94, i32 40
  %95 = ptrtoint ptr %vruntime1.i.i.i.i to i32
  call void @__asan_load8_noabort(i32 %95)
  %96 = load i64, ptr %vruntime1.i.i.i.i, align 16
  %sub.i.i.i.i = sub i64 %93, %96
  %cmp.i.i.i.i85 = icmp slt i64 %sub.i.i.i.i, 0
  %rb_left.i.i = getelementptr inbounds %struct.rb_node, ptr %94, i32 0, i32 2
  %rb_right.i.i = getelementptr inbounds %struct.rb_node, ptr %94, i32 0, i32 1
  %link.1.i.i = select i1 %cmp.i.i.i.i85, ptr %rb_left.i.i, ptr %rb_right.i.i
  %leftmost.1.off0.i.i = select i1 %cmp.i.i.i.i85, i1 %leftmost.0.off03.i.i, i1 false
  %97 = ptrtoint ptr %link.1.i.i to i32
  call void @__asan_load4_noabort(i32 %97)
  %98 = load ptr, ptr %link.1.i.i, align 4
  %tobool.not.i.i86 = icmp eq ptr %98, null
  br i1 %tobool.not.i.i86, label %while.cond.while.end_crit_edge.i.i, label %while.body.i.i

while.cond.while.end_crit_edge.i.i:               ; preds = %while.body.i.i
  %phi.cast.le.i.i = ptrtoint ptr %94 to i32
  %99 = ptrtoint ptr %run_node.i to i32
  call void @__asan_store4_noabort(i32 %99)
  store i32 %phi.cast.le.i.i, ptr %run_node.i, align 4
  %rb_right.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 1, i32 1
  %100 = ptrtoint ptr %rb_right.i.i.i to i32
  call void @__asan_store4_noabort(i32 %100)
  store ptr null, ptr %rb_right.i.i.i, align 4
  %rb_left.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 1, i32 2
  %101 = ptrtoint ptr %rb_left.i.i.i to i32
  call void @__asan_store4_noabort(i32 %101)
  store ptr null, ptr %rb_left.i.i.i, align 4
  %102 = ptrtoint ptr %link.1.i.i to i32
  call void @__asan_store4_noabort(i32 %102)
  store ptr %run_node.i, ptr %link.1.i.i, align 4
  br i1 %leftmost.1.off0.i.i, label %if.then.i.i.i, label %__enqueue_entity.exit

if.then.i.critedge.i.i:                           ; preds = %if.then20
  %103 = ptrtoint ptr %run_node.i to i32
  call void @__asan_store4_noabort(i32 %103)
  store i32 0, ptr %run_node.i, align 4
  %rb_right.i.c.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 1, i32 1
  %104 = ptrtoint ptr %rb_right.i.c.i.i to i32
  call void @__asan_store4_noabort(i32 %104)
  store ptr null, ptr %rb_right.i.c.i.i, align 4
  %rb_left.i.c.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 1, i32 2
  %105 = ptrtoint ptr %rb_left.i.c.i.i to i32
  call void @__asan_store4_noabort(i32 %105)
  store ptr null, ptr %rb_left.i.c.i.i, align 4
  %106 = ptrtoint ptr %tasks_timeline.i to i32
  call void @__asan_store4_noabort(i32 %106)
  store ptr %run_node.i, ptr %tasks_timeline.i, align 4
  br label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %if.then.i.critedge.i.i, %while.cond.while.end_crit_edge.i.i
  %rb_leftmost.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 10, i32 1
  %107 = ptrtoint ptr %rb_leftmost.i.i.i to i32
  call void @__asan_store4_noabort(i32 %107)
  store ptr %run_node.i, ptr %rb_leftmost.i.i.i, align 4
  br label %__enqueue_entity.exit

__enqueue_entity.exit:                            ; preds = %if.then.i.i.i, %while.cond.while.end_crit_edge.i.i
  tail call void @rb_insert_color(ptr noundef %run_node.i, ptr noundef %tasks_timeline.i) #20
  br label %if.end21

if.end21:                                         ; preds = %__enqueue_entity.exit, %check_spread.exit
  %on_rq = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 3
  %108 = ptrtoint ptr %on_rq to i32
  call void @__asan_store4_noabort(i32 %108)
  store i32 1, ptr %on_rq, align 4
  %109 = ptrtoint ptr %nr_running.i to i32
  call void @__asan_load4_noabort(i32 %109)
  %110 = load i32, ptr %nr_running.i, align 8
  %cmp22 = icmp eq i32 %110, 1
  br i1 %cmp22, label %if.then23, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end21
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@enqueue_entity, %if.then23)) #20
          to label %if.end25 [label %if.then23], !srcloc !261

if.then23:                                        ; preds = %lor.lhs.false, %if.end21
  %call24 = tail call fastcc zeroext i1 @list_add_leaf_cfs_rq(ptr noundef %cfs_rq)
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %lor.lhs.false
  %111 = ptrtoint ptr %nr_running.i to i32
  call void @__asan_load4_noabort(i32 %111)
  %112 = load i32, ptr %nr_running.i, align 8
  %cmp27 = icmp eq i32 %112, 1
  br i1 %cmp27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end25
  tail call fastcc void @check_enqueue_throttle(ptr noundef %cfs_rq)
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.end25
  ret void
}

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @update_load_avg(ptr noundef %cfs_rq, ptr noundef %se, i32 noundef %flags) unnamed_addr #7 align 64 {
entry:
  %throttle_count.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 38
  %0 = ptrtoint ptr %throttle_count.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %throttle_count.i, align 4
  %tobool.not.i = icmp eq i32 %1, 0
  br i1 %tobool.not.i, label %if.end.i, label %if.then.i, !prof !259

if.then.i:                                        ; preds = %entry
  %throttled_clock_task.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 35
  %2 = ptrtoint ptr %throttled_clock_task.i to i32
  call void @__asan_load8_noabort(i32 %2)
  %3 = load i64, ptr %throttled_clock_task.i, align 8
  %throttled_clock_task_time.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 36
  %4 = ptrtoint ptr %throttled_clock_task_time.i to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %throttled_clock_task_time.i, align 16
  %sub.i = sub i64 %3, %5
  br label %cfs_rq_clock_pelt.exit

if.end.i:                                         ; preds = %entry
  %rq.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %6 = ptrtoint ptr %rq.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %rq.i.i, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %8 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i.i = icmp eq i32 %8, 0
  br i1 %tobool.not.i.i.i, label %lockdep_assert_rq_held.exit.i.i, label %land.rhs.i.i.i

land.rhs.i.i.i:                                   ; preds = %if.end.i
  %core_enabled.i.i.i.i = getelementptr inbounds %struct.rq, ptr %7, i32 0, i32 81
  %9 = ptrtoint ptr %core_enabled.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %core_enabled.i.i.i.i, align 128
  %tobool.not.i.i.i.i = icmp eq i32 %10, 0
  br i1 %tobool.not.i.i.i.i, label %__rq_lockp.exit.i.i.i, label %if.then.i.i.i.i

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i
  %core.i.i.i.i = getelementptr inbounds %struct.rq, ptr %7, i32 0, i32 79
  %11 = ptrtoint ptr %core.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %core.i.i.i.i, align 8
  br label %__rq_lockp.exit.i.i.i

__rq_lockp.exit.i.i.i:                            ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i
  %retval.0.i.i.i.i = phi ptr [ %12, %if.then.i.i.i.i ], [ %7, %land.rhs.i.i.i ]
  %dep_map.i.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i.i, i32 0, i32 4
  %call.i.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i.i, i32 noundef -1) #20
  %cmp.not.i.i.i = icmp eq i32 %call.i.i.i.i, 0
  br i1 %cmp.not.i.i.i, label %do.end.i.i.i, label %lockdep_assert_rq_held.exit.i.i, !prof !260

do.end.i.i.i:                                     ; preds = %__rq_lockp.exit.i.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i.i

lockdep_assert_rq_held.exit.i.i:                  ; preds = %do.end.i.i.i, %__rq_lockp.exit.i.i.i, %if.end.i
  %clock_update_flags.i.i.i = getelementptr inbounds %struct.rq, ptr %7, i32 0, i32 25
  %13 = ptrtoint ptr %clock_update_flags.i.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %clock_update_flags.i.i.i, align 4
  %cmp.i.i.i = icmp ult i32 %14, 2
  br i1 %cmp.i.i.i, label %land.rhs.i4.i.i, label %rq_clock_pelt.exit.i

land.rhs.i4.i.i:                                  ; preds = %lockdep_assert_rq_held.exit.i.i
  %.b37.i.i.i = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i.i, label %rq_clock_pelt.exit.i, label %if.then.i.i.i, !prof !259

if.then.i.i.i:                                    ; preds = %land.rhs.i4.i.i
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %rq_clock_pelt.exit.i

rq_clock_pelt.exit.i:                             ; preds = %if.then.i.i.i, %land.rhs.i4.i.i, %lockdep_assert_rq_held.exit.i.i
  %clock_pelt.i.i = getelementptr inbounds %struct.rq, ptr %7, i32 0, i32 29
  %15 = ptrtoint ptr %clock_pelt.i.i to i32
  call void @__asan_load8_noabort(i32 %15)
  %16 = load i64, ptr %clock_pelt.i.i, align 8
  %lost_idle_time.i.i = getelementptr inbounds %struct.rq, ptr %7, i32 0, i32 30
  %17 = ptrtoint ptr %lost_idle_time.i.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %lost_idle_time.i.i, align 16
  %conv.i.i = zext i32 %18 to i64
  %throttled_clock_task_time4.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 36
  %19 = ptrtoint ptr %throttled_clock_task_time4.i to i32
  call void @__asan_load8_noabort(i32 %19)
  %20 = load i64, ptr %throttled_clock_task_time4.i, align 16
  %21 = add i64 %20, %conv.i.i
  %sub5.i = sub i64 %16, %21
  br label %cfs_rq_clock_pelt.exit

cfs_rq_clock_pelt.exit:                           ; preds = %rq_clock_pelt.exit.i, %if.then.i
  %retval.0.i = phi i64 [ %sub.i, %if.then.i ], [ %sub5.i, %rq_clock_pelt.exit.i ]
  %avg = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15
  %22 = ptrtoint ptr %avg to i32
  call void @__asan_load8_noabort(i32 %22)
  %23 = load i64, ptr %avg, align 128
  %tobool.not = icmp ne i64 %23, 0
  %and = and i32 %flags, 2
  %tobool1.not = icmp eq i32 %and, 0
  %or.cond = and i1 %tobool1.not, %tobool.not
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %cfs_rq_clock_pelt.exit
  %call2 = tail call i32 @__update_load_avg_se(i64 noundef %retval.0.i, ptr noundef %cfs_rq, ptr noundef %se) #20
  br label %if.end

if.end:                                           ; preds = %if.then, %cfs_rq_clock_pelt.exit
  %call3 = tail call fastcc i32 @update_cfs_rq_load_avg(i64 noundef %retval.0.i, ptr noundef %cfs_rq)
  %my_q.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 12
  %24 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i35 = icmp eq ptr %25, null
  br i1 %tobool.not.i35, label %propagate_entity_load_avg.exit, label %if.end.i36

if.end.i36:                                       ; preds = %if.end
  %propagate.i = getelementptr inbounds %struct.cfs_rq, ptr %25, i32 0, i32 22
  %26 = ptrtoint ptr %propagate.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %propagate.i, align 4
  %tobool1.not.i = icmp eq i32 %27, 0
  br i1 %tobool1.not.i, label %propagate_entity_load_avg.exit, label %if.end3.i

if.end3.i:                                        ; preds = %if.end.i36
  %28 = ptrtoint ptr %propagate.i to i32
  call void @__asan_store4_noabort(i32 %28)
  store i32 0, ptr %propagate.i, align 4
  %cfs_rq.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 11
  %29 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %cfs_rq.i.i, align 16
  %prop_runnable_sum.i = getelementptr inbounds %struct.cfs_rq, ptr %25, i32 0, i32 23
  %31 = ptrtoint ptr %prop_runnable_sum.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %prop_runnable_sum.i, align 8
  %propagate.i.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 22
  %33 = ptrtoint ptr %propagate.i.i to i32
  call void @__asan_store4_noabort(i32 %33)
  store i32 1, ptr %propagate.i.i, align 4
  %prop_runnable_sum.i.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 23
  %34 = ptrtoint ptr %prop_runnable_sum.i.i to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load i32, ptr %prop_runnable_sum.i.i, align 8
  %add.i.i = add i32 %35, %32
  store i32 %add.i.i, ptr %prop_runnable_sum.i.i, align 8
  %util_avg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %25, i32 0, i32 17, i32 7
  %36 = ptrtoint ptr %util_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load i32, ptr %util_avg.i.i, align 8
  %util_avg2.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 7
  %38 = ptrtoint ptr %util_avg2.i.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load i32, ptr %util_avg2.i.i, align 8
  %tobool.not.i.i = icmp eq i32 %37, %39
  br i1 %tobool.not.i.i, label %update_tg_cfs_util.exit.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.end3.i
  %sub.i.i = sub i32 %37, %39
  %period_contrib.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 17, i32 4
  %40 = ptrtoint ptr %period_contrib.i.i.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %period_contrib.i.i.i, align 4
  %add.i.i.i = add i32 %41, 46718
  %42 = ptrtoint ptr %util_avg2.i.i to i32
  call void @__asan_store4_noabort(i32 %42)
  store i32 %37, ptr %util_avg2.i.i, align 8
  %mul.i.i = mul i32 %add.i.i.i, %37
  %util_sum.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 3
  %43 = ptrtoint ptr %util_sum.i.i to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load i32, ptr %util_sum.i.i, align 8
  %sub11.i.i = sub i32 %mul.i.i, %44
  store i32 %mul.i.i, ptr %util_sum.i.i, align 8
  %util_avg15.i.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 17, i32 7
  %45 = ptrtoint ptr %util_avg15.i.i to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load volatile i32, ptr %util_avg15.i.i, align 4
  %add.i22.i = add i32 %46, %sub.i.i
  %cmp.i.i = icmp slt i32 %sub.i.i, 0
  %cmp17.i.i = icmp ugt i32 %add.i22.i, %46
  %47 = select i1 %cmp.i.i, i1 %cmp17.i.i, i1 false
  %res.0.i.i = select i1 %47, i32 0, i32 %add.i22.i
  store volatile i32 %res.0.i.i, ptr %util_avg15.i.i, align 4
  %util_sum34.i.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 17, i32 3
  %48 = ptrtoint ptr %util_sum34.i.i to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load volatile i32, ptr %util_sum34.i.i, align 4
  %add42.i.i = add i32 %49, %sub11.i.i
  %cmp43.i.i = icmp slt i32 %sub11.i.i, 0
  %cmp45.i.i = icmp ugt i32 %add42.i.i, %49
  %50 = select i1 %cmp43.i.i, i1 %cmp45.i.i, i1 false
  %res36.0.i.i = select i1 %50, i32 0, i32 %add42.i.i
  store volatile i32 %res36.0.i.i, ptr %util_sum34.i.i, align 4
  %mul63.i.i = mul i32 %res.0.i.i, 46718
  %51 = tail call i32 @llvm.umax.i32(i32 %res36.0.i.i, i32 %mul63.i.i) #20
  %52 = ptrtoint ptr %util_sum34.i.i to i32
  call void @__asan_store4_noabort(i32 %52)
  store i32 %51, ptr %util_sum34.i.i, align 8
  br label %update_tg_cfs_util.exit.i

update_tg_cfs_util.exit.i:                        ; preds = %if.end.i.i, %if.end3.i
  %runnable_avg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %25, i32 0, i32 17, i32 6
  %53 = ptrtoint ptr %runnable_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load i32, ptr %runnable_avg.i.i, align 4
  %runnable_avg2.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 6
  %55 = ptrtoint ptr %runnable_avg2.i.i to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load i32, ptr %runnable_avg2.i.i, align 4
  %tobool.not.i23.i = icmp eq i32 %54, %56
  br i1 %tobool.not.i23.i, label %update_tg_cfs_runnable.exit.i, label %if.end.i32.i

if.end.i32.i:                                     ; preds = %update_tg_cfs_util.exit.i
  %sub.i24.i = sub i32 %54, %56
  %period_contrib.i.i25.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 17, i32 4
  %57 = ptrtoint ptr %period_contrib.i.i25.i to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load i32, ptr %period_contrib.i.i25.i, align 4
  %add.i.i26.i = add i32 %58, 46718
  %59 = ptrtoint ptr %runnable_avg2.i.i to i32
  call void @__asan_store4_noabort(i32 %59)
  store i32 %54, ptr %runnable_avg2.i.i, align 4
  %mul.i27.i = mul i32 %add.i.i26.i, %54
  %runnable_sum.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 2
  %60 = ptrtoint ptr %runnable_sum.i.i to i32
  call void @__asan_load8_noabort(i32 %60)
  %61 = load i64, ptr %runnable_sum.i.i, align 16
  %conv.i.i37 = trunc i64 %61 to i32
  %sub11.i28.i = sub i32 %mul.i27.i, %conv.i.i37
  %conv12.i.i = zext i32 %mul.i27.i to i64
  store i64 %conv12.i.i, ptr %runnable_sum.i.i, align 16
  %runnable_avg16.i.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 17, i32 6
  %62 = ptrtoint ptr %runnable_avg16.i.i to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load volatile i32, ptr %runnable_avg16.i.i, align 4
  %add.i29.i = add i32 %63, %sub.i24.i
  %cmp.i30.i = icmp slt i32 %sub.i24.i, 0
  %cmp19.i.i = icmp ugt i32 %add.i29.i, %63
  %64 = select i1 %cmp.i30.i, i1 %cmp19.i.i, i1 false
  %res.0.i31.i = select i1 %64, i32 0, i32 %add.i29.i
  store volatile i32 %res.0.i31.i, ptr %runnable_avg16.i.i, align 4
  %runnable_sum37.i.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 17, i32 2
  %65 = ptrtoint ptr %runnable_sum37.i.i to i32
  call void @__asan_load8_noabort(i32 %65)
  %66 = load volatile i64, ptr %runnable_sum37.i.i, align 8
  %conv45.i.i = sext i32 %sub11.i28.i to i64
  %add46.i.i = add i64 %66, %conv45.i.i
  %cmp47.i.i = icmp slt i32 %sub11.i28.i, 0
  %cmp50.i.i = icmp ugt i64 %add46.i.i, %66
  %67 = select i1 %cmp47.i.i, i1 %cmp50.i.i, i1 false
  %res39.0.i.i = select i1 %67, i64 0, i64 %add46.i.i
  store volatile i64 %res39.0.i.i, ptr %runnable_sum37.i.i, align 8
  %conv67.i.i = trunc i64 %res39.0.i.i to i32
  %mul70.i.i = mul i32 %res.0.i31.i, 46718
  %68 = tail call i32 @llvm.umax.i32(i32 %mul70.i.i, i32 %conv67.i.i) #20
  %conv74.i.i = zext i32 %68 to i64
  %69 = ptrtoint ptr %runnable_sum37.i.i to i32
  call void @__asan_store8_noabort(i32 %69)
  store i64 %conv74.i.i, ptr %runnable_sum37.i.i, align 16
  br label %update_tg_cfs_runnable.exit.i

update_tg_cfs_runnable.exit.i:                    ; preds = %if.end.i32.i, %update_tg_cfs_util.exit.i
  %70 = ptrtoint ptr %prop_runnable_sum.i to i32
  call void @__asan_load4_noabort(i32 %70)
  %71 = load i32, ptr %prop_runnable_sum.i, align 8
  %tobool.not.i34.i = icmp eq i32 %71, 0
  br i1 %tobool.not.i34.i, label %update_tg_cfs_load.exit.i, label %if.end.i38.i

if.end.i38.i:                                     ; preds = %update_tg_cfs_runnable.exit.i
  %72 = ptrtoint ptr %prop_runnable_sum.i to i32
  call void @__asan_store4_noabort(i32 %72)
  store i32 0, ptr %prop_runnable_sum.i, align 8
  %period_contrib.i.i35.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 17, i32 4
  %73 = ptrtoint ptr %period_contrib.i.i35.i to i32
  call void @__asan_load4_noabort(i32 %73)
  %74 = load i32, ptr %period_contrib.i.i35.i, align 4
  %add.i.i36.i = add i32 %74, 46718
  %cmp.i37.i = icmp sgt i32 %71, -1
  br i1 %cmp.i37.i, label %if.then2.i.i, label %if.else.i.i

if.then2.i.i:                                     ; preds = %if.end.i38.i
  %load_sum4.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 1
  %75 = ptrtoint ptr %load_sum4.i.i to i32
  call void @__asan_load8_noabort(i32 %75)
  %76 = load i64, ptr %load_sum4.i.i, align 8
  %77 = trunc i64 %76 to i32
  %conv5.i.i = add i32 %71, %77
  %78 = tail call i32 @llvm.smin.i32(i32 %conv5.i.i, i32 %add.i.i36.i) #20
  br label %if.end26.i.i

if.else.i.i:                                      ; preds = %if.end.i38.i
  %79 = ptrtoint ptr %25 to i32
  call void @__asan_load4_noabort(i32 %79)
  %80 = load i32, ptr %25, align 128
  %tobool8.not.i.i = icmp eq i32 %80, 0
  br i1 %tobool8.not.i.i, label %if.end15.i.i, label %if.then9.i.i

if.then9.i.i:                                     ; preds = %if.else.i.i
  %load_sum11.i.i = getelementptr inbounds %struct.cfs_rq, ptr %25, i32 0, i32 17, i32 1
  %81 = ptrtoint ptr %load_sum11.i.i to i32
  call void @__asan_load8_noabort(i32 %81)
  %82 = load i64, ptr %load_sum11.i.i, align 8
  %cmp164.i.i.i.i = icmp ult i64 %82, 4294967296
  br i1 %cmp164.i.i.i.i, label %if.then168.i.i.i.i, label %if.else174.i.i.i.i, !prof !259

if.then168.i.i.i.i:                               ; preds = %if.then9.i.i
  %conv169.i.i.i.i = trunc i64 %82 to i32
  %div172.i.i.i.i = udiv i32 %conv169.i.i.i.i, %80
  %conv173.i.i.i.i = zext i32 %div172.i.i.i.i to i64
  br label %if.end15.i.i

if.else174.i.i.i.i:                               ; preds = %if.then9.i.i
  %83 = tail call { i64, i64 } asm ".ifnc $0,r0; .ifnc $0r0,fpr11; .ifnc $0r0,r11fp; .ifnc $0r0,ipr12; .ifnc $0r0,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09.ifnc $1,r2; .ifnc $1r2,fpr11; .ifnc $1r2,r11fp; .ifnc $1r2,ipr12; .ifnc $1r2,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09.ifnc $2,r4; .ifnc $2r4,fpr11; .ifnc $2r4,r11fp; .ifnc $2r4,ipr12; .ifnc $2r4,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09bl\09__do_div64", "={r0},={r2},{r4},{r0},~{r12},~{lr},~{cc}"(i32 %80, i64 %82) #23, !srcloc !263
  %asmresult1.i.i.i.i.i = extractvalue { i64, i64 } %83, 1
  br label %if.end15.i.i

if.end15.i.i:                                     ; preds = %if.else174.i.i.i.i, %if.then168.i.i.i.i, %if.else.i.i
  %load_sum.0.i.i = phi i64 [ 0, %if.else.i.i ], [ %conv173.i.i.i.i, %if.then168.i.i.i.i ], [ %asmresult1.i.i.i.i.i, %if.else174.i.i.i.i ]
  %load_sum17.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 1
  %84 = ptrtoint ptr %load_sum17.i.i to i32
  call void @__asan_load8_noabort(i32 %84)
  %85 = load i64, ptr %load_sum17.i.i, align 8
  %86 = tail call i64 @llvm.umin.i64(i64 %85, i64 %load_sum.0.i.i) #20
  %cond24.off0.i.i = trunc i64 %86 to i32
  br label %if.end26.i.i

if.end26.i.i:                                     ; preds = %if.end15.i.i, %if.then2.i.i
  %runnable_sum.0.i.i = phi i32 [ %78, %if.then2.i.i ], [ %cond24.off0.i.i, %if.end15.i.i ]
  %util_sum.i39.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 3
  %87 = ptrtoint ptr %util_sum.i39.i to i32
  call void @__asan_load4_noabort(i32 %87)
  %88 = load i32, ptr %util_sum.i39.i, align 8
  %shr.i.i = lshr i32 %88, 10
  %89 = tail call i32 @llvm.smax.i32(i32 %runnable_sum.0.i.i, i32 %shr.i.i) #20
  %90 = ptrtoint ptr %se to i32
  call void @__asan_load4_noabort(i32 %90)
  %91 = load i32, ptr %se, align 128
  %mul.i40.i = mul i32 %89, %91
  %conv36.i.i = sext i32 %mul.i40.i to i64
  %cmp164.i.i282.i.i = icmp sgt i32 %mul.i40.i, -1
  br i1 %cmp164.i.i282.i.i, label %if.then168.i.i286.i.i, label %if.else174.i.i288.i.i, !prof !259

if.then168.i.i286.i.i:                            ; preds = %if.end26.i.i
  %div172.i.i284.i.i = udiv i32 %mul.i40.i, %add.i.i36.i
  br label %div_u64.exit290.i.i

if.else174.i.i288.i.i:                            ; preds = %if.end26.i.i
  %92 = tail call { i64, i64 } asm ".ifnc $0,r0; .ifnc $0r0,fpr11; .ifnc $0r0,r11fp; .ifnc $0r0,ipr12; .ifnc $0r0,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09.ifnc $1,r2; .ifnc $1r2,fpr11; .ifnc $1r2,r11fp; .ifnc $1r2,ipr12; .ifnc $1r2,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09.ifnc $2,r4; .ifnc $2r4,fpr11; .ifnc $2r4,r11fp; .ifnc $2r4,ipr12; .ifnc $2r4,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09bl\09__do_div64", "={r0},={r2},{r4},{r0},~{r12},~{lr},~{cc}"(i32 %add.i.i36.i, i64 %conv36.i.i) #23, !srcloc !263
  %asmresult1.i.i.i287.i.i = extractvalue { i64, i64 } %92, 1
  %extract.t293.i.i = trunc i64 %asmresult1.i.i.i287.i.i to i32
  br label %div_u64.exit290.i.i

div_u64.exit290.i.i:                              ; preds = %if.else174.i.i288.i.i, %if.then168.i.i286.i.i
  %dividend.addr.0.i.i289.off0.i.i = phi i32 [ %div172.i.i284.i.i, %if.then168.i.i286.i.i ], [ %extract.t293.i.i, %if.else174.i.i288.i.i ]
  %load_avg40.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 5
  %93 = ptrtoint ptr %load_avg40.i.i to i32
  call void @__asan_load4_noabort(i32 %93)
  %94 = load i32, ptr %load_avg40.i.i, align 32
  %tobool41.not.i.i = icmp eq i32 %dividend.addr.0.i.i289.off0.i.i, %94
  br i1 %tobool41.not.i.i, label %update_tg_cfs_load.exit.i, label %if.end43.i.i

if.end43.i.i:                                     ; preds = %div_u64.exit290.i.i
  %sub.i41.i = sub i32 %dividend.addr.0.i.i289.off0.i.i, %94
  %conv45.i42.i = sext i32 %91 to i64
  %load_sum47.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 1
  %95 = ptrtoint ptr %load_sum47.i.i to i32
  call void @__asan_load8_noabort(i32 %95)
  %96 = load i64, ptr %load_sum47.i.i, align 8
  %mul48.i.i = mul i64 %96, %conv45.i42.i
  %sub49.i.i = sub i64 %conv36.i.i, %mul48.i.i
  %conv50291.i.i = zext i32 %89 to i64
  store i64 %conv50291.i.i, ptr %load_sum47.i.i, align 8
  %97 = ptrtoint ptr %load_avg40.i.i to i32
  call void @__asan_store4_noabort(i32 %97)
  store i32 %dividend.addr.0.i.i289.off0.i.i, ptr %load_avg40.i.i, align 32
  %load_avg56.i.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 17, i32 5
  %98 = ptrtoint ptr %load_avg56.i.i to i32
  call void @__asan_load4_noabort(i32 %98)
  %99 = load volatile i32, ptr %load_avg56.i.i, align 4
  %add59.i.i = add i32 %99, %sub.i41.i
  %cmp60.i.i = icmp slt i32 %sub.i41.i, 0
  %cmp62.i.i = icmp ugt i32 %add59.i.i, %99
  %100 = select i1 %cmp60.i.i, i1 %cmp62.i.i, i1 false
  %res.0.i43.i = select i1 %100, i32 0, i32 %add59.i.i
  store volatile i32 %res.0.i43.i, ptr %load_avg56.i.i, align 4
  %load_sum80.i.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 17, i32 1
  %101 = ptrtoint ptr %load_sum80.i.i to i32
  call void @__asan_load8_noabort(i32 %101)
  %102 = load volatile i64, ptr %load_sum80.i.i, align 8
  %add88.i.i = add i64 %102, %sub49.i.i
  %cmp89.i.i = icmp slt i64 %sub49.i.i, 0
  %cmp92.i.i = icmp ugt i64 %add88.i.i, %102
  %103 = select i1 %cmp89.i.i, i1 %cmp92.i.i, i1 false
  %res82.0.i.i = select i1 %103, i64 0, i64 %add88.i.i
  store volatile i64 %res82.0.i.i, ptr %load_sum80.i.i, align 8
  %conv109.i.i = trunc i64 %res82.0.i.i to i32
  %mul112.i.i = mul i32 %res.0.i43.i, 46718
  %104 = tail call i32 @llvm.umax.i32(i32 %mul112.i.i, i32 %conv109.i.i) #20
  %conv120.i.i = zext i32 %104 to i64
  %105 = ptrtoint ptr %load_sum80.i.i to i32
  call void @__asan_store8_noabort(i32 %105)
  store i64 %conv120.i.i, ptr %load_sum80.i.i, align 8
  br label %update_tg_cfs_load.exit.i

update_tg_cfs_load.exit.i:                        ; preds = %if.end43.i.i, %div_u64.exit290.i.i, %update_tg_cfs_runnable.exit.i
  tail call fastcc void @trace_pelt_cfs_tp(ptr noundef %30) #20
  tail call fastcc void @trace_pelt_se_tp(ptr noundef %se) #20
  br label %propagate_entity_load_avg.exit

propagate_entity_load_avg.exit:                   ; preds = %update_tg_cfs_load.exit.i, %if.end.i36, %if.end
  %retval.0.i40 = phi i32 [ 1, %update_tg_cfs_load.exit.i ], [ 0, %if.end ], [ 0, %if.end.i36 ]
  %106 = ptrtoint ptr %avg to i32
  call void @__asan_load8_noabort(i32 %106)
  %107 = load i64, ptr %avg, align 128
  %tobool7.not = icmp ne i64 %107, 0
  %and9 = and i32 %flags, 4
  %tobool10.not = icmp eq i32 %and9, 0
  %or.cond34 = or i1 %tobool10.not, %tobool7.not
  br i1 %or.cond34, label %if.else, label %if.then11

if.then11:                                        ; preds = %propagate_entity_load_avg.exit
  tail call fastcc void @attach_entity_load_avg(ptr noundef %cfs_rq, ptr noundef %se)
  %load_avg.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 5
  %108 = ptrtoint ptr %load_avg.i to i32
  call void @__asan_load4_noabort(i32 %108)
  %109 = load i32, ptr %load_avg.i, align 32
  %tg_load_avg_contrib.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 21
  %110 = ptrtoint ptr %tg_load_avg_contrib.i to i32
  call void @__asan_load4_noabort(i32 %110)
  %111 = load i32, ptr %tg_load_avg_contrib.i, align 128
  %sub.i41 = sub i32 %109, %111
  %tg.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 30
  %112 = ptrtoint ptr %tg.i to i32
  call void @__asan_load4_noabort(i32 %112)
  %113 = load ptr, ptr %tg.i, align 4
  %cmp.i = icmp ne ptr %113, @root_task_group
  %114 = tail call i32 @llvm.abs.i32(i32 %sub.i41, i1 false) #20
  %div21.i = lshr i32 %111, 6
  %cmp4.i = icmp ugt i32 %114, %div21.i
  %or.cond.i = select i1 %cmp.i, i1 %cmp4.i, i1 false
  br i1 %or.cond.i, label %if.then5.i, label %if.end19

if.then5.i:                                       ; preds = %if.then11
  %load_avg7.i = getelementptr inbounds %struct.task_group, ptr %113, i32 0, i32 6
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %load_avg7.i, i32 noundef 4) #20
  tail call void @llvm.prefetch.p0(ptr %load_avg7.i, i32 1, i32 3, i32 1) #20
  %115 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %load_avg7.i, ptr %load_avg7.i, i32 %sub.i41, ptr elementtype(i32) %load_avg7.i) #20, !srcloc !262
  br label %if.end19.sink.split

if.else:                                          ; preds = %propagate_entity_load_avg.exit
  %or = or i32 %retval.0.i40, %call3
  %tobool12.not = icmp eq i32 %or, 0
  br i1 %tobool12.not, label %if.end19, label %if.then13

if.then13:                                        ; preds = %if.else
  %rq.i.i42 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %116 = ptrtoint ptr %rq.i.i42 to i32
  call void @__asan_load4_noabort(i32 %116)
  %117 = load ptr, ptr %rq.i.i42, align 4
  %cfs.i = getelementptr inbounds %struct.rq, ptr %117, i32 0, i32 14
  %cmp.i43 = icmp eq ptr %cfs.i, %cfs_rq
  br i1 %cmp.i43, label %if.then.i44, label %cfs_rq_util_change.exit

if.then.i44:                                      ; preds = %if.then13
  tail call fastcc void @cpufreq_update_util(ptr noundef %117, i32 noundef 0) #20
  br label %cfs_rq_util_change.exit

cfs_rq_util_change.exit:                          ; preds = %if.then.i44, %if.then13
  %and14 = and i32 %flags, 1
  %tobool15.not = icmp eq i32 %and14, 0
  br i1 %tobool15.not, label %if.end19, label %if.then16

if.then16:                                        ; preds = %cfs_rq_util_change.exit
  %load_avg.i46 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 5
  %118 = ptrtoint ptr %load_avg.i46 to i32
  call void @__asan_load4_noabort(i32 %118)
  %119 = load i32, ptr %load_avg.i46, align 32
  %tg_load_avg_contrib.i47 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 21
  %120 = ptrtoint ptr %tg_load_avg_contrib.i47 to i32
  call void @__asan_load4_noabort(i32 %120)
  %121 = load i32, ptr %tg_load_avg_contrib.i47, align 128
  %sub.i48 = sub i32 %119, %121
  %tg.i49 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 30
  %122 = ptrtoint ptr %tg.i49 to i32
  call void @__asan_load4_noabort(i32 %122)
  %123 = load ptr, ptr %tg.i49, align 4
  %cmp.i50 = icmp ne ptr %123, @root_task_group
  %124 = tail call i32 @llvm.abs.i32(i32 %sub.i48, i1 false) #20
  %div21.i51 = lshr i32 %121, 6
  %cmp4.i52 = icmp ugt i32 %124, %div21.i51
  %or.cond.i53 = select i1 %cmp.i50, i1 %cmp4.i52, i1 false
  br i1 %or.cond.i53, label %if.then5.i56, label %if.end19

if.then5.i56:                                     ; preds = %if.then16
  %load_avg7.i54 = getelementptr inbounds %struct.task_group, ptr %123, i32 0, i32 6
  %call.i.i.i55 = tail call zeroext i1 @__kasan_check_write(ptr noundef %load_avg7.i54, i32 noundef 4) #20
  tail call void @llvm.prefetch.p0(ptr %load_avg7.i54, i32 1, i32 3, i32 1) #20
  %125 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %load_avg7.i54, ptr %load_avg7.i54, i32 %sub.i48, ptr elementtype(i32) %load_avg7.i54) #20, !srcloc !262
  br label %if.end19.sink.split

if.end19.sink.split:                              ; preds = %if.then5.i56, %if.then5.i
  %load_avg.i46.sink = phi ptr [ %load_avg.i46, %if.then5.i56 ], [ %load_avg.i, %if.then5.i ]
  %tg_load_avg_contrib.i47.sink = phi ptr [ %tg_load_avg_contrib.i47, %if.then5.i56 ], [ %tg_load_avg_contrib.i, %if.then5.i ]
  %126 = ptrtoint ptr %load_avg.i46.sink to i32
  call void @__asan_load4_noabort(i32 %126)
  %127 = load i32, ptr %load_avg.i46.sink, align 32
  %128 = ptrtoint ptr %tg_load_avg_contrib.i47.sink to i32
  call void @__asan_store4_noabort(i32 %128)
  store i32 %127, ptr %tg_load_avg_contrib.i47.sink, align 128
  br label %if.end19

if.end19:                                         ; preds = %if.end19.sink.split, %if.then16, %cfs_rq_util_change.exit, %if.else, %if.then11
  ret void
}

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc zeroext i1 @list_add_leaf_cfs_rq(ptr noundef %cfs_rq) unnamed_addr #7 align 64 {
entry:
  %rq.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %0 = ptrtoint ptr %rq.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %rq.i, align 4
  %cpu.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 46
  %2 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu.i, align 4
  %on_list = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 28
  %4 = ptrtoint ptr %on_list to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %on_list, align 32
  %tobool.not = icmp eq i32 %5, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %tmp_alone_branch = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 18
  %6 = ptrtoint ptr %tmp_alone_branch to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %tmp_alone_branch, align 128
  %leaf_cfs_rq_list = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 17
  %cmp = icmp eq ptr %7, %leaf_cfs_rq_list
  br label %cleanup

if.end:                                           ; preds = %entry
  %8 = ptrtoint ptr %on_list to i32
  call void @__asan_store4_noabort(i32 %8)
  store i32 1, ptr %on_list, align 32
  %tg = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 30
  %9 = ptrtoint ptr %tg to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %tg, align 4
  %parent = getelementptr inbounds %struct.task_group, ptr %10, i32 0, i32 12
  %11 = ptrtoint ptr %parent to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %parent, align 8
  %tobool3.not = icmp eq ptr %12, null
  br i1 %tobool3.not, label %if.then22, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %cfs_rq6 = getelementptr inbounds %struct.task_group, ptr %12, i32 0, i32 2
  %13 = ptrtoint ptr %cfs_rq6 to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %cfs_rq6, align 4
  %arrayidx = getelementptr ptr, ptr %14, i32 %3
  %15 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %arrayidx, align 4
  %on_list7 = getelementptr inbounds %struct.cfs_rq, ptr %16, i32 0, i32 28
  %17 = ptrtoint ptr %on_list7 to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %on_list7, align 32
  %tobool8.not = icmp eq i32 %18, 0
  %leaf_cfs_rq_list28 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 29
  br i1 %tobool8.not, label %if.end27, label %if.then9

if.then9:                                         ; preds = %land.lhs.true
  %leaf_cfs_rq_list15 = getelementptr inbounds %struct.cfs_rq, ptr %16, i32 0, i32 29
  %prev.i = getelementptr inbounds %struct.cfs_rq, ptr %16, i32 0, i32 29, i32 1
  %19 = ptrtoint ptr %prev.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %prev.i, align 4
  %call.i.i = tail call zeroext i1 @__list_add_valid(ptr noundef %leaf_cfs_rq_list28, ptr noundef %20, ptr noundef %leaf_cfs_rq_list15) #20
  br i1 %call.i.i, label %if.end.i.i, label %list_add_tail_rcu.exit

if.end.i.i:                                       ; preds = %if.then9
  %21 = ptrtoint ptr %leaf_cfs_rq_list28 to i32
  call void @__asan_store4_noabort(i32 %21)
  store ptr %leaf_cfs_rq_list15, ptr %leaf_cfs_rq_list28, align 4
  %prev2.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 29, i32 1
  %22 = ptrtoint ptr %prev2.i.i to i32
  call void @__asan_store4_noabort(i32 %22)
  store ptr %20, ptr %prev2.i.i, align 4
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !265
  %23 = ptrtoint ptr %20 to i32
  call void @__asan_store4_noabort(i32 %23)
  store volatile ptr %leaf_cfs_rq_list28, ptr %20, align 4
  %24 = ptrtoint ptr %prev.i to i32
  call void @__asan_store4_noabort(i32 %24)
  store ptr %leaf_cfs_rq_list28, ptr %prev.i, align 4
  br label %list_add_tail_rcu.exit

list_add_tail_rcu.exit:                           ; preds = %if.end.i.i, %if.then9
  %leaf_cfs_rq_list16 = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 17
  %tmp_alone_branch17 = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 18
  %25 = ptrtoint ptr %tmp_alone_branch17 to i32
  call void @__asan_store4_noabort(i32 %25)
  store ptr %leaf_cfs_rq_list16, ptr %tmp_alone_branch17, align 128
  br label %cleanup

if.then22:                                        ; preds = %if.end
  %leaf_cfs_rq_list23 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 29
  %leaf_cfs_rq_list24 = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 17
  %prev.i53 = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 17, i32 1
  %26 = ptrtoint ptr %prev.i53 to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load ptr, ptr %prev.i53, align 4
  %call.i.i54 = tail call zeroext i1 @__list_add_valid(ptr noundef %leaf_cfs_rq_list23, ptr noundef %27, ptr noundef %leaf_cfs_rq_list24) #20
  br i1 %call.i.i54, label %if.end.i.i56, label %list_add_tail_rcu.exit57

if.end.i.i56:                                     ; preds = %if.then22
  %28 = ptrtoint ptr %leaf_cfs_rq_list23 to i32
  call void @__asan_store4_noabort(i32 %28)
  store ptr %leaf_cfs_rq_list24, ptr %leaf_cfs_rq_list23, align 4
  %prev2.i.i55 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 29, i32 1
  %29 = ptrtoint ptr %prev2.i.i55 to i32
  call void @__asan_store4_noabort(i32 %29)
  store ptr %27, ptr %prev2.i.i55, align 4
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !265
  %30 = ptrtoint ptr %27 to i32
  call void @__asan_store4_noabort(i32 %30)
  store volatile ptr %leaf_cfs_rq_list23, ptr %27, align 4
  %31 = ptrtoint ptr %prev.i53 to i32
  call void @__asan_store4_noabort(i32 %31)
  store ptr %leaf_cfs_rq_list23, ptr %prev.i53, align 4
  br label %list_add_tail_rcu.exit57

list_add_tail_rcu.exit57:                         ; preds = %if.end.i.i56, %if.then22
  %tmp_alone_branch26 = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 18
  %32 = ptrtoint ptr %tmp_alone_branch26 to i32
  call void @__asan_store4_noabort(i32 %32)
  store ptr %leaf_cfs_rq_list24, ptr %tmp_alone_branch26, align 128
  br label %cleanup

if.end27:                                         ; preds = %land.lhs.true
  %tmp_alone_branch29 = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 18
  %33 = ptrtoint ptr %tmp_alone_branch29 to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load ptr, ptr %tmp_alone_branch29, align 128
  %35 = ptrtoint ptr %34 to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load ptr, ptr %34, align 4
  %call.i.i58 = tail call zeroext i1 @__list_add_valid(ptr noundef %leaf_cfs_rq_list28, ptr noundef %34, ptr noundef %36) #20
  br i1 %call.i.i58, label %if.end.i.i60, label %list_add_rcu.exit

if.end.i.i60:                                     ; preds = %if.end27
  %37 = ptrtoint ptr %leaf_cfs_rq_list28 to i32
  call void @__asan_store4_noabort(i32 %37)
  store ptr %36, ptr %leaf_cfs_rq_list28, align 4
  %prev2.i.i59 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 29, i32 1
  %38 = ptrtoint ptr %prev2.i.i59 to i32
  call void @__asan_store4_noabort(i32 %38)
  store ptr %34, ptr %prev2.i.i59, align 4
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !265
  %39 = ptrtoint ptr %34 to i32
  call void @__asan_store4_noabort(i32 %39)
  store volatile ptr %leaf_cfs_rq_list28, ptr %34, align 4
  %prev37.i.i = getelementptr inbounds %struct.list_head, ptr %36, i32 0, i32 1
  %40 = ptrtoint ptr %prev37.i.i to i32
  call void @__asan_store4_noabort(i32 %40)
  store ptr %leaf_cfs_rq_list28, ptr %prev37.i.i, align 4
  br label %list_add_rcu.exit

list_add_rcu.exit:                                ; preds = %if.end.i.i60, %if.end27
  %41 = ptrtoint ptr %tmp_alone_branch29 to i32
  call void @__asan_store4_noabort(i32 %41)
  store ptr %leaf_cfs_rq_list28, ptr %tmp_alone_branch29, align 128
  br label %cleanup

cleanup:                                          ; preds = %list_add_rcu.exit, %list_add_tail_rcu.exit57, %list_add_tail_rcu.exit, %if.then
  %retval.0 = phi i1 [ %cmp, %if.then ], [ true, %list_add_tail_rcu.exit ], [ false, %list_add_rcu.exit ], [ true, %list_add_tail_rcu.exit57 ]
  ret i1 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @resched_curr(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @init_cfs_bandwidth(ptr noundef %cfs_b) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call void @__raw_spin_lock_init(ptr noundef %cfs_b, ptr noundef nonnull @.str, ptr noundef nonnull @init_cfs_bandwidth.__key, i16 noundef signext 2) #20
  %runtime = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 3
  %0 = ptrtoint ptr %runtime to i32
  call void @__asan_store8_noabort(i32 %0)
  store i64 0, ptr %runtime, align 8
  %quota = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 2
  %1 = ptrtoint ptr %quota to i32
  call void @__asan_store8_noabort(i32 %1)
  store i64 -1, ptr %quota, align 8
  %period = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 1
  %2 = ptrtoint ptr %period to i32
  call void @__asan_store8_noabort(i32 %2)
  store i64 100000000, ptr %period, align 8
  %burst = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 4
  %3 = ptrtoint ptr %burst to i32
  call void @__asan_store8_noabort(i32 %3)
  store i64 0, ptr %burst, align 8
  %throttled_cfs_rq = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 12
  %4 = ptrtoint ptr %throttled_cfs_rq to i32
  call void @__asan_store4_noabort(i32 %4)
  store volatile ptr %throttled_cfs_rq, ptr %throttled_cfs_rq, align 4
  %prev.i = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 12, i32 1
  %5 = ptrtoint ptr %prev.i to i32
  call void @__asan_store4_noabort(i32 %5)
  store ptr %throttled_cfs_rq, ptr %prev.i, align 4
  %period_timer = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 10
  tail call void @hrtimer_init(ptr noundef %period_timer, i32 noundef 1, i32 noundef 2) #20
  %function = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 10, i32 2
  %6 = ptrtoint ptr %function to i32
  call void @__asan_store4_noabort(i32 %6)
  store ptr @sched_cfs_period_timer, ptr %function, align 8
  %slack_timer = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 11
  tail call void @hrtimer_init(ptr noundef %slack_timer, i32 noundef 1, i32 noundef 1) #20
  %function4 = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 11, i32 2
  %7 = ptrtoint ptr %function4 to i32
  call void @__asan_store4_noabort(i32 %7)
  store ptr @sched_cfs_slack_timer, ptr %function4, align 8
  %slack_started = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 9
  %8 = ptrtoint ptr %slack_started to i32
  call void @__asan_store1_noabort(i32 %8)
  store i8 0, ptr %slack_started, align 2
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @__raw_spin_lock_init(ptr noundef, ptr noundef, ptr noundef, i16 noundef signext) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @hrtimer_init(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @sched_cfs_period_timer(ptr noundef %timer) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %timer, i32 -104
  %call = tail call i32 @_raw_spin_lock_irqsave(ptr noundef %add.ptr) #20
  %period = getelementptr i8, ptr %timer, i32 -56
  %base.i = getelementptr inbounds %struct.hrtimer, ptr %timer, i32 0, i32 3
  %0 = ptrtoint ptr %period to i32
  call void @__asan_load8_noabort(i32 %0)
  %1 = load i64, ptr %period, align 8
  %2 = ptrtoint ptr %base.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %base.i, align 4
  %get_time.i93 = getelementptr inbounds %struct.hrtimer_clock_base, ptr %3, i32 0, i32 6
  %4 = ptrtoint ptr %get_time.i93 to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %get_time.i93, align 4
  %call.i94 = tail call i64 %5() #20
  %call1.i95 = tail call i64 @hrtimer_forward(ptr noundef %timer, i64 noundef %call.i94, i64 noundef %1) #20
  %conv396 = trunc i64 %call1.i95 to i32
  %tobool.not97 = icmp eq i32 %conv396, 0
  br i1 %tobool.not97, label %do.body49, label %if.end.lr.ph

if.end.lr.ph:                                     ; preds = %entry
  %quota.i = getelementptr i8, ptr %timer, i32 -48
  %throttled_cfs_rq.i = getelementptr i8, ptr %timer, i32 96
  %nr_periods.i = getelementptr i8, ptr %timer, i32 104
  %runtime3.i.i = getelementptr i8, ptr %timer, i32 -40
  %runtime_snap.i.i = getelementptr i8, ptr %timer, i32 -24
  %burst_time.i.i = getelementptr i8, ptr %timer, i32 128
  %nr_burst.i.i = getelementptr i8, ptr %timer, i32 112
  %burst.i.i = getelementptr i8, ptr %timer, i32 -32
  %idle.i = getelementptr i8, ptr %timer, i32 -8
  %nr_throttled.i = getelementptr i8, ptr %timer, i32 108
  br label %if.end

if.end:                                           ; preds = %if.end45, %if.end.lr.ph
  %conv399 = phi i32 [ %conv396, %if.end.lr.ph ], [ %conv3, %if.end45 ]
  %count.098 = phi i32 [ 0, %if.end.lr.ph ], [ %count.1, %if.end45 ]
  %6 = ptrtoint ptr %quota.i to i32
  call void @__asan_load8_noabort(i32 %6)
  %7 = load i64, ptr %quota.i, align 8
  %cmp.i = icmp eq i64 %7, -1
  br i1 %cmp.i, label %do_sched_cfs_period_timer.exit, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.end
  %8 = ptrtoint ptr %throttled_cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load volatile ptr, ptr %throttled_cfs_rq.i, align 4
  %cmp.i.i = icmp ne ptr %9, %throttled_cfs_rq.i
  %10 = ptrtoint ptr %nr_periods.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %nr_periods.i, align 8
  %add.i = add i32 %11, %conv399
  store i32 %add.i, ptr %nr_periods.i, align 8
  %12 = ptrtoint ptr %runtime3.i.i to i32
  call void @__asan_load8_noabort(i32 %12)
  %13 = load i64, ptr %runtime3.i.i, align 8
  %add.i.i = add i64 %13, %7
  %14 = ptrtoint ptr %runtime_snap.i.i to i32
  call void @__asan_load8_noabort(i32 %14)
  %15 = load i64, ptr %runtime_snap.i.i, align 8
  %sub.i.i = sub i64 %15, %add.i.i
  %cmp5.i.i = icmp sgt i64 %sub.i.i, 0
  br i1 %cmp5.i.i, label %if.then6.i.i, label %__refill_cfs_bandwidth_runtime.exit.i

if.then6.i.i:                                     ; preds = %if.end.i.i
  %16 = ptrtoint ptr %burst_time.i.i to i32
  call void @__asan_load8_noabort(i32 %16)
  %17 = load i64, ptr %burst_time.i.i, align 8
  %add7.i.i = add i64 %17, %sub.i.i
  store i64 %add7.i.i, ptr %burst_time.i.i, align 8
  %18 = ptrtoint ptr %nr_burst.i.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %nr_burst.i.i, align 8
  %inc.i.i = add i32 %19, 1
  store i32 %inc.i.i, ptr %nr_burst.i.i, align 8
  br label %__refill_cfs_bandwidth_runtime.exit.i

__refill_cfs_bandwidth_runtime.exit.i:            ; preds = %if.then6.i.i, %if.end.i.i
  %20 = ptrtoint ptr %burst.i.i to i32
  call void @__asan_load8_noabort(i32 %20)
  %21 = load i64, ptr %burst.i.i, align 8
  %add11.i.i = add i64 %21, %7
  %22 = tail call i64 @llvm.umin.i64(i64 %add.i.i, i64 %add11.i.i) #20
  %23 = ptrtoint ptr %runtime3.i.i to i32
  call void @__asan_store8_noabort(i32 %23)
  store i64 %22, ptr %runtime3.i.i, align 8
  %24 = ptrtoint ptr %runtime_snap.i.i to i32
  call void @__asan_store8_noabort(i32 %24)
  store i64 %22, ptr %runtime_snap.i.i, align 8
  %25 = ptrtoint ptr %idle.i to i32
  call void @__asan_load1_noabort(i32 %25)
  %26 = load i8, ptr %idle.i, align 8
  %tobool1.not.i = icmp eq i8 %26, 0
  %brmerge.i = select i1 %tobool1.not.i, i1 true, i1 %cmp.i.i
  br i1 %brmerge.i, label %if.end4.i, label %do_sched_cfs_period_timer.exit

if.end4.i:                                        ; preds = %__refill_cfs_bandwidth_runtime.exit.i
  br i1 %cmp.i.i, label %if.end8.i, label %cleanup.sink.split.i

if.end8.i:                                        ; preds = %if.end4.i
  %27 = ptrtoint ptr %nr_throttled.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load i32, ptr %nr_throttled.i, align 4
  %add9.i = add i32 %28, %conv399
  store i32 %add9.i, ptr %nr_throttled.i, align 4
  br label %land.rhs.i

land.rhs.i:                                       ; preds = %do.body.i, %if.end8.i
  %flags.addr.049.i = phi i32 [ %call, %if.end8.i ], [ %call22.i, %do.body.i ]
  %29 = ptrtoint ptr %runtime3.i.i to i32
  call void @__asan_load8_noabort(i32 %29)
  %30 = load i64, ptr %runtime3.i.i, align 8
  %cmp11.not.i = icmp eq i64 %30, 0
  br i1 %cmp11.not.i, label %cleanup.sink.split.i, label %do.body.i

do.body.i:                                        ; preds = %land.rhs.i
  tail call void @_raw_spin_unlock_irqrestore(ptr noundef %add.ptr, i32 noundef %flags.addr.049.i) #20
  tail call fastcc void @distribute_cfs_runtime(ptr noundef %add.ptr) #20
  %call22.i = tail call i32 @_raw_spin_lock_irqsave(ptr noundef %add.ptr) #20
  %31 = ptrtoint ptr %throttled_cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load volatile ptr, ptr %throttled_cfs_rq.i, align 4
  %cmp.i47.not.i = icmp eq ptr %32, %throttled_cfs_rq.i
  br i1 %cmp.i47.not.i, label %cleanup.sink.split.i, label %land.rhs.i

cleanup.sink.split.i:                             ; preds = %do.body.i, %land.rhs.i, %if.end4.i
  %.sink.i = phi i8 [ 1, %if.end4.i ], [ 0, %land.rhs.i ], [ 0, %do.body.i ]
  %33 = ptrtoint ptr %idle.i to i32
  call void @__asan_store1_noabort(i32 %33)
  store i8 %.sink.i, ptr %idle.i, align 8
  br label %do_sched_cfs_period_timer.exit

do_sched_cfs_period_timer.exit:                   ; preds = %cleanup.sink.split.i, %__refill_cfs_bandwidth_runtime.exit.i, %if.end
  %tobool46.not = phi i1 [ false, %if.end ], [ false, %__refill_cfs_bandwidth_runtime.exit.i ], [ true, %cleanup.sink.split.i ]
  %inc = add i32 %count.098, 1
  %cmp5 = icmp sgt i32 %inc, 3
  br i1 %cmp5, label %if.then7, label %if.end45

if.then7:                                         ; preds = %do_sched_cfs_period_timer.exit
  %34 = ptrtoint ptr %period to i32
  call void @__asan_load8_noabort(i32 %34)
  %35 = load i64, ptr %period, align 8
  %mul = shl i64 %35, 1
  call void @__asan_load8_noabort(i32 ptrtoint (ptr @max_cfs_quota_period to i32))
  %36 = load i64, ptr @max_cfs_quota_period, align 8
  %cmp10 = icmp ult i64 %mul, %36
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.then7
  %37 = ptrtoint ptr %period to i32
  call void @__asan_store8_noabort(i32 %37)
  store i64 %mul, ptr %period, align 8
  %38 = ptrtoint ptr %quota.i to i32
  call void @__asan_load8_noabort(i32 %38)
  %39 = load i64, ptr %quota.i, align 8
  %mul15 = shl i64 %39, 1
  store i64 %mul15, ptr %quota.i, align 8
  %40 = ptrtoint ptr %burst.i.i to i32
  call void @__asan_load8_noabort(i32 %40)
  %41 = load i64, ptr %burst.i.i, align 8
  %mul16 = shl i64 %41, 1
  store i64 %mul16, ptr %burst.i.i, align 8
  %call17 = tail call i32 @___ratelimit(ptr noundef nonnull @sched_cfs_period_timer._rs, ptr noundef nonnull @__func__.sched_cfs_period_timer) #20
  %tobool18.not = icmp eq i32 %call17, 0
  br i1 %tobool18.not, label %if.end45, label %do.end22

do.end22:                                         ; preds = %if.then12
  %42 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %42, -16384
  %43 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %43, i32 0, i32 3
  %44 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load i32, ptr %cpu, align 4
  %46 = tail call { i64, i32 } asm "umull\09${0:Q}, ${0:R}, ${2:Q}, ${3:Q}\0A\09cmn\09${0:Q}, ${2:Q}\0A\09adcs\09${0:R}, ${0:R}, ${2:R}\0A\09adc\09${0:Q}, $1, #0", "=&r,=&{r12},r,r,1,~{cc}"(i64 -9002011107970261189, i64 %mul, i32 0) #23, !srcloc !266
  %asmresult.i.i.i = extractvalue { i64, i32 } %46, 0
  %asmresult4.i.i.i = extractvalue { i64, i32 } %46, 1
  %47 = tail call { i64, i32 } asm "umlal\09${0:R}, ${0:Q}, ${2:R}, ${3:Q}\0A\09umlal\09${0:R}, $1, ${2:Q}, ${3:R}\0A\09mov\09${0:R}, #0\0A\09adds\09${0:Q}, $1, ${0:Q}\0A\09adc\09${0:R}, ${0:R}, #0\0A\09umlal\09${0:Q}, ${0:R}, ${2:R}, ${3:R}", "=&r,=&{r12},r,r,0,1,~{cc}"(i64 -9002011107970261189, i64 %mul, i64 %asmresult.i.i.i, i32 %asmresult4.i.i.i) #23, !srcloc !267
  %asmresult10.i.i.i = extractvalue { i64, i32 } %47, 0
  %div158.i.i91 = lshr i64 %asmresult10.i.i.i, 9
  %48 = ptrtoint ptr %quota.i to i32
  call void @__asan_load8_noabort(i32 %48)
  %49 = load i64, ptr %quota.i, align 8
  %50 = tail call { i64, i32 } asm "umull\09${0:Q}, ${0:R}, ${2:Q}, ${3:Q}\0A\09cmn\09${0:Q}, ${2:Q}\0A\09adcs\09${0:R}, ${0:R}, ${2:R}\0A\09adc\09${0:Q}, $1, #0", "=&r,=&{r12},r,r,1,~{cc}"(i64 -9002011107970261189, i64 %49, i32 0) #23, !srcloc !266
  %asmresult.i.i.i76 = extractvalue { i64, i32 } %50, 0
  %asmresult4.i.i.i77 = extractvalue { i64, i32 } %50, 1
  %51 = tail call { i64, i32 } asm "umlal\09${0:R}, ${0:Q}, ${2:R}, ${3:Q}\0A\09umlal\09${0:R}, $1, ${2:Q}, ${3:R}\0A\09mov\09${0:R}, #0\0A\09adds\09${0:Q}, $1, ${0:Q}\0A\09adc\09${0:R}, ${0:R}, #0\0A\09umlal\09${0:Q}, ${0:R}, ${2:R}, ${3:R}", "=&r,=&{r12},r,r,0,1,~{cc}"(i64 -9002011107970261189, i64 %49, i64 %asmresult.i.i.i76, i32 %asmresult4.i.i.i77) #23, !srcloc !267
  %asmresult10.i.i.i78 = extractvalue { i64, i32 } %51, 0
  %div158.i.i7992 = lshr i64 %asmresult10.i.i.i78, 9
  %call28 = tail call i32 (ptr, ...) @_printk(ptr noundef nonnull @.str.20, i32 noundef %45, i64 noundef %div158.i.i91, i64 noundef %div158.i.i7992) #22
  br label %if.end45

if.else:                                          ; preds = %if.then7
  %call30 = tail call i32 @___ratelimit(ptr noundef nonnull @sched_cfs_period_timer._rs.21, ptr noundef nonnull @__func__.sched_cfs_period_timer) #20
  %tobool31.not = icmp eq i32 %call30, 0
  br i1 %tobool31.not, label %if.end45, label %do.end35

do.end35:                                         ; preds = %if.else
  %52 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i80 = and i32 %52, -16384
  %53 = inttoptr i32 %and.i80 to ptr
  %cpu38 = getelementptr inbounds %struct.thread_info, ptr %53, i32 0, i32 3
  %54 = ptrtoint ptr %cpu38 to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load i32, ptr %cpu38, align 4
  %56 = tail call { i64, i32 } asm "umull\09${0:Q}, ${0:R}, ${2:Q}, ${3:Q}\0A\09cmn\09${0:Q}, ${2:Q}\0A\09adcs\09${0:R}, ${0:R}, ${2:R}\0A\09adc\09${0:Q}, $1, #0", "=&r,=&{r12},r,r,1,~{cc}"(i64 -9002011107970261189, i64 %35, i32 0) #23, !srcloc !266
  %asmresult.i.i.i81 = extractvalue { i64, i32 } %56, 0
  %asmresult4.i.i.i82 = extractvalue { i64, i32 } %56, 1
  %57 = tail call { i64, i32 } asm "umlal\09${0:R}, ${0:Q}, ${2:R}, ${3:Q}\0A\09umlal\09${0:R}, $1, ${2:Q}, ${3:R}\0A\09mov\09${0:R}, #0\0A\09adds\09${0:Q}, $1, ${0:Q}\0A\09adc\09${0:R}, ${0:R}, #0\0A\09umlal\09${0:Q}, ${0:R}, ${2:R}, ${3:R}", "=&r,=&{r12},r,r,0,1,~{cc}"(i64 -9002011107970261189, i64 %35, i64 %asmresult.i.i.i81, i32 %asmresult4.i.i.i82) #23, !srcloc !267
  %asmresult10.i.i.i83 = extractvalue { i64, i32 } %57, 0
  %div158.i.i8489 = lshr i64 %asmresult10.i.i.i83, 9
  %58 = ptrtoint ptr %quota.i to i32
  call void @__asan_load8_noabort(i32 %58)
  %59 = load i64, ptr %quota.i, align 8
  %60 = tail call { i64, i32 } asm "umull\09${0:Q}, ${0:R}, ${2:Q}, ${3:Q}\0A\09cmn\09${0:Q}, ${2:Q}\0A\09adcs\09${0:R}, ${0:R}, ${2:R}\0A\09adc\09${0:Q}, $1, #0", "=&r,=&{r12},r,r,1,~{cc}"(i64 -9002011107970261189, i64 %59, i32 0) #23, !srcloc !266
  %asmresult.i.i.i85 = extractvalue { i64, i32 } %60, 0
  %asmresult4.i.i.i86 = extractvalue { i64, i32 } %60, 1
  %61 = tail call { i64, i32 } asm "umlal\09${0:R}, ${0:Q}, ${2:R}, ${3:Q}\0A\09umlal\09${0:R}, $1, ${2:Q}, ${3:R}\0A\09mov\09${0:R}, #0\0A\09adds\09${0:Q}, $1, ${0:Q}\0A\09adc\09${0:R}, ${0:R}, #0\0A\09umlal\09${0:Q}, ${0:R}, ${2:R}, ${3:R}", "=&r,=&{r12},r,r,0,1,~{cc}"(i64 -9002011107970261189, i64 %59, i64 %asmresult.i.i.i85, i32 %asmresult4.i.i.i86) #23, !srcloc !267
  %asmresult10.i.i.i87 = extractvalue { i64, i32 } %61, 0
  %div158.i.i8890 = lshr i64 %asmresult10.i.i.i87, 9
  %call42 = tail call i32 (ptr, ...) @_printk(ptr noundef nonnull @.str.23, i32 noundef %55, i64 noundef %div158.i.i8489, i64 noundef %div158.i.i8890) #22
  br label %if.end45

if.end45:                                         ; preds = %do.end35, %if.else, %do.end22, %if.then12, %do_sched_cfs_period_timer.exit
  %count.1 = phi i32 [ %inc, %do_sched_cfs_period_timer.exit ], [ 0, %if.else ], [ 0, %do.end35 ], [ 0, %if.then12 ], [ 0, %do.end22 ]
  %62 = ptrtoint ptr %period to i32
  call void @__asan_load8_noabort(i32 %62)
  %63 = load i64, ptr %period, align 8
  %64 = ptrtoint ptr %base.i to i32
  call void @__asan_load4_noabort(i32 %64)
  %65 = load ptr, ptr %base.i, align 4
  %get_time.i = getelementptr inbounds %struct.hrtimer_clock_base, ptr %65, i32 0, i32 6
  %66 = ptrtoint ptr %get_time.i to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load ptr, ptr %get_time.i, align 4
  %call.i = tail call i64 %67() #20
  %call1.i = tail call i64 @hrtimer_forward(ptr noundef %timer, i64 noundef %call.i, i64 noundef %63) #20
  %conv3 = trunc i64 %call1.i to i32
  %tobool.not = icmp eq i32 %conv3, 0
  br i1 %tobool.not, label %for.end, label %if.end

for.end:                                          ; preds = %if.end45
  br i1 %tobool46.not, label %do.body49, label %if.then47

if.then47:                                        ; preds = %for.end
  %period_active = getelementptr i8, ptr %timer, i32 -7
  %68 = ptrtoint ptr %period_active to i32
  call void @__asan_store1_noabort(i32 %68)
  store i8 0, ptr %period_active, align 1
  br label %do.body49

do.body49:                                        ; preds = %if.then47, %for.end, %entry
  %tobool46.not102 = phi i32 [ 1, %for.end ], [ 0, %if.then47 ], [ 1, %entry ]
  tail call void @_raw_spin_unlock_irqrestore(ptr noundef %add.ptr, i32 noundef %call) #20
  ret i32 %tobool46.not102
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @sched_cfs_slack_timer(ptr noundef %timer) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %timer, i32 -152
  %0 = load i32, ptr @sysctl_sched_cfs_bandwidth_slice, align 4
  %conv.i.i = zext i32 %0 to i64
  %mul.i.i = mul nuw nsw i64 %conv.i.i, 1000
  %call1.i = tail call i32 @_raw_spin_lock_irqsave(ptr noundef %add.ptr) #20
  %slack_started.i = getelementptr i8, ptr %timer, i32 -54
  %1 = ptrtoint ptr %slack_started.i to i32
  call void @__asan_store1_noabort(i32 %1)
  store i8 0, ptr %slack_started.i, align 2
  %period_timer.i.i = getelementptr i8, ptr %timer, i32 -48
  %base.i.i.i = getelementptr i8, ptr %timer, i32 -12
  %2 = ptrtoint ptr %base.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %base.i.i.i, align 4
  %running.i.i.i = getelementptr inbounds %struct.hrtimer_clock_base, ptr %3, i32 0, i32 4
  %4 = ptrtoint ptr %running.i.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %running.i.i.i, align 8
  %cmp.i.not.i.i = icmp eq ptr %5, %period_timer.i.i
  br i1 %cmp.i.not.i.i, label %do.body3.i, label %runtime_refresh_within.exit.i

runtime_refresh_within.exit.i:                    ; preds = %entry
  %expires.i.i.i = getelementptr i8, ptr %timer, i32 -32
  %6 = ptrtoint ptr %expires.i.i.i to i32
  call void @__asan_load8_noabort(i32 %6)
  %7 = load i64, ptr %expires.i.i.i, align 8
  %get_time.i.i.i = getelementptr inbounds %struct.hrtimer_clock_base, ptr %3, i32 0, i32 6
  %8 = ptrtoint ptr %get_time.i.i.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %get_time.i.i.i, align 4
  %call.i.i.i = tail call i64 %9() #20
  %sub.i.i.i = sub i64 %7, %call.i.i.i
  %cmp.i.i = icmp sgt i64 %sub.i.i.i, 1999999
  br i1 %cmp.i.i, label %if.end.i, label %do.body3.i

do.body3.i:                                       ; preds = %runtime_refresh_within.exit.i, %entry
  tail call void @_raw_spin_unlock_irqrestore(ptr noundef %add.ptr, i32 noundef %call1.i) #20
  br label %do_sched_cfs_slack_timer.exit

if.end.i:                                         ; preds = %runtime_refresh_within.exit.i
  %quota.i = getelementptr i8, ptr %timer, i32 -96
  %10 = ptrtoint ptr %quota.i to i32
  call void @__asan_load8_noabort(i32 %10)
  %11 = load i64, ptr %quota.i, align 8
  %cmp12.not.i = icmp eq i64 %11, -1
  br i1 %cmp12.not.i, label %if.then30.critedge.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %runtime14.i = getelementptr i8, ptr %timer, i32 -88
  %12 = ptrtoint ptr %runtime14.i to i32
  call void @__asan_load8_noabort(i32 %12)
  %13 = load i64, ptr %runtime14.i, align 8
  %cmp15.not.i = icmp ugt i64 %13, %mul.i.i
  tail call void @_raw_spin_unlock_irqrestore(ptr noundef %add.ptr, i32 noundef %call1.i) #20
  br i1 %cmp15.not.i, label %if.end31.i, label %do_sched_cfs_slack_timer.exit

if.then30.critedge.i:                             ; preds = %if.end.i
  tail call void @_raw_spin_unlock_irqrestore(ptr noundef %add.ptr, i32 noundef %call1.i) #20
  br label %do_sched_cfs_slack_timer.exit

if.end31.i:                                       ; preds = %land.lhs.true.i
  tail call fastcc void @distribute_cfs_runtime(ptr noundef %add.ptr) #20
  br label %do_sched_cfs_slack_timer.exit

do_sched_cfs_slack_timer.exit:                    ; preds = %if.end31.i, %if.then30.critedge.i, %land.lhs.true.i, %do.body3.i
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @start_cfs_bandwidth(ptr noundef %cfs_b) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %0 = load i32, ptr @debug_locks, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %dep_map = getelementptr inbounds %struct.raw_spinlock, ptr %cfs_b, i32 0, i32 4
  %call.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map, i32 noundef -1) #20
  %cmp.not = icmp eq i32 %call.i, 0
  br i1 %cmp.not, label %do.end, label %if.end, !prof !260

do.end:                                           ; preds = %land.rhs
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 5371, i32 noundef 9, ptr noundef null) #20
  br label %if.end

if.end:                                           ; preds = %do.end, %land.rhs, %entry
  %period_active = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 8
  %1 = ptrtoint ptr %period_active to i32
  call void @__asan_load1_noabort(i32 %1)
  %2 = load i8, ptr %period_active, align 1
  %tobool24.not = icmp eq i8 %2, 0
  br i1 %tobool24.not, label %if.end26, label %return

if.end26:                                         ; preds = %if.end
  %3 = ptrtoint ptr %period_active to i32
  call void @__asan_store1_noabort(i32 %3)
  store i8 1, ptr %period_active, align 1
  %period_timer = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 10
  %period = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 1
  %4 = ptrtoint ptr %period to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %period, align 8
  %base.i = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 10, i32 3
  %6 = ptrtoint ptr %base.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %base.i, align 4
  %get_time.i = getelementptr inbounds %struct.hrtimer_clock_base, ptr %7, i32 0, i32 6
  %8 = ptrtoint ptr %get_time.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %get_time.i, align 4
  %call.i36 = tail call i64 %9() #20
  %call1.i = tail call i64 @hrtimer_forward(ptr noundef %period_timer, i64 noundef %call.i36, i64 noundef %5) #20
  %_softexpires.i.i = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 10, i32 1
  %10 = ptrtoint ptr %_softexpires.i.i to i32
  call void @__asan_load8_noabort(i32 %10)
  %11 = load i64, ptr %_softexpires.i.i, align 8
  %expires.i.i = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 10, i32 0, i32 1
  %12 = ptrtoint ptr %expires.i.i to i32
  call void @__asan_load8_noabort(i32 %12)
  %13 = load i64, ptr %expires.i.i, align 8
  %sub.i = sub i64 %13, %11
  tail call void @hrtimer_start_range_ns(ptr noundef %period_timer, i64 noundef %11, i64 noundef %sub.i, i32 noundef 2) #20
  br label %return

return:                                           ; preds = %if.end26, %if.end
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @warn_slowpath_fmt(ptr noundef, i32 noundef, i32 noundef, ptr noundef, ...) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @__update_idle_core(ptr nocapture noundef readonly %rq) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %cpu.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 46
  %0 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %cpu.i, align 4
  %2 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i = and i32 %2, -16384
  %3 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %3, i32 0, i32 1
  %4 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %5, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !268
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #20
  %call.i = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 696, ptr noundef nonnull @.str.28) #20
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %entry
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %1
  %6 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %7, ptrtoint (ptr @sd_llc_shared to i32)
  %8 = inttoptr i32 %add.i to ptr
  %9 = ptrtoint ptr %8 to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load volatile ptr, ptr %8, align 4
  %call.i16 = tail call i32 @rcu_read_lock_held() #20
  %tobool.not.i17 = icmp eq i32 %call.i16, 0
  br i1 %tobool.not.i17, label %land.lhs.true.i18, label %do.end12.i

land.lhs.true.i18:                                ; preds = %rcu_read_lock.exit
  %call7.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool8.not.i = icmp eq i32 %call7.i, 0
  br i1 %tobool8.not.i, label %do.end12.i, label %land.lhs.true9.i

land.lhs.true9.i:                                 ; preds = %land.lhs.true.i18
  %.b24.i = load i1, ptr @test_idle_cores.__warned, align 1
  br i1 %.b24.i, label %do.end12.i, label %if.then.i19

if.then.i19:                                      ; preds = %land.lhs.true9.i
  store i1 true, ptr @test_idle_cores.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 6152, ptr noundef nonnull @.str.16) #20
  br label %do.end12.i

do.end12.i:                                       ; preds = %if.then.i19, %land.lhs.true9.i, %land.lhs.true.i18, %rcu_read_lock.exit
  %tobool14.not.i = icmp eq ptr %10, null
  br i1 %tobool14.not.i, label %unlock, label %test_idle_cores.exit

test_idle_cores.exit:                             ; preds = %do.end12.i
  %has_idle_cores.i = getelementptr inbounds %struct.sched_domain_shared, ptr %10, i32 0, i32 2
  %11 = ptrtoint ptr %has_idle_cores.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %has_idle_cores.i, align 4
  %tobool20.i.not = icmp eq i32 %12, 0
  br i1 %tobool20.i.not, label %for.cond.preheader, label %unlock

for.cond.preheader:                               ; preds = %test_idle_cores.exit
  %thread_sibling.i = getelementptr [4 x %struct.cpu_topology], ptr @cpu_topology, i32 0, i32 %1, i32 5
  %call342 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef %thread_sibling.i) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %13 = load i32, ptr @nr_cpu_ids, align 4
  %cmp43 = icmp ult i32 %call342, %13
  br i1 %cmp43, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond.backedge, %for.cond.preheader
  %call344 = phi i32 [ %call3, %for.cond.backedge ], [ %call342, %for.cond.preheader ]
  %cmp4 = icmp eq i32 %call344, %1
  br i1 %cmp4, label %for.cond.backedge, label %if.end6

for.cond.backedge:                                ; preds = %if.end6, %for.body
  %call3 = tail call i32 @cpumask_next(i32 noundef %call344, ptr noundef %thread_sibling.i) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %14 = load i32, ptr @nr_cpu_ids, align 4
  %cmp = icmp ult i32 %call3, %14
  br i1 %cmp, label %for.body, label %for.end

if.end6:                                          ; preds = %for.body
  %call7 = tail call i32 @available_idle_cpu(i32 noundef %call344) #20
  %tobool.not = icmp eq i32 %call7, 0
  br i1 %tobool.not, label %unlock, label %for.cond.backedge

for.end:                                          ; preds = %for.cond.backedge, %for.cond.preheader
  %15 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %arrayidx.i, align 4
  %add.i21 = add i32 %16, ptrtoint (ptr @sd_llc_shared to i32)
  %17 = inttoptr i32 %add.i21 to ptr
  %18 = ptrtoint ptr %17 to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load volatile ptr, ptr %17, align 4
  %call.i22 = tail call i32 @rcu_read_lock_held() #20
  %tobool.not.i23 = icmp eq i32 %call.i22, 0
  br i1 %tobool.not.i23, label %land.lhs.true.i26, label %do.end12.i30

land.lhs.true.i26:                                ; preds = %for.end
  %call7.i24 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool8.not.i25 = icmp eq i32 %call7.i24, 0
  br i1 %tobool8.not.i25, label %do.end12.i30, label %land.lhs.true9.i27

land.lhs.true9.i27:                               ; preds = %land.lhs.true.i26
  %.b27.i = load i1, ptr @set_idle_cores.__warned, align 1
  br i1 %.b27.i, label %do.end12.i30, label %if.then.i28

if.then.i28:                                      ; preds = %land.lhs.true9.i27
  store i1 true, ptr @set_idle_cores.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 6143, ptr noundef nonnull @.str.16) #20
  br label %do.end12.i30

do.end12.i30:                                     ; preds = %if.then.i28, %land.lhs.true9.i27, %land.lhs.true.i26, %for.end
  %tobool14.not.i29 = icmp eq ptr %19, null
  br i1 %tobool14.not.i29, label %unlock, label %do.body20.i

do.body20.i:                                      ; preds = %do.end12.i30
  %has_idle_cores.i31 = getelementptr inbounds %struct.sched_domain_shared, ptr %19, i32 0, i32 2
  %20 = ptrtoint ptr %has_idle_cores.i31 to i32
  call void @__asan_store4_noabort(i32 %20)
  store volatile i32 1, ptr %has_idle_cores.i31, align 4
  br label %unlock

unlock:                                           ; preds = %do.body20.i, %do.end12.i30, %if.end6, %test_idle_cores.exit, %do.end12.i
  %call.i32 = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i32, label %rcu_read_unlock.exit, label %land.lhs.true.i35

land.lhs.true.i35:                                ; preds = %unlock
  %call1.i33 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i34 = icmp eq i32 %call1.i33, 0
  br i1 %tobool.not.i34, label %rcu_read_unlock.exit, label %land.lhs.true2.i37

land.lhs.true2.i37:                               ; preds = %land.lhs.true.i35
  %.b4.i36 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i36, label %rcu_read_unlock.exit, label %if.then.i38

if.then.i38:                                      ; preds = %land.lhs.true2.i37
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i38, %land.lhs.true2.i37, %land.lhs.true.i35, %unlock
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %21 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i39 = and i32 %21, -16384
  %22 = inttoptr i32 %and.i.i.i.i.i39 to ptr
  %preempt_count.i.i.i.i40 = getelementptr inbounds %struct.thread_info, ptr %22, i32 0, i32 1
  %23 = ptrtoint ptr %preempt_count.i.i.i.i40 to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load volatile i32, ptr %preempt_count.i.i.i.i40, align 4
  %sub.i.i.i = add i32 %24, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i40, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  ret void
}

; Function Attrs: mustprogress nofree nounwind null_pointer_is_valid readonly willreturn
declare dso_local i32 @cpumask_next(i32 noundef, ptr noundef) local_unnamed_addr #8

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @available_idle_cpu(i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @pick_next_task_fair(ptr noundef %rq, ptr noundef %prev, ptr noundef %rf) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %cfs = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 14
  %nr_running.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 14, i32 1
  %tobool.not = icmp eq ptr %prev, null
  %sched_class = getelementptr inbounds %struct.task_struct, ptr %prev, i32 0, i32 21
  %tobool57.not = icmp eq ptr %rf, null
  br label %again

again:                                            ; preds = %if.end63, %entry
  %0 = ptrtoint ptr %nr_running.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %nr_running.i, align 8
  %cmp.i.not = icmp eq i32 %1, 0
  br i1 %cmp.i.not, label %idle, label %if.end

if.end:                                           ; preds = %again
  br i1 %tobool.not, label %do.body45.preheader, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %2 = ptrtoint ptr %sched_class to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %sched_class, align 32
  %cmp.not = icmp eq ptr %3, @fair_sched_class
  br i1 %cmp.not, label %do.body, label %if.then43

do.body:                                          ; preds = %do.cond, %lor.lhs.false
  %cfs_rq.1 = phi ptr [ %17, %do.cond ], [ %cfs, %lor.lhs.false ]
  %curr3 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.1, i32 0, i32 11
  %4 = ptrtoint ptr %curr3 to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %curr3, align 8
  %tobool4.not = icmp eq ptr %5, null
  br i1 %tobool4.not, label %do.cond, label %if.then5

if.then5:                                         ; preds = %do.body
  %on_rq = getelementptr inbounds %struct.sched_entity, ptr %5, i32 0, i32 3
  %6 = ptrtoint ptr %on_rq to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %on_rq, align 4
  %tobool6.not = icmp eq i32 %7, 0
  br i1 %tobool6.not, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.then5
  tail call fastcc void @update_curr(ptr noundef %cfs_rq.1)
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.then5
  %curr.0 = phi ptr [ %5, %if.then7 ], [ null, %if.then5 ]
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@pick_next_task_fair, %if.end.i)) #20
          to label %do.cond [label %if.end.i], !srcloc !261

if.end.i:                                         ; preds = %if.end8
  %runtime_enabled.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.1, i32 0, i32 32
  %8 = ptrtoint ptr %runtime_enabled.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %runtime_enabled.i, align 4
  %tobool.not.i = icmp eq i32 %9, 0
  br i1 %tobool.not.i, label %do.cond, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %if.end.i
  %runtime_remaining.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.1, i32 0, i32 33
  %10 = ptrtoint ptr %runtime_remaining.i to i32
  call void @__asan_load8_noabort(i32 %10)
  %11 = load i64, ptr %runtime_remaining.i, align 8
  %cmp.i120 = icmp sgt i64 %11, 0
  br i1 %cmp.i120, label %do.cond, label %if.end4.i, !prof !259

if.end4.i:                                        ; preds = %lor.rhs.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@pick_next_task_fair, %land.rhs.i.i)) #20
          to label %if.end8.i [label %land.rhs.i.i], !srcloc !261

land.rhs.i.i:                                     ; preds = %if.end4.i
  %throttled.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.1, i32 0, i32 37
  %12 = ptrtoint ptr %throttled.i.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %throttled.i.i, align 8
  %tobool.i.not.i = icmp eq i32 %13, 0
  br i1 %tobool.i.not.i, label %if.end8.i, label %if.then12, !prof !270

if.end8.i:                                        ; preds = %land.rhs.i.i, %if.end4.i
  %call9.i = tail call fastcc zeroext i1 @throttle_cfs_rq(ptr noundef %cfs_rq.1) #20
  br i1 %call9.i, label %if.then12, label %do.cond, !prof !260

if.then12:                                        ; preds = %if.end8.i, %land.rhs.i.i
  %14 = ptrtoint ptr %nr_running.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %nr_running.i, align 8
  %tobool14.not = icmp eq i32 %15, 0
  br i1 %tobool14.not, label %idle, label %if.then43

do.cond:                                          ; preds = %if.end8.i, %lor.rhs.i, %if.end.i, %if.end8, %do.body
  %curr.1 = phi ptr [ null, %do.body ], [ %curr.0, %if.end8.i ], [ %curr.0, %if.end8 ], [ %curr.0, %lor.rhs.i ], [ %curr.0, %if.end.i ]
  %call19 = tail call fastcc ptr @pick_next_entity(ptr noundef %cfs_rq.1, ptr noundef %curr.1)
  %my_q.i = getelementptr inbounds %struct.sched_entity, ptr %call19, i32 0, i32 12
  %16 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %my_q.i, align 4
  %tobool21.not = icmp eq ptr %17, null
  br i1 %tobool21.not, label %do.end, label %do.body

do.end:                                           ; preds = %do.cond
  %my_q.i.le = getelementptr inbounds %struct.sched_entity, ptr %call19, i32 0, i32 12
  %18 = ptrtoint ptr %my_q.i.le to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load ptr, ptr %my_q.i.le, align 4
  %tobool.not.i122 = icmp eq ptr %19, null
  br i1 %tobool.not.i122, label %task_of.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %do.end
  %.b42.i = load i1, ptr @task_of.__already_done, align 1
  br i1 %.b42.i, label %task_of.exit, label %if.then.i, !prof !259

if.then.i:                                        ; preds = %land.rhs.i
  store i1 true, ptr @task_of.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1376, i32 noundef 9, ptr noundef nonnull @.str.31) #20
  br label %task_of.exit

task_of.exit:                                     ; preds = %if.then.i, %land.rhs.i, %do.end
  %add.ptr.i = getelementptr i8, ptr %call19, i32 -128
  %cmp23.not = icmp eq ptr %add.ptr.i, %prev
  br i1 %cmp23.not, label %done, label %if.then24

if.then24:                                        ; preds = %task_of.exit
  %se25 = getelementptr inbounds %struct.task_struct, ptr %prev, i32 0, i32 18
  %cfs_rq.i167 = getelementptr inbounds %struct.sched_entity, ptr %call19, i32 0, i32 11
  %20 = ptrtoint ptr %cfs_rq.i167 to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %cfs_rq.i167, align 16
  %cfs_rq1.i168 = getelementptr inbounds %struct.task_struct, ptr %prev, i32 0, i32 18, i32 11
  %22 = ptrtoint ptr %cfs_rq1.i168 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %cfs_rq1.i168, align 16
  %cmp.i123169 = icmp ne ptr %21, %23
  %tobool27.not162170 = icmp eq ptr %21, null
  %tobool27.not171 = or i1 %tobool27.not162170, %cmp.i123169
  br i1 %tobool27.not171, label %while.body, label %while.end

while.body:                                       ; preds = %if.end40, %if.then24
  %24 = phi ptr [ %38, %if.end40 ], [ %23, %if.then24 ]
  %cfs_rq.i174 = phi ptr [ %cfs_rq.i, %if.end40 ], [ %cfs_rq.i167, %if.then24 ]
  %pse.0173 = phi ptr [ %pse.1, %if.end40 ], [ %se25, %if.then24 ]
  %se.3172 = phi ptr [ %se.4, %if.end40 ], [ %call19, %if.then24 ]
  %depth = getelementptr inbounds %struct.sched_entity, ptr %se.3172, i32 0, i32 9
  %25 = ptrtoint ptr %depth to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %depth, align 8
  %depth30 = getelementptr inbounds %struct.sched_entity, ptr %pse.0173, i32 0, i32 9
  %27 = ptrtoint ptr %depth30 to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load i32, ptr %depth30, align 8
  %cmp31.not = icmp sgt i32 %26, %28
  br i1 %cmp31.not, label %if.end35, label %if.then32

if.then32:                                        ; preds = %while.body
  tail call fastcc void @put_prev_entity(ptr noundef %24, ptr noundef %pse.0173)
  %parent.i = getelementptr inbounds %struct.sched_entity, ptr %pse.0173, i32 0, i32 10
  %29 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %parent.i, align 4
  br label %if.end35

if.end35:                                         ; preds = %if.then32, %while.body
  %pse.1 = phi ptr [ %30, %if.then32 ], [ %pse.0173, %while.body ]
  %cmp36.not = icmp slt i32 %26, %28
  br i1 %cmp36.not, label %if.end40, label %if.then37

if.then37:                                        ; preds = %if.end35
  %31 = ptrtoint ptr %cfs_rq.i174 to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %cfs_rq.i174, align 16
  tail call fastcc void @set_next_entity(ptr noundef %32, ptr noundef %se.3172)
  %parent.i126 = getelementptr inbounds %struct.sched_entity, ptr %se.3172, i32 0, i32 10
  %33 = ptrtoint ptr %parent.i126 to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load ptr, ptr %parent.i126, align 4
  br label %if.end40

if.end40:                                         ; preds = %if.then37, %if.end35
  %se.4 = phi ptr [ %34, %if.then37 ], [ %se.3172, %if.end35 ]
  %cfs_rq.i = getelementptr inbounds %struct.sched_entity, ptr %se.4, i32 0, i32 11
  %35 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load ptr, ptr %cfs_rq.i, align 16
  %cfs_rq1.i = getelementptr inbounds %struct.sched_entity, ptr %pse.1, i32 0, i32 11
  %37 = ptrtoint ptr %cfs_rq1.i to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load ptr, ptr %cfs_rq1.i, align 16
  %cmp.i123 = icmp ne ptr %36, %38
  %tobool27.not162 = icmp eq ptr %36, null
  %tobool27.not = or i1 %tobool27.not162, %cmp.i123
  br i1 %tobool27.not, label %while.body, label %while.end

while.end:                                        ; preds = %if.end40, %if.then24
  %se.3.lcssa = phi ptr [ %call19, %if.then24 ], [ %se.4, %if.end40 ]
  %pse.0.lcssa = phi ptr [ %se25, %if.then24 ], [ %pse.1, %if.end40 ]
  %.lcssa = phi ptr [ %21, %if.then24 ], [ %36, %if.end40 ]
  tail call fastcc void @put_prev_entity(ptr noundef nonnull %.lcssa, ptr noundef %pse.0.lcssa)
  tail call fastcc void @set_next_entity(ptr noundef nonnull %.lcssa, ptr noundef %se.3.lcssa)
  br label %done

if.then43:                                        ; preds = %if.then12, %lor.lhs.false
  %curr.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 20
  %39 = ptrtoint ptr %curr.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load ptr, ptr %curr.i, align 8
  %cmp.not.i = icmp eq ptr %40, %prev
  br i1 %cmp.not.i, label %put_prev_task.exit, label %land.rhs.i127

land.rhs.i127:                                    ; preds = %if.then43
  %.b40.i = load i1, ptr @put_prev_task.__already_done, align 1
  br i1 %.b40.i, label %put_prev_task.exit, label %if.then.i128, !prof !259

if.then.i128:                                     ; preds = %land.rhs.i127
  store i1 true, ptr @put_prev_task.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 2190, i32 noundef 9, ptr noundef null) #20
  br label %put_prev_task.exit

put_prev_task.exit:                               ; preds = %if.then.i128, %land.rhs.i127, %if.then43
  %41 = ptrtoint ptr %sched_class to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load ptr, ptr %sched_class, align 32
  %put_prev_task.i = getelementptr inbounds %struct.sched_class, ptr %42, i32 0, i32 7
  %43 = ptrtoint ptr %put_prev_task.i to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load ptr, ptr %put_prev_task.i, align 4
  tail call void %44(ptr noundef %rq, ptr noundef nonnull %prev) #20
  br label %do.body45.preheader

do.body45.preheader:                              ; preds = %put_prev_task.exit, %if.end
  br label %do.body45

do.body45:                                        ; preds = %do.body45, %do.body45.preheader
  %cfs_rq.4 = phi ptr [ %46, %do.body45 ], [ %cfs, %do.body45.preheader ]
  %call46 = tail call fastcc ptr @pick_next_entity(ptr noundef %cfs_rq.4, ptr noundef null)
  tail call fastcc void @set_next_entity(ptr noundef %cfs_rq.4, ptr noundef %call46)
  %my_q.i129 = getelementptr inbounds %struct.sched_entity, ptr %call46, i32 0, i32 12
  %45 = ptrtoint ptr %my_q.i129 to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load ptr, ptr %my_q.i129, align 4
  %tobool49.not = icmp eq ptr %46, null
  br i1 %tobool49.not, label %task_of.exit136, label %do.body45

task_of.exit136:                                  ; preds = %do.body45
  %add.ptr.i135 = getelementptr i8, ptr %call46, i32 -128
  br label %done

done:                                             ; preds = %task_of.exit136, %while.end, %task_of.exit
  %p.0 = phi ptr [ %add.ptr.i135, %task_of.exit136 ], [ %add.ptr.i, %while.end ], [ %prev, %task_of.exit ]
  %group_node = getelementptr inbounds %struct.task_struct, ptr %p.0, i32 0, i32 18, i32 2
  %cfs_tasks = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 48
  %call.i.i = tail call zeroext i1 @__list_del_entry_valid(ptr noundef %group_node) #20
  br i1 %call.i.i, label %if.end.i.i, label %__list_del_entry.exit.i

if.end.i.i:                                       ; preds = %done
  %prev.i.i = getelementptr inbounds %struct.task_struct, ptr %p.0, i32 0, i32 18, i32 2, i32 1
  %47 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load ptr, ptr %prev.i.i, align 4
  %49 = ptrtoint ptr %group_node to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load ptr, ptr %group_node, align 4
  %prev1.i.i.i = getelementptr inbounds %struct.list_head, ptr %50, i32 0, i32 1
  %51 = ptrtoint ptr %prev1.i.i.i to i32
  call void @__asan_store4_noabort(i32 %51)
  store ptr %48, ptr %prev1.i.i.i, align 4
  %52 = ptrtoint ptr %48 to i32
  call void @__asan_store4_noabort(i32 %52)
  store volatile ptr %50, ptr %48, align 4
  br label %__list_del_entry.exit.i

__list_del_entry.exit.i:                          ; preds = %if.end.i.i, %done
  %53 = ptrtoint ptr %cfs_tasks to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load ptr, ptr %cfs_tasks, align 4
  %call.i.i.i = tail call zeroext i1 @__list_add_valid(ptr noundef %group_node, ptr noundef %cfs_tasks, ptr noundef %54) #20
  br i1 %call.i.i.i, label %if.end.i.i.i, label %list_move.exit

if.end.i.i.i:                                     ; preds = %__list_del_entry.exit.i
  %prev1.i.i2.i = getelementptr inbounds %struct.list_head, ptr %54, i32 0, i32 1
  %55 = ptrtoint ptr %prev1.i.i2.i to i32
  call void @__asan_store4_noabort(i32 %55)
  store ptr %group_node, ptr %prev1.i.i2.i, align 4
  %56 = ptrtoint ptr %group_node to i32
  call void @__asan_store4_noabort(i32 %56)
  store ptr %54, ptr %group_node, align 4
  %prev3.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p.0, i32 0, i32 18, i32 2, i32 1
  %57 = ptrtoint ptr %prev3.i.i.i to i32
  call void @__asan_store4_noabort(i32 %57)
  store ptr %cfs_tasks, ptr %prev3.i.i.i, align 4
  %58 = ptrtoint ptr %cfs_tasks to i32
  call void @__asan_store4_noabort(i32 %58)
  store volatile ptr %group_node, ptr %cfs_tasks, align 4
  br label %list_move.exit

list_move.exit:                                   ; preds = %if.end.i.i.i, %__list_del_entry.exit.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 6), ptr blockaddress(@pick_next_task_fair, %if.end.i137)) #20
          to label %if.end56 [label %if.end.i137], !srcloc !261

if.end.i137:                                      ; preds = %list_move.exit
  %cpu.i.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 46
  %59 = ptrtoint ptr %cpu.i.i.i to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load i32, ptr %cpu.i.i.i, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %61 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i.i.i = icmp ugt i32 %61, %60
  br i1 %cmp.not.i.i.i.i.i.i, label %cpu_active.exit.i.i, label %land.rhs.i.i.i.i.i.i

land.rhs.i.i.i.i.i.i:                             ; preds = %if.end.i137
  %.b37.i.i.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i.i.i, label %cpu_active.exit.i.i, label %if.then.i.i.i.i.i.i, !prof !259

if.then.i.i.i.i.i.i:                              ; preds = %land.rhs.i.i.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_active.exit.i.i

cpu_active.exit.i.i:                              ; preds = %if.then.i.i.i.i.i.i, %land.rhs.i.i.i.i.i.i, %if.end.i137
  %div3.i.i.i.i.i = lshr i32 %60, 5
  %arrayidx.i.i.i.i.i = getelementptr i32, ptr @__cpu_active_mask, i32 %div3.i.i.i.i.i
  %62 = ptrtoint ptr %arrayidx.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load volatile i32, ptr %arrayidx.i.i.i.i.i, align 4
  %and.i.i.i.i.i = and i32 %60, 31
  %64 = shl nuw i32 1, %and.i.i.i.i.i
  %65 = and i32 %63, %64
  %tobool.i.not.i.i = icmp eq i32 %65, 0
  br i1 %tobool.i.not.i.i, label %if.end56, label %if.end.i.i138

if.end.i.i138:                                    ; preds = %cpu_active.exit.i.i
  %base.i.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 66, i32 3
  %66 = ptrtoint ptr %base.i.i.i to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load ptr, ptr %base.i.i.i, align 4
  %68 = ptrtoint ptr %67 to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load ptr, ptr %67, align 8
  %hres_active.i.i.i = getelementptr inbounds %struct.hrtimer_cpu_base, ptr %69, i32 0, i32 4
  %70 = ptrtoint ptr %hres_active.i.i.i to i32
  call void @__asan_load1_noabort(i32 %70)
  %bf.load.i.i.i = load i8, ptr %hres_active.i.i.i, align 8
  %phi.cmp = icmp sgt i8 %bf.load.i.i.i, -1
  br i1 %phi.cmp, label %if.end56, label %if.then55

if.then55:                                        ; preds = %if.end.i.i138
  tail call fastcc void @hrtick_start_fair(ptr noundef %rq, ptr noundef %p.0)
  br label %if.end56

if.end56:                                         ; preds = %if.then55, %if.end.i.i138, %cpu_active.exit.i.i, %list_move.exit
  tail call fastcc void @update_misfit_status(ptr noundef %p.0, ptr noundef %rq)
  br label %cleanup67

idle:                                             ; preds = %if.then12, %again
  br i1 %tobool57.not, label %cleanup67, label %if.end59

if.end59:                                         ; preds = %idle
  %call60 = tail call fastcc i32 @newidle_balance(ptr noundef %rq, ptr noundef nonnull %rf)
  %cmp61 = icmp slt i32 %call60, 0
  br i1 %cmp61, label %cleanup67, label %if.end63

if.end63:                                         ; preds = %if.end59
  %cmp64.not = icmp eq i32 %call60, 0
  br i1 %cmp64.not, label %if.end66, label %again

if.end66:                                         ; preds = %if.end63
  %util_sum1.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 14, i32 17, i32 3
  %71 = ptrtoint ptr %util_sum1.i to i32
  call void @__asan_load4_noabort(i32 %71)
  %72 = load i32, ptr %util_sum1.i, align 8
  %util_sum2.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 50, i32 3
  %73 = ptrtoint ptr %util_sum2.i to i32
  call void @__asan_load4_noabort(i32 %73)
  %74 = load i32, ptr %util_sum2.i, align 8
  %add.i = add i32 %74, %72
  %util_sum3.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 51, i32 3
  %75 = ptrtoint ptr %util_sum3.i to i32
  call void @__asan_load4_noabort(i32 %75)
  %76 = load i32, ptr %util_sum3.i, align 8
  %add4.i = add i32 %add.i, %76
  %cmp.i140 = icmp ugt i32 %add4.i, 47791489
  br i1 %cmp.i140, label %if.then.i141, label %cleanup67

if.then.i141:                                     ; preds = %if.end66
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %77 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i.i = icmp eq i32 %77, 0
  br i1 %tobool.not.i.i.i, label %lockdep_assert_rq_held.exit.i.i, label %land.rhs.i.i.i

land.rhs.i.i.i:                                   ; preds = %if.then.i141
  %core_enabled.i.i.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 81
  %78 = ptrtoint ptr %core_enabled.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %78)
  %79 = load i32, ptr %core_enabled.i.i.i.i, align 128
  %tobool.not.i.i.i.i = icmp eq i32 %79, 0
  br i1 %tobool.not.i.i.i.i, label %__rq_lockp.exit.i.i.i, label %if.then.i.i.i.i

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i
  %core.i.i.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 79
  %80 = ptrtoint ptr %core.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load ptr, ptr %core.i.i.i.i, align 8
  br label %__rq_lockp.exit.i.i.i

__rq_lockp.exit.i.i.i:                            ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i
  %retval.0.i.i.i.i = phi ptr [ %81, %if.then.i.i.i.i ], [ %rq, %land.rhs.i.i.i ]
  %dep_map.i.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i.i, i32 0, i32 4
  %call.i.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i.i, i32 noundef -1) #20
  %cmp.not.i.i.i = icmp eq i32 %call.i.i.i.i, 0
  br i1 %cmp.not.i.i.i, label %do.end.i.i.i, label %lockdep_assert_rq_held.exit.i.i, !prof !260

do.end.i.i.i:                                     ; preds = %__rq_lockp.exit.i.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i.i

lockdep_assert_rq_held.exit.i.i:                  ; preds = %do.end.i.i.i, %__rq_lockp.exit.i.i.i, %if.then.i141
  %clock_update_flags.i.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 25
  %82 = ptrtoint ptr %clock_update_flags.i.i.i to i32
  call void @__asan_load4_noabort(i32 %82)
  %83 = load i32, ptr %clock_update_flags.i.i.i, align 4
  %cmp.i.i.i = icmp ult i32 %83, 2
  br i1 %cmp.i.i.i, label %land.rhs.i3.i.i, label %rq_clock_task.exit.i

land.rhs.i3.i.i:                                  ; preds = %lockdep_assert_rq_held.exit.i.i
  %.b37.i.i.i = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i.i, label %rq_clock_task.exit.i, label %if.then.i.i.i, !prof !259

if.then.i.i.i:                                    ; preds = %land.rhs.i3.i.i
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %rq_clock_task.exit.i

rq_clock_task.exit.i:                             ; preds = %if.then.i.i.i, %land.rhs.i3.i.i, %lockdep_assert_rq_held.exit.i.i
  %clock_task.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 28
  %84 = ptrtoint ptr %clock_task.i.i to i32
  call void @__asan_load8_noabort(i32 %84)
  %85 = load i64, ptr %clock_task.i.i, align 128
  %clock_pelt.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 29
  %86 = ptrtoint ptr %clock_pelt.i to i32
  call void @__asan_load8_noabort(i32 %86)
  %87 = load i64, ptr %clock_pelt.i, align 8
  %sub.i = sub i64 %85, %87
  %lost_idle_time.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 30
  %88 = ptrtoint ptr %lost_idle_time.i to i32
  call void @__asan_load4_noabort(i32 %88)
  %89 = load i32, ptr %lost_idle_time.i, align 16
  %90 = trunc i64 %sub.i to i32
  %conv6.i = add i32 %89, %90
  store i32 %conv6.i, ptr %lost_idle_time.i, align 16
  br label %cleanup67

cleanup67:                                        ; preds = %rq_clock_task.exit.i, %if.end66, %if.end59, %idle, %if.end56
  %retval.0 = phi ptr [ %p.0, %if.end56 ], [ null, %if.end66 ], [ null, %rq_clock_task.exit.i ], [ inttoptr (i32 -1 to ptr), %if.end59 ], [ null, %idle ]
  ret ptr %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @update_curr(ptr nocapture noundef %cfs_rq) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %curr1 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 11
  %0 = ptrtoint ptr %curr1 to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %curr1, align 8
  %rq.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %2 = ptrtoint ptr %rq.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %rq.i, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %4 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i = icmp eq i32 %4, 0
  br i1 %tobool.not.i.i, label %lockdep_assert_rq_held.exit.i, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %entry
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %3, i32 0, i32 81
  %5 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i85 = icmp eq i32 %6, 0
  br i1 %tobool.not.i.i.i85, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.rhs.i.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %3, i32 0, i32 79
  %7 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %land.rhs.i.i
  %retval.0.i.i.i = phi ptr [ %8, %if.then.i.i.i ], [ %3, %land.rhs.i.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i, i32 noundef -1) #20
  %cmp.not.i.i = icmp eq i32 %call.i.i.i, 0
  br i1 %cmp.not.i.i, label %do.end.i.i, label %lockdep_assert_rq_held.exit.i, !prof !260

do.end.i.i:                                       ; preds = %__rq_lockp.exit.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i

lockdep_assert_rq_held.exit.i:                    ; preds = %do.end.i.i, %__rq_lockp.exit.i.i, %entry
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %3, i32 0, i32 25
  %9 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %clock_update_flags.i.i, align 4
  %cmp.i.i86 = icmp ult i32 %10, 2
  br i1 %cmp.i.i86, label %land.rhs.i3.i, label %rq_clock_task.exit

land.rhs.i3.i:                                    ; preds = %lockdep_assert_rq_held.exit.i
  %.b37.i.i = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i, label %rq_clock_task.exit, label %if.then.i.i, !prof !259

if.then.i.i:                                      ; preds = %land.rhs.i3.i
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %rq_clock_task.exit

rq_clock_task.exit:                               ; preds = %if.then.i.i, %land.rhs.i3.i, %lockdep_assert_rq_held.exit.i
  %clock_task.i = getelementptr inbounds %struct.rq, ptr %3, i32 0, i32 28
  %11 = ptrtoint ptr %clock_task.i to i32
  call void @__asan_load8_noabort(i32 %11)
  %12 = load i64, ptr %clock_task.i, align 128
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %cleanup, label %if.end, !prof !260

if.end:                                           ; preds = %rq_clock_task.exit
  %exec_start = getelementptr inbounds %struct.sched_entity, ptr %1, i32 0, i32 4
  %13 = ptrtoint ptr %exec_start to i32
  call void @__asan_load8_noabort(i32 %13)
  %14 = load i64, ptr %exec_start, align 32
  %sub = sub i64 %12, %14
  %cmp = icmp slt i64 %sub, 1
  br i1 %cmp, label %cleanup, label %if.end13, !prof !260

if.end13:                                         ; preds = %if.end
  %15 = ptrtoint ptr %exec_start to i32
  call void @__asan_store8_noabort(i32 %15)
  store i64 %12, ptr %exec_start, align 32
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@update_curr, %if.then23)) #20
          to label %if.end28 [label %if.then23], !srcloc !261

if.then23:                                        ; preds = %if.end13
  %my_q.i = getelementptr inbounds %struct.sched_entity, ptr %1, i32 0, i32 12
  %16 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i87 = icmp eq ptr %17, null
  %stats.i = getelementptr inbounds %struct.sched_entity_stats, ptr %1, i32 0, i32 1
  %stats1.i = getelementptr i8, ptr %1, i32 640
  %retval.0.i88 = select i1 %tobool.not.i87, ptr %stats1.i, ptr %stats.i
  %exec_max = getelementptr inbounds %struct.sched_statistics, ptr %retval.0.i88, i32 0, i32 12
  %18 = ptrtoint ptr %exec_max to i32
  call void @__asan_load8_noabort(i32 %18)
  %19 = load i64, ptr %exec_max, align 32
  %20 = tail call i64 @llvm.umax.i64(i64 %sub, i64 %19)
  %21 = ptrtoint ptr %exec_max to i32
  call void @__asan_store8_noabort(i32 %21)
  store i64 %20, ptr %exec_max, align 32
  br label %if.end28

if.end28:                                         ; preds = %if.then23, %if.end13
  %sum_exec_runtime = getelementptr inbounds %struct.sched_entity, ptr %1, i32 0, i32 5
  %22 = ptrtoint ptr %sum_exec_runtime to i32
  call void @__asan_load8_noabort(i32 %22)
  %23 = load i64, ptr %sum_exec_runtime, align 8
  %add = add i64 %23, %sub
  store i64 %add, ptr %sum_exec_runtime, align 8
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@update_curr, %if.then41)) #20
          to label %do.end45 [label %if.then41], !srcloc !261

if.then41:                                        ; preds = %if.end28
  %exec_clock = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 5
  %24 = ptrtoint ptr %exec_clock to i32
  call void @__asan_load8_noabort(i32 %24)
  %25 = load i64, ptr %exec_clock, align 8
  %add42 = add i64 %25, %sub
  store i64 %add42, ptr %exec_clock, align 8
  br label %do.end45

do.end45:                                         ; preds = %if.then41, %if.end28
  %26 = ptrtoint ptr %1 to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %1, align 128
  %cmp.not.i = icmp eq i32 %27, 1024
  br i1 %cmp.not.i, label %calc_delta_fair.exit, label %if.then.i, !prof !259

if.then.i:                                        ; preds = %do.end45
  %call.i = tail call fastcc i64 @__calc_delta(i64 noundef %sub, i32 noundef 1024, ptr noundef nonnull %1) #20
  br label %calc_delta_fair.exit

calc_delta_fair.exit:                             ; preds = %if.then.i, %do.end45
  %delta.addr.0.i = phi i64 [ %call.i, %if.then.i ], [ %sub, %do.end45 ]
  %vruntime = getelementptr inbounds %struct.sched_entity, ptr %1, i32 0, i32 6
  %28 = ptrtoint ptr %vruntime to i32
  call void @__asan_load8_noabort(i32 %28)
  %29 = load i64, ptr %vruntime, align 16
  %add47 = add i64 %29, %delta.addr.0.i
  store i64 %add47, ptr %vruntime, align 16
  %30 = ptrtoint ptr %curr1 to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %curr1, align 8
  %rb_leftmost.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 10, i32 1
  %32 = ptrtoint ptr %rb_leftmost.i to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load ptr, ptr %rb_leftmost.i, align 4
  %min_vruntime.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 6
  %34 = ptrtoint ptr %min_vruntime.i to i32
  call void @__asan_load8_noabort(i32 %34)
  %35 = load i64, ptr %min_vruntime.i, align 32
  %tobool.not.i90 = icmp eq ptr %31, null
  br i1 %tobool.not.i90, label %if.end5.i, label %if.then.i91

if.then.i91:                                      ; preds = %calc_delta_fair.exit
  %on_rq.i = getelementptr inbounds %struct.sched_entity, ptr %31, i32 0, i32 3
  %36 = ptrtoint ptr %on_rq.i to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load i32, ptr %on_rq.i, align 4
  %tobool2.not.i = icmp eq i32 %37, 0
  br i1 %tobool2.not.i, label %if.end5.i, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i91
  %vruntime4.i = getelementptr inbounds %struct.sched_entity, ptr %31, i32 0, i32 6
  %38 = ptrtoint ptr %vruntime4.i to i32
  call void @__asan_load8_noabort(i32 %38)
  %39 = load i64, ptr %vruntime4.i, align 16
  br label %if.end5.i

if.end5.i:                                        ; preds = %if.then3.i, %if.then.i91, %calc_delta_fair.exit
  %vruntime.0.i = phi i64 [ %39, %if.then3.i ], [ %35, %calc_delta_fair.exit ], [ %35, %if.then.i91 ]
  %curr.0.i = phi ptr [ %31, %if.then3.i ], [ null, %calc_delta_fair.exit ], [ null, %if.then.i91 ]
  %tobool6.not.i = icmp eq ptr %33, null
  br i1 %tobool6.not.i, label %update_min_vruntime.exit, label %if.then7.i

if.then7.i:                                       ; preds = %if.end5.i
  %tobool8.not.i = icmp eq ptr %curr.0.i, null
  %vruntime10.i = getelementptr i8, ptr %33, i32 40
  %40 = ptrtoint ptr %vruntime10.i to i32
  call void @__asan_load8_noabort(i32 %40)
  %41 = load i64, ptr %vruntime10.i, align 16
  br i1 %tobool8.not.i, label %update_min_vruntime.exit, label %if.else11.i

if.else11.i:                                      ; preds = %if.then7.i
  %sub.i.i92 = sub i64 %41, %vruntime.0.i
  %cmp.i.i93 = icmp slt i64 %sub.i.i92, 0
  %spec.select.i.i = select i1 %cmp.i.i93, i64 %41, i64 %vruntime.0.i
  br label %update_min_vruntime.exit

update_min_vruntime.exit:                         ; preds = %if.else11.i, %if.then7.i, %if.end5.i
  %vruntime.2.i = phi i64 [ %vruntime.0.i, %if.end5.i ], [ %spec.select.i.i, %if.else11.i ], [ %41, %if.then7.i ]
  %sub.i35.i = sub i64 %vruntime.2.i, %35
  %cmp.i36.i = icmp sgt i64 %sub.i35.i, 0
  %spec.select.i37.i = select i1 %cmp.i36.i, i64 %vruntime.2.i, i64 %35
  %42 = ptrtoint ptr %min_vruntime.i to i32
  call void @__asan_store8_noabort(i32 %42)
  store i64 %spec.select.i37.i, ptr %min_vruntime.i, align 32
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !271
  %43 = ptrtoint ptr %min_vruntime.i to i32
  call void @__asan_load8_noabort(i32 %43)
  %44 = load i64, ptr %min_vruntime.i, align 32
  %min_vruntime_copy.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 9
  %45 = ptrtoint ptr %min_vruntime_copy.i to i32
  call void @__asan_store8_noabort(i32 %45)
  store i64 %44, ptr %min_vruntime_copy.i, align 8
  %my_q = getelementptr inbounds %struct.sched_entity, ptr %1, i32 0, i32 12
  %46 = ptrtoint ptr %my_q to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load ptr, ptr %my_q, align 4
  %tobool48.not = icmp eq ptr %47, null
  br i1 %tobool48.not, label %task_of.exit, label %if.end52

task_of.exit:                                     ; preds = %update_min_vruntime.exit
  %add.ptr.i = getelementptr i8, ptr %1, i32 -128
  %48 = ptrtoint ptr %vruntime to i32
  call void @__asan_load8_noabort(i32 %48)
  %49 = load i64, ptr %vruntime, align 16
  tail call fastcc void @trace_sched_stat_runtime(ptr noundef %add.ptr.i, i64 noundef %sub, i64 noundef %49)
  tail call void @cpuacct_charge(ptr noundef %add.ptr.i, i64 noundef %sub) #20
  %50 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i.i = and i32 %50, -16384
  %51 = inttoptr i32 %and.i.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %51, i32 0, i32 1
  %52 = ptrtoint ptr %preempt_count.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load volatile i32, ptr %preempt_count.i.i.i.i.i, align 4
  %add.i.i.i.i = add i32 %53, 1
  store volatile i32 %add.i.i.i.i, ptr %preempt_count.i.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !268
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #20
  %call.i.i = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i.i, label %rcu_read_lock.exit.i, label %land.lhs.true.i.i98

land.lhs.true.i.i98:                              ; preds = %task_of.exit
  %call1.i.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i.i97 = icmp eq i32 %call1.i.i, 0
  br i1 %tobool.not.i.i97, label %rcu_read_lock.exit.i, label %land.lhs.true2.i.i

land.lhs.true2.i.i:                               ; preds = %land.lhs.true.i.i98
  %.b4.i.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i.i, label %rcu_read_lock.exit.i, label %if.then.i.i99

if.then.i.i99:                                    ; preds = %land.lhs.true2.i.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 696, ptr noundef nonnull @.str.28) #20
  br label %rcu_read_lock.exit.i

rcu_read_lock.exit.i:                             ; preds = %if.then.i.i99, %land.lhs.true2.i.i, %land.lhs.true.i.i98, %task_of.exit
  %cgroups.i.i.i = getelementptr i8, ptr %1, i32 4336
  %54 = ptrtoint ptr %cgroups.i.i.i to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load volatile ptr, ptr %cgroups.i.i.i, align 16
  %call.i.i.i.i100 = tail call i32 @lock_is_held_type(ptr noundef getelementptr inbounds (%struct.mutex, ptr @cgroup_mutex, i32 0, i32 5), i32 noundef -1) #20
  %tobool.not.i.i.i101 = icmp eq i32 %call.i.i.i.i100, 0
  br i1 %tobool.not.i.i.i101, label %lor.lhs.false.i.i.i, label %task_dfl_cgroup.exit.i

lor.lhs.false.i.i.i:                              ; preds = %rcu_read_lock.exit.i
  %call.i18.i.i.i = tail call i32 @lock_is_held_type(ptr noundef getelementptr inbounds (%struct.spinlock, ptr @css_set_lock, i32 0, i32 0, i32 0, i32 4), i32 noundef -1) #20
  %tobool3.not.i.i.i = icmp eq i32 %call.i18.i.i.i, 0
  br i1 %tobool3.not.i.i.i, label %lor.lhs.false4.i.i.i, label %task_dfl_cgroup.exit.i

lor.lhs.false4.i.i.i:                             ; preds = %lor.lhs.false.i.i.i
  %flags.i.i.i = getelementptr i8, ptr %1, i32 -116
  %56 = ptrtoint ptr %flags.i.i.i to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load i32, ptr %flags.i.i.i, align 4
  %and.i.i.i = and i32 %57, 4
  %tobool5.not.i.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool5.not.i.i.i, label %lor.lhs.false6.i.i.i, label %task_dfl_cgroup.exit.i

lor.lhs.false6.i.i.i:                             ; preds = %lor.lhs.false4.i.i.i
  %call7.i.i.i = tail call i32 @rcu_read_lock_held() #20
  %tobool8.not.i.i.i = icmp eq i32 %call7.i.i.i, 0
  br i1 %tobool8.not.i.i.i, label %land.lhs.true.i.i.i, label %task_dfl_cgroup.exit.i

land.lhs.true.i.i.i:                              ; preds = %lor.lhs.false6.i.i.i
  %call9.i.i.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool10.not.i.i.i = icmp eq i32 %call9.i.i.i, 0
  br i1 %tobool10.not.i.i.i, label %task_dfl_cgroup.exit.i, label %land.lhs.true11.i.i.i

land.lhs.true11.i.i.i:                            ; preds = %land.lhs.true.i.i.i
  %.b17.i.i.i = load i1, ptr @task_css_set.__warned, align 1
  br i1 %.b17.i.i.i, label %task_dfl_cgroup.exit.i, label %if.then.i.i.i102

if.then.i.i.i102:                                 ; preds = %land.lhs.true11.i.i.i
  store i1 true, ptr @task_css_set.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.30, i32 noundef 481, ptr noundef nonnull @.str.16) #20
  br label %task_dfl_cgroup.exit.i

task_dfl_cgroup.exit.i:                           ; preds = %if.then.i.i.i102, %land.lhs.true11.i.i.i, %land.lhs.true.i.i.i, %lor.lhs.false6.i.i.i, %lor.lhs.false4.i.i.i, %lor.lhs.false.i.i.i, %rcu_read_lock.exit.i
  %dfl_cgrp.i.i = getelementptr inbounds %struct.css_set, ptr %55, i32 0, i32 3
  %58 = ptrtoint ptr %dfl_cgrp.i.i to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load ptr, ptr %dfl_cgrp.i.i, align 4
  %parent.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %59, i32 0, i32 12
  %60 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load ptr, ptr %parent.i.i, align 8
  %tobool.not.i103 = icmp eq ptr %61, null
  br i1 %tobool.not.i103, label %if.end.i105, label %if.then.i104

if.then.i104:                                     ; preds = %task_dfl_cgroup.exit.i
  tail call void @__cgroup_account_cputime(ptr noundef %59, i64 noundef %sub) #20
  br label %if.end.i105

if.end.i105:                                      ; preds = %if.then.i104, %task_dfl_cgroup.exit.i
  %call.i5.i = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i5.i, label %cgroup_account_cputime.exit, label %land.lhs.true.i8.i

land.lhs.true.i8.i:                               ; preds = %if.end.i105
  %call1.i6.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i7.i = icmp eq i32 %call1.i6.i, 0
  br i1 %tobool.not.i7.i, label %cgroup_account_cputime.exit, label %land.lhs.true2.i10.i

land.lhs.true2.i10.i:                             ; preds = %land.lhs.true.i8.i
  %.b4.i9.i = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i9.i, label %cgroup_account_cputime.exit, label %if.then.i11.i

if.then.i11.i:                                    ; preds = %land.lhs.true2.i10.i
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %cgroup_account_cputime.exit

cgroup_account_cputime.exit:                      ; preds = %if.then.i11.i, %land.lhs.true2.i10.i, %land.lhs.true.i8.i, %if.end.i105
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %62 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i12.i = and i32 %62, -16384
  %63 = inttoptr i32 %and.i.i.i.i.i12.i to ptr
  %preempt_count.i.i.i.i13.i = getelementptr inbounds %struct.thread_info, ptr %63, i32 0, i32 1
  %64 = ptrtoint ptr %preempt_count.i.i.i.i13.i to i32
  call void @__asan_load4_noabort(i32 %64)
  %65 = load volatile i32, ptr %preempt_count.i.i.i.i13.i, align 4
  %sub.i.i.i.i = add i32 %65, -1
  store volatile i32 %sub.i.i.i.i, ptr %preempt_count.i.i.i.i13.i, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  %signal.i.i = getelementptr i8, ptr %1, i32 1552
  %66 = ptrtoint ptr %signal.i.i to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load ptr, ptr %signal.i.i, align 16
  %timers_active.i.i = getelementptr inbounds %struct.signal_struct, ptr %67, i32 0, i32 21, i32 1
  %68 = ptrtoint ptr %timers_active.i.i to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load volatile i32, ptr %timers_active.i.i, align 8
  %tobool.not.i.i106 = icmp eq i32 %69, 0
  br i1 %tobool.not.i.i106, label %if.end52, label %if.end.i.i108

if.end.i.i108:                                    ; preds = %cgroup_account_cputime.exit
  %sighand.i.i = getelementptr i8, ptr %1, i32 1556
  %70 = ptrtoint ptr %sighand.i.i to i32
  call void @__asan_load4_noabort(i32 %70)
  %71 = load ptr, ptr %sighand.i.i, align 4
  %tobool3.not.i.i107 = icmp eq ptr %71, null
  br i1 %tobool3.not.i.i107, label %if.end52, label %if.end.i110

if.end.i110:                                      ; preds = %if.end.i.i108
  %sum_exec_runtime.i = getelementptr inbounds %struct.signal_struct, ptr %67, i32 0, i32 20, i32 0, i32 2
  %call.i.i.i109 = tail call zeroext i1 @__kasan_check_write(ptr noundef %sum_exec_runtime.i, i32 noundef 8) #20
  tail call void @generic_atomic64_add(i64 noundef %sub, ptr noundef %sum_exec_runtime.i) #20
  br label %if.end52

if.end52:                                         ; preds = %if.end.i110, %if.end.i.i108, %cgroup_account_cputime.exit, %update_min_vruntime.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@update_curr, %lor.lhs.false.i)) #20
          to label %cleanup [label %lor.lhs.false.i], !srcloc !261

lor.lhs.false.i:                                  ; preds = %if.end52
  %runtime_enabled.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 32
  %72 = ptrtoint ptr %runtime_enabled.i to i32
  call void @__asan_load4_noabort(i32 %72)
  %73 = load i32, ptr %runtime_enabled.i, align 4
  %tobool.not.i = icmp eq i32 %73, 0
  br i1 %tobool.not.i, label %cleanup, label %if.end.i

if.end.i:                                         ; preds = %lor.lhs.false.i
  %runtime_remaining.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 33
  %74 = ptrtoint ptr %runtime_remaining.i.i to i32
  call void @__asan_load8_noabort(i32 %74)
  %75 = load i64, ptr %runtime_remaining.i.i, align 8
  %sub.i.i = sub i64 %75, %sub
  store i64 %sub.i.i, ptr %runtime_remaining.i.i, align 8
  %cmp.i.i = icmp sgt i64 %sub.i.i, 0
  br i1 %cmp.i.i, label %cleanup, label %if.end.i.i, !prof !259

if.end.i.i:                                       ; preds = %if.end.i
  %throttled.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 37
  %76 = ptrtoint ptr %throttled.i.i to i32
  call void @__asan_load4_noabort(i32 %76)
  %77 = load i32, ptr %throttled.i.i, align 8
  %tobool3.not.i.i = icmp eq i32 %77, 0
  br i1 %tobool3.not.i.i, label %if.end5.i.i, label %cleanup

if.end5.i.i:                                      ; preds = %if.end.i.i
  %tg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 30
  %78 = ptrtoint ptr %tg.i.i to i32
  call void @__asan_load4_noabort(i32 %78)
  %79 = load ptr, ptr %tg.i.i, align 4
  %cfs_bandwidth.i.i.i = getelementptr inbounds %struct.task_group, ptr %79, i32 0, i32 16
  tail call void @_raw_spin_lock(ptr noundef %cfs_bandwidth.i.i.i) #20
  %80 = load i32, ptr @sysctl_sched_cfs_bandwidth_slice, align 4
  %conv.i.i.i = zext i32 %80 to i64
  %mul.i.i.i = mul nuw nsw i64 %conv.i.i.i, 1000
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %81 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i.i = icmp eq i32 %81, 0
  br i1 %tobool.not.i.i.i, label %if.end.i.i.i, label %land.rhs.i.i.i

land.rhs.i.i.i:                                   ; preds = %if.end5.i.i
  %dep_map.i.i.i = getelementptr inbounds %struct.task_group, ptr %79, i32 0, i32 16, i32 0, i32 4
  %call.i.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i.i, i32 noundef -1) #20
  %cmp.not.i.i.i = icmp eq i32 %call.i.i.i.i, 0
  br i1 %cmp.not.i.i.i, label %do.end.i.i.i, label %if.end.i.i.i, !prof !260

do.end.i.i.i:                                     ; preds = %land.rhs.i.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 4699, i32 noundef 9, ptr noundef null) #20
  br label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %do.end.i.i.i, %land.rhs.i.i.i, %if.end5.i.i
  %82 = ptrtoint ptr %runtime_remaining.i.i to i32
  call void @__asan_load8_noabort(i32 %82)
  %83 = load i64, ptr %runtime_remaining.i.i, align 8
  %sub.i.i.i = sub i64 %mul.i.i.i, %83
  %quota.i.i.i = getelementptr inbounds %struct.task_group, ptr %79, i32 0, i32 16, i32 2
  %84 = ptrtoint ptr %quota.i.i.i to i32
  call void @__asan_load8_noabort(i32 %84)
  %85 = load i64, ptr %quota.i.i.i, align 8
  %cmp24.i.i.i = icmp eq i64 %85, -1
  br i1 %cmp24.i.i.i, label %assign_cfs_rq_runtime.exit.i, label %if.else.i.i.i

if.else.i.i.i:                                    ; preds = %if.end.i.i.i
  tail call void @start_cfs_bandwidth(ptr noundef %cfs_bandwidth.i.i.i) #20
  %runtime.i.i.i = getelementptr inbounds %struct.task_group, ptr %79, i32 0, i32 16, i32 3
  %86 = ptrtoint ptr %runtime.i.i.i to i32
  call void @__asan_load8_noabort(i32 %86)
  %87 = load i64, ptr %runtime.i.i.i, align 8
  %cmp26.not.i.i.i = icmp eq i64 %87, 0
  br i1 %cmp26.not.i.i.i, label %assign_cfs_rq_runtime.exit.i, label %if.then27.i.i.i

if.then27.i.i.i:                                  ; preds = %if.else.i.i.i
  %88 = tail call i64 @llvm.umin.i64(i64 %87, i64 %sub.i.i.i) #20
  %sub32.i.i.i = sub i64 %87, %88
  %89 = ptrtoint ptr %runtime.i.i.i to i32
  call void @__asan_store8_noabort(i32 %89)
  store i64 %sub32.i.i.i, ptr %runtime.i.i.i, align 8
  %idle.i.i.i = getelementptr inbounds %struct.task_group, ptr %79, i32 0, i32 16, i32 7
  %90 = ptrtoint ptr %idle.i.i.i to i32
  call void @__asan_store1_noabort(i32 %90)
  store i8 0, ptr %idle.i.i.i, align 8
  br label %assign_cfs_rq_runtime.exit.i

assign_cfs_rq_runtime.exit.i:                     ; preds = %if.then27.i.i.i, %if.else.i.i.i, %if.end.i.i.i
  %amount.0.i.i.i = phi i64 [ %88, %if.then27.i.i.i ], [ 0, %if.else.i.i.i ], [ %sub.i.i.i, %if.end.i.i.i ]
  %91 = ptrtoint ptr %runtime_remaining.i.i to i32
  call void @__asan_load8_noabort(i32 %91)
  %92 = load i64, ptr %runtime_remaining.i.i, align 8
  %add.i.i.i = add i64 %92, %amount.0.i.i.i
  store i64 %add.i.i.i, ptr %runtime_remaining.i.i, align 8
  %cmp37.i.i.i = icmp slt i64 %add.i.i.i, 1
  tail call void @_raw_spin_unlock(ptr noundef %cfs_bandwidth.i.i.i) #20
  br i1 %cmp37.i.i.i, label %land.lhs.true.i.i, label %cleanup

land.lhs.true.i.i:                                ; preds = %assign_cfs_rq_runtime.exit.i
  %93 = ptrtoint ptr %curr1 to i32
  call void @__asan_load4_noabort(i32 %93)
  %94 = load ptr, ptr %curr1, align 8
  %tobool7.not.i.i = icmp eq ptr %94, null
  br i1 %tobool7.not.i.i, label %cleanup, label %if.then14.i.i, !prof !260

if.then14.i.i:                                    ; preds = %land.lhs.true.i.i
  %95 = ptrtoint ptr %rq.i to i32
  call void @__asan_load4_noabort(i32 %95)
  %96 = load ptr, ptr %rq.i, align 4
  tail call void @resched_curr(ptr noundef %96) #20
  br label %cleanup

cleanup:                                          ; preds = %if.then14.i.i, %land.lhs.true.i.i, %assign_cfs_rq_runtime.exit.i, %if.end.i.i, %if.end.i, %lor.lhs.false.i, %if.end52, %if.end, %rq_clock_task.exit
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc ptr @pick_next_entity(ptr nocapture noundef readonly %cfs_rq, ptr noundef %curr) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %rb_leftmost.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 10, i32 1
  %0 = ptrtoint ptr %rb_leftmost.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %rb_leftmost.i, align 4
  %tobool.not.i = icmp eq ptr %1, null
  %add.ptr.i = getelementptr i8, ptr %1, i32 -8
  %retval.0.i = select i1 %tobool.not.i, ptr null, ptr %add.ptr.i
  %tobool.not = icmp eq ptr %retval.0.i, null
  br i1 %tobool.not, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %tobool1.not = icmp eq ptr %curr, null
  br i1 %tobool1.not, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false
  %vruntime.i = getelementptr inbounds %struct.sched_entity, ptr %curr, i32 0, i32 6
  %2 = ptrtoint ptr %vruntime.i to i32
  call void @__asan_load8_noabort(i32 %2)
  %3 = load i64, ptr %vruntime.i, align 16
  %vruntime1.i = getelementptr inbounds %struct.sched_entity, ptr %retval.0.i, i32 0, i32 6
  %4 = ptrtoint ptr %vruntime1.i to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %vruntime1.i, align 16
  %sub.i = sub i64 %3, %5
  %cmp.i = icmp slt i64 %sub.i, 0
  br i1 %cmp.i, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %entry
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %lor.lhs.false
  %left.0 = phi ptr [ %curr, %if.then ], [ %add.ptr.i, %land.lhs.true ], [ %add.ptr.i, %lor.lhs.false ]
  %skip = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 14
  %6 = ptrtoint ptr %skip to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %skip, align 4
  %tobool3.not = icmp ne ptr %7, null
  %cmp = icmp eq ptr %7, %left.0
  %or.cond = select i1 %tobool3.not, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then6, label %if.end25

if.then6:                                         ; preds = %if.end
  %cmp7 = icmp eq ptr %left.0, %curr
  br i1 %cmp7, label %if.end18, label %if.else

if.else:                                          ; preds = %if.then6
  %run_node.i = getelementptr inbounds %struct.sched_entity, ptr %left.0, i32 0, i32 1
  %call.i = tail call ptr @rb_next(ptr noundef %run_node.i) #20
  %tobool.not.i76 = icmp eq ptr %call.i, null
  %add.ptr.i77 = getelementptr i8, ptr %call.i, i32 -8
  %tobool11.not182 = icmp eq ptr %add.ptr.i77, null
  %tobool11.not = or i1 %tobool.not.i76, %tobool11.not182
  br i1 %tobool11.not, label %if.end18, label %lor.lhs.false12

lor.lhs.false12:                                  ; preds = %if.else
  %tobool13.not = icmp eq ptr %curr, null
  br i1 %tobool13.not, label %land.lhs.true20, label %land.lhs.true14

land.lhs.true14:                                  ; preds = %lor.lhs.false12
  %vruntime.i79 = getelementptr inbounds %struct.sched_entity, ptr %curr, i32 0, i32 6
  %8 = ptrtoint ptr %vruntime.i79 to i32
  call void @__asan_load8_noabort(i32 %8)
  %9 = load i64, ptr %vruntime.i79, align 16
  %vruntime1.i80 = getelementptr i8, ptr %call.i, i32 40
  %10 = ptrtoint ptr %vruntime1.i80 to i32
  call void @__asan_load8_noabort(i32 %10)
  %11 = load i64, ptr %vruntime1.i80, align 16
  %sub.i81 = sub i64 %9, %11
  %cmp.i82 = icmp slt i64 %sub.i81, 0
  %spec.select = select i1 %cmp.i82, ptr %curr, ptr %add.ptr.i77
  br label %land.lhs.true20

if.end18:                                         ; preds = %if.else, %if.then6
  %second.0 = phi ptr [ %retval.0.i, %if.then6 ], [ %curr, %if.else ]
  %tobool19.not = icmp eq ptr %second.0, null
  br i1 %tobool19.not, label %if.end25, label %land.lhs.true20

land.lhs.true20:                                  ; preds = %if.end18, %land.lhs.true14, %lor.lhs.false12
  %second.0172 = phi ptr [ %second.0, %if.end18 ], [ %add.ptr.i77, %lor.lhs.false12 ], [ %spec.select, %land.lhs.true14 ]
  %vruntime.i83 = getelementptr inbounds %struct.sched_entity, ptr %second.0172, i32 0, i32 6
  %12 = ptrtoint ptr %vruntime.i83 to i32
  call void @__asan_load8_noabort(i32 %12)
  %13 = load i64, ptr %vruntime.i83, align 16
  %vruntime1.i84 = getelementptr inbounds %struct.sched_entity, ptr %left.0, i32 0, i32 6
  %14 = ptrtoint ptr %vruntime1.i84 to i32
  call void @__asan_load8_noabort(i32 %14)
  %15 = load i64, ptr %vruntime1.i84, align 16
  %sub.i85 = sub i64 %13, %15
  %cmp.i86 = icmp slt i64 %sub.i85, 1
  br i1 %cmp.i86, label %wakeup_preempt_entity.exit.thread, label %if.end.i

if.end.i:                                         ; preds = %land.lhs.true20
  %16 = load i32, ptr @sysctl_sched_wakeup_granularity, align 4
  %conv.i.i = zext i32 %16 to i64
  %17 = ptrtoint ptr %left.0 to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %left.0, align 128
  %cmp.not.i.i.i = icmp eq i32 %18, 1024
  br i1 %cmp.not.i.i.i, label %wakeup_preempt_entity.exit, label %if.then.i.i.i, !prof !259

if.then.i.i.i:                                    ; preds = %if.end.i
  %inv_weight.i.i.i.i = getelementptr inbounds %struct.load_weight, ptr %left.0, i32 0, i32 1
  %19 = ptrtoint ptr %inv_weight.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %inv_weight.i.i.i.i, align 4
  %tobool.not.i33.i.i.i = icmp eq i32 %20, 0
  br i1 %tobool.not.i33.i.i.i, label %if.end.i.i.i.i, label %__update_inv_weight.exit.i.i.i, !prof !260

if.end.i.i.i.i:                                   ; preds = %if.then.i.i.i
  %tobool3.not.i.i.i.i = icmp eq i32 %18, 0
  br i1 %tobool3.not.i.i.i.i, label %if.end15.i.i.i.i, label %if.else.i.i.i.i, !prof !260

if.else.i.i.i.i:                                  ; preds = %if.end.i.i.i.i
  %div.i.i.i.i = udiv i32 -1, %18
  br label %if.end15.i.i.i.i

if.end15.i.i.i.i:                                 ; preds = %if.else.i.i.i.i, %if.end.i.i.i.i
  %storemerge.i.i.i.i = phi i32 [ %div.i.i.i.i, %if.else.i.i.i.i ], [ -1, %if.end.i.i.i.i ]
  %21 = ptrtoint ptr %inv_weight.i.i.i.i to i32
  call void @__asan_store4_noabort(i32 %21)
  store i32 %storemerge.i.i.i.i, ptr %inv_weight.i.i.i.i, align 4
  br label %__update_inv_weight.exit.i.i.i

__update_inv_weight.exit.i.i.i:                   ; preds = %if.end15.i.i.i.i, %if.then.i.i.i
  %22 = phi i32 [ %storemerge.i.i.i.i, %if.end15.i.i.i.i ], [ %20, %if.then.i.i.i ]
  %conv1.i.i.i.i = zext i32 %22 to i64
  %mul.i.i.i.i = shl nuw nsw i64 %conv1.i.i.i.i, 10
  %tobool9.not.i.i.i = icmp ult i32 %22, 4194304
  %extract.t32.i.i.i = trunc i64 %mul.i.i.i.i to i32
  br i1 %tobool9.not.i.i.i, label %__calc_delta.exit.i.i, label %if.then10.i.i.i

if.then10.i.i.i:                                  ; preds = %__update_inv_weight.exit.i.i.i
  %shr7.i.i.i = lshr i32 %22, 22
  %23 = tail call i32 @llvm.ctlz.i32(i32 %shr7.i.i.i, i1 true) #20, !range !258
  %sub.i.i.i.i = sub nuw nsw i32 32, %23
  %sh_prom13.i.i.i = zext i32 %sub.i.i.i.i to i64
  %shr14.i.i.i = lshr i64 %mul.i.i.i.i, %sh_prom13.i.i.i
  %extract.t.i.i.i = trunc i64 %shr14.i.i.i to i32
  br label %__calc_delta.exit.i.i

__calc_delta.exit.i.i:                            ; preds = %if.then10.i.i.i, %__update_inv_weight.exit.i.i.i
  %fact.1.off0.i.i.i = phi i32 [ %extract.t.i.i.i, %if.then10.i.i.i ], [ %extract.t32.i.i.i, %__update_inv_weight.exit.i.i.i ]
  %shift.1.i.i.i = phi i32 [ %23, %if.then10.i.i.i ], [ 32, %__update_inv_weight.exit.i.i.i ]
  %conv1.i.i.i.i.i = zext i32 %fact.1.off0.i.i.i to i64
  %mul.i.i.i.i.i = mul nuw i64 %conv1.i.i.i.i.i, %conv.i.i
  %sh_prom.i.i.i.i = zext i32 %shift.1.i.i.i to i64
  %shr2.i.i.i.i = lshr i64 %mul.i.i.i.i.i, %sh_prom.i.i.i.i
  %.pre.i = and i64 %shr2.i.i.i.i, 4294967295
  br label %wakeup_preempt_entity.exit

wakeup_preempt_entity.exit:                       ; preds = %__calc_delta.exit.i.i, %if.end.i
  %conv.pre-phi.i = phi i64 [ %conv.i.i, %if.end.i ], [ %.pre.i, %__calc_delta.exit.i.i ]
  %cmp2.i = icmp ugt i64 %sub.i85, %conv.pre-phi.i
  br i1 %cmp2.i, label %if.end25, label %wakeup_preempt_entity.exit.thread

wakeup_preempt_entity.exit.thread:                ; preds = %wakeup_preempt_entity.exit, %land.lhs.true20
  br label %if.end25

if.end25:                                         ; preds = %wakeup_preempt_entity.exit.thread, %wakeup_preempt_entity.exit, %if.end18, %if.end
  %se.1 = phi ptr [ %left.0, %if.end ], [ %left.0, %if.end18 ], [ %second.0172, %wakeup_preempt_entity.exit.thread ], [ %left.0, %wakeup_preempt_entity.exit ]
  %next = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 12
  %24 = ptrtoint ptr %next to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %next, align 4
  %tobool26.not = icmp eq ptr %25, null
  br i1 %tobool26.not, label %if.else33, label %land.lhs.true27

land.lhs.true27:                                  ; preds = %if.end25
  %vruntime.i88 = getelementptr inbounds %struct.sched_entity, ptr %25, i32 0, i32 6
  %26 = ptrtoint ptr %vruntime.i88 to i32
  call void @__asan_load8_noabort(i32 %26)
  %27 = load i64, ptr %vruntime.i88, align 16
  %vruntime1.i89 = getelementptr inbounds %struct.sched_entity, ptr %left.0, i32 0, i32 6
  %28 = ptrtoint ptr %vruntime1.i89 to i32
  call void @__asan_load8_noabort(i32 %28)
  %29 = load i64, ptr %vruntime1.i89, align 16
  %sub.i90 = sub i64 %27, %29
  %cmp.i91 = icmp slt i64 %sub.i90, 1
  br i1 %cmp.i91, label %if.then31, label %if.end.i94

if.end.i94:                                       ; preds = %land.lhs.true27
  %30 = load i32, ptr @sysctl_sched_wakeup_granularity, align 4
  %conv.i.i92 = zext i32 %30 to i64
  %31 = ptrtoint ptr %left.0 to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %left.0, align 128
  %cmp.not.i.i.i93 = icmp eq i32 %32, 1024
  br i1 %cmp.not.i.i.i93, label %wakeup_preempt_entity.exit128, label %if.then.i.i.i97, !prof !259

if.then.i.i.i97:                                  ; preds = %if.end.i94
  %inv_weight.i.i.i.i95 = getelementptr inbounds %struct.load_weight, ptr %left.0, i32 0, i32 1
  %33 = ptrtoint ptr %inv_weight.i.i.i.i95 to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %inv_weight.i.i.i.i95, align 4
  %tobool.not.i33.i.i.i96 = icmp eq i32 %34, 0
  br i1 %tobool.not.i33.i.i.i96, label %if.end.i.i.i.i99, label %__update_inv_weight.exit.i.i.i108, !prof !260

if.end.i.i.i.i99:                                 ; preds = %if.then.i.i.i97
  %tobool3.not.i.i.i.i98 = icmp eq i32 %32, 0
  br i1 %tobool3.not.i.i.i.i98, label %if.end15.i.i.i.i103, label %if.else.i.i.i.i101, !prof !260

if.else.i.i.i.i101:                               ; preds = %if.end.i.i.i.i99
  %div.i.i.i.i100 = udiv i32 -1, %32
  br label %if.end15.i.i.i.i103

if.end15.i.i.i.i103:                              ; preds = %if.else.i.i.i.i101, %if.end.i.i.i.i99
  %storemerge.i.i.i.i102 = phi i32 [ %div.i.i.i.i100, %if.else.i.i.i.i101 ], [ -1, %if.end.i.i.i.i99 ]
  %35 = ptrtoint ptr %inv_weight.i.i.i.i95 to i32
  call void @__asan_store4_noabort(i32 %35)
  store i32 %storemerge.i.i.i.i102, ptr %inv_weight.i.i.i.i95, align 4
  br label %__update_inv_weight.exit.i.i.i108

__update_inv_weight.exit.i.i.i108:                ; preds = %if.end15.i.i.i.i103, %if.then.i.i.i97
  %36 = phi i32 [ %storemerge.i.i.i.i102, %if.end15.i.i.i.i103 ], [ %34, %if.then.i.i.i97 ]
  %conv1.i.i.i.i104 = zext i32 %36 to i64
  %mul.i.i.i.i105 = shl nuw nsw i64 %conv1.i.i.i.i104, 10
  %tobool9.not.i.i.i106 = icmp ult i32 %36, 4194304
  %extract.t32.i.i.i107 = trunc i64 %mul.i.i.i.i105 to i32
  br i1 %tobool9.not.i.i.i106, label %__calc_delta.exit.i.i122, label %if.then10.i.i.i114

if.then10.i.i.i114:                               ; preds = %__update_inv_weight.exit.i.i.i108
  %shr7.i.i.i109 = lshr i32 %36, 22
  %37 = tail call i32 @llvm.ctlz.i32(i32 %shr7.i.i.i109, i1 true) #20, !range !258
  %sub.i.i.i.i110 = sub nuw nsw i32 32, %37
  %sh_prom13.i.i.i111 = zext i32 %sub.i.i.i.i110 to i64
  %shr14.i.i.i112 = lshr i64 %mul.i.i.i.i105, %sh_prom13.i.i.i111
  %extract.t.i.i.i113 = trunc i64 %shr14.i.i.i112 to i32
  br label %__calc_delta.exit.i.i122

__calc_delta.exit.i.i122:                         ; preds = %if.then10.i.i.i114, %__update_inv_weight.exit.i.i.i108
  %fact.1.off0.i.i.i115 = phi i32 [ %extract.t.i.i.i113, %if.then10.i.i.i114 ], [ %extract.t32.i.i.i107, %__update_inv_weight.exit.i.i.i108 ]
  %shift.1.i.i.i116 = phi i32 [ %37, %if.then10.i.i.i114 ], [ 32, %__update_inv_weight.exit.i.i.i108 ]
  %conv1.i.i.i.i.i117 = zext i32 %fact.1.off0.i.i.i115 to i64
  %mul.i.i.i.i.i118 = mul nuw i64 %conv1.i.i.i.i.i117, %conv.i.i92
  %sh_prom.i.i.i.i119 = zext i32 %shift.1.i.i.i116 to i64
  %shr2.i.i.i.i120 = lshr i64 %mul.i.i.i.i.i118, %sh_prom.i.i.i.i119
  %.pre.i121 = and i64 %shr2.i.i.i.i120, 4294967295
  br label %wakeup_preempt_entity.exit128

wakeup_preempt_entity.exit128:                    ; preds = %__calc_delta.exit.i.i122, %if.end.i94
  %conv.pre-phi.i123 = phi i64 [ %conv.i.i92, %if.end.i94 ], [ %.pre.i121, %__calc_delta.exit.i.i122 ]
  %cmp2.i124 = icmp ugt i64 %sub.i90, %conv.pre-phi.i123
  br i1 %cmp2.i124, label %if.else33, label %if.then31

if.then31:                                        ; preds = %wakeup_preempt_entity.exit128, %land.lhs.true27
  %38 = ptrtoint ptr %next to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load ptr, ptr %next, align 4
  br label %if.end42

if.else33:                                        ; preds = %wakeup_preempt_entity.exit128, %if.end25
  %last = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 13
  %40 = ptrtoint ptr %last to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load ptr, ptr %last, align 16
  %tobool34.not = icmp eq ptr %41, null
  br i1 %tobool34.not, label %if.end42, label %land.lhs.true35

land.lhs.true35:                                  ; preds = %if.else33
  %vruntime.i129 = getelementptr inbounds %struct.sched_entity, ptr %41, i32 0, i32 6
  %42 = ptrtoint ptr %vruntime.i129 to i32
  call void @__asan_load8_noabort(i32 %42)
  %43 = load i64, ptr %vruntime.i129, align 16
  %vruntime1.i130 = getelementptr inbounds %struct.sched_entity, ptr %left.0, i32 0, i32 6
  %44 = ptrtoint ptr %vruntime1.i130 to i32
  call void @__asan_load8_noabort(i32 %44)
  %45 = load i64, ptr %vruntime1.i130, align 16
  %sub.i131 = sub i64 %43, %45
  %cmp.i132 = icmp slt i64 %sub.i131, 1
  br i1 %cmp.i132, label %if.then39, label %if.end.i135

if.end.i135:                                      ; preds = %land.lhs.true35
  %46 = load i32, ptr @sysctl_sched_wakeup_granularity, align 4
  %conv.i.i133 = zext i32 %46 to i64
  %47 = ptrtoint ptr %left.0 to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load i32, ptr %left.0, align 128
  %cmp.not.i.i.i134 = icmp eq i32 %48, 1024
  br i1 %cmp.not.i.i.i134, label %wakeup_preempt_entity.exit169, label %if.then.i.i.i138, !prof !259

if.then.i.i.i138:                                 ; preds = %if.end.i135
  %inv_weight.i.i.i.i136 = getelementptr inbounds %struct.load_weight, ptr %left.0, i32 0, i32 1
  %49 = ptrtoint ptr %inv_weight.i.i.i.i136 to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load i32, ptr %inv_weight.i.i.i.i136, align 4
  %tobool.not.i33.i.i.i137 = icmp eq i32 %50, 0
  br i1 %tobool.not.i33.i.i.i137, label %if.end.i.i.i.i140, label %__update_inv_weight.exit.i.i.i149, !prof !260

if.end.i.i.i.i140:                                ; preds = %if.then.i.i.i138
  %tobool3.not.i.i.i.i139 = icmp eq i32 %48, 0
  br i1 %tobool3.not.i.i.i.i139, label %if.end15.i.i.i.i144, label %if.else.i.i.i.i142, !prof !260

if.else.i.i.i.i142:                               ; preds = %if.end.i.i.i.i140
  %div.i.i.i.i141 = udiv i32 -1, %48
  br label %if.end15.i.i.i.i144

if.end15.i.i.i.i144:                              ; preds = %if.else.i.i.i.i142, %if.end.i.i.i.i140
  %storemerge.i.i.i.i143 = phi i32 [ %div.i.i.i.i141, %if.else.i.i.i.i142 ], [ -1, %if.end.i.i.i.i140 ]
  %51 = ptrtoint ptr %inv_weight.i.i.i.i136 to i32
  call void @__asan_store4_noabort(i32 %51)
  store i32 %storemerge.i.i.i.i143, ptr %inv_weight.i.i.i.i136, align 4
  br label %__update_inv_weight.exit.i.i.i149

__update_inv_weight.exit.i.i.i149:                ; preds = %if.end15.i.i.i.i144, %if.then.i.i.i138
  %52 = phi i32 [ %storemerge.i.i.i.i143, %if.end15.i.i.i.i144 ], [ %50, %if.then.i.i.i138 ]
  %conv1.i.i.i.i145 = zext i32 %52 to i64
  %mul.i.i.i.i146 = shl nuw nsw i64 %conv1.i.i.i.i145, 10
  %tobool9.not.i.i.i147 = icmp ult i32 %52, 4194304
  %extract.t32.i.i.i148 = trunc i64 %mul.i.i.i.i146 to i32
  br i1 %tobool9.not.i.i.i147, label %__calc_delta.exit.i.i163, label %if.then10.i.i.i155

if.then10.i.i.i155:                               ; preds = %__update_inv_weight.exit.i.i.i149
  %shr7.i.i.i150 = lshr i32 %52, 22
  %53 = tail call i32 @llvm.ctlz.i32(i32 %shr7.i.i.i150, i1 true) #20, !range !258
  %sub.i.i.i.i151 = sub nuw nsw i32 32, %53
  %sh_prom13.i.i.i152 = zext i32 %sub.i.i.i.i151 to i64
  %shr14.i.i.i153 = lshr i64 %mul.i.i.i.i146, %sh_prom13.i.i.i152
  %extract.t.i.i.i154 = trunc i64 %shr14.i.i.i153 to i32
  br label %__calc_delta.exit.i.i163

__calc_delta.exit.i.i163:                         ; preds = %if.then10.i.i.i155, %__update_inv_weight.exit.i.i.i149
  %fact.1.off0.i.i.i156 = phi i32 [ %extract.t.i.i.i154, %if.then10.i.i.i155 ], [ %extract.t32.i.i.i148, %__update_inv_weight.exit.i.i.i149 ]
  %shift.1.i.i.i157 = phi i32 [ %53, %if.then10.i.i.i155 ], [ 32, %__update_inv_weight.exit.i.i.i149 ]
  %conv1.i.i.i.i.i158 = zext i32 %fact.1.off0.i.i.i156 to i64
  %mul.i.i.i.i.i159 = mul nuw i64 %conv1.i.i.i.i.i158, %conv.i.i133
  %sh_prom.i.i.i.i160 = zext i32 %shift.1.i.i.i157 to i64
  %shr2.i.i.i.i161 = lshr i64 %mul.i.i.i.i.i159, %sh_prom.i.i.i.i160
  %.pre.i162 = and i64 %shr2.i.i.i.i161, 4294967295
  br label %wakeup_preempt_entity.exit169

wakeup_preempt_entity.exit169:                    ; preds = %__calc_delta.exit.i.i163, %if.end.i135
  %conv.pre-phi.i164 = phi i64 [ %conv.i.i133, %if.end.i135 ], [ %.pre.i162, %__calc_delta.exit.i.i163 ]
  %cmp2.i165 = icmp ugt i64 %sub.i131, %conv.pre-phi.i164
  br i1 %cmp2.i165, label %if.end42, label %if.then39

if.then39:                                        ; preds = %wakeup_preempt_entity.exit169, %land.lhs.true35
  %54 = ptrtoint ptr %last to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load ptr, ptr %last, align 16
  br label %if.end42

if.end42:                                         ; preds = %if.then39, %wakeup_preempt_entity.exit169, %if.else33, %if.then31
  %se.2 = phi ptr [ %39, %if.then31 ], [ %55, %if.then39 ], [ %se.1, %wakeup_preempt_entity.exit169 ], [ %se.1, %if.else33 ]
  ret ptr %se.2
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @put_prev_entity(ptr noundef %cfs_rq, ptr noundef %prev) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %on_rq = getelementptr inbounds %struct.sched_entity, ptr %prev, i32 0, i32 3
  %0 = ptrtoint ptr %on_rq to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %on_rq, align 4
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call fastcc void @update_curr(ptr noundef %cfs_rq)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@put_prev_entity, %if.end.i)) #20
          to label %check_cfs_rq_runtime.exit [label %if.end.i], !srcloc !261

if.end.i:                                         ; preds = %if.end
  %runtime_enabled.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 32
  %2 = ptrtoint ptr %runtime_enabled.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %runtime_enabled.i, align 4
  %tobool.not.i = icmp eq i32 %3, 0
  br i1 %tobool.not.i, label %check_cfs_rq_runtime.exit, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %if.end.i
  %runtime_remaining.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 33
  %4 = ptrtoint ptr %runtime_remaining.i to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %runtime_remaining.i, align 8
  %cmp.i = icmp sgt i64 %5, 0
  br i1 %cmp.i, label %check_cfs_rq_runtime.exit, label %if.end4.i, !prof !259

if.end4.i:                                        ; preds = %lor.rhs.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@put_prev_entity, %land.rhs.i.i)) #20
          to label %if.end8.i [label %land.rhs.i.i], !srcloc !261

land.rhs.i.i:                                     ; preds = %if.end4.i
  %throttled.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 37
  %6 = ptrtoint ptr %throttled.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %throttled.i.i, align 8
  %tobool.i.not.i = icmp eq i32 %7, 0
  br i1 %tobool.i.not.i, label %if.end8.i, label %check_cfs_rq_runtime.exit

if.end8.i:                                        ; preds = %land.rhs.i.i, %if.end4.i
  %call9.i = tail call fastcc zeroext i1 @throttle_cfs_rq(ptr noundef %cfs_rq) #20
  br label %check_cfs_rq_runtime.exit

check_cfs_rq_runtime.exit:                        ; preds = %if.end8.i, %land.rhs.i.i, %lor.rhs.i, %if.end.i, %if.end
  %vruntime.i = getelementptr inbounds %struct.sched_entity, ptr %prev, i32 0, i32 6
  %8 = ptrtoint ptr %vruntime.i to i32
  call void @__asan_load8_noabort(i32 %8)
  %9 = load i64, ptr %vruntime.i, align 16
  %min_vruntime.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 6
  %10 = ptrtoint ptr %min_vruntime.i to i32
  call void @__asan_load8_noabort(i32 %10)
  %11 = load i64, ptr %min_vruntime.i, align 32
  %sub.i = sub i64 %9, %11
  %12 = tail call i64 @llvm.abs.i64(i64 %sub.i, i1 false) #20
  %13 = load i32, ptr @sysctl_sched_latency, align 4
  %mul.i = mul i32 %13, 3
  %conv.i = zext i32 %mul.i to i64
  %cmp2.i = icmp sgt i64 %12, %conv.i
  br i1 %cmp2.i, label %do.body.i, label %check_spread.exit

do.body.i:                                        ; preds = %check_cfs_rq_runtime.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@put_prev_entity, %if.then7.i)) #20
          to label %check_spread.exit [label %if.then7.i], !srcloc !261

if.then7.i:                                       ; preds = %do.body.i
  %nr_spread_over.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 15
  %14 = ptrtoint ptr %nr_spread_over.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %nr_spread_over.i, align 8
  %inc.i = add i32 %15, 1
  store i32 %inc.i, ptr %nr_spread_over.i, align 8
  br label %check_spread.exit

check_spread.exit:                                ; preds = %if.then7.i, %do.body.i, %check_cfs_rq_runtime.exit
  %16 = ptrtoint ptr %on_rq to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %on_rq, align 4
  %tobool2.not = icmp eq i32 %17, 0
  br i1 %tobool2.not, label %if.end4, label %if.then3

if.then3:                                         ; preds = %check_spread.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@put_prev_entity, %if.end.i16)) #20
          to label %update_stats_wait_start_fair.exit [label %if.end.i16], !srcloc !261

if.end.i16:                                       ; preds = %if.then3
  %my_q.i.i = getelementptr inbounds %struct.sched_entity, ptr %prev, i32 0, i32 12
  %18 = ptrtoint ptr %my_q.i.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load ptr, ptr %my_q.i.i, align 4
  %tobool.not.i.i = icmp eq ptr %19, null
  %stats.i.i = getelementptr inbounds %struct.sched_entity_stats, ptr %prev, i32 0, i32 1
  %stats1.i.i = getelementptr i8, ptr %prev, i32 640
  %retval.0.i12.i = select i1 %tobool.not.i.i, ptr %stats1.i.i, ptr %stats.i.i
  %add.ptr.i.i = getelementptr i8, ptr %prev, i32 -128
  %spec.select.i = select i1 %tobool.not.i.i, ptr %add.ptr.i.i, ptr null
  %rq.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %20 = ptrtoint ptr %rq.i.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %rq.i.i, align 4
  tail call void @__update_stats_wait_start(ptr noundef %21, ptr noundef %spec.select.i, ptr noundef %retval.0.i12.i) #20
  br label %update_stats_wait_start_fair.exit

update_stats_wait_start_fair.exit:                ; preds = %if.end.i16, %if.then3
  %run_node.i = getelementptr inbounds %struct.sched_entity, ptr %prev, i32 0, i32 1
  %tasks_timeline.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 10
  %22 = ptrtoint ptr %tasks_timeline.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %tasks_timeline.i, align 4
  %tobool.not2.i.i = icmp eq ptr %23, null
  br i1 %tobool.not2.i.i, label %if.then.i.critedge.i.i, label %while.body.lr.ph.i.i

while.body.lr.ph.i.i:                             ; preds = %update_stats_wait_start_fair.exit
  %24 = ptrtoint ptr %vruntime.i to i32
  call void @__asan_load8_noabort(i32 %24)
  %25 = load i64, ptr %vruntime.i, align 16
  br label %while.body.i.i

while.body.i.i:                                   ; preds = %while.body.i.i, %while.body.lr.ph.i.i
  %26 = phi ptr [ %23, %while.body.lr.ph.i.i ], [ %30, %while.body.i.i ]
  %leftmost.0.off03.i.i = phi i1 [ true, %while.body.lr.ph.i.i ], [ %leftmost.1.off0.i.i, %while.body.i.i ]
  %vruntime1.i.i.i.i = getelementptr i8, ptr %26, i32 40
  %27 = ptrtoint ptr %vruntime1.i.i.i.i to i32
  call void @__asan_load8_noabort(i32 %27)
  %28 = load i64, ptr %vruntime1.i.i.i.i, align 16
  %sub.i.i.i.i = sub i64 %25, %28
  %cmp.i.i.i.i = icmp slt i64 %sub.i.i.i.i, 0
  %rb_left.i.i = getelementptr inbounds %struct.rb_node, ptr %26, i32 0, i32 2
  %rb_right.i.i = getelementptr inbounds %struct.rb_node, ptr %26, i32 0, i32 1
  %link.1.i.i = select i1 %cmp.i.i.i.i, ptr %rb_left.i.i, ptr %rb_right.i.i
  %leftmost.1.off0.i.i = select i1 %cmp.i.i.i.i, i1 %leftmost.0.off03.i.i, i1 false
  %29 = ptrtoint ptr %link.1.i.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %link.1.i.i, align 4
  %tobool.not.i.i17 = icmp eq ptr %30, null
  br i1 %tobool.not.i.i17, label %while.cond.while.end_crit_edge.i.i, label %while.body.i.i

while.cond.while.end_crit_edge.i.i:               ; preds = %while.body.i.i
  %phi.cast.le.i.i = ptrtoint ptr %26 to i32
  %31 = ptrtoint ptr %run_node.i to i32
  call void @__asan_store4_noabort(i32 %31)
  store i32 %phi.cast.le.i.i, ptr %run_node.i, align 4
  %rb_right.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %prev, i32 0, i32 1, i32 1
  %32 = ptrtoint ptr %rb_right.i.i.i to i32
  call void @__asan_store4_noabort(i32 %32)
  store ptr null, ptr %rb_right.i.i.i, align 4
  %rb_left.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %prev, i32 0, i32 1, i32 2
  %33 = ptrtoint ptr %rb_left.i.i.i to i32
  call void @__asan_store4_noabort(i32 %33)
  store ptr null, ptr %rb_left.i.i.i, align 4
  %34 = ptrtoint ptr %link.1.i.i to i32
  call void @__asan_store4_noabort(i32 %34)
  store ptr %run_node.i, ptr %link.1.i.i, align 4
  br i1 %leftmost.1.off0.i.i, label %if.then.i.i.i, label %__enqueue_entity.exit

if.then.i.critedge.i.i:                           ; preds = %update_stats_wait_start_fair.exit
  %35 = ptrtoint ptr %run_node.i to i32
  call void @__asan_store4_noabort(i32 %35)
  store i32 0, ptr %run_node.i, align 4
  %rb_right.i.c.i.i = getelementptr inbounds %struct.sched_entity, ptr %prev, i32 0, i32 1, i32 1
  %36 = ptrtoint ptr %rb_right.i.c.i.i to i32
  call void @__asan_store4_noabort(i32 %36)
  store ptr null, ptr %rb_right.i.c.i.i, align 4
  %rb_left.i.c.i.i = getelementptr inbounds %struct.sched_entity, ptr %prev, i32 0, i32 1, i32 2
  %37 = ptrtoint ptr %rb_left.i.c.i.i to i32
  call void @__asan_store4_noabort(i32 %37)
  store ptr null, ptr %rb_left.i.c.i.i, align 4
  %38 = ptrtoint ptr %tasks_timeline.i to i32
  call void @__asan_store4_noabort(i32 %38)
  store ptr %run_node.i, ptr %tasks_timeline.i, align 4
  br label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %if.then.i.critedge.i.i, %while.cond.while.end_crit_edge.i.i
  %rb_leftmost.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 10, i32 1
  %39 = ptrtoint ptr %rb_leftmost.i.i.i to i32
  call void @__asan_store4_noabort(i32 %39)
  store ptr %run_node.i, ptr %rb_leftmost.i.i.i, align 4
  br label %__enqueue_entity.exit

__enqueue_entity.exit:                            ; preds = %if.then.i.i.i, %while.cond.while.end_crit_edge.i.i
  tail call void @rb_insert_color(ptr noundef %run_node.i, ptr noundef %tasks_timeline.i) #20
  tail call fastcc void @update_load_avg(ptr noundef %cfs_rq, ptr noundef %prev, i32 noundef 0)
  br label %if.end4

if.end4:                                          ; preds = %__enqueue_entity.exit, %check_spread.exit
  %curr = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 11
  %40 = ptrtoint ptr %curr to i32
  call void @__asan_store4_noabort(i32 %40)
  store ptr null, ptr %curr, align 8
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @set_next_entity(ptr noundef %cfs_rq, ptr noundef %se) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %last.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 13
  %0 = ptrtoint ptr %last.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %last.i, align 16
  %cmp.i = icmp eq ptr %1, %se
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %entry
  %tobool.not8.i.i = icmp eq ptr %se, null
  br i1 %tobool.not8.i.i, label %clear_buddies.exit, label %for.body.i.i

for.body.i.i:                                     ; preds = %for.inc.i.i, %if.then.i
  %se.addr.09.i.i = phi ptr [ %8, %for.inc.i.i ], [ %se, %if.then.i ]
  %cfs_rq.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i.i, i32 0, i32 11
  %2 = ptrtoint ptr %cfs_rq.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %cfs_rq.i.i.i, align 16
  %last.i.i = getelementptr inbounds %struct.cfs_rq, ptr %3, i32 0, i32 13
  %4 = ptrtoint ptr %last.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %last.i.i, align 16
  %cmp.not.i.i = icmp eq ptr %5, %se.addr.09.i.i
  br i1 %cmp.not.i.i, label %for.inc.i.i, label %if.end.i

for.inc.i.i:                                      ; preds = %for.body.i.i
  %6 = ptrtoint ptr %last.i.i to i32
  call void @__asan_store4_noabort(i32 %6)
  store ptr null, ptr %last.i.i, align 16
  %parent.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i.i, i32 0, i32 10
  %7 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i = icmp eq ptr %8, null
  br i1 %tobool.not.i.i, label %if.end.i, label %for.body.i.i

if.end.i:                                         ; preds = %for.inc.i.i, %for.body.i.i, %entry
  %next.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 12
  %9 = ptrtoint ptr %next.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %next.i, align 4
  %cmp1.i = icmp ne ptr %10, %se
  %tobool.not8.i14.i = icmp eq ptr %se, null
  %or.cond.i = or i1 %tobool.not8.i14.i, %cmp1.i
  br i1 %or.cond.i, label %if.end3.i, label %for.body.i18.i

for.body.i18.i:                                   ; preds = %for.inc.i21.i, %if.end.i
  %se.addr.09.i15.i = phi ptr [ %17, %for.inc.i21.i ], [ %se, %if.end.i ]
  %cfs_rq.i.i16.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i15.i, i32 0, i32 11
  %11 = ptrtoint ptr %cfs_rq.i.i16.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %cfs_rq.i.i16.i, align 16
  %next.i.i = getelementptr inbounds %struct.cfs_rq, ptr %12, i32 0, i32 12
  %13 = ptrtoint ptr %next.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %next.i.i, align 4
  %cmp.not.i17.i = icmp eq ptr %14, %se.addr.09.i15.i
  br i1 %cmp.not.i17.i, label %for.inc.i21.i, label %if.end3.i

for.inc.i21.i:                                    ; preds = %for.body.i18.i
  %15 = ptrtoint ptr %next.i.i to i32
  call void @__asan_store4_noabort(i32 %15)
  store ptr null, ptr %next.i.i, align 4
  %parent.i19.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i15.i, i32 0, i32 10
  %16 = ptrtoint ptr %parent.i19.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %parent.i19.i, align 4
  %tobool.not.i20.i = icmp eq ptr %17, null
  br i1 %tobool.not.i20.i, label %if.end3.i, label %for.body.i18.i

if.end3.i:                                        ; preds = %for.inc.i21.i, %for.body.i18.i, %if.end.i
  %skip.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 14
  %18 = ptrtoint ptr %skip.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load ptr, ptr %skip.i, align 4
  %cmp4.i = icmp ne ptr %19, %se
  %or.cond33.i = or i1 %tobool.not8.i14.i, %cmp4.i
  br i1 %or.cond33.i, label %clear_buddies.exit, label %for.body.i26.i

for.body.i26.i:                                   ; preds = %for.inc.i29.i, %if.end3.i
  %se.addr.09.i23.i = phi ptr [ %26, %for.inc.i29.i ], [ %se, %if.end3.i ]
  %cfs_rq.i.i24.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i23.i, i32 0, i32 11
  %20 = ptrtoint ptr %cfs_rq.i.i24.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %cfs_rq.i.i24.i, align 16
  %skip.i.i = getelementptr inbounds %struct.cfs_rq, ptr %21, i32 0, i32 14
  %22 = ptrtoint ptr %skip.i.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %skip.i.i, align 4
  %cmp.not.i25.i = icmp eq ptr %23, %se.addr.09.i23.i
  br i1 %cmp.not.i25.i, label %for.inc.i29.i, label %clear_buddies.exit

for.inc.i29.i:                                    ; preds = %for.body.i26.i
  %24 = ptrtoint ptr %skip.i.i to i32
  call void @__asan_store4_noabort(i32 %24)
  store ptr null, ptr %skip.i.i, align 4
  %parent.i27.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i23.i, i32 0, i32 10
  %25 = ptrtoint ptr %parent.i27.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load ptr, ptr %parent.i27.i, align 4
  %tobool.not.i28.i = icmp eq ptr %26, null
  br i1 %tobool.not.i28.i, label %clear_buddies.exit, label %for.body.i26.i

clear_buddies.exit:                               ; preds = %for.inc.i29.i, %for.body.i26.i, %if.end3.i, %if.then.i
  %on_rq = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 3
  %27 = ptrtoint ptr %on_rq to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load i32, ptr %on_rq, align 4
  %tobool.not = icmp eq i32 %28, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %clear_buddies.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@set_next_entity, %if.end.i37)) #20
          to label %update_stats_wait_end_fair.exit [label %if.end.i37], !srcloc !261

if.end.i37:                                       ; preds = %if.then
  %my_q.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 12
  %29 = ptrtoint ptr %my_q.i.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %my_q.i.i, align 4
  %tobool.not.i.i36 = icmp eq ptr %30, null
  %stats.i.i = getelementptr inbounds %struct.sched_entity_stats, ptr %se, i32 0, i32 1
  %stats1.i.i = getelementptr i8, ptr %se, i32 640
  %retval.0.i24.i = select i1 %tobool.not.i.i36, ptr %stats1.i.i, ptr %stats.i.i
  %31 = ptrtoint ptr %retval.0.i24.i to i32
  call void @__asan_load8_noabort(i32 %31)
  %32 = load i64, ptr %retval.0.i24.i, align 128
  %tobool4.not.i = icmp eq i64 %32, 0
  br i1 %tobool4.not.i, label %update_stats_wait_end_fair.exit, label %if.end14.i, !prof !260

if.end14.i:                                       ; preds = %if.end.i37
  %add.ptr.i.i = getelementptr i8, ptr %se, i32 -128
  %spec.select.i = select i1 %tobool.not.i.i36, ptr %add.ptr.i.i, ptr null
  %rq.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %33 = ptrtoint ptr %rq.i.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load ptr, ptr %rq.i.i, align 4
  tail call void @__update_stats_wait_end(ptr noundef %34, ptr noundef %spec.select.i, ptr noundef %retval.0.i24.i) #20
  br label %update_stats_wait_end_fair.exit

update_stats_wait_end_fair.exit:                  ; preds = %if.end14.i, %if.end.i37, %if.then
  %run_node.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 1
  %rb_leftmost.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 10, i32 1
  %35 = ptrtoint ptr %rb_leftmost.i.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load ptr, ptr %rb_leftmost.i.i, align 4
  %cmp.i.i = icmp eq ptr %36, %run_node.i
  br i1 %cmp.i.i, label %if.then.i.i, label %__dequeue_entity.exit

if.then.i.i:                                      ; preds = %update_stats_wait_end_fair.exit
  %call.i.i = tail call ptr @rb_next(ptr noundef %run_node.i) #20
  %37 = ptrtoint ptr %rb_leftmost.i.i to i32
  call void @__asan_store4_noabort(i32 %37)
  store ptr %call.i.i, ptr %rb_leftmost.i.i, align 4
  br label %__dequeue_entity.exit

__dequeue_entity.exit:                            ; preds = %if.then.i.i, %update_stats_wait_end_fair.exit
  %tasks_timeline.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 10
  tail call void @rb_erase(ptr noundef %run_node.i, ptr noundef %tasks_timeline.i) #20
  tail call fastcc void @update_load_avg(ptr noundef %cfs_rq, ptr noundef %se, i32 noundef 1)
  br label %if.end

if.end:                                           ; preds = %__dequeue_entity.exit, %clear_buddies.exit
  %rq.i.i38 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %38 = ptrtoint ptr %rq.i.i38 to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load ptr, ptr %rq.i.i38, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %40 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i.i = icmp eq i32 %40, 0
  br i1 %tobool.not.i.i.i, label %lockdep_assert_rq_held.exit.i.i, label %land.rhs.i.i.i

land.rhs.i.i.i:                                   ; preds = %if.end
  %core_enabled.i.i.i.i = getelementptr inbounds %struct.rq, ptr %39, i32 0, i32 81
  %41 = ptrtoint ptr %core_enabled.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load i32, ptr %core_enabled.i.i.i.i, align 128
  %tobool.not.i.i.i.i = icmp eq i32 %42, 0
  br i1 %tobool.not.i.i.i.i, label %__rq_lockp.exit.i.i.i, label %if.then.i.i.i.i

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i
  %core.i.i.i.i = getelementptr inbounds %struct.rq, ptr %39, i32 0, i32 79
  %43 = ptrtoint ptr %core.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load ptr, ptr %core.i.i.i.i, align 8
  br label %__rq_lockp.exit.i.i.i

__rq_lockp.exit.i.i.i:                            ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i
  %retval.0.i.i.i.i = phi ptr [ %44, %if.then.i.i.i.i ], [ %39, %land.rhs.i.i.i ]
  %dep_map.i.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i.i, i32 0, i32 4
  %call.i.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i.i, i32 noundef -1) #20
  %cmp.not.i.i.i = icmp eq i32 %call.i.i.i.i, 0
  br i1 %cmp.not.i.i.i, label %do.end.i.i.i, label %lockdep_assert_rq_held.exit.i.i, !prof !260

do.end.i.i.i:                                     ; preds = %__rq_lockp.exit.i.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i.i

lockdep_assert_rq_held.exit.i.i:                  ; preds = %do.end.i.i.i, %__rq_lockp.exit.i.i.i, %if.end
  %clock_update_flags.i.i.i = getelementptr inbounds %struct.rq, ptr %39, i32 0, i32 25
  %45 = ptrtoint ptr %clock_update_flags.i.i.i to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load i32, ptr %clock_update_flags.i.i.i, align 4
  %cmp.i.i.i = icmp ult i32 %46, 2
  br i1 %cmp.i.i.i, label %land.rhs.i3.i.i, label %update_stats_curr_start.exit

land.rhs.i3.i.i:                                  ; preds = %lockdep_assert_rq_held.exit.i.i
  %.b37.i.i.i = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i.i, label %update_stats_curr_start.exit, label %if.then.i.i.i, !prof !259

if.then.i.i.i:                                    ; preds = %land.rhs.i3.i.i
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %update_stats_curr_start.exit

update_stats_curr_start.exit:                     ; preds = %if.then.i.i.i, %land.rhs.i3.i.i, %lockdep_assert_rq_held.exit.i.i
  %clock_task.i.i = getelementptr inbounds %struct.rq, ptr %39, i32 0, i32 28
  %47 = ptrtoint ptr %clock_task.i.i to i32
  call void @__asan_load8_noabort(i32 %47)
  %48 = load i64, ptr %clock_task.i.i, align 128
  %exec_start.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 4
  %49 = ptrtoint ptr %exec_start.i to i32
  call void @__asan_store8_noabort(i32 %49)
  store i64 %48, ptr %exec_start.i, align 32
  %curr = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 11
  %50 = ptrtoint ptr %curr to i32
  call void @__asan_store4_noabort(i32 %50)
  store ptr %se, ptr %curr, align 8
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@set_next_entity, %land.lhs.true)) #20
          to label %if.end12 [label %land.lhs.true], !srcloc !261

land.lhs.true:                                    ; preds = %update_stats_curr_start.exit
  %51 = ptrtoint ptr %rq.i.i38 to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load ptr, ptr %rq.i.i38, align 4
  %cfs = getelementptr inbounds %struct.rq, ptr %52, i32 0, i32 14
  %53 = ptrtoint ptr %cfs to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load i32, ptr %cfs, align 128
  %55 = ptrtoint ptr %se to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load i32, ptr %se, align 128
  %mul = shl i32 %56, 1
  %cmp.not = icmp ult i32 %54, %mul
  br i1 %cmp.not, label %if.end12, label %if.then7

if.then7:                                         ; preds = %land.lhs.true
  %my_q.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 12
  %57 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i = icmp eq ptr %58, null
  %stats.i = getelementptr inbounds %struct.sched_entity_stats, ptr %se, i32 0, i32 1
  %stats1.i = getelementptr i8, ptr %se, i32 640
  %retval.0.i39 = select i1 %tobool.not.i, ptr %stats1.i, ptr %stats.i
  %slice_max = getelementptr inbounds %struct.sched_statistics, ptr %retval.0.i39, i32 0, i32 13
  %59 = ptrtoint ptr %slice_max to i32
  call void @__asan_load8_noabort(i32 %59)
  %60 = load i64, ptr %slice_max, align 8
  %sum_exec_runtime = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 5
  %61 = ptrtoint ptr %sum_exec_runtime to i32
  call void @__asan_load8_noabort(i32 %61)
  %62 = load i64, ptr %sum_exec_runtime, align 8
  %prev_sum_exec_runtime = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 7
  %63 = ptrtoint ptr %prev_sum_exec_runtime to i32
  call void @__asan_load8_noabort(i32 %63)
  %64 = load i64, ptr %prev_sum_exec_runtime, align 8
  %sub = sub i64 %62, %64
  %65 = tail call i64 @llvm.umax.i64(i64 %60, i64 %sub)
  %66 = ptrtoint ptr %slice_max to i32
  call void @__asan_store8_noabort(i32 %66)
  store i64 %65, ptr %slice_max, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then7, %land.lhs.true, %update_stats_curr_start.exit
  %sum_exec_runtime13 = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 5
  %67 = ptrtoint ptr %sum_exec_runtime13 to i32
  call void @__asan_load8_noabort(i32 %67)
  %68 = load i64, ptr %sum_exec_runtime13, align 8
  %prev_sum_exec_runtime14 = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 7
  %69 = ptrtoint ptr %prev_sum_exec_runtime14 to i32
  call void @__asan_store8_noabort(i32 %69)
  store i64 %68, ptr %prev_sum_exec_runtime14, align 8
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @hrtick_start_fair(ptr noundef %rq, ptr noundef %p) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %se1 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %cfs_rq.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %0 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %cfs_rq.i, align 16
  %stack.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 1
  %2 = ptrtoint ptr %stack.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %stack.i, align 4
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %3, i32 0, i32 3
  %4 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %cpu.i, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %5
  %6 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %arrayidx, align 4
  %add = add i32 %7, ptrtoint (ptr @runqueues to i32)
  %8 = inttoptr i32 %add to ptr
  %cmp.not = icmp eq ptr %8, %rq
  br i1 %cmp.not, label %if.end34, label %land.rhs

land.rhs:                                         ; preds = %entry
  %.b72 = load i1, ptr @hrtick_start_fair.__already_done, align 1
  br i1 %.b72, label %if.end34, label %if.then, !prof !259

if.then:                                          ; preds = %land.rhs
  store i1 true, ptr @hrtick_start_fair.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 5503, i32 noundef 9, ptr noundef nonnull @.str.32) #20
  br label %if.end34

if.end34:                                         ; preds = %if.then, %land.rhs, %entry
  %h_nr_running = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 14, i32 2
  %9 = ptrtoint ptr %h_nr_running to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %h_nr_running, align 4
  %cmp42 = icmp ugt i32 %10, 1
  br i1 %cmp42, label %if.then43, label %cleanup56

if.then43:                                        ; preds = %if.end34
  %call44 = tail call fastcc i64 @sched_slice(ptr noundef %1, ptr noundef %se1)
  %sum_exec_runtime = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 5
  %11 = ptrtoint ptr %sum_exec_runtime to i32
  call void @__asan_load8_noabort(i32 %11)
  %12 = load i64, ptr %sum_exec_runtime, align 8
  %prev_sum_exec_runtime = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 7
  %13 = ptrtoint ptr %prev_sum_exec_runtime to i32
  call void @__asan_load8_noabort(i32 %13)
  %14 = load i64, ptr %prev_sum_exec_runtime, align 8
  %sub.neg = sub i64 %14, %12
  %sub45 = add i64 %sub.neg, %call44
  %cmp46 = icmp slt i64 %sub45, 0
  br i1 %cmp46, label %if.then47, label %if.end52

if.then47:                                        ; preds = %if.then43
  %curr.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 20
  %15 = ptrtoint ptr %curr.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %curr.i, align 8
  %cmp.i.not = icmp eq ptr %16, %p
  br i1 %cmp.i.not, label %if.then50, label %cleanup56

if.then50:                                        ; preds = %if.then47
  tail call void @resched_curr(ptr noundef %rq) #20
  br label %cleanup56

if.end52:                                         ; preds = %if.then43
  tail call void @hrtick_start(ptr noundef %rq, i64 noundef %sub45) #20
  br label %cleanup56

cleanup56:                                        ; preds = %if.end52, %if.then50, %if.then47, %if.end34
  ret void
}

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @update_misfit_status(ptr noundef %p, ptr nocapture noundef %rq) unnamed_addr #7 align 64 {
entry:
  %ue.sroa.0.i.i.i.i = alloca i32, align 8
  %ue.sroa.5.i.i.i.i = alloca i32, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_asym_cpucapacity, ptr blockaddress(@update_misfit_status, %if.end)) #20
          to label %return [label %if.end], !srcloc !261

if.end:                                           ; preds = %entry
  %tobool3.not = icmp eq ptr %p, null
  br i1 %tobool3.not, label %return.sink.split, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %nr_cpus_allowed = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 32
  %0 = ptrtoint ptr %nr_cpus_allowed to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %nr_cpus_allowed, align 8
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %return.sink.split, label %if.end5

if.end5:                                          ; preds = %lor.lhs.false
  %cpu.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 46
  %2 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu.i, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %3
  %4 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %5, ptrtoint (ptr @runqueues to i32)
  %6 = inttoptr i32 %add.i to ptr
  %cpu_capacity.i = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 37
  %7 = ptrtoint ptr %cpu_capacity.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %cpu_capacity.i, align 16
  %util_avg.i.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 7
  %9 = ptrtoint ptr %util_avg.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load volatile i32, ptr %util_avg.i.i.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.0.i.i.i.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.5.i.i.i.i)
  %util_est.i.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9
  %11 = ptrtoint ptr %util_est.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %ue.sroa.0.0.copyload.i.i.i.i = load volatile i32, ptr %util_est.i.i.i.i, align 16
  %12 = ptrtoint ptr %ue.sroa.0.i.i.i.i to i32
  call void @__asan_store4_noabort(i32 %12)
  store volatile i32 %ue.sroa.0.0.copyload.i.i.i.i, ptr %ue.sroa.0.i.i.i.i, align 8
  %ue.sroa.5.0.util_est.sroa_idx.i.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9, i32 1
  %13 = ptrtoint ptr %ue.sroa.5.0.util_est.sroa_idx.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %ue.sroa.5.0.copyload.i.i.i.i = load volatile i32, ptr %ue.sroa.5.0.util_est.sroa_idx.i.i.i.i, align 4
  %14 = ptrtoint ptr %ue.sroa.5.i.i.i.i to i32
  call void @__asan_store4_noabort(i32 %14)
  store volatile i32 %ue.sroa.5.0.copyload.i.i.i.i, ptr %ue.sroa.5.i.i.i.i, align 4
  %and.i.i.i.i = and i32 %ue.sroa.0.0.copyload.i.i.i.i, 2147483647
  %15 = tail call i32 @llvm.umax.i32(i32 %ue.sroa.5.0.copyload.i.i.i.i, i32 %and.i.i.i.i) #20
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.0.i.i.i.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.5.i.i.i.i)
  %16 = tail call i32 @llvm.umax.i32(i32 %10, i32 %15) #20
  %call1.i.i = tail call i32 @uclamp_eff_value(ptr noundef nonnull %p, i32 noundef 0) #20
  %17 = tail call i32 @llvm.umax.i32(i32 %16, i32 %call1.i.i) #20
  %call2.i.i = tail call i32 @uclamp_eff_value(ptr noundef nonnull %p, i32 noundef 1) #20
  %18 = tail call i32 @llvm.umin.i32(i32 %17, i32 %call2.i.i) #20
  %mul.i = mul i32 %18, 1280
  %mul1.i = shl i32 %8, 10
  %cmp.i.not = icmp ult i32 %mul.i, %mul1.i
  br i1 %cmp.i.not, label %return.sink.split, label %if.end12

if.end12:                                         ; preds = %if.end5
  %cfs_rq.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %19 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %cfs_rq.i.i, align 16
  %rq.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %20, i32 0, i32 27
  %21 = ptrtoint ptr %rq.i.i.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %rq.i.i.i, align 4
  %tg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %20, i32 0, i32 30
  %23 = ptrtoint ptr %tg.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %tg.i.i, align 4
  %se1.i.i = getelementptr inbounds %struct.task_group, ptr %24, i32 0, i32 1
  %25 = ptrtoint ptr %se1.i.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load ptr, ptr %se1.i.i, align 8
  %cpu.i.i.i = getelementptr inbounds %struct.rq, ptr %22, i32 0, i32 46
  %27 = ptrtoint ptr %cpu.i.i.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load i32, ptr %cpu.i.i.i, align 4
  %arrayidx.i.i = getelementptr ptr, ptr %26, i32 %28
  %29 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %arrayidx.i.i, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %31 = load volatile i32, ptr @jiffies, align 128
  %last_h_load_update.i.i = getelementptr inbounds %struct.cfs_rq, ptr %20, i32 0, i32 25
  %32 = ptrtoint ptr %last_h_load_update.i.i to i32
  call void @__asan_load8_noabort(i32 %32)
  %33 = load i64, ptr %last_h_load_update.i.i, align 16
  %conv.i.i = zext i32 %31 to i64
  %cmp.i.i = icmp eq i64 %33, %conv.i.i
  br i1 %cmp.i.i, label %task_h_load.exit, label %do.body5.i.i

do.body5.i.i:                                     ; preds = %if.end12
  %h_load_next.i.i = getelementptr inbounds %struct.cfs_rq, ptr %20, i32 0, i32 26
  %34 = ptrtoint ptr %h_load_next.i.i to i32
  call void @__asan_store4_noabort(i32 %34)
  store volatile ptr null, ptr %h_load_next.i.i, align 8
  %tobool.not82.i.i = icmp eq ptr %30, null
  br i1 %tobool.not82.i.i, label %if.then28.i.i, label %for.body.i.i

for.body.i.i:                                     ; preds = %for.inc.i.i, %do.body5.i.i
  %se.083.i.i = phi ptr [ %41, %for.inc.i.i ], [ %30, %do.body5.i.i ]
  %cfs_rq.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.083.i.i, i32 0, i32 11
  %35 = ptrtoint ptr %cfs_rq.i.i.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load ptr, ptr %cfs_rq.i.i.i, align 16
  %h_load_next16.i.i = getelementptr inbounds %struct.cfs_rq, ptr %36, i32 0, i32 26
  %37 = ptrtoint ptr %h_load_next16.i.i to i32
  call void @__asan_store4_noabort(i32 %37)
  store volatile ptr %se.083.i.i, ptr %h_load_next16.i.i, align 8
  %last_h_load_update21.i.i = getelementptr inbounds %struct.cfs_rq, ptr %36, i32 0, i32 25
  %38 = ptrtoint ptr %last_h_load_update21.i.i to i32
  call void @__asan_load8_noabort(i32 %38)
  %39 = load i64, ptr %last_h_load_update21.i.i, align 16
  %cmp23.i.i = icmp eq i64 %39, %conv.i.i
  br i1 %cmp23.i.i, label %if.end32.i.i, label %for.inc.i.i

for.inc.i.i:                                      ; preds = %for.body.i.i
  %parent.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.083.i.i, i32 0, i32 10
  %40 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i = icmp eq ptr %41, null
  br i1 %tobool.not.i.i, label %if.then28.i.i, label %for.body.i.i

if.then28.i.i:                                    ; preds = %for.inc.i.i, %do.body5.i.i
  %cfs_rq.addr.0.lcssa.i.i = phi ptr [ %20, %do.body5.i.i ], [ %36, %for.inc.i.i ]
  %load_avg.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.0.lcssa.i.i, i32 0, i32 17, i32 5
  %42 = ptrtoint ptr %load_avg.i.i.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load i32, ptr %load_avg.i.i.i, align 32
  %h_load.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.0.lcssa.i.i, i32 0, i32 24
  %44 = ptrtoint ptr %h_load.i.i to i32
  call void @__asan_store4_noabort(i32 %44)
  store i32 %43, ptr %h_load.i.i, align 4
  %last_h_load_update31.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.0.lcssa.i.i, i32 0, i32 25
  %45 = ptrtoint ptr %last_h_load_update31.i.i to i32
  call void @__asan_store8_noabort(i32 %45)
  store i64 %conv.i.i, ptr %last_h_load_update31.i.i, align 16
  br label %if.end32.i.i

if.end32.i.i:                                     ; preds = %if.then28.i.i, %for.body.i.i
  %cfs_rq.addr.176.i.i = phi ptr [ %cfs_rq.addr.0.lcssa.i.i, %if.then28.i.i ], [ %36, %for.body.i.i ]
  %h_load_next3684.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.176.i.i, i32 0, i32 26
  %46 = ptrtoint ptr %h_load_next3684.i.i to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load volatile ptr, ptr %h_load_next3684.i.i, align 8
  %cmp37.not85.i.i = icmp eq ptr %47, null
  br i1 %cmp37.not85.i.i, label %task_h_load.exit, label %div_u64.exit.i.i

div_u64.exit.i.i:                                 ; preds = %div_u64.exit.i.i, %if.end32.i.i
  %48 = phi ptr [ %60, %div_u64.exit.i.i ], [ %47, %if.end32.i.i ]
  %cfs_rq.addr.286.i.i = phi ptr [ %56, %div_u64.exit.i.i ], [ %cfs_rq.addr.176.i.i, %if.end32.i.i ]
  %load_avg.i.i = getelementptr inbounds %struct.sched_entity, ptr %48, i32 0, i32 15, i32 5
  %49 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load i32, ptr %load_avg.i.i, align 32
  %h_load39.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.286.i.i, i32 0, i32 24
  %51 = ptrtoint ptr %h_load39.i.i to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load i32, ptr %h_load39.i.i, align 4
  %mul.i.i = mul i32 %50, %52
  %load_avg.i74.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.286.i.i, i32 0, i32 17, i32 5
  %53 = ptrtoint ptr %load_avg.i74.i.i to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load i32, ptr %load_avg.i74.i.i, align 32
  %add.i.i = add i32 %54, 1
  %div172.i.i.i.i = udiv i32 %mul.i.i, %add.i.i
  %my_q.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %48, i32 0, i32 12
  %55 = ptrtoint ptr %my_q.i.i.i to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load ptr, ptr %my_q.i.i.i, align 4
  %h_load45.i.i = getelementptr inbounds %struct.cfs_rq, ptr %56, i32 0, i32 24
  %57 = ptrtoint ptr %h_load45.i.i to i32
  call void @__asan_store4_noabort(i32 %57)
  store i32 %div172.i.i.i.i, ptr %h_load45.i.i, align 4
  %last_h_load_update47.i.i = getelementptr inbounds %struct.cfs_rq, ptr %56, i32 0, i32 25
  %58 = ptrtoint ptr %last_h_load_update47.i.i to i32
  call void @__asan_store8_noabort(i32 %58)
  store i64 %conv.i.i, ptr %last_h_load_update47.i.i, align 16
  %h_load_next36.i.i = getelementptr inbounds %struct.cfs_rq, ptr %56, i32 0, i32 26
  %59 = ptrtoint ptr %h_load_next36.i.i to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load volatile ptr, ptr %h_load_next36.i.i, align 8
  %cmp37.not.i.i = icmp eq ptr %60, null
  br i1 %cmp37.not.i.i, label %task_h_load.exit, label %div_u64.exit.i.i

task_h_load.exit:                                 ; preds = %div_u64.exit.i.i, %if.end32.i.i, %if.end12
  %h_load.i = getelementptr inbounds %struct.cfs_rq, ptr %20, i32 0, i32 24
  %61 = ptrtoint ptr %h_load.i to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load i32, ptr %h_load.i, align 4
  %load_avg.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 5
  %63 = ptrtoint ptr %load_avg.i to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load i32, ptr %load_avg.i, align 32
  %mul.i25 = mul i32 %62, %64
  %load_avg.i7.i = getelementptr inbounds %struct.cfs_rq, ptr %20, i32 0, i32 17, i32 5
  %65 = ptrtoint ptr %load_avg.i7.i to i32
  call void @__asan_load4_noabort(i32 %65)
  %66 = load i32, ptr %load_avg.i7.i, align 32
  %add.i27 = add i32 %66, 1
  %div172.i.i.i = udiv i32 %mul.i25, %add.i27
  %67 = tail call i32 @llvm.umax.i32(i32 %div172.i.i.i, i32 1)
  br label %return.sink.split

return.sink.split:                                ; preds = %task_h_load.exit, %if.end5, %lor.lhs.false, %if.end
  %.sink = phi i32 [ %67, %task_h_load.exit ], [ 0, %lor.lhs.false ], [ 0, %if.end ], [ 0, %if.end5 ]
  %misfit_task_load16 = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 42
  %68 = ptrtoint ptr %misfit_task_load16 to i32
  call void @__asan_store4_noabort(i32 %68)
  store i32 %.sink, ptr %misfit_task_load16, align 64
  br label %return

return:                                           ; preds = %return.sink.split, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @newidle_balance(ptr noundef %this_rq, ptr nocapture noundef %rf) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %continue_balancing = alloca i32, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %0 = load volatile i32, ptr @jiffies, align 128
  %add = add i32 %0, 100
  %cpu = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 46
  %1 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %cpu, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_asym_cpucapacity, ptr blockaddress(@newidle_balance, %if.end.i)) #20
          to label %update_misfit_status.exit [label %if.end.i], !srcloc !261

if.end.i:                                         ; preds = %entry
  %misfit_task_load16.i = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 42
  %3 = ptrtoint ptr %misfit_task_load16.i to i32
  call void @__asan_store4_noabort(i32 %3)
  store i32 0, ptr %misfit_task_load16.i, align 64
  br label %update_misfit_status.exit

update_misfit_status.exit:                        ; preds = %if.end.i, %entry
  %ttwu_pending = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 8
  %4 = ptrtoint ptr %ttwu_pending to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %ttwu_pending, align 8
  %tobool.not = icmp eq i32 %5, 0
  br i1 %tobool.not, label %if.end, label %cleanup108

if.end:                                           ; preds = %update_misfit_status.exit
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %6 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i = icmp eq i32 %6, 0
  br i1 %tobool.not.i.i, label %lockdep_assert_rq_held.exit.i, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %if.end
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 81
  %7 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %8, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.rhs.i.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 79
  %9 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %land.rhs.i.i
  %retval.0.i.i.i = phi ptr [ %10, %if.then.i.i.i ], [ %this_rq, %land.rhs.i.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i, i32 noundef -1) #20
  %cmp.not.i.i = icmp eq i32 %call.i.i.i, 0
  br i1 %cmp.not.i.i, label %do.end.i.i, label %lockdep_assert_rq_held.exit.i, !prof !260

do.end.i.i:                                       ; preds = %__rq_lockp.exit.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i

lockdep_assert_rq_held.exit.i:                    ; preds = %do.end.i.i, %__rq_lockp.exit.i.i, %if.end
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 25
  %11 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %clock_update_flags.i.i, align 4
  %cmp.i.i = icmp ult i32 %12, 2
  br i1 %cmp.i.i, label %land.rhs.i3.i, label %rq_clock.exit

land.rhs.i3.i:                                    ; preds = %lockdep_assert_rq_held.exit.i
  %.b37.i.i = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i, label %rq_clock.exit, label %if.then.i.i, !prof !259

if.then.i.i:                                      ; preds = %land.rhs.i3.i
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %rq_clock.exit

rq_clock.exit:                                    ; preds = %if.then.i.i, %land.rhs.i3.i, %lockdep_assert_rq_held.exit.i
  %clock.i = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 26
  %13 = ptrtoint ptr %clock.i to i32
  call void @__asan_load8_noabort(i32 %13)
  %14 = load i64, ptr %clock.i, align 32
  %idle_stamp = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 54
  %15 = ptrtoint ptr %idle_stamp to i32
  call void @__asan_store8_noabort(i32 %15)
  store i64 %14, ptr %idle_stamp, align 128
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %16 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i = icmp ugt i32 %16, %2
  br i1 %cmp.not.i.i.i.i, label %cpu_active.exit, label %land.rhs.i.i.i.i

land.rhs.i.i.i.i:                                 ; preds = %rq_clock.exit
  %.b37.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i, label %cpu_active.exit, label %if.then.i.i.i.i, !prof !259

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_active.exit

cpu_active.exit:                                  ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i.i, %rq_clock.exit
  %div3.i.i.i = lshr i32 %2, 5
  %arrayidx.i.i.i = getelementptr i32, ptr @__cpu_active_mask, i32 %div3.i.i.i
  %17 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load volatile i32, ptr %arrayidx.i.i.i, align 4
  %and.i.i.i = and i32 %2, 31
  %19 = shl nuw i32 1, %and.i.i.i
  %20 = and i32 %18, %19
  %tobool.i.not = icmp eq i32 %20, 0
  br i1 %tobool.i.not, label %cleanup108, label %if.end3

if.end3:                                          ; preds = %cpu_active.exit
  %21 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load i32, ptr %clock_update_flags.i.i, align 4
  %cmp.i = icmp ugt i32 %22, 2
  br i1 %cmp.i, label %if.then.i179, label %if.end.i181

if.then.i179:                                     ; preds = %if.end3
  %clock_update_flags1.i = getelementptr inbounds %struct.rq_flags, ptr %rf, i32 0, i32 2
  %23 = ptrtoint ptr %clock_update_flags1.i to i32
  call void @__asan_store4_noabort(i32 %23)
  store i32 4, ptr %clock_update_flags1.i, align 4
  br label %if.end.i181

if.end.i181:                                      ; preds = %if.then.i179, %if.end3
  %core_enabled.i.i = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 81
  %24 = ptrtoint ptr %core_enabled.i.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %core_enabled.i.i, align 128
  %tobool.not.i.i180 = icmp eq i32 %25, 0
  br i1 %tobool.not.i.i180, label %rq_unpin_lock.exit, label %if.then.i.i182

if.then.i.i182:                                   ; preds = %if.end.i181
  %core.i.i = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 79
  %26 = ptrtoint ptr %core.i.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load ptr, ptr %core.i.i, align 8
  br label %rq_unpin_lock.exit

rq_unpin_lock.exit:                               ; preds = %if.then.i.i182, %if.end.i181
  %retval.0.i.i = phi ptr [ %27, %if.then.i.i182 ], [ %this_rq, %if.end.i181 ]
  %dep_map.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i, i32 0, i32 4
  %cookie.i = getelementptr inbounds %struct.rq_flags, ptr %rf, i32 0, i32 1
  %28 = ptrtoint ptr %cookie.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %.unpack.i = load i32, ptr %cookie.i, align 4
  %29 = insertvalue [1 x i32] undef, i32 %.unpack.i, 0
  tail call void @lock_unpin_lock(ptr noundef %dep_map.i, [1 x i32] %29) #20
  %30 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i = and i32 %30, -16384
  %31 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %31, i32 0, i32 1
  %32 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %33, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !268
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #20
  %call.i = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %rq_unpin_lock.exit
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 696, ptr noundef nonnull @.str.28) #20
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %rq_unpin_lock.exit
  %sd4 = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 36
  %34 = ptrtoint ptr %sd4 to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load volatile ptr, ptr %sd4, align 4
  %call.i183 = tail call i32 @lock_is_held_type(ptr noundef getelementptr inbounds (%struct.mutex, ptr @sched_domains_mutex, i32 0, i32 5), i32 noundef -1) #20
  %tobool7.not = icmp eq i32 %call.i183, 0
  br i1 %tobool7.not, label %lor.lhs.false, label %do.end17

lor.lhs.false:                                    ; preds = %rcu_read_lock.exit
  %call8 = tail call i32 @rcu_read_lock_held() #20
  %tobool9.not = icmp eq i32 %call8, 0
  br i1 %tobool9.not, label %land.lhs.true, label %do.end17

land.lhs.true:                                    ; preds = %lor.lhs.false
  %call10 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool11.not = icmp eq i32 %call10, 0
  br i1 %tobool11.not, label %do.end17, label %land.lhs.true12

land.lhs.true12:                                  ; preds = %land.lhs.true
  %.b165 = load i1, ptr @newidle_balance.__warned, align 1
  br i1 %.b165, label %do.end17, label %if.then14

if.then14:                                        ; preds = %land.lhs.true12
  store i1 true, ptr @newidle_balance.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 10885, ptr noundef nonnull @.str.16) #20
  br label %do.end17

do.end17:                                         ; preds = %if.then14, %land.lhs.true12, %land.lhs.true, %lor.lhs.false, %rcu_read_lock.exit
  %rd = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 35
  %36 = ptrtoint ptr %rd to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load ptr, ptr %rd, align 8
  %overload = getelementptr inbounds %struct.root_domain, ptr %37, i32 0, i32 5
  %38 = ptrtoint ptr %overload to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load volatile i32, ptr %overload, align 8
  %tobool23.not = icmp eq i32 %39, 0
  %tobool28.not = icmp eq ptr %35, null
  br i1 %tobool23.not, label %if.then27, label %lor.lhs.false24

lor.lhs.false24:                                  ; preds = %do.end17
  br i1 %tobool28.not, label %if.end31, label %land.lhs.true26

land.lhs.true26:                                  ; preds = %lor.lhs.false24
  %avg_idle = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 55
  %40 = ptrtoint ptr %avg_idle to i32
  call void @__asan_load8_noabort(i32 %40)
  %41 = load i64, ptr %avg_idle, align 8
  %max_newidle_lb_cost = getelementptr inbounds %struct.sched_domain, ptr %35, i32 0, i32 14
  %42 = ptrtoint ptr %max_newidle_lb_cost to i32
  call void @__asan_load8_noabort(i32 %42)
  %43 = load i64, ptr %max_newidle_lb_cost, align 8
  %cmp = icmp ult i64 %41, %43
  br i1 %cmp, label %if.else.i.i.i, label %if.end31

if.then27:                                        ; preds = %do.end17
  br i1 %tobool28.not, label %if.end30, label %if.else.i.i.i

if.else.i.i.i:                                    ; preds = %if.then27, %land.lhs.true26
  %balance_interval.i.i = getelementptr inbounds %struct.sched_domain, ptr %35, i32 0, i32 12
  %44 = ptrtoint ptr %balance_interval.i.i to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load i32, ptr %balance_interval.i.i, align 8
  %call2.i.i.i = tail call i32 @__msecs_to_jiffies(i32 noundef %45) #20
  %46 = tail call i32 @llvm.umax.i32(i32 %call2.i.i.i, i32 1) #20
  %47 = load i32, ptr @max_load_balance_interval, align 4
  %48 = tail call i32 @llvm.umin.i32(i32 %46, i32 %47) #20
  %last_balance.i = getelementptr inbounds %struct.sched_domain, ptr %35, i32 0, i32 11
  %49 = ptrtoint ptr %last_balance.i to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load i32, ptr %last_balance.i, align 4
  %add.i = add i32 %50, %48
  %sub.i = sub i32 %add.i, %add
  %cmp.i186 = icmp slt i32 %sub.i, 0
  %spec.select = select i1 %cmp.i186, i32 %add.i, i32 %add
  br label %if.end30

if.end30:                                         ; preds = %if.else.i.i.i, %if.then27
  %next_balance.1 = phi i32 [ %add, %if.then27 ], [ %spec.select, %if.else.i.i.i ]
  %call.i189 = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i189, label %rcu_read_unlock.exit, label %land.lhs.true.i192

land.lhs.true.i192:                               ; preds = %if.end30
  %call1.i190 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i191 = icmp eq i32 %call1.i190, 0
  br i1 %tobool.not.i191, label %rcu_read_unlock.exit, label %land.lhs.true2.i194

land.lhs.true2.i194:                              ; preds = %land.lhs.true.i192
  %.b4.i193 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i193, label %rcu_read_unlock.exit, label %if.then.i195

if.then.i195:                                     ; preds = %land.lhs.true2.i194
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i195, %land.lhs.true2.i194, %land.lhs.true.i192, %if.end30
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %51 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i196 = and i32 %51, -16384
  %52 = inttoptr i32 %and.i.i.i.i.i196 to ptr
  %preempt_count.i.i.i.i197 = getelementptr inbounds %struct.thread_info, ptr %52, i32 0, i32 1
  %53 = ptrtoint ptr %preempt_count.i.i.i.i197 to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load volatile i32, ptr %preempt_count.i.i.i.i197, align 4
  %sub.i.i.i = add i32 %54, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i197, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  br label %out

if.end31:                                         ; preds = %land.lhs.true26, %lor.lhs.false24
  %call.i198 = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i198, label %rcu_read_unlock.exit208, label %land.lhs.true.i201

land.lhs.true.i201:                               ; preds = %if.end31
  %call1.i199 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i200 = icmp eq i32 %call1.i199, 0
  br i1 %tobool.not.i200, label %rcu_read_unlock.exit208, label %land.lhs.true2.i203

land.lhs.true2.i203:                              ; preds = %land.lhs.true.i201
  %.b4.i202 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i202, label %rcu_read_unlock.exit208, label %if.then.i204

if.then.i204:                                     ; preds = %land.lhs.true2.i203
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %rcu_read_unlock.exit208

rcu_read_unlock.exit208:                          ; preds = %if.then.i204, %land.lhs.true2.i203, %land.lhs.true.i201, %if.end31
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %55 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i205 = and i32 %55, -16384
  %56 = inttoptr i32 %and.i.i.i.i.i205 to ptr
  %preempt_count.i.i.i.i206 = getelementptr inbounds %struct.thread_info, ptr %56, i32 0, i32 1
  %57 = ptrtoint ptr %preempt_count.i.i.i.i206 to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load volatile i32, ptr %preempt_count.i.i.i.i206, align 4
  %sub.i.i.i207 = add i32 %58, -1
  store volatile i32 %sub.i.i.i207, ptr %preempt_count.i.i.i.i206, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  tail call void @raw_spin_rq_unlock(ptr noundef %this_rq) #20
  %call32 = tail call i64 @sched_clock_cpu(i32 noundef %2) #20
  tail call fastcc void @update_blocked_averages(i32 noundef %2)
  %59 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i168 = and i32 %59, -16384
  %60 = inttoptr i32 %and.i.i.i.i.i168 to ptr
  %preempt_count.i.i.i.i169 = getelementptr inbounds %struct.thread_info, ptr %60, i32 0, i32 1
  %61 = ptrtoint ptr %preempt_count.i.i.i.i169 to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load volatile i32, ptr %preempt_count.i.i.i.i169, align 4
  %add.i.i.i170 = add i32 %62, 1
  store volatile i32 %add.i.i.i170, ptr %preempt_count.i.i.i.i169, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !268
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #20
  %call.i171 = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i171, label %rcu_read_lock.exit178, label %land.lhs.true.i174

land.lhs.true.i174:                               ; preds = %rcu_read_unlock.exit208
  %call1.i172 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i173 = icmp eq i32 %call1.i172, 0
  br i1 %tobool.not.i173, label %rcu_read_lock.exit178, label %land.lhs.true2.i176

land.lhs.true2.i176:                              ; preds = %land.lhs.true.i174
  %.b4.i175 = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i175, label %rcu_read_lock.exit178, label %if.then.i177

if.then.i177:                                     ; preds = %land.lhs.true2.i176
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 696, ptr noundef nonnull @.str.28) #20
  br label %rcu_read_lock.exit178

rcu_read_lock.exit178:                            ; preds = %if.then.i177, %land.lhs.true2.i176, %land.lhs.true.i174, %rcu_read_unlock.exit208
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %2
  %63 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load i32, ptr %arrayidx, align 4
  %add42 = add i32 %64, ptrtoint (ptr @runqueues to i32)
  %65 = inttoptr i32 %add42 to ptr
  %sd43 = getelementptr inbounds %struct.rq, ptr %65, i32 0, i32 36
  %66 = ptrtoint ptr %sd43 to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load volatile ptr, ptr %sd43, align 4
  %call.i209 = tail call i32 @lock_is_held_type(ptr noundef getelementptr inbounds (%struct.mutex, ptr @sched_domains_mutex, i32 0, i32 5), i32 noundef -1) #20
  %tobool46.not = icmp eq i32 %call.i209, 0
  br i1 %tobool46.not, label %lor.lhs.false47, label %do.end58

lor.lhs.false47:                                  ; preds = %rcu_read_lock.exit178
  %call48 = tail call i32 @rcu_read_lock_held() #20
  %tobool49.not = icmp eq i32 %call48, 0
  br i1 %tobool49.not, label %land.lhs.true50, label %do.end58

land.lhs.true50:                                  ; preds = %lor.lhs.false47
  %call51 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool52.not = icmp eq i32 %call51, 0
  br i1 %tobool52.not, label %do.end58, label %land.lhs.true53

land.lhs.true53:                                  ; preds = %land.lhs.true50
  %.b163164 = load i1, ptr @newidle_balance.__warned.36, align 1
  br i1 %.b163164, label %do.end58, label %if.then55

if.then55:                                        ; preds = %land.lhs.true53
  store i1 true, ptr @newidle_balance.__warned.36, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 10904, ptr noundef nonnull @.str.16) #20
  br label %do.end58

do.end58:                                         ; preds = %if.then55, %land.lhs.true53, %land.lhs.true50, %lor.lhs.false47, %rcu_read_lock.exit178
  %tobool60.not270 = icmp eq ptr %67, null
  br i1 %tobool60.not270, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %do.end58
  %avg_idle61 = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 55
  %nr_running = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 1
  br label %for.body

for.body:                                         ; preds = %for.inc, %for.body.lr.ph
  %t0.0276 = phi i64 [ %call32, %for.body.lr.ph ], [ %t0.1284, %for.inc ]
  %curr_cost.0275 = phi i64 [ 0, %for.body.lr.ph ], [ %curr_cost.1283, %for.inc ]
  %sd.0272 = phi ptr [ %67, %for.body.lr.ph ], [ %97, %for.inc ]
  %next_balance.2271 = phi i32 [ %add, %for.body.lr.ph ], [ %spec.select267, %for.inc ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %continue_balancing) #20
  %balance_interval.i.i210 = getelementptr inbounds %struct.sched_domain, ptr %sd.0272, i32 0, i32 12
  %68 = ptrtoint ptr %balance_interval.i.i210 to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load i32, ptr %balance_interval.i.i210, align 8
  %call2.i.i.i216 = tail call i32 @__msecs_to_jiffies(i32 noundef %69) #20
  %70 = tail call i32 @llvm.umax.i32(i32 %call2.i.i.i216, i32 1) #20
  %71 = load i32, ptr @max_load_balance_interval, align 4
  %72 = tail call i32 @llvm.umin.i32(i32 %70, i32 %71) #20
  %last_balance.i219 = getelementptr inbounds %struct.sched_domain, ptr %sd.0272, i32 0, i32 11
  %73 = ptrtoint ptr %last_balance.i219 to i32
  call void @__asan_load4_noabort(i32 %73)
  %74 = load i32, ptr %last_balance.i219, align 4
  %add.i220 = add i32 %74, %72
  %sub.i221 = sub i32 %add.i220, %next_balance.2271
  %cmp.i222 = icmp slt i32 %sub.i221, 0
  %spec.select267 = select i1 %cmp.i222, i32 %add.i220, i32 %next_balance.2271
  %75 = ptrtoint ptr %avg_idle61 to i32
  call void @__asan_load8_noabort(i32 %75)
  %76 = load i64, ptr %avg_idle61, align 8
  %max_newidle_lb_cost62 = getelementptr inbounds %struct.sched_domain, ptr %sd.0272, i32 0, i32 14
  %77 = ptrtoint ptr %max_newidle_lb_cost62 to i32
  call void @__asan_load8_noabort(i32 %77)
  %78 = load i64, ptr %max_newidle_lb_cost62, align 8
  %add63 = add i64 %78, %curr_cost.0275
  %cmp64 = icmp ult i64 %76, %add63
  br i1 %cmp64, label %cleanup.thread, label %if.end66

if.end66:                                         ; preds = %for.body
  %flags = getelementptr inbounds %struct.sched_domain, ptr %sd.0272, i32 0, i32 9
  %79 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %79)
  %80 = load i32, ptr %flags, align 4
  %and = and i32 %80, 1
  %tobool67.not = icmp eq i32 %and, 0
  br i1 %tobool67.not, label %lor.lhs.false75, label %if.then68

if.then68:                                        ; preds = %if.end66
  %call69 = call fastcc i32 @load_balance(i32 noundef %2, ptr noundef %this_rq, ptr noundef nonnull %sd.0272, i32 noundef 2, ptr noundef nonnull %continue_balancing)
  %call70 = tail call i64 @sched_clock_cpu(i32 noundef %2) #20
  %sub = sub i64 %call70, %t0.0276
  %81 = ptrtoint ptr %max_newidle_lb_cost62 to i32
  call void @__asan_load8_noabort(i32 %81)
  %82 = load i64, ptr %max_newidle_lb_cost62, align 8
  %cmp.i227 = icmp ult i64 %82, %sub
  br i1 %cmp.i227, label %if.then.i228, label %if.else.i

if.then.i228:                                     ; preds = %if.then68
  %83 = ptrtoint ptr %max_newidle_lb_cost62 to i32
  call void @__asan_store8_noabort(i32 %83)
  store i64 %sub, ptr %max_newidle_lb_cost62, align 8
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %84 = load volatile i32, ptr @jiffies, align 128
  %last_decay_max_lb_cost.i = getelementptr inbounds %struct.sched_domain, ptr %sd.0272, i32 0, i32 15
  %85 = ptrtoint ptr %last_decay_max_lb_cost.i to i32
  call void @__asan_store4_noabort(i32 %85)
  store i32 %84, ptr %last_decay_max_lb_cost.i, align 8
  br label %if.end73

if.else.i:                                        ; preds = %if.then68
  %last_decay_max_lb_cost2.i = getelementptr inbounds %struct.sched_domain, ptr %sd.0272, i32 0, i32 15
  %86 = ptrtoint ptr %last_decay_max_lb_cost2.i to i32
  call void @__asan_load4_noabort(i32 %86)
  %87 = load i32, ptr %last_decay_max_lb_cost2.i, align 8
  %add.i229 = add i32 %87, 100
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %88 = load volatile i32, ptr @jiffies, align 128
  %sub.i230 = sub i32 %add.i229, %88
  %cmp3.i = icmp slt i32 %sub.i230, 0
  br i1 %cmp3.i, label %if.then4.i, label %if.end73

if.then4.i:                                       ; preds = %if.else.i
  %mul.i = mul i64 %82, 253
  %div16.i = lshr i64 %mul.i, 8
  %89 = ptrtoint ptr %max_newidle_lb_cost62 to i32
  call void @__asan_store8_noabort(i32 %89)
  store i64 %div16.i, ptr %max_newidle_lb_cost62, align 8
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %90 = load volatile i32, ptr @jiffies, align 128
  %91 = ptrtoint ptr %last_decay_max_lb_cost2.i to i32
  call void @__asan_store4_noabort(i32 %91)
  store i32 %90, ptr %last_decay_max_lb_cost2.i, align 8
  br label %if.end73

if.end73:                                         ; preds = %if.then4.i, %if.else.i, %if.then.i228
  %add72 = add i64 %sub, %curr_cost.0275
  %tobool74.not = icmp eq i32 %call69, 0
  br i1 %tobool74.not, label %lor.lhs.false75, label %cleanup.thread

lor.lhs.false75:                                  ; preds = %if.end73, %if.end66
  %t0.1284 = phi i64 [ %call70, %if.end73 ], [ %t0.0276, %if.end66 ]
  %curr_cost.1283 = phi i64 [ %add72, %if.end73 ], [ %curr_cost.0275, %if.end66 ]
  %92 = ptrtoint ptr %nr_running to i32
  call void @__asan_load4_noabort(i32 %92)
  %93 = load i32, ptr %nr_running, align 4
  %cmp76.not = icmp eq i32 %93, 0
  br i1 %cmp76.not, label %lor.lhs.false77, label %cleanup.thread

lor.lhs.false77:                                  ; preds = %lor.lhs.false75
  %94 = ptrtoint ptr %ttwu_pending to i32
  call void @__asan_load4_noabort(i32 %94)
  %95 = load i32, ptr %ttwu_pending, align 8
  %tobool79.not = icmp eq i32 %95, 0
  br i1 %tobool79.not, label %for.inc, label %cleanup.thread

cleanup.thread:                                   ; preds = %lor.lhs.false77, %lor.lhs.false75, %if.end73, %for.body
  %pulled_task.2.ph = phi i32 [ 0, %lor.lhs.false77 ], [ %call69, %if.end73 ], [ 0, %lor.lhs.false75 ], [ 0, %for.body ]
  %curr_cost.2.ph = phi i64 [ %curr_cost.1283, %lor.lhs.false77 ], [ %add72, %if.end73 ], [ %curr_cost.1283, %lor.lhs.false75 ], [ %curr_cost.0275, %for.body ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %continue_balancing) #20
  br label %for.end

for.inc:                                          ; preds = %lor.lhs.false77
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %continue_balancing) #20
  %96 = ptrtoint ptr %sd.0272 to i32
  call void @__asan_load4_noabort(i32 %96)
  %97 = load ptr, ptr %sd.0272, align 8
  %tobool60.not = icmp eq ptr %97, null
  br i1 %tobool60.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %cleanup.thread, %do.end58
  %next_balance.4 = phi i32 [ %spec.select267, %cleanup.thread ], [ %add, %do.end58 ], [ %spec.select267, %for.inc ]
  %pulled_task.3 = phi i32 [ %pulled_task.2.ph, %cleanup.thread ], [ 0, %do.end58 ], [ 0, %for.inc ]
  %curr_cost.3 = phi i64 [ %curr_cost.2.ph, %cleanup.thread ], [ 0, %do.end58 ], [ %curr_cost.1283, %for.inc ]
  %call.i231 = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i231, label %rcu_read_unlock.exit241, label %land.lhs.true.i234

land.lhs.true.i234:                               ; preds = %for.end
  %call1.i232 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i233 = icmp eq i32 %call1.i232, 0
  br i1 %tobool.not.i233, label %rcu_read_unlock.exit241, label %land.lhs.true2.i236

land.lhs.true2.i236:                              ; preds = %land.lhs.true.i234
  %.b4.i235 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i235, label %rcu_read_unlock.exit241, label %if.then.i237

if.then.i237:                                     ; preds = %land.lhs.true2.i236
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %rcu_read_unlock.exit241

rcu_read_unlock.exit241:                          ; preds = %if.then.i237, %land.lhs.true2.i236, %land.lhs.true.i234, %for.end
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %98 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i238 = and i32 %98, -16384
  %99 = inttoptr i32 %and.i.i.i.i.i238 to ptr
  %preempt_count.i.i.i.i239 = getelementptr inbounds %struct.thread_info, ptr %99, i32 0, i32 1
  %100 = ptrtoint ptr %preempt_count.i.i.i.i239 to i32
  call void @__asan_load4_noabort(i32 %100)
  %101 = load volatile i32, ptr %preempt_count.i.i.i.i239, align 4
  %sub.i.i.i240 = add i32 %101, -1
  store volatile i32 %sub.i.i.i240, ptr %preempt_count.i.i.i.i239, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  tail call void @raw_spin_rq_lock_nested(ptr noundef %this_rq, i32 noundef 0) #20
  %max_idle_balance_cost = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 58
  %102 = ptrtoint ptr %max_idle_balance_cost to i32
  call void @__asan_load8_noabort(i32 %102)
  %103 = load i64, ptr %max_idle_balance_cost, align 32
  %cmp83 = icmp ugt i64 %curr_cost.3, %103
  br i1 %cmp83, label %if.then84, label %if.end86

if.then84:                                        ; preds = %rcu_read_unlock.exit241
  %104 = ptrtoint ptr %max_idle_balance_cost to i32
  call void @__asan_store8_noabort(i32 %104)
  store i64 %curr_cost.3, ptr %max_idle_balance_cost, align 32
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %rcu_read_unlock.exit241
  %h_nr_running = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 14, i32 2
  %105 = ptrtoint ptr %h_nr_running to i32
  call void @__asan_load4_noabort(i32 %105)
  %106 = load i32, ptr %h_nr_running, align 4
  %tobool87.not = icmp eq i32 %106, 0
  %tobool89.not = icmp eq i32 %pulled_task.3, 0
  %spec.store.select = select i1 %tobool89.not, i32 1, i32 %pulled_task.3
  %pulled_task.4 = select i1 %tobool87.not, i32 %pulled_task.3, i32 %spec.store.select
  %nr_running92 = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 1
  %107 = ptrtoint ptr %nr_running92 to i32
  call void @__asan_load4_noabort(i32 %107)
  %108 = load i32, ptr %nr_running92, align 4
  %cmp95.not = icmp eq i32 %108, %106
  %spec.select167 = select i1 %cmp95.not, i32 %pulled_task.4, i32 -1
  br label %out

out:                                              ; preds = %if.end86, %rcu_read_unlock.exit
  %next_balance.5 = phi i32 [ %next_balance.1, %rcu_read_unlock.exit ], [ %next_balance.4, %if.end86 ]
  %pulled_task.5 = phi i32 [ 0, %rcu_read_unlock.exit ], [ %spec.select167, %if.end86 ]
  %next_balance98 = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 23
  %109 = ptrtoint ptr %next_balance98 to i32
  call void @__asan_load4_noabort(i32 %109)
  %110 = load i32, ptr %next_balance98, align 4
  %sub99 = sub i32 %next_balance.5, %110
  %cmp100 = icmp slt i32 %sub99, 0
  br i1 %cmp100, label %if.then101, label %if.end103

if.then101:                                       ; preds = %out
  %111 = ptrtoint ptr %next_balance98 to i32
  call void @__asan_store4_noabort(i32 %111)
  store i32 %next_balance.5, ptr %next_balance98, align 4
  br label %if.end103

if.end103:                                        ; preds = %if.then101, %out
  %tobool104.not = icmp eq i32 %pulled_task.5, 0
  br i1 %tobool104.not, label %if.else, label %if.then105

if.then105:                                       ; preds = %if.end103
  %112 = ptrtoint ptr %idle_stamp to i32
  call void @__asan_store8_noabort(i32 %112)
  store i64 0, ptr %idle_stamp, align 128
  br label %if.end107

if.else:                                          ; preds = %if.end103
  %113 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %113)
  %114 = load i32, ptr %cpu, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @housekeeping_overridden, ptr blockaddress(@newidle_balance, %if.then.i.i242)) #20
          to label %if.end.i244 [label %if.then.i.i242], !srcloc !261

if.then.i.i242:                                   ; preds = %if.else
  %call3.i.i = tail call zeroext i1 @housekeeping_test_cpu(i32 noundef %114, i32 noundef 8) #20
  br i1 %call3.i.i, label %if.end.i244, label %if.end107

if.end.i244:                                      ; preds = %if.then.i.i242, %if.else
  %avg_idle.i = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 55
  %115 = ptrtoint ptr %avg_idle.i to i32
  call void @__asan_load8_noabort(i32 %115)
  %116 = load i64, ptr %avg_idle.i, align 8
  %117 = load i32, ptr @sysctl_sched_migration_cost, align 4
  %conv.i = zext i32 %117 to i64
  %cmp.i243 = icmp ult i64 %116, %conv.i
  br i1 %cmp.i243, label %if.end107, label %do.end.i

do.end.i:                                         ; preds = %if.end.i244
  %118 = load volatile i32, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 2), align 8
  %tobool.not.i245 = icmp eq i32 %118, 0
  br i1 %tobool.not.i245, label %if.end107, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %do.end.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %119 = load volatile i32, ptr @jiffies, align 128
  %120 = load volatile i32, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 5), align 4
  %sub.i246 = sub i32 %119, %120
  %cmp8.i = icmp slt i32 %sub.i246, 0
  br i1 %cmp8.i, label %if.end107, label %do.body12.i

do.body12.i:                                      ; preds = %lor.lhs.false.i
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %114
  %121 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %121)
  %122 = load i32, ptr %arrayidx.i, align 4
  %add.i247 = add i32 %122, ptrtoint (ptr @runqueues to i32)
  %123 = inttoptr i32 %add.i247 to ptr
  %nohz_flags.i = getelementptr inbounds %struct.rq, ptr %123, i32 0, i32 7
  %call.i.i.i248 = tail call zeroext i1 @__kasan_check_write(ptr noundef %nohz_flags.i, i32 noundef 4) #20
  tail call void @llvm.prefetch.p0(ptr %nohz_flags.i, i32 1, i32 3, i32 1) #20
  %124 = tail call { i32, i32 } asm sideeffect "@ atomic_or\0A1:\09ldrex\09$0, [$3]\0A\09orr\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %nohz_flags.i, ptr %nohz_flags.i, i32 4, ptr elementtype(i32) %nohz_flags.i) #20, !srcloc !272
  br label %if.end107

if.end107:                                        ; preds = %do.body12.i, %lor.lhs.false.i, %do.end.i, %if.end.i244, %if.then.i.i242, %if.then105
  %125 = ptrtoint ptr %core_enabled.i.i to i32
  call void @__asan_load4_noabort(i32 %125)
  %126 = load i32, ptr %core_enabled.i.i, align 128
  %tobool.not.i.i250 = icmp eq i32 %126, 0
  br i1 %tobool.not.i.i250, label %rq_repin_lock.exit, label %if.then.i.i252

if.then.i.i252:                                   ; preds = %if.end107
  %core.i.i251 = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 79
  %127 = ptrtoint ptr %core.i.i251 to i32
  call void @__asan_load4_noabort(i32 %127)
  %128 = load ptr, ptr %core.i.i251, align 8
  br label %rq_repin_lock.exit

rq_repin_lock.exit:                               ; preds = %if.then.i.i252, %if.end107
  %retval.0.i.i253 = phi ptr [ %128, %if.then.i.i252 ], [ %this_rq, %if.end107 ]
  %dep_map.i254 = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i253, i32 0, i32 4
  %129 = ptrtoint ptr %cookie.i to i32
  call void @__asan_load4_noabort(i32 %129)
  %.unpack.i256 = load i32, ptr %cookie.i, align 4
  %130 = insertvalue [1 x i32] undef, i32 %.unpack.i256, 0
  tail call void @lock_repin_lock(ptr noundef %dep_map.i254, [1 x i32] %130) #20
  %clock_update_flags.i257 = getelementptr inbounds %struct.rq_flags, ptr %rf, i32 0, i32 2
  %131 = ptrtoint ptr %clock_update_flags.i257 to i32
  call void @__asan_load4_noabort(i32 %131)
  %132 = load i32, ptr %clock_update_flags.i257, align 4
  %133 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %133)
  %134 = load i32, ptr %clock_update_flags.i.i, align 4
  %or.i = or i32 %134, %132
  store i32 %or.i, ptr %clock_update_flags.i.i, align 4
  br label %cleanup108

cleanup108:                                       ; preds = %rq_repin_lock.exit, %cpu_active.exit, %update_misfit_status.exit
  %retval.0 = phi i32 [ %pulled_task.5, %rq_repin_lock.exit ], [ 0, %update_misfit_status.exit ], [ 0, %cpu_active.exit ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @update_group_capacity(ptr nocapture noundef readonly %sd, i32 noundef %cpu) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %child1 = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 1
  %0 = ptrtoint ptr %child1 to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %child1, align 4
  %groups = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 2
  %2 = ptrtoint ptr %groups to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %groups, align 8
  %balance_interval = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 12
  %4 = ptrtoint ptr %balance_interval to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %balance_interval, align 8
  %call2.i = tail call i32 @__msecs_to_jiffies(i32 noundef %5) #20
  %6 = call i32 @llvm.umax.i32(i32 %call2.i, i32 1)
  %7 = load i32, ptr @max_load_balance_interval, align 4
  %8 = tail call i32 @llvm.umin.i32(i32 %6, i32 %7)
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %9 = load volatile i32, ptr @jiffies, align 128
  %add = add i32 %9, %8
  %sgc = getelementptr inbounds %struct.sched_group, ptr %3, i32 0, i32 3
  %10 = ptrtoint ptr %sgc to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %sgc, align 4
  %next_update = getelementptr inbounds %struct.sched_group_capacity, ptr %11, i32 0, i32 4
  %12 = ptrtoint ptr %next_update to i32
  call void @__asan_store4_noabort(i32 %12)
  store i32 %add, ptr %next_update, align 4
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %arrayidx.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %cpu
  %13 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %arrayidx.i.i, align 4
  %add.i.i = add i32 %14, ptrtoint (ptr @runqueues to i32)
  %15 = inttoptr i32 %add.i.i to ptr
  %add.i.i.i = add i32 %14, ptrtoint (ptr @cpu_scale to i32)
  %16 = inttoptr i32 %add.i.i.i to ptr
  %17 = ptrtoint ptr %16 to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %16, align 4
  %util_avg.i.i.i = getelementptr inbounds %struct.rq, ptr %15, i32 0, i32 52, i32 7
  %19 = ptrtoint ptr %util_avg.i.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %util_avg.i.i.i, align 8
  %cmp.not.i.i = icmp ugt i32 %18, %20
  br i1 %cmp.not.i.i, label %do.end6.i.i, label %scale_rt_capacity.exit.thread.i, !prof !259

do.end6.i.i:                                      ; preds = %if.then
  %util_avg.i.i = getelementptr inbounds %struct.rq, ptr %15, i32 0, i32 50, i32 7
  %21 = ptrtoint ptr %util_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load volatile i32, ptr %util_avg.i.i, align 8
  %util_avg12.i.i = getelementptr inbounds %struct.rq, ptr %15, i32 0, i32 51, i32 7
  %23 = ptrtoint ptr %util_avg12.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load volatile i32, ptr %util_avg12.i.i, align 8
  %add13.i.i = add i32 %24, %22
  %load_avg.i.i.i = getelementptr inbounds %struct.rq, ptr %15, i32 0, i32 53, i32 5
  %25 = ptrtoint ptr %load_avg.i.i.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load volatile i32, ptr %load_avg.i.i.i, align 32
  %conv16.i.i = add i32 %add13.i.i, %26
  %cmp17.not.i.i = icmp ugt i32 %18, %conv16.i.i
  br i1 %cmp17.not.i.i, label %scale_rt_capacity.exit.i, label %scale_rt_capacity.exit.thread.i, !prof !259

scale_rt_capacity.exit.thread.i:                  ; preds = %do.end6.i.i, %if.then
  %27 = ptrtoint ptr %groups to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %groups, align 8
  %cpu_capacity_orig38.i = getelementptr inbounds %struct.rq, ptr %15, i32 0, i32 38
  %29 = ptrtoint ptr %cpu_capacity_orig38.i to i32
  call void @__asan_store4_noabort(i32 %29)
  store i32 %18, ptr %cpu_capacity_orig38.i, align 4
  br label %update_cpu_capacity.exit

scale_rt_capacity.exit.i:                         ; preds = %do.end6.i.i
  %sub.i.i103 = sub i32 %18, %conv16.i.i
  %sub.i.i.i = sub i32 %18, %20
  %mul.i.i.i = mul i32 %sub.i.i103, %sub.i.i.i
  %div.i.i.i = udiv i32 %mul.i.i.i, %18
  %30 = ptrtoint ptr %groups to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %groups, align 8
  %cpu_capacity_orig.i = getelementptr inbounds %struct.rq, ptr %15, i32 0, i32 38
  %32 = ptrtoint ptr %cpu_capacity_orig.i to i32
  call void @__asan_store4_noabort(i32 %32)
  store i32 %18, ptr %cpu_capacity_orig.i, align 4
  %tobool.not.i = icmp ugt i32 %18, %mul.i.i.i
  %spec.select.i = select i1 %tobool.not.i, i32 1, i32 %div.i.i.i
  br label %update_cpu_capacity.exit

update_cpu_capacity.exit:                         ; preds = %scale_rt_capacity.exit.i, %scale_rt_capacity.exit.thread.i
  %33 = phi ptr [ %28, %scale_rt_capacity.exit.thread.i ], [ %31, %scale_rt_capacity.exit.i ]
  %34 = phi i32 [ 1, %scale_rt_capacity.exit.thread.i ], [ %spec.select.i, %scale_rt_capacity.exit.i ]
  %35 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %arrayidx.i.i, align 4
  %add11.i = add i32 %36, ptrtoint (ptr @runqueues to i32)
  %37 = inttoptr i32 %add11.i to ptr
  %cpu_capacity.i = getelementptr inbounds %struct.rq, ptr %37, i32 0, i32 37
  %38 = ptrtoint ptr %cpu_capacity.i to i32
  call void @__asan_store4_noabort(i32 %38)
  store i32 %34, ptr %cpu_capacity.i, align 16
  %39 = load i32, ptr %arrayidx.i.i, align 4
  %add20.i = add i32 %39, ptrtoint (ptr @runqueues to i32)
  %40 = inttoptr i32 %add20.i to ptr
  tail call fastcc void @trace_sched_cpu_capacity_tp(ptr noundef %40) #20
  %sgc.i = getelementptr inbounds %struct.sched_group, ptr %33, i32 0, i32 3
  br label %cleanup

if.end:                                           ; preds = %entry
  %flags = getelementptr inbounds %struct.sched_domain, ptr %1, i32 0, i32 9
  %41 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load i32, ptr %flags, align 4
  %and = and i32 %42, 4096
  %tobool8.not = icmp eq i32 %and, 0
  br i1 %tobool8.not, label %if.else, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end
  %cpumask.i = getelementptr inbounds %struct.sched_group, ptr %3, i32 0, i32 6
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %43 = load i32, ptr @nr_cpu_ids, align 4
  %call11110 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef %cpumask.i) #24
  %cmp12111 = icmp ult i32 %call11110, %43
  br i1 %cmp12111, label %for.body, label %cleanup

for.body:                                         ; preds = %for.body, %for.cond.preheader
  %call11115 = phi i32 [ %call11, %for.body ], [ %call11110, %for.cond.preheader ]
  %capacity.0114 = phi i32 [ %add14, %for.body ], [ 0, %for.cond.preheader ]
  %min_capacity.0113 = phi i32 [ %49, %for.body ], [ -1, %for.cond.preheader ]
  %max_capacity.0112 = phi i32 [ %50, %for.body ], [ 0, %for.cond.preheader ]
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call11115
  %44 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %45, ptrtoint (ptr @runqueues to i32)
  %46 = inttoptr i32 %add.i to ptr
  %cpu_capacity.i104 = getelementptr inbounds %struct.rq, ptr %46, i32 0, i32 37
  %47 = ptrtoint ptr %cpu_capacity.i104 to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load i32, ptr %cpu_capacity.i104, align 16
  %add14 = add i32 %48, %capacity.0114
  %49 = tail call i32 @llvm.umin.i32(i32 %48, i32 %min_capacity.0113)
  %50 = tail call i32 @llvm.umax.i32(i32 %48, i32 %max_capacity.0112)
  %call11 = tail call i32 @cpumask_next(i32 noundef %call11115, ptr noundef %cpumask.i) #24
  %cmp12 = icmp ult i32 %call11, %43
  br i1 %cmp12, label %for.body, label %cleanup

if.else:                                          ; preds = %if.end
  %groups27 = getelementptr inbounds %struct.sched_domain, ptr %1, i32 0, i32 2
  %51 = ptrtoint ptr %groups27 to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load ptr, ptr %groups27, align 8
  br label %do.body

do.body:                                          ; preds = %do.body, %if.else
  %max_capacity.1 = phi i32 [ 0, %if.else ], [ %62, %do.body ]
  %min_capacity.1 = phi i32 [ -1, %if.else ], [ %59, %do.body ]
  %capacity.1 = phi i32 [ 0, %if.else ], [ %add31, %do.body ]
  %group.0 = phi ptr [ %52, %if.else ], [ %64, %do.body ]
  %sgc29 = getelementptr inbounds %struct.sched_group, ptr %group.0, i32 0, i32 3
  %53 = ptrtoint ptr %sgc29 to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load ptr, ptr %sgc29, align 4
  %capacity30 = getelementptr inbounds %struct.sched_group_capacity, ptr %54, i32 0, i32 1
  %55 = ptrtoint ptr %capacity30 to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load i32, ptr %capacity30, align 4
  %add31 = add i32 %56, %capacity.1
  %min_capacity32 = getelementptr inbounds %struct.sched_group_capacity, ptr %54, i32 0, i32 2
  %57 = ptrtoint ptr %min_capacity32 to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load i32, ptr %min_capacity32, align 4
  %59 = tail call i32 @llvm.umin.i32(i32 %58, i32 %min_capacity.1)
  %max_capacity39 = getelementptr inbounds %struct.sched_group_capacity, ptr %54, i32 0, i32 3
  %60 = ptrtoint ptr %max_capacity39 to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load i32, ptr %max_capacity39, align 4
  %62 = tail call i32 @llvm.umax.i32(i32 %61, i32 %max_capacity.1)
  %63 = ptrtoint ptr %group.0 to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load ptr, ptr %group.0, align 4
  %cmp47.not = icmp eq ptr %64, %52
  br i1 %cmp47.not, label %cleanup, label %do.body

cleanup:                                          ; preds = %do.body, %for.body, %for.cond.preheader, %update_cpu_capacity.exit
  %sgc.sink127 = phi ptr [ %sgc.i, %update_cpu_capacity.exit ], [ %sgc, %for.cond.preheader ], [ %sgc, %do.body ], [ %sgc, %for.body ]
  %capacity.2.sink = phi i32 [ %34, %update_cpu_capacity.exit ], [ 0, %for.cond.preheader ], [ %add31, %do.body ], [ %add14, %for.body ]
  %min_capacity.2.sink = phi i32 [ %34, %update_cpu_capacity.exit ], [ -1, %for.cond.preheader ], [ %59, %do.body ], [ %49, %for.body ]
  %max_capacity.2.sink = phi i32 [ %34, %update_cpu_capacity.exit ], [ 0, %for.cond.preheader ], [ %62, %do.body ], [ %50, %for.body ]
  %65 = ptrtoint ptr %sgc.sink127 to i32
  call void @__asan_load4_noabort(i32 %65)
  %66 = load ptr, ptr %sgc.sink127, align 4
  %capacity50 = getelementptr inbounds %struct.sched_group_capacity, ptr %66, i32 0, i32 1
  %67 = ptrtoint ptr %capacity50 to i32
  call void @__asan_store4_noabort(i32 %67)
  store i32 %capacity.2.sink, ptr %capacity50, align 4
  %68 = load ptr, ptr %sgc.sink127, align 4
  %min_capacity52 = getelementptr inbounds %struct.sched_group_capacity, ptr %68, i32 0, i32 2
  %69 = ptrtoint ptr %min_capacity52 to i32
  call void @__asan_store4_noabort(i32 %69)
  store i32 %min_capacity.2.sink, ptr %min_capacity52, align 4
  %70 = load ptr, ptr %sgc.sink127, align 4
  %max_capacity54 = getelementptr inbounds %struct.sched_group_capacity, ptr %70, i32 0, i32 3
  %71 = ptrtoint ptr %max_capacity54 to i32
  call void @__asan_store4_noabort(i32 %71)
  store i32 %max_capacity.2.sink, ptr %max_capacity54, align 4
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @update_max_interval() local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @__num_online_cpus, i32 noundef 4) #20
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__num_online_cpus to i32))
  %0 = load volatile i32, ptr @__num_online_cpus, align 4
  %mul = mul i32 %0, 100
  %div = udiv i32 %mul, 10
  store i32 %div, ptr @max_load_balance_interval, align 4
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @nohz_balance_exit_idle(ptr noundef %rq) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 3
  %2 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %3
  %4 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %arrayidx, align 4
  %add = add i32 %5, ptrtoint (ptr @runqueues to i32)
  %6 = inttoptr i32 %add to ptr
  %cmp.not = icmp eq ptr %6, %rq
  br i1 %cmp.not, label %if.end32, label %land.rhs

land.rhs:                                         ; preds = %entry
  %.b60 = load i1, ptr @nohz_balance_exit_idle.__already_done, align 1
  br i1 %.b60, label %if.end32, label %if.then, !prof !259

if.then:                                          ; preds = %land.rhs
  store i1 true, ptr @nohz_balance_exit_idle.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 10549, i32 noundef 9, ptr noundef nonnull @.str.2) #20
  br label %if.end32

if.end32:                                         ; preds = %if.then, %land.rhs, %entry
  %nohz_tick_stopped = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 6
  %7 = ptrtoint ptr %nohz_tick_stopped to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %nohz_tick_stopped, align 16
  %tobool40.not = icmp eq i32 %8, 0
  br i1 %tobool40.not, label %return, label %if.end50, !prof !259

if.end50:                                         ; preds = %if.end32
  %9 = ptrtoint ptr %nohz_tick_stopped to i32
  call void @__asan_store4_noabort(i32 %9)
  store i32 0, ptr %nohz_tick_stopped, align 16
  %cpu52 = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 46
  %10 = ptrtoint ptr %cpu52 to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %cpu52, align 4
  %12 = load ptr, ptr @nohz, align 128
  tail call fastcc void @cpumask_clear_cpu(i32 noundef %11, ptr noundef %12)
  %call.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 1), i32 noundef 4) #20
  tail call void @llvm.prefetch.p0(ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 1), i32 1, i32 3, i32 1) #20
  %13 = tail call { i32, i32 } asm sideeffect "@ atomic_sub\0A1:\09ldrex\09$0, [$3]\0A\09sub\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 1), ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 1), i32 1, ptr elementtype(i32) getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 1)) #20, !srcloc !273
  %14 = ptrtoint ptr %cpu52 to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %cpu52, align 4
  tail call fastcc void @set_cpu_sd_state_busy(i32 noundef %15)
  br label %return

return:                                           ; preds = %if.end50, %if.end32
  ret void
}

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @cpumask_clear_cpu(i32 noundef %cpu, ptr noundef %dstp) unnamed_addr #7 align 64 {
entry:
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %0 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i = icmp ugt i32 %0, %cpu
  br i1 %cmp.not.i.i, label %cpumask_check.exit, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %entry
  %.b37.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i, label %cpumask_check.exit, label %if.then.i.i, !prof !259

if.then.i.i:                                      ; preds = %land.rhs.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpumask_check.exit

cpumask_check.exit:                               ; preds = %if.then.i.i, %land.rhs.i.i, %entry
  tail call void @_clear_bit(i32 noundef %cpu, ptr noundef %dstp) #20
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @set_cpu_sd_state_busy(i32 noundef %cpu) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %3, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !268
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #20
  %call.i = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 696, ptr noundef nonnull @.str.28) #20
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %entry
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %cpu
  %4 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %arrayidx, align 4
  %add = add i32 %5, ptrtoint (ptr @sd_llc to i32)
  %6 = inttoptr i32 %add to ptr
  %7 = ptrtoint ptr %6 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load volatile ptr, ptr %6, align 4
  %call = tail call i32 @rcu_read_lock_held() #20
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %land.lhs.true, label %do.end12

land.lhs.true:                                    ; preds = %rcu_read_lock.exit
  %call7 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool8.not = icmp eq i32 %call7, 0
  br i1 %tobool8.not, label %do.end12, label %land.lhs.true9

land.lhs.true9:                                   ; preds = %land.lhs.true
  %.b22 = load i1, ptr @set_cpu_sd_state_busy.__warned, align 1
  br i1 %.b22, label %do.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true9
  store i1 true, ptr @set_cpu_sd_state_busy.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 10536, ptr noundef nonnull @.str.16) #20
  br label %do.end12

do.end12:                                         ; preds = %if.then, %land.lhs.true9, %land.lhs.true, %rcu_read_lock.exit
  %tobool14.not = icmp eq ptr %8, null
  br i1 %tobool14.not, label %unlock, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end12
  %nohz_idle = getelementptr inbounds %struct.sched_domain, ptr %8, i32 0, i32 8
  %9 = ptrtoint ptr %nohz_idle to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %nohz_idle, align 8
  %tobool15.not = icmp eq i32 %10, 0
  br i1 %tobool15.not, label %unlock, label %if.end17

if.end17:                                         ; preds = %lor.lhs.false
  %11 = ptrtoint ptr %nohz_idle to i32
  call void @__asan_store4_noabort(i32 %11)
  store i32 0, ptr %nohz_idle, align 8
  %shared = getelementptr inbounds %struct.sched_domain, ptr %8, i32 0, i32 39
  %12 = ptrtoint ptr %shared to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %shared, align 4
  %nr_busy_cpus = getelementptr inbounds %struct.sched_domain_shared, ptr %13, i32 0, i32 1
  %call.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %nr_busy_cpus, i32 noundef 4) #20
  tail call void @llvm.prefetch.p0(ptr %nr_busy_cpus, i32 1, i32 3, i32 1) #20
  %14 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %nr_busy_cpus, ptr %nr_busy_cpus, i32 1, ptr elementtype(i32) %nr_busy_cpus) #20, !srcloc !262
  br label %unlock

unlock:                                           ; preds = %if.end17, %lor.lhs.false, %do.end12
  %call.i23 = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i23, label %rcu_read_unlock.exit, label %land.lhs.true.i26

land.lhs.true.i26:                                ; preds = %unlock
  %call1.i24 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i25 = icmp eq i32 %call1.i24, 0
  br i1 %tobool.not.i25, label %rcu_read_unlock.exit, label %land.lhs.true2.i28

land.lhs.true2.i28:                               ; preds = %land.lhs.true.i26
  %.b4.i27 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i27, label %rcu_read_unlock.exit, label %if.then.i29

if.then.i29:                                      ; preds = %land.lhs.true2.i28
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i29, %land.lhs.true2.i28, %land.lhs.true.i26, %unlock
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %15 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i30 = and i32 %15, -16384
  %16 = inttoptr i32 %and.i.i.i.i.i30 to ptr
  %preempt_count.i.i.i.i31 = getelementptr inbounds %struct.thread_info, ptr %16, i32 0, i32 1
  %17 = ptrtoint ptr %preempt_count.i.i.i.i31 to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load volatile i32, ptr %preempt_count.i.i.i.i31, align 4
  %sub.i.i.i = add i32 %18, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i31, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @nohz_balance_enter_idle(i32 noundef %cpu) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %cpu
  %0 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %arrayidx, align 4
  %add = add i32 %1, ptrtoint (ptr @runqueues to i32)
  %2 = inttoptr i32 %add to ptr
  %3 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %3, -16384
  %4 = inttoptr i32 %and.i to ptr
  %cpu2 = getelementptr inbounds %struct.thread_info, ptr %4, i32 0, i32 3
  %5 = ptrtoint ptr %cpu2 to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %cpu2, align 4
  %cmp.not = icmp eq i32 %6, %cpu
  br i1 %cmp.not, label %if.end33, label %land.rhs

land.rhs:                                         ; preds = %entry
  %.b89 = load i1, ptr @nohz_balance_enter_idle.__already_done, align 1
  br i1 %.b89, label %if.end33, label %if.then, !prof !259

if.then:                                          ; preds = %land.rhs
  store i1 true, ptr @nohz_balance_enter_idle.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 10585, i32 noundef 9, ptr noundef nonnull @.str.3) #20
  br label %if.end33

if.end33:                                         ; preds = %if.then, %land.rhs, %entry
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %7 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i = icmp ugt i32 %7, %cpu
  br i1 %cmp.not.i.i.i.i, label %cpu_active.exit, label %land.rhs.i.i.i.i

land.rhs.i.i.i.i:                                 ; preds = %if.end33
  %.b37.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i, label %cpu_active.exit, label %if.then.i.i.i.i, !prof !259

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_active.exit

cpu_active.exit:                                  ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i.i, %if.end33
  %div3.i.i.i = lshr i32 %cpu, 5
  %arrayidx.i.i.i = getelementptr i32, ptr @__cpu_active_mask, i32 %div3.i.i.i
  %8 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load volatile i32, ptr %arrayidx.i.i.i, align 4
  %and.i.i.i = and i32 %cpu, 31
  %10 = shl nuw i32 1, %and.i.i.i
  %11 = and i32 %9, %10
  %tobool.i.not = icmp eq i32 %11, 0
  br i1 %tobool.i.not, label %cleanup, label %if.end43

if.end43:                                         ; preds = %cpu_active.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @housekeeping_overridden, ptr blockaddress(@nohz_balance_enter_idle, %if.then.i)) #20
          to label %if.end46 [label %if.then.i], !srcloc !261

if.then.i:                                        ; preds = %if.end43
  %call3.i = tail call zeroext i1 @housekeeping_test_cpu(i32 noundef %cpu, i32 noundef 8) #20
  br i1 %call3.i, label %if.end46, label %cleanup

if.end46:                                         ; preds = %if.then.i, %if.end43
  %has_blocked_load = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 3
  %12 = ptrtoint ptr %has_blocked_load to i32
  call void @__asan_store4_noabort(i32 %12)
  store i32 1, ptr %has_blocked_load, align 4
  %nohz_tick_stopped = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 6
  %13 = ptrtoint ptr %nohz_tick_stopped to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %nohz_tick_stopped, align 16
  %tobool47.not = icmp eq i32 %14, 0
  br i1 %tobool47.not, label %if.end49, label %do.body74

if.end49:                                         ; preds = %if.end46
  %sd.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 36
  %15 = ptrtoint ptr %sd.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile ptr, ptr %sd.i, align 4
  %call.i = tail call i32 @rcu_read_lock_sched_held() #20
  %tobool.not.i = icmp eq i32 %call.i, 0
  br i1 %tobool.not.i, label %land.lhs.true.i, label %on_null_domain.exit

land.lhs.true.i:                                  ; preds = %if.end49
  %call2.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool3.not.i = icmp eq i32 %call2.i, 0
  br i1 %tobool3.not.i, label %on_null_domain.exit, label %land.lhs.true4.i

land.lhs.true4.i:                                 ; preds = %land.lhs.true.i
  %.b12.i = load i1, ptr @on_null_domain.__warned, align 1
  br i1 %.b12.i, label %on_null_domain.exit, label %if.then.i90

if.then.i90:                                      ; preds = %land.lhs.true4.i
  store i1 true, ptr @on_null_domain.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 10345, ptr noundef nonnull @.str.16) #20
  br label %on_null_domain.exit

on_null_domain.exit:                              ; preds = %if.then.i90, %land.lhs.true4.i, %land.lhs.true.i, %if.end49
  %tobool9.not.i.not = icmp eq ptr %16, null
  br i1 %tobool9.not.i.not, label %cleanup, label %if.end53

if.end53:                                         ; preds = %on_null_domain.exit
  %17 = ptrtoint ptr %nohz_tick_stopped to i32
  call void @__asan_store4_noabort(i32 %17)
  store i32 1, ptr %nohz_tick_stopped, align 16
  %18 = load ptr, ptr @nohz, align 128
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %19 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i = icmp ugt i32 %19, %cpu
  br i1 %cmp.not.i.i.i, label %cpumask_set_cpu.exit, label %land.rhs.i.i.i

land.rhs.i.i.i:                                   ; preds = %if.end53
  %.b37.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i, label %cpumask_set_cpu.exit, label %if.then.i.i.i, !prof !259

if.then.i.i.i:                                    ; preds = %land.rhs.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpumask_set_cpu.exit

cpumask_set_cpu.exit:                             ; preds = %if.then.i.i.i, %land.rhs.i.i.i, %if.end53
  tail call void @_set_bit(i32 noundef %cpu, ptr noundef %18) #20
  %call.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 1), i32 noundef 4) #20
  tail call void @llvm.prefetch.p0(ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 1), i32 1, i32 3, i32 1) #20
  %20 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 1), ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 1), i32 1, ptr elementtype(i32) getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 1)) #20, !srcloc !262
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !274
  %21 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i.i = and i32 %21, -16384
  %22 = inttoptr i32 %and.i.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %22, i32 0, i32 1
  %23 = ptrtoint ptr %preempt_count.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load volatile i32, ptr %preempt_count.i.i.i.i.i, align 4
  %add.i.i.i.i = add i32 %24, 1
  store volatile i32 %add.i.i.i.i, ptr %preempt_count.i.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !268
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #20
  %call.i.i91 = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i.i91, label %rcu_read_lock.exit.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %cpumask_set_cpu.exit
  %call1.i.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i.i = icmp eq i32 %call1.i.i, 0
  br i1 %tobool.not.i.i, label %rcu_read_lock.exit.i, label %land.lhs.true2.i.i

land.lhs.true2.i.i:                               ; preds = %land.lhs.true.i.i
  %.b4.i.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i.i, label %rcu_read_lock.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true2.i.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 696, ptr noundef nonnull @.str.28) #20
  br label %rcu_read_lock.exit.i

rcu_read_lock.exit.i:                             ; preds = %if.then.i.i, %land.lhs.true2.i.i, %land.lhs.true.i.i, %cpumask_set_cpu.exit
  %25 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %arrayidx, align 4
  %add.i = add i32 %26, ptrtoint (ptr @sd_llc to i32)
  %27 = inttoptr i32 %add.i to ptr
  %28 = ptrtoint ptr %27 to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile ptr, ptr %27, align 4
  %call.i92 = tail call i32 @rcu_read_lock_held() #20
  %tobool.not.i93 = icmp eq i32 %call.i92, 0
  br i1 %tobool.not.i93, label %land.lhs.true.i94, label %do.end12.i

land.lhs.true.i94:                                ; preds = %rcu_read_lock.exit.i
  %call7.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool8.not.i = icmp eq i32 %call7.i, 0
  br i1 %tobool8.not.i, label %do.end12.i, label %land.lhs.true9.i

land.lhs.true9.i:                                 ; preds = %land.lhs.true.i94
  %.b22.i = load i1, ptr @set_cpu_sd_state_idle.__warned, align 1
  br i1 %.b22.i, label %do.end12.i, label %if.then.i95

if.then.i95:                                      ; preds = %land.lhs.true9.i
  store i1 true, ptr @set_cpu_sd_state_idle.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 10566, ptr noundef nonnull @.str.16) #20
  br label %do.end12.i

do.end12.i:                                       ; preds = %if.then.i95, %land.lhs.true9.i, %land.lhs.true.i94, %rcu_read_lock.exit.i
  %tobool14.not.i = icmp eq ptr %29, null
  br i1 %tobool14.not.i, label %unlock.i, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %do.end12.i
  %nohz_idle.i = getelementptr inbounds %struct.sched_domain, ptr %29, i32 0, i32 8
  %30 = ptrtoint ptr %nohz_idle.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load i32, ptr %nohz_idle.i, align 8
  %tobool15.not.i = icmp eq i32 %31, 0
  br i1 %tobool15.not.i, label %if.end17.i, label %unlock.i

if.end17.i:                                       ; preds = %lor.lhs.false.i
  %32 = ptrtoint ptr %nohz_idle.i to i32
  call void @__asan_store4_noabort(i32 %32)
  store i32 1, ptr %nohz_idle.i, align 8
  %shared.i = getelementptr inbounds %struct.sched_domain, ptr %29, i32 0, i32 39
  %33 = ptrtoint ptr %shared.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load ptr, ptr %shared.i, align 4
  %nr_busy_cpus.i = getelementptr inbounds %struct.sched_domain_shared, ptr %34, i32 0, i32 1
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %nr_busy_cpus.i, i32 noundef 4) #20
  tail call void @llvm.prefetch.p0(ptr %nr_busy_cpus.i, i32 1, i32 3, i32 1) #20
  %35 = tail call { i32, i32 } asm sideeffect "@ atomic_sub\0A1:\09ldrex\09$0, [$3]\0A\09sub\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %nr_busy_cpus.i, ptr %nr_busy_cpus.i, i32 1, ptr elementtype(i32) %nr_busy_cpus.i) #20, !srcloc !273
  br label %unlock.i

unlock.i:                                         ; preds = %if.end17.i, %lor.lhs.false.i, %do.end12.i
  %call.i23.i = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i23.i, label %set_cpu_sd_state_idle.exit, label %land.lhs.true.i26.i

land.lhs.true.i26.i:                              ; preds = %unlock.i
  %call1.i24.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i25.i = icmp eq i32 %call1.i24.i, 0
  br i1 %tobool.not.i25.i, label %set_cpu_sd_state_idle.exit, label %land.lhs.true2.i28.i

land.lhs.true2.i28.i:                             ; preds = %land.lhs.true.i26.i
  %.b4.i27.i = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i27.i, label %set_cpu_sd_state_idle.exit, label %if.then.i29.i

if.then.i29.i:                                    ; preds = %land.lhs.true2.i28.i
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %set_cpu_sd_state_idle.exit

set_cpu_sd_state_idle.exit:                       ; preds = %if.then.i29.i, %land.lhs.true2.i28.i, %land.lhs.true.i26.i, %unlock.i
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %36 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i30.i = and i32 %36, -16384
  %37 = inttoptr i32 %and.i.i.i.i.i30.i to ptr
  %preempt_count.i.i.i.i31.i = getelementptr inbounds %struct.thread_info, ptr %37, i32 0, i32 1
  %38 = ptrtoint ptr %preempt_count.i.i.i.i31.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load volatile i32, ptr %preempt_count.i.i.i.i31.i, align 4
  %sub.i.i.i.i = add i32 %39, -1
  store volatile i32 %sub.i.i.i.i, ptr %preempt_count.i.i.i.i31.i, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  store volatile i32 1, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 3), align 4
  br label %do.body74

do.body74:                                        ; preds = %set_cpu_sd_state_idle.exit, %if.end46
  store volatile i32 1, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 2), align 8
  br label %cleanup

cleanup:                                          ; preds = %do.body74, %on_null_domain.exit, %if.then.i, %cpu_active.exit
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @nohz_run_idle_balance(i32 noundef %cpu) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %cpu
  %0 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %arrayidx, align 4
  %add = add i32 %1, ptrtoint (ptr @runqueues to i32)
  %2 = inttoptr i32 %add to ptr
  %nohz_flags = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 7
  %call.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %nohz_flags, i32 noundef 4) #20
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !275
  tail call void @llvm.prefetch.p0(ptr %nohz_flags, i32 1, i32 3, i32 1) #20
  %3 = tail call { i32, i32, i32 } asm sideeffect "@ atomic_fetch_andnot\0A1:\09ldrex\09$0, [$4]\0A\09bic\09$1, $0, $5\0A\09strex\09$2, $1, [$4]\0A\09teq\09$2, #0\0A\09bne\091b", "=&r,=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %nohz_flags, ptr %nohz_flags, i32 4, ptr elementtype(i32) %nohz_flags) #20, !srcloc !276
  %asmresult.i.i.i = extractvalue { i32, i32, i32 } %3, 0
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !277
  %cmp = icmp eq i32 %asmresult.i.i.i, 4
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %4 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i = and i32 %4, -16384
  %5 = inttoptr i32 %and.i.i to ptr
  %6 = ptrtoint ptr %5 to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %5, align 16384
  %8 = and i32 %7, 2
  %tobool.i.not = icmp eq i32 %8, 0
  br i1 %tobool.i.not, label %do.body3, label %if.end

do.body3:                                         ; preds = %land.lhs.true
  %9 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %arrayidx, align 4
  %add11 = add i32 %10, ptrtoint (ptr @runqueues to i32)
  %11 = inttoptr i32 %add11 to ptr
  tail call fastcc void @_nohz_idle_balance(ptr noundef %11, i32 noundef 2)
  br label %if.end

if.end:                                           ; preds = %do.body3, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @_nohz_idle_balance(ptr nocapture noundef readonly %this_rq, i32 noundef %flags) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %0 = load volatile i32, ptr @jiffies, align 128
  %add = add i32 %0, 6000
  %cpu = getelementptr inbounds %struct.rq, ptr %this_rq, i32 0, i32 46
  %1 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %cpu, align 4
  %and = and i32 %flags, 11
  %cmp = icmp eq i32 %and, 1
  br i1 %cmp, label %land.rhs, label %if.end27

land.rhs:                                         ; preds = %entry
  %.b12 = load i1, ptr @_nohz_idle_balance.__already_done, align 1
  br i1 %.b12, label %if.end27, label %if.then, !prof !259

if.then:                                          ; preds = %land.rhs
  store i1 true, ptr @_nohz_idle_balance.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 10673, i32 noundef 9, ptr noundef nonnull @.str.33) #20
  br label %if.end27

if.end27:                                         ; preds = %if.then, %land.rhs, %entry
  %and35 = and i32 %flags, 2
  %tobool36.not = icmp eq i32 %and35, 0
  br i1 %tobool36.not, label %if.end47, label %do.body42

do.body42:                                        ; preds = %if.end27
  store volatile i32 0, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 2), align 8
  br label %if.end47

if.end47:                                         ; preds = %do.body42, %if.end27
  %and48 = and i32 %flags, 8
  %tobool49.not = icmp eq i32 %and48, 0
  br i1 %tobool49.not, label %do.end64, label %do.body55

do.body55:                                        ; preds = %if.end47
  store volatile i32 0, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 3), align 4
  br label %do.end64

do.end64:                                         ; preds = %do.body55, %if.end47
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !278
  %add67 = add i32 %2, 1
  %3 = load ptr, ptr @nohz, align 128
  %call = tail call i32 @cpumask_next_wrap(i32 noundef %2, ptr noundef %3, i32 noundef %add67, i1 noundef zeroext false) #20
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %4 = load i32, ptr @nr_cpu_ids, align 4
  %cmp6932 = icmp ult i32 %call, %4
  br i1 %cmp6932, label %for.body.lr.ph, label %if.end136.thread

for.body.lr.ph:                                   ; preds = %do.end64
  %and114 = and i32 %flags, 1
  %tobool115.not = icmp eq i32 %and114, 0
  br label %for.body

for.body:                                         ; preds = %for.inc, %for.body.lr.ph
  %next_balance.037 = phi i32 [ %add, %for.body.lr.ph ], [ %next_balance.1, %for.inc ]
  %has_blocked_load.0.off036 = phi i1 [ false, %for.body.lr.ph ], [ %has_blocked_load.3.off0, %for.inc ]
  %update_next_balance.035 = phi i32 [ 0, %for.body.lr.ph ], [ %update_next_balance.1, %for.inc ]
  %balance_cpu.033 = phi i32 [ %call, %for.body.lr.ph ], [ %call127, %for.inc ]
  %call70 = tail call i32 @idle_cpu(i32 noundef %balance_cpu.033) #20
  %tobool71.not = icmp eq i32 %call70, 0
  br i1 %tobool71.not, label %for.inc, label %if.end73

if.end73:                                         ; preds = %for.body
  %5 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i = and i32 %5, -16384
  %6 = inttoptr i32 %and.i.i to ptr
  %7 = ptrtoint ptr %6 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load volatile i32, ptr %6, align 16384
  %9 = and i32 %8, 2
  %tobool.i.not = icmp eq i32 %9, 0
  br i1 %tobool.i.not, label %do.body94, label %if.then75

if.then75:                                        ; preds = %if.end73
  %not.tobool36.not = xor i1 %tobool36.not, true
  %spec.select = select i1 %not.tobool36.not, i1 true, i1 %has_blocked_load.0.off036
  br i1 %tobool49.not, label %abort, label %do.body87

do.body87:                                        ; preds = %if.then75
  store volatile i32 1, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 3), align 4
  br i1 %spec.select, label %do.body158, label %if.end163

do.body94:                                        ; preds = %if.end73
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %balance_cpu.033
  %10 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %arrayidx, align 4
  %add99 = add i32 %11, ptrtoint (ptr @runqueues to i32)
  %12 = inttoptr i32 %add99 to ptr
  br i1 %tobool36.not, label %if.end108, label %if.then102

if.then102:                                       ; preds = %do.body94
  %cpu1.i = getelementptr inbounds %struct.rq, ptr %12, i32 0, i32 46
  %13 = ptrtoint ptr %cpu1.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %cpu1.i, align 4
  %has_blocked_load.i = getelementptr inbounds %struct.rq, ptr %12, i32 0, i32 3
  %15 = ptrtoint ptr %has_blocked_load.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %has_blocked_load.i, align 4
  %tobool.not.i = icmp eq i32 %16, 0
  br i1 %tobool.not.i, label %update_nohz_stats.exit, label %if.end.i

if.end.i:                                         ; preds = %if.then102
  %17 = load ptr, ptr @nohz, align 128
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %18 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i = icmp ugt i32 %18, %14
  br i1 %cmp.not.i.i.i.i, label %cpumask_test_cpu.exit.i, label %land.rhs.i.i.i.i

land.rhs.i.i.i.i:                                 ; preds = %if.end.i
  %.b37.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i, label %cpumask_test_cpu.exit.i, label %if.then.i.i.i.i, !prof !259

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpumask_test_cpu.exit.i

cpumask_test_cpu.exit.i:                          ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i.i, %if.end.i
  %div3.i.i.i = lshr i32 %14, 5
  %arrayidx.i.i.i = getelementptr i32, ptr %17, i32 %div3.i.i.i
  %19 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load volatile i32, ptr %arrayidx.i.i.i, align 4
  %and.i.i.i = and i32 %14, 31
  %21 = shl nuw i32 1, %and.i.i.i
  %22 = and i32 %20, %21
  %tobool2.not.i = icmp eq i32 %22, 0
  br i1 %tobool2.not.i, label %update_nohz_stats.exit, label %do.end.i

do.end.i:                                         ; preds = %cpumask_test_cpu.exit.i
  %last_blocked_load_update_tick.i = getelementptr inbounds %struct.rq, ptr %12, i32 0, i32 2
  %23 = ptrtoint ptr %last_blocked_load_update_tick.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load volatile i32, ptr %last_blocked_load_update_tick.i, align 16
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %25 = load volatile i32, ptr @jiffies, align 128
  %sub.i = sub i32 %24, %25
  %cmp.i = icmp slt i32 %sub.i, 0
  br i1 %cmp.i, label %if.end6.i, label %update_nohz_stats.exit

if.end6.i:                                        ; preds = %do.end.i
  tail call fastcc void @update_blocked_averages(i32 noundef %14) #20
  %26 = ptrtoint ptr %has_blocked_load.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %has_blocked_load.i, align 4
  %tobool8.i = icmp ne i32 %27, 0
  br label %update_nohz_stats.exit

update_nohz_stats.exit:                           ; preds = %if.end6.i, %do.end.i, %cpumask_test_cpu.exit.i, %if.then102
  %retval.0.i = phi i1 [ %tobool8.i, %if.end6.i ], [ false, %if.then102 ], [ false, %cpumask_test_cpu.exit.i ], [ true, %do.end.i ]
  %or11 = or i1 %has_blocked_load.0.off036, %retval.0.i
  br label %if.end108

if.end108:                                        ; preds = %update_nohz_stats.exit, %do.body94
  %has_blocked_load.2.off0 = phi i1 [ %or11, %update_nohz_stats.exit ], [ %has_blocked_load.0.off036, %do.body94 ]
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %28 = load volatile i32, ptr @jiffies, align 128
  %next_balance109 = getelementptr inbounds %struct.rq, ptr %12, i32 0, i32 23
  %29 = ptrtoint ptr %next_balance109 to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %next_balance109, align 4
  %sub110 = sub i32 %28, %30
  %cmp111 = icmp sgt i32 %sub110, -1
  br i1 %cmp111, label %if.then113, label %if.end118

if.then113:                                       ; preds = %if.end108
  %31 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #20, !srcloc !279
  %and.i.i.i15 = and i32 %31, 128
  %tobool.not.i.i = icmp eq i32 %and.i.i.i15, 0
  br i1 %tobool.not.i.i, label %if.then.i.i, label %_raw_spin_rq_lock_irqsave.exit.i

if.then.i.i:                                      ; preds = %if.then113
  tail call void @trace_hardirqs_off() #20
  br label %_raw_spin_rq_lock_irqsave.exit.i

_raw_spin_rq_lock_irqsave.exit.i:                 ; preds = %if.then.i.i, %if.then113
  tail call void @raw_spin_rq_lock_nested(ptr noundef %12, i32 noundef 0) #20
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %12, i32 0, i32 81
  %32 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %33, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %_raw_spin_rq_lock_irqsave.exit.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %12, i32 0, i32 79
  %34 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %_raw_spin_rq_lock_irqsave.exit.i
  %retval.0.i.i.i = phi ptr [ %35, %if.then.i.i.i ], [ %12, %_raw_spin_rq_lock_irqsave.exit.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call1.i.i = tail call i32 @lock_pin_lock(ptr noundef %dep_map.i.i) #20
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %12, i32 0, i32 25
  %36 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load i32, ptr %clock_update_flags.i.i, align 4
  %and.i.i16 = and i32 %37, 3
  store i32 %and.i.i16, ptr %clock_update_flags.i.i, align 4
  %balance_callback.i.i = getelementptr inbounds %struct.rq, ptr %12, i32 0, i32 39
  %38 = ptrtoint ptr %balance_callback.i.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load ptr, ptr %balance_callback.i.i, align 8
  %tobool.not.i3.i = icmp ne ptr %39, null
  %cmp.i.i = icmp ne ptr %39, @balance_push_callback
  %spec.select.i.i = and i1 %tobool.not.i3.i, %cmp.i.i
  br i1 %spec.select.i.i, label %land.rhs6.i.i, label %rq_lock_irqsave.exit

land.rhs6.i.i:                                    ; preds = %__rq_lockp.exit.i.i
  %.b48.i.i = load i1, ptr @rq_pin_lock.__already_done, align 1
  br i1 %.b48.i.i, label %rq_lock_irqsave.exit, label %if.then.i4.i, !prof !259

if.then.i4.i:                                     ; preds = %land.rhs6.i.i
  store i1 true, ptr @rq_pin_lock.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1545, i32 noundef 9, ptr noundef nonnull @.str.35) #20
  br label %rq_lock_irqsave.exit

rq_lock_irqsave.exit:                             ; preds = %if.then.i4.i, %land.rhs6.i.i, %__rq_lockp.exit.i.i
  tail call void @update_rq_clock(ptr noundef %12) #20
  %40 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i21 = icmp eq i32 %41, 0
  br i1 %tobool.not.i.i.i21, label %rq_unpin_lock.exit.i, label %if.then.i.i.i23

if.then.i.i.i23:                                  ; preds = %rq_lock_irqsave.exit
  %core.i.i.i22 = getelementptr inbounds %struct.rq, ptr %12, i32 0, i32 79
  %42 = ptrtoint ptr %core.i.i.i22 to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load ptr, ptr %core.i.i.i22, align 8
  br label %rq_unpin_lock.exit.i

rq_unpin_lock.exit.i:                             ; preds = %if.then.i.i.i23, %rq_lock_irqsave.exit
  %retval.0.i.i.i24 = phi ptr [ %43, %if.then.i.i.i23 ], [ %12, %rq_lock_irqsave.exit ]
  %dep_map.i.i25 = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i24, i32 0, i32 4
  %44 = insertvalue [1 x i32] undef, i32 %call1.i.i, 0
  tail call void @lock_unpin_lock(ptr noundef %dep_map.i.i25, [1 x i32] %44) #20
  tail call void @raw_spin_rq_unlock(ptr noundef %12) #20
  br i1 %tobool.not.i.i, label %if.then.i3.i, label %do.body2.i.i

if.then.i3.i:                                     ; preds = %rq_unpin_lock.exit.i
  tail call void @trace_hardirqs_on() #20
  br label %do.body2.i.i

do.body2.i.i:                                     ; preds = %if.then.i3.i, %rq_unpin_lock.exit.i
  %45 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #20, !srcloc !280
  %and.i.i.i.i = and i32 %45, 128
  %tobool10.not.i.i = icmp eq i32 %and.i.i.i.i, 0
  br i1 %tobool10.not.i.i, label %if.then14.i.i, label %rq_unlock_irqrestore.exit, !prof !260

if.then14.i.i:                                    ; preds = %do.body2.i.i
  tail call void @warn_bogus_irq_restore() #20
  br label %rq_unlock_irqrestore.exit

rq_unlock_irqrestore.exit:                        ; preds = %if.then14.i.i, %do.body2.i.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %31) #20, !srcloc !281
  br i1 %tobool115.not, label %if.end118, label %if.then116

if.then116:                                       ; preds = %rq_unlock_irqrestore.exit
  tail call fastcc void @rebalance_domains(ptr noundef %12, i32 noundef 0)
  br label %if.end118

if.end118:                                        ; preds = %if.then116, %rq_unlock_irqrestore.exit, %if.end108
  %46 = ptrtoint ptr %next_balance109 to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load i32, ptr %next_balance109, align 4
  %sub120 = sub i32 %47, %next_balance.037
  %cmp121 = icmp slt i32 %sub120, 0
  %spec.select13 = select i1 %cmp121, i32 1, i32 %update_next_balance.035
  %spec.select14 = select i1 %cmp121, i32 %47, i32 %next_balance.037
  br label %for.inc

for.inc:                                          ; preds = %if.end118, %for.body
  %update_next_balance.1 = phi i32 [ %update_next_balance.035, %for.body ], [ %spec.select13, %if.end118 ]
  %has_blocked_load.3.off0 = phi i1 [ %has_blocked_load.0.off036, %for.body ], [ %has_blocked_load.2.off0, %if.end118 ]
  %next_balance.1 = phi i32 [ %next_balance.037, %for.body ], [ %spec.select14, %if.end118 ]
  %48 = load ptr, ptr @nohz, align 128
  %call127 = tail call i32 @cpumask_next_wrap(i32 noundef %balance_cpu.033, ptr noundef %48, i32 noundef %add67, i1 noundef zeroext true) #20
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %49 = load i32, ptr @nr_cpu_ids, align 4
  %cmp69 = icmp ult i32 %call127, %49
  br i1 %cmp69, label %for.body, label %for.end

for.end:                                          ; preds = %for.inc
  %tobool128.not = icmp eq i32 %update_next_balance.1, 0
  br i1 %tobool128.not, label %if.end136, label %if.then135, !prof !260

if.then135:                                       ; preds = %for.end
  store i32 %next_balance.1, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 4), align 16
  br label %if.end136

if.end136:                                        ; preds = %if.then135, %for.end
  br i1 %tobool36.not, label %abort, label %do.body144

if.end136.thread:                                 ; preds = %do.end64
  br i1 %tobool36.not, label %if.end163, label %do.body144.thread

do.body144.thread:                                ; preds = %if.end136.thread
  %add14649 = add i32 %0, 4
  store volatile i32 %add14649, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 5), align 4
  br label %if.end163

do.body144:                                       ; preds = %if.end136
  %add146 = add i32 %0, 4
  store volatile i32 %add146, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 5), align 4
  br i1 %has_blocked_load.3.off0, label %do.body158, label %if.end163

abort:                                            ; preds = %if.end136, %if.then75
  %has_blocked_load.4.off0 = phi i1 [ %spec.select, %if.then75 ], [ %has_blocked_load.3.off0, %if.end136 ]
  br i1 %has_blocked_load.4.off0, label %do.body158, label %if.end163

do.body158:                                       ; preds = %abort, %do.body144, %do.body87
  store volatile i32 1, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 2), align 8
  br label %if.end163

if.end163:                                        ; preds = %do.body158, %abort, %do.body144, %do.body144.thread, %if.end136.thread, %do.body87
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @trigger_load_balance(ptr noundef %rq) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %sd.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 36
  %0 = ptrtoint ptr %sd.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile ptr, ptr %sd.i, align 4
  %call.i = tail call i32 @rcu_read_lock_sched_held() #20
  %tobool.not.i = icmp eq i32 %call.i, 0
  br i1 %tobool.not.i, label %land.lhs.true.i, label %on_null_domain.exit

land.lhs.true.i:                                  ; preds = %entry
  %call2.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool3.not.i = icmp eq i32 %call2.i, 0
  br i1 %tobool3.not.i, label %on_null_domain.exit, label %land.lhs.true4.i

land.lhs.true4.i:                                 ; preds = %land.lhs.true.i
  %.b12.i = load i1, ptr @on_null_domain.__warned, align 1
  br i1 %.b12.i, label %on_null_domain.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true4.i
  store i1 true, ptr @on_null_domain.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 10345, ptr noundef nonnull @.str.16) #20
  br label %on_null_domain.exit

on_null_domain.exit:                              ; preds = %if.then.i, %land.lhs.true4.i, %land.lhs.true.i, %entry
  %tobool9.not.i.not = icmp eq ptr %1, null
  br i1 %tobool9.not.i.not, label %return, label %lor.rhs, !prof !260

lor.rhs:                                          ; preds = %on_null_domain.exit
  %cpu.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 46
  %2 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu.i, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %4 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i = icmp ugt i32 %4, %3
  br i1 %cmp.not.i.i.i.i, label %cpu_active.exit, label %land.rhs.i.i.i.i

land.rhs.i.i.i.i:                                 ; preds = %lor.rhs
  %.b37.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i, label %cpu_active.exit, label %if.then.i.i.i.i, !prof !259

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_active.exit

cpu_active.exit:                                  ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i.i, %lor.rhs
  %div3.i.i.i = lshr i32 %3, 5
  %arrayidx.i.i.i = getelementptr i32, ptr @__cpu_active_mask, i32 %div3.i.i.i
  %5 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %arrayidx.i.i.i, align 4
  %and.i.i.i = and i32 %3, 31
  %7 = shl nuw i32 1, %and.i.i.i
  %8 = and i32 %6, %7
  %tobool.i.not = icmp eq i32 %8, 0
  br i1 %tobool.i.not, label %return, label %if.end, !prof !260

if.end:                                           ; preds = %cpu_active.exit
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %9 = load volatile i32, ptr @jiffies, align 128
  %next_balance = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 23
  %10 = ptrtoint ptr %next_balance to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %next_balance, align 4
  %sub = sub i32 %9, %11
  %cmp = icmp sgt i32 %sub, -1
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  tail call void @raise_softirq(i32 noundef 7) #20
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %12 = load volatile i32, ptr @jiffies, align 128
  %13 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %cpu.i, align 4
  %idle_balance.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 41
  %15 = ptrtoint ptr %idle_balance.i to i32
  call void @__asan_load1_noabort(i32 %15)
  %16 = load i8, ptr %idle_balance.i, align 1
  %tobool.not.i11 = icmp eq i8 %16, 0
  br i1 %tobool.not.i11, label %if.end.i, label %return, !prof !259

if.end.i:                                         ; preds = %if.end7
  tail call void @nohz_balance_exit_idle(ptr noundef %rq) #20
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 1), i32 noundef 4) #20
  %17 = load volatile i32, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 1), align 4
  %tobool4.not.i = icmp eq i32 %17, 0
  br i1 %tobool4.not.i, label %return, label %do.end.i, !prof !259

do.end.i:                                         ; preds = %if.end.i
  %18 = load volatile i32, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 2), align 8
  %tobool15.not.i = icmp eq i32 %18, 0
  br i1 %tobool15.not.i, label %if.end21.i, label %do.end18.i

do.end18.i:                                       ; preds = %do.end.i
  %19 = load volatile i32, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 5), align 4
  %sub.i = sub i32 %19, %12
  %20 = lshr i32 %sub.i, 30
  %21 = and i32 %20, 2
  br label %if.end21.i

if.end21.i:                                       ; preds = %do.end18.i, %do.end.i
  %flags.0.i = phi i32 [ 0, %do.end.i ], [ %21, %do.end18.i ]
  %22 = load i32, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 4), align 16
  %sub22.i = sub i32 %12, %22
  %cmp23.i = icmp slt i32 %sub22.i, 0
  br i1 %cmp23.i, label %do.end155.i, label %if.end25.i

if.end25.i:                                       ; preds = %if.end21.i
  %nr_running.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 1
  %23 = ptrtoint ptr %nr_running.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %nr_running.i, align 4
  %cmp26.i = icmp ugt i32 %24, 1
  br i1 %cmp26.i, label %do.end155.i, label %if.end28.i

if.end28.i:                                       ; preds = %if.end25.i
  %25 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i.i = and i32 %25, -16384
  %26 = inttoptr i32 %and.i.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %26, i32 0, i32 1
  %27 = ptrtoint ptr %preempt_count.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load volatile i32, ptr %preempt_count.i.i.i.i.i, align 4
  %add.i.i.i.i = add i32 %28, 1
  store volatile i32 %add.i.i.i.i, ptr %preempt_count.i.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !268
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #20
  %call.i.i = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i.i, label %rcu_read_lock.exit.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.end28.i
  %call1.i.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i.i = icmp eq i32 %call1.i.i, 0
  br i1 %tobool.not.i.i, label %rcu_read_lock.exit.i, label %land.lhs.true2.i.i

land.lhs.true2.i.i:                               ; preds = %land.lhs.true.i.i
  %.b4.i.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i.i, label %rcu_read_lock.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true2.i.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 696, ptr noundef nonnull @.str.28) #20
  br label %rcu_read_lock.exit.i

rcu_read_lock.exit.i:                             ; preds = %if.then.i.i, %land.lhs.true2.i.i, %land.lhs.true.i.i, %if.end28.i
  %29 = ptrtoint ptr %sd.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load volatile ptr, ptr %sd.i, align 4
  %call35.i = tail call i32 @rcu_read_lock_held() #20
  %tobool36.not.i = icmp eq i32 %call35.i, 0
  br i1 %tobool36.not.i, label %land.lhs.true37.i, label %do.end45.i

land.lhs.true37.i:                                ; preds = %rcu_read_lock.exit.i
  %call38.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool39.not.i = icmp eq i32 %call38.i, 0
  br i1 %tobool39.not.i, label %do.end45.i, label %land.lhs.true40.i

land.lhs.true40.i:                                ; preds = %land.lhs.true37.i
  %.b199.i = load i1, ptr @nohz_balancer_kick.__warned, align 1
  br i1 %.b199.i, label %do.end45.i, label %if.then42.i

if.then42.i:                                      ; preds = %land.lhs.true40.i
  store i1 true, ptr @nohz_balancer_kick.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 10455, ptr noundef nonnull @.str.16) #20
  br label %do.end45.i

do.end45.i:                                       ; preds = %if.then42.i, %land.lhs.true40.i, %land.lhs.true37.i, %rcu_read_lock.exit.i
  %tobool47.not.i = icmp eq ptr %30, null
  br i1 %tobool47.not.i, label %if.end55.i, label %if.then48.i

if.then48.i:                                      ; preds = %do.end45.i
  %h_nr_running.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 14, i32 2
  %31 = ptrtoint ptr %h_nr_running.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %h_nr_running.i, align 4
  %cmp49.not.i = icmp eq i32 %32, 0
  br i1 %cmp49.not.i, label %if.end55.i, label %land.lhs.true50.i

land.lhs.true50.i:                                ; preds = %if.then48.i
  %cpu_capacity.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 37
  %33 = ptrtoint ptr %cpu_capacity.i.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %cpu_capacity.i.i, align 16
  %imbalance_pct.i.i = getelementptr inbounds %struct.sched_domain, ptr %30, i32 0, i32 6
  %35 = ptrtoint ptr %imbalance_pct.i.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %imbalance_pct.i.i, align 8
  %mul.i.i = mul i32 %36, %34
  %cpu_capacity_orig.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 38
  %37 = ptrtoint ptr %cpu_capacity_orig.i.i to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %cpu_capacity_orig.i.i, align 4
  %mul1.i.i = mul i32 %38, 100
  %cmp.i.not.i = icmp ult i32 %mul.i.i, %mul1.i.i
  br i1 %cmp.i.not.i, label %unlock.i, label %if.end55.i

if.end55.i:                                       ; preds = %land.lhs.true50.i, %if.then48.i, %do.end45.i
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %14
  %39 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %40, ptrtoint (ptr @sd_asym_packing to i32)
  %41 = inttoptr i32 %add.i to ptr
  %42 = ptrtoint ptr %41 to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load volatile ptr, ptr %41, align 4
  %call66.i = tail call i32 @rcu_read_lock_held() #20
  %tobool67.not.i = icmp eq i32 %call66.i, 0
  br i1 %tobool67.not.i, label %land.lhs.true68.i, label %do.end76.i

land.lhs.true68.i:                                ; preds = %if.end55.i
  %call69.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool70.not.i = icmp eq i32 %call69.i, 0
  br i1 %tobool70.not.i, label %do.end76.i, label %land.lhs.true71.i

land.lhs.true71.i:                                ; preds = %land.lhs.true68.i
  %.b193198.i = load i1, ptr @nohz_balancer_kick.__warned.37, align 1
  br i1 %.b193198.i, label %do.end76.i, label %if.then73.i

if.then73.i:                                      ; preds = %land.lhs.true71.i
  store i1 true, ptr @nohz_balancer_kick.__warned.37, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 10468, ptr noundef nonnull @.str.16) #20
  br label %do.end76.i

do.end76.i:                                       ; preds = %if.then73.i, %land.lhs.true71.i, %land.lhs.true68.i, %if.end55.i
  %tobool78.not.i = icmp eq ptr %43, null
  br i1 %tobool78.not.i, label %if.end86.i, label %for.cond.preheader.i

for.cond.preheader.i:                             ; preds = %do.end76.i
  %span.i.i = getelementptr inbounds %struct.sched_domain, ptr %43, i32 0, i32 41
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %for.cond.preheader.i
  %i.0.i = phi i32 [ %call81.i, %for.body.i ], [ -1, %for.cond.preheader.i ]
  %44 = load ptr, ptr @nohz, align 128
  %call81.i = tail call i32 @cpumask_next_and(i32 noundef %i.0.i, ptr noundef %span.i.i, ptr noundef %44) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %45 = load i32, ptr @nr_cpu_ids, align 4
  %cmp82.i = icmp ult i32 %call81.i, %45
  br i1 %cmp82.i, label %for.body.i, label %if.end86.i

for.body.i:                                       ; preds = %for.cond.i
  %call.i204.i = tail call i32 @arch_asym_cpu_priority(i32 noundef %call81.i) #20
  %call1.i205.i = tail call i32 @arch_asym_cpu_priority(i32 noundef %14) #20
  %cmp.i206.i = icmp sgt i32 %call.i204.i, %call1.i205.i
  br i1 %cmp.i206.i, label %unlock.i, label %for.cond.i

if.end86.i:                                       ; preds = %for.cond.i, %do.end76.i
  %46 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load i32, ptr %arrayidx.i, align 4
  %add99.i = add i32 %47, ptrtoint (ptr @sd_asym_cpucapacity to i32)
  %48 = inttoptr i32 %add99.i to ptr
  %49 = ptrtoint ptr %48 to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load volatile ptr, ptr %48, align 4
  %call101.i = tail call i32 @rcu_read_lock_held() #20
  %tobool102.not.i = icmp eq i32 %call101.i, 0
  br i1 %tobool102.not.i, label %land.lhs.true103.i, label %do.end111.i

land.lhs.true103.i:                               ; preds = %if.end86.i
  %call104.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool105.not.i = icmp eq i32 %call104.i, 0
  br i1 %tobool105.not.i, label %do.end111.i, label %land.lhs.true106.i

land.lhs.true106.i:                               ; preds = %land.lhs.true103.i
  %.b194197.i = load i1, ptr @nohz_balancer_kick.__warned.38, align 1
  br i1 %.b194197.i, label %do.end111.i, label %if.then108.i

if.then108.i:                                     ; preds = %land.lhs.true106.i
  store i1 true, ptr @nohz_balancer_kick.__warned.38, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 10483, ptr noundef nonnull @.str.16) #20
  br label %do.end111.i

do.end111.i:                                      ; preds = %if.then108.i, %land.lhs.true106.i, %land.lhs.true103.i, %if.end86.i
  %tobool113.not.i = icmp eq ptr %50, null
  br i1 %tobool113.not.i, label %if.end119.i, label %if.then114.i

if.then114.i:                                     ; preds = %do.end111.i
  %misfit_task_load.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 42
  %51 = ptrtoint ptr %misfit_task_load.i.i to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load i32, ptr %misfit_task_load.i.i, align 64
  %tobool.not.i207.i = icmp eq i32 %52, 0
  br i1 %tobool.not.i207.i, label %check_misfit_status.exit.thread.i, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %if.then114.i
  %cpu_capacity_orig.i208.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 38
  %53 = ptrtoint ptr %cpu_capacity_orig.i208.i to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load i32, ptr %cpu_capacity_orig.i208.i, align 4
  %rd.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 35
  %55 = ptrtoint ptr %rd.i.i to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load ptr, ptr %rd.i.i, align 8
  %max_cpu_capacity.i.i = getelementptr inbounds %struct.root_domain, ptr %56, i32 0, i32 20
  %57 = ptrtoint ptr %max_cpu_capacity.i.i to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load i32, ptr %max_cpu_capacity.i.i, align 4
  %cmp.i209.i = icmp ult i32 %54, %58
  br i1 %cmp.i209.i, label %unlock.i, label %check_misfit_status.exit.i

check_misfit_status.exit.i:                       ; preds = %land.rhs.i.i
  %cpu_capacity.i.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 37
  %59 = ptrtoint ptr %cpu_capacity.i.i.i to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load i32, ptr %cpu_capacity.i.i.i, align 16
  %imbalance_pct.i.i.i = getelementptr inbounds %struct.sched_domain, ptr %50, i32 0, i32 6
  %61 = ptrtoint ptr %imbalance_pct.i.i.i to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load i32, ptr %imbalance_pct.i.i.i, align 8
  %mul.i.i.i = mul i32 %62, %60
  %mul1.i.i.i = mul i32 %54, 100
  %cmp.i.i.not.i = icmp ult i32 %mul.i.i.i, %mul1.i.i.i
  br i1 %cmp.i.i.not.i, label %unlock.i, label %check_misfit_status.exit.thread.i

check_misfit_status.exit.thread.i:                ; preds = %check_misfit_status.exit.i, %if.then114.i
  br label %unlock.i

if.end119.i:                                      ; preds = %do.end111.i
  %63 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load i32, ptr %arrayidx.i, align 4
  %add132.i = add i32 %64, ptrtoint (ptr @sd_llc_shared to i32)
  %65 = inttoptr i32 %add132.i to ptr
  %66 = ptrtoint ptr %65 to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load volatile ptr, ptr %65, align 4
  %call134.i = tail call i32 @rcu_read_lock_held() #20
  %tobool135.not.i = icmp eq i32 %call134.i, 0
  br i1 %tobool135.not.i, label %land.lhs.true136.i, label %do.end144.i

land.lhs.true136.i:                               ; preds = %if.end119.i
  %call137.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool138.not.i = icmp eq i32 %call137.i, 0
  br i1 %tobool138.not.i, label %do.end144.i, label %land.lhs.true139.i

land.lhs.true139.i:                               ; preds = %land.lhs.true136.i
  %.b195196.i = load i1, ptr @nohz_balancer_kick.__warned.39, align 1
  br i1 %.b195196.i, label %do.end144.i, label %if.then141.i

if.then141.i:                                     ; preds = %land.lhs.true139.i
  store i1 true, ptr @nohz_balancer_kick.__warned.39, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 10504, ptr noundef nonnull @.str.16) #20
  br label %do.end144.i

do.end144.i:                                      ; preds = %if.then141.i, %land.lhs.true139.i, %land.lhs.true136.i, %if.end119.i
  %tobool146.not.i = icmp eq ptr %67, null
  br i1 %tobool146.not.i, label %unlock.i, label %if.then147.i

if.then147.i:                                     ; preds = %do.end144.i
  %nr_busy_cpus.i = getelementptr inbounds %struct.sched_domain_shared, ptr %67, i32 0, i32 1
  %call.i.i203.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %nr_busy_cpus.i, i32 noundef 4) #20
  %68 = ptrtoint ptr %nr_busy_cpus.i to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load volatile i32, ptr %nr_busy_cpus.i, align 4
  %cmp149.i = icmp sgt i32 %69, 1
  %spec.select201.i = select i1 %cmp149.i, i32 3, i32 %flags.0.i
  br label %unlock.i

unlock.i:                                         ; preds = %if.then147.i, %do.end144.i, %check_misfit_status.exit.thread.i, %check_misfit_status.exit.i, %land.rhs.i.i, %for.body.i, %land.lhs.true50.i
  %flags.1.i = phi i32 [ %flags.0.i, %do.end144.i ], [ 3, %land.lhs.true50.i ], [ %spec.select201.i, %if.then147.i ], [ %flags.0.i, %check_misfit_status.exit.thread.i ], [ 3, %check_misfit_status.exit.i ], [ 3, %land.rhs.i.i ], [ 3, %for.body.i ]
  %call.i22 = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i22, label %rcu_read_unlock.exit, label %land.lhs.true.i24

land.lhs.true.i24:                                ; preds = %unlock.i
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i23 = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i23, label %rcu_read_unlock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i24
  %.b4.i = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_unlock.exit, label %if.then.i25

if.then.i25:                                      ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i25, %land.lhs.true2.i, %land.lhs.true.i24, %unlock.i
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %70 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i = and i32 %70, -16384
  %71 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %71, i32 0, i32 1
  %72 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %72)
  %73 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %sub.i.i.i = add i32 %73, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  br label %do.end155.i

do.end155.i:                                      ; preds = %rcu_read_unlock.exit, %if.end25.i, %if.end21.i
  %flags.2.i = phi i32 [ %flags.0.i, %if.end21.i ], [ %flags.1.i, %rcu_read_unlock.exit ], [ 3, %if.end25.i ]
  %74 = load volatile i32, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 3), align 4
  %tobool157.not.i = icmp eq i32 %74, 0
  %or.i = or i32 %flags.2.i, 8
  %spec.select202.i = select i1 %tobool157.not.i, i32 %flags.2.i, i32 %or.i
  %tobool160.not.i = icmp eq i32 %spec.select202.i, 0
  br i1 %tobool160.not.i, label %return, label %if.then161.i

if.then161.i:                                     ; preds = %do.end155.i
  %and.i = and i32 %spec.select202.i, 1
  %tobool.not.i12 = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i12, label %if.end.i16, label %if.then.i14

if.then.i14:                                      ; preds = %if.then161.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %75 = load volatile i32, ptr @jiffies, align 128
  %add.i13 = add i32 %75, 1
  store i32 %add.i13, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 4), align 16
  br label %if.end.i16

if.end.i16:                                       ; preds = %if.then.i14, %if.then161.i
  %call.i.i15 = tail call ptr @housekeeping_cpumask(i32 noundef 4) #20
  %76 = load ptr, ptr @nohz, align 128
  %call112.i.i = tail call i32 @cpumask_next_and(i32 noundef -1, ptr noundef %76, ptr noundef %call.i.i15) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %77 = load i32, ptr @nr_cpu_ids, align 4
  %cmp13.i.i = icmp ult i32 %call112.i.i, %77
  br i1 %cmp13.i.i, label %for.body.i.i, label %find_new_ilb.exit.i

for.body.i.i:                                     ; preds = %for.cond.backedge.i.i, %if.end.i16
  %call114.i.i = phi i32 [ %call1.i.i18, %for.cond.backedge.i.i ], [ %call112.i.i, %if.end.i16 ]
  %78 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i17 = and i32 %78, -16384
  %79 = inttoptr i32 %and.i.i.i17 to ptr
  %cpu.i.i = getelementptr inbounds %struct.thread_info, ptr %79, i32 0, i32 3
  %80 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load i32, ptr %cpu.i.i, align 4
  %cmp3.i.i = icmp eq i32 %call114.i.i, %81
  br i1 %cmp3.i.i, label %for.cond.backedge.i.i, label %if.end.i.i

for.cond.backedge.i.i:                            ; preds = %if.end.i.i, %for.body.i.i
  %82 = load ptr, ptr @nohz, align 128
  %call1.i.i18 = tail call i32 @cpumask_next_and(i32 noundef %call114.i.i, ptr noundef %82, ptr noundef %call.i.i15) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %83 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.i.i = icmp ult i32 %call1.i.i18, %83
  br i1 %cmp.i.i, label %for.body.i.i, label %find_new_ilb.exit.i

if.end.i.i:                                       ; preds = %for.body.i.i
  %call4.i.i = tail call i32 @idle_cpu(i32 noundef %call114.i.i) #20
  %tobool.not.i.i19 = icmp eq i32 %call4.i.i, 0
  br i1 %tobool.not.i.i19, label %for.cond.backedge.i.i, label %find_new_ilb.exit.i

find_new_ilb.exit.i:                              ; preds = %if.end.i.i, %for.cond.backedge.i.i, %if.end.i16
  %retval.0.i.i = phi i32 [ %77, %if.end.i16 ], [ %83, %for.cond.backedge.i.i ], [ %call114.i.i, %if.end.i.i ]
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %84 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i = icmp ult i32 %retval.0.i.i, %84
  br i1 %cmp.not.i, label %if.end2.i, label %return

if.end2.i:                                        ; preds = %find_new_ilb.exit.i
  %arrayidx.i20 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %retval.0.i.i
  %85 = ptrtoint ptr %arrayidx.i20 to i32
  call void @__asan_load4_noabort(i32 %85)
  %86 = load i32, ptr %arrayidx.i20, align 4
  %add4.i = add i32 %86, ptrtoint (ptr @runqueues to i32)
  %87 = inttoptr i32 %add4.i to ptr
  %nohz_flags.i = getelementptr inbounds %struct.rq, ptr %87, i32 0, i32 7
  %call.i.i.i21 = tail call zeroext i1 @__kasan_check_write(ptr noundef %nohz_flags.i, i32 noundef 4) #20
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !282
  tail call void @llvm.prefetch.p0(ptr %nohz_flags.i, i32 1, i32 3, i32 1) #20
  %88 = tail call { i32, i32, i32 } asm sideeffect "@ atomic_fetch_or\0A1:\09ldrex\09$0, [$4]\0A\09orr\09$1, $0, $5\0A\09strex\09$2, $1, [$4]\0A\09teq\09$2, #0\0A\09bne\091b", "=&r,=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %nohz_flags.i, ptr %nohz_flags.i, i32 %spec.select202.i, ptr elementtype(i32) %nohz_flags.i) #20, !srcloc !283
  %asmresult.i.i.i.i = extractvalue { i32, i32, i32 } %88, 0
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !284
  %and6.i = and i32 %asmresult.i.i.i.i, 11
  %tobool7.not.i = icmp eq i32 %and6.i, 0
  br i1 %tobool7.not.i, label %if.end9.i, label %return

if.end9.i:                                        ; preds = %if.end2.i
  %89 = ptrtoint ptr %arrayidx.i20 to i32
  call void @__asan_load4_noabort(i32 %89)
  %90 = load i32, ptr %arrayidx.i20, align 4
  %add18.i = add i32 %90, ptrtoint (ptr @runqueues to i32)
  %91 = inttoptr i32 %add18.i to ptr
  %nohz_csd.i = getelementptr inbounds %struct.rq, ptr %91, i32 0, i32 5
  %call19.i = tail call i32 @smp_call_function_single_async(i32 noundef %retval.0.i.i, ptr noundef %nohz_csd.i) #20
  br label %return

return:                                           ; preds = %if.end9.i, %if.end2.i, %find_new_ilb.exit.i, %do.end155.i, %if.end.i, %if.end7, %cpu_active.exit, %on_null_domain.exit
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @raise_softirq(i32 noundef) local_unnamed_addr #4

; Function Attrs: nofree norecurse nosync nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @task_vruntime_update(ptr nocapture noundef readonly %rq, ptr noundef readonly %p, i1 noundef zeroext %in_fi) local_unnamed_addr #9 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %sched_class = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 21
  %0 = ptrtoint ptr %sched_class to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %sched_class, align 32
  %cmp.not = icmp eq ptr %1, @fair_sched_class
  br i1 %cmp.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %se1 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %core = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 79
  %2 = ptrtoint ptr %core to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %core, align 8
  %core_forceidle_seq = getelementptr inbounds %struct.rq, ptr %3, i32 0, i32 88
  %4 = ptrtoint ptr %core_forceidle_seq to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %core_forceidle_seq, align 4
  %tobool.not13.i = icmp eq ptr %se1, null
  br i1 %tobool.not13.i, label %cleanup, label %for.body.i

for.body.i:                                       ; preds = %for.inc.i, %if.end
  %se.addr.014.i = phi ptr [ %15, %for.inc.i ], [ %se1, %if.end ]
  %cfs_rq.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.014.i, i32 0, i32 11
  %6 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %cfs_rq.i.i, align 16
  br i1 %in_fi, label %if.then.i, label %for.inc.i

if.then.i:                                        ; preds = %for.body.i
  %forceidle_seq.i = getelementptr inbounds %struct.cfs_rq, ptr %7, i32 0, i32 7
  %8 = ptrtoint ptr %forceidle_seq.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %forceidle_seq.i, align 8
  %cmp.i = icmp eq i32 %9, %5
  br i1 %cmp.i, label %cleanup, label %if.end.i

if.end.i:                                         ; preds = %if.then.i
  %10 = ptrtoint ptr %forceidle_seq.i to i32
  call void @__asan_store4_noabort(i32 %10)
  store i32 %5, ptr %forceidle_seq.i, align 8
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.end.i, %for.body.i
  %min_vruntime.i = getelementptr inbounds %struct.cfs_rq, ptr %7, i32 0, i32 6
  %11 = ptrtoint ptr %min_vruntime.i to i32
  call void @__asan_load8_noabort(i32 %11)
  %12 = load i64, ptr %min_vruntime.i, align 32
  %min_vruntime_fi.i = getelementptr inbounds %struct.cfs_rq, ptr %7, i32 0, i32 8
  %13 = ptrtoint ptr %min_vruntime_fi.i to i32
  call void @__asan_store8_noabort(i32 %13)
  store i64 %12, ptr %min_vruntime_fi.i, align 16
  %parent.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.014.i, i32 0, i32 10
  %14 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %parent.i, align 4
  %tobool.not.i = icmp eq ptr %15, null
  br i1 %tobool.not.i, label %cleanup, label %for.body.i

cleanup:                                          ; preds = %for.inc.i, %if.then.i, %if.end, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local zeroext i1 @cfs_prio_less(ptr noundef readonly %a, ptr noundef readonly %b, i1 noundef zeroext %in_fi) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %stack.i = getelementptr inbounds %struct.task_struct, ptr %a, i32 0, i32 1
  %0 = ptrtoint ptr %stack.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %stack.i, align 4
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 3
  %2 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %cpu.i, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %3
  %4 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %arrayidx, align 4
  %add = add i32 %5, ptrtoint (ptr @runqueues to i32)
  %6 = inttoptr i32 %add to ptr
  %se = getelementptr inbounds %struct.task_struct, ptr %a, i32 0, i32 18
  %se2 = getelementptr inbounds %struct.task_struct, ptr %b, i32 0, i32 18
  %stack.i97 = getelementptr inbounds %struct.task_struct, ptr %b, i32 0, i32 1
  %7 = ptrtoint ptr %stack.i97 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %stack.i97, align 4
  %cpu.i98 = getelementptr inbounds %struct.thread_info, ptr %8, i32 0, i32 3
  %9 = ptrtoint ptr %cpu.i98 to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load volatile i32, ptr %cpu.i98, align 4
  %arrayidx11 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %10
  %11 = ptrtoint ptr %arrayidx11 to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %arrayidx11, align 4
  %add12 = add i32 %12, ptrtoint (ptr @runqueues to i32)
  %13 = inttoptr i32 %add12 to ptr
  %core = getelementptr inbounds %struct.rq, ptr %13, i32 0, i32 79
  %14 = ptrtoint ptr %core to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %core, align 8
  %core13 = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 79
  %16 = ptrtoint ptr %core13 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %core13, align 8
  %cmp.not = icmp eq ptr %15, %17
  br i1 %cmp.not, label %if.end45, label %land.rhs

land.rhs:                                         ; preds = %entry
  %.b96 = load i1, ptr @cfs_prio_less.__already_done, align 1
  br i1 %.b96, label %if.end45, label %if.then, !prof !259

if.then:                                          ; preds = %land.rhs
  store i1 true, ptr @cfs_prio_less.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 11102, i32 noundef 9, ptr noundef nonnull @.str.4) #20
  br label %if.end45

if.end45:                                         ; preds = %if.then, %land.rhs, %entry
  %cfs_rq118 = getelementptr inbounds %struct.task_struct, ptr %a, i32 0, i32 18, i32 11
  %18 = ptrtoint ptr %cfs_rq118 to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load ptr, ptr %cfs_rq118, align 16
  %tg119 = getelementptr inbounds %struct.cfs_rq, ptr %19, i32 0, i32 30
  %20 = ptrtoint ptr %tg119 to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %tg119, align 4
  %cfs_rq53120 = getelementptr inbounds %struct.task_struct, ptr %b, i32 0, i32 18, i32 11
  %22 = ptrtoint ptr %cfs_rq53120 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %cfs_rq53120, align 16
  %tg54121 = getelementptr inbounds %struct.cfs_rq, ptr %23, i32 0, i32 30
  %24 = ptrtoint ptr %tg54121 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %tg54121, align 4
  %cmp55.not122 = icmp eq ptr %21, %25
  br i1 %cmp55.not122, label %while.end, label %while.body

while.body:                                       ; preds = %if.end64, %if.end45
  %sea.0124 = phi ptr [ %sea.1, %if.end64 ], [ %se, %if.end45 ]
  %seb.0123 = phi ptr [ %seb.1, %if.end64 ], [ %se2, %if.end45 ]
  %depth = getelementptr inbounds %struct.sched_entity, ptr %sea.0124, i32 0, i32 9
  %26 = ptrtoint ptr %depth to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %depth, align 8
  %depth56 = getelementptr inbounds %struct.sched_entity, ptr %seb.0123, i32 0, i32 9
  %28 = ptrtoint ptr %depth56 to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %depth56, align 8
  %cmp57.not = icmp slt i32 %27, %29
  br i1 %cmp57.not, label %if.end60, label %if.then58

if.then58:                                        ; preds = %while.body
  %parent.i = getelementptr inbounds %struct.sched_entity, ptr %sea.0124, i32 0, i32 10
  %30 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %parent.i, align 4
  br label %if.end60

if.end60:                                         ; preds = %if.then58, %while.body
  %sea.1 = phi ptr [ %31, %if.then58 ], [ %sea.0124, %while.body ]
  %cmp61.not = icmp sgt i32 %27, %29
  br i1 %cmp61.not, label %if.end64, label %if.then62

if.then62:                                        ; preds = %if.end60
  %parent.i99 = getelementptr inbounds %struct.sched_entity, ptr %seb.0123, i32 0, i32 10
  %32 = ptrtoint ptr %parent.i99 to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load ptr, ptr %parent.i99, align 4
  br label %if.end64

if.end64:                                         ; preds = %if.then62, %if.end60
  %seb.1 = phi ptr [ %33, %if.then62 ], [ %seb.0123, %if.end60 ]
  %cfs_rq = getelementptr inbounds %struct.sched_entity, ptr %sea.1, i32 0, i32 11
  %34 = ptrtoint ptr %cfs_rq to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load ptr, ptr %cfs_rq, align 16
  %tg = getelementptr inbounds %struct.cfs_rq, ptr %35, i32 0, i32 30
  %36 = ptrtoint ptr %tg to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load ptr, ptr %tg, align 4
  %cfs_rq53 = getelementptr inbounds %struct.sched_entity, ptr %seb.1, i32 0, i32 11
  %38 = ptrtoint ptr %cfs_rq53 to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load ptr, ptr %cfs_rq53, align 16
  %tg54 = getelementptr inbounds %struct.cfs_rq, ptr %39, i32 0, i32 30
  %40 = ptrtoint ptr %tg54 to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load ptr, ptr %tg54, align 4
  %cmp55.not = icmp eq ptr %37, %41
  br i1 %cmp55.not, label %while.end, label %while.body

while.end:                                        ; preds = %if.end64, %if.end45
  %sea.0.lcssa117 = phi ptr [ %se, %if.end45 ], [ %sea.1, %if.end64 ]
  %seb.0.lcssa116 = phi ptr [ %se2, %if.end45 ], [ %seb.1, %if.end64 ]
  %42 = ptrtoint ptr %core13 to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load ptr, ptr %core13, align 8
  %core_forceidle_seq = getelementptr inbounds %struct.rq, ptr %43, i32 0, i32 88
  %44 = ptrtoint ptr %core_forceidle_seq to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load i32, ptr %core_forceidle_seq, align 4
  %tobool.not13.i = icmp eq ptr %sea.0.lcssa117, null
  br i1 %tobool.not13.i, label %se_fi_update.exit, label %for.body.i

for.body.i:                                       ; preds = %for.inc.i, %while.end
  %se.addr.014.i = phi ptr [ %55, %for.inc.i ], [ %sea.0.lcssa117, %while.end ]
  %cfs_rq.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.014.i, i32 0, i32 11
  %46 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load ptr, ptr %cfs_rq.i.i, align 16
  br i1 %in_fi, label %if.then.i, label %for.inc.i

if.then.i:                                        ; preds = %for.body.i
  %forceidle_seq.i = getelementptr inbounds %struct.cfs_rq, ptr %47, i32 0, i32 7
  %48 = ptrtoint ptr %forceidle_seq.i to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load i32, ptr %forceidle_seq.i, align 8
  %cmp.i = icmp eq i32 %49, %45
  br i1 %cmp.i, label %se_fi_update.exit, label %if.end.i

if.end.i:                                         ; preds = %if.then.i
  %50 = ptrtoint ptr %forceidle_seq.i to i32
  call void @__asan_store4_noabort(i32 %50)
  store i32 %45, ptr %forceidle_seq.i, align 8
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.end.i, %for.body.i
  %min_vruntime.i = getelementptr inbounds %struct.cfs_rq, ptr %47, i32 0, i32 6
  %51 = ptrtoint ptr %min_vruntime.i to i32
  call void @__asan_load8_noabort(i32 %51)
  %52 = load i64, ptr %min_vruntime.i, align 32
  %min_vruntime_fi.i = getelementptr inbounds %struct.cfs_rq, ptr %47, i32 0, i32 8
  %53 = ptrtoint ptr %min_vruntime_fi.i to i32
  call void @__asan_store8_noabort(i32 %53)
  store i64 %52, ptr %min_vruntime_fi.i, align 16
  %parent.i100 = getelementptr inbounds %struct.sched_entity, ptr %se.addr.014.i, i32 0, i32 10
  %54 = ptrtoint ptr %parent.i100 to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load ptr, ptr %parent.i100, align 4
  %tobool.not.i = icmp eq ptr %55, null
  br i1 %tobool.not.i, label %se_fi_update.exit, label %for.body.i

se_fi_update.exit:                                ; preds = %for.inc.i, %if.then.i, %while.end
  %56 = ptrtoint ptr %core13 to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load ptr, ptr %core13, align 8
  %core_forceidle_seq68 = getelementptr inbounds %struct.rq, ptr %57, i32 0, i32 88
  %58 = ptrtoint ptr %core_forceidle_seq68 to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load i32, ptr %core_forceidle_seq68, align 4
  %tobool.not13.i101 = icmp eq ptr %seb.0.lcssa116, null
  br i1 %tobool.not13.i101, label %se_fi_update.exit114, label %for.body.i104

for.body.i104:                                    ; preds = %for.inc.i113, %se_fi_update.exit
  %se.addr.014.i102 = phi ptr [ %69, %for.inc.i113 ], [ %seb.0.lcssa116, %se_fi_update.exit ]
  %cfs_rq.i.i103 = getelementptr inbounds %struct.sched_entity, ptr %se.addr.014.i102, i32 0, i32 11
  %60 = ptrtoint ptr %cfs_rq.i.i103 to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load ptr, ptr %cfs_rq.i.i103, align 16
  br i1 %in_fi, label %if.then.i107, label %for.inc.i113

if.then.i107:                                     ; preds = %for.body.i104
  %forceidle_seq.i105 = getelementptr inbounds %struct.cfs_rq, ptr %61, i32 0, i32 7
  %62 = ptrtoint ptr %forceidle_seq.i105 to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load i32, ptr %forceidle_seq.i105, align 8
  %cmp.i106 = icmp eq i32 %63, %59
  br i1 %cmp.i106, label %se_fi_update.exit114, label %if.end.i108

if.end.i108:                                      ; preds = %if.then.i107
  %64 = ptrtoint ptr %forceidle_seq.i105 to i32
  call void @__asan_store4_noabort(i32 %64)
  store i32 %59, ptr %forceidle_seq.i105, align 8
  br label %for.inc.i113

for.inc.i113:                                     ; preds = %if.end.i108, %for.body.i104
  %min_vruntime.i109 = getelementptr inbounds %struct.cfs_rq, ptr %61, i32 0, i32 6
  %65 = ptrtoint ptr %min_vruntime.i109 to i32
  call void @__asan_load8_noabort(i32 %65)
  %66 = load i64, ptr %min_vruntime.i109, align 32
  %min_vruntime_fi.i110 = getelementptr inbounds %struct.cfs_rq, ptr %61, i32 0, i32 8
  %67 = ptrtoint ptr %min_vruntime_fi.i110 to i32
  call void @__asan_store8_noabort(i32 %67)
  store i64 %66, ptr %min_vruntime_fi.i110, align 16
  %parent.i111 = getelementptr inbounds %struct.sched_entity, ptr %se.addr.014.i102, i32 0, i32 10
  %68 = ptrtoint ptr %parent.i111 to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load ptr, ptr %parent.i111, align 4
  %tobool.not.i112 = icmp eq ptr %69, null
  br i1 %tobool.not.i112, label %se_fi_update.exit114, label %for.body.i104

se_fi_update.exit114:                             ; preds = %for.inc.i113, %if.then.i107, %se_fi_update.exit
  %cfs_rq53.le = getelementptr inbounds %struct.sched_entity, ptr %seb.0.lcssa116, i32 0, i32 11
  %cfs_rq.le = getelementptr inbounds %struct.sched_entity, ptr %sea.0.lcssa117, i32 0, i32 11
  %70 = ptrtoint ptr %cfs_rq.le to i32
  call void @__asan_load4_noabort(i32 %70)
  %71 = load ptr, ptr %cfs_rq.le, align 16
  %72 = ptrtoint ptr %cfs_rq53.le to i32
  call void @__asan_load4_noabort(i32 %72)
  %73 = load ptr, ptr %cfs_rq53.le, align 16
  %vruntime = getelementptr inbounds %struct.sched_entity, ptr %sea.0.lcssa117, i32 0, i32 6
  %74 = ptrtoint ptr %vruntime to i32
  call void @__asan_load8_noabort(i32 %74)
  %75 = load i64, ptr %vruntime, align 16
  %vruntime72 = getelementptr inbounds %struct.sched_entity, ptr %seb.0.lcssa116, i32 0, i32 6
  %76 = ptrtoint ptr %vruntime72 to i32
  call void @__asan_load8_noabort(i32 %76)
  %77 = load i64, ptr %vruntime72, align 16
  %min_vruntime_fi = getelementptr inbounds %struct.cfs_rq, ptr %73, i32 0, i32 8
  %78 = ptrtoint ptr %min_vruntime_fi to i32
  call void @__asan_load8_noabort(i32 %78)
  %79 = load i64, ptr %min_vruntime_fi, align 16
  %min_vruntime_fi73 = getelementptr inbounds %struct.cfs_rq, ptr %71, i32 0, i32 8
  %80 = ptrtoint ptr %min_vruntime_fi73 to i32
  call void @__asan_load8_noabort(i32 %80)
  %81 = load i64, ptr %min_vruntime_fi73, align 16
  %82 = add i64 %75, %79
  %83 = add i64 %77, %81
  %add75 = sub i64 %82, %83
  %cmp76 = icmp sgt i64 %add75, 0
  ret i1 %cmp76
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @init_cfs_rq(ptr noundef %cfs_rq) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tasks_timeline = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 10
  %0 = ptrtoint ptr %tasks_timeline to i32
  call void @__asan_store4_noabort(i32 %0)
  store ptr null, ptr %tasks_timeline, align 64
  %.compoundliteral.sroa.2.0.tasks_timeline.sroa_idx = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 10, i32 1
  %1 = ptrtoint ptr %.compoundliteral.sroa.2.0.tasks_timeline.sroa_idx to i32
  call void @__asan_store4_noabort(i32 %1)
  store ptr null, ptr %.compoundliteral.sroa.2.0.tasks_timeline.sroa_idx, align 4
  %min_vruntime = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 6
  %2 = ptrtoint ptr %min_vruntime to i32
  call void @__asan_store8_noabort(i32 %2)
  store i64 -1048576, ptr %min_vruntime, align 32
  %min_vruntime_copy = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 9
  %3 = ptrtoint ptr %min_vruntime_copy to i32
  call void @__asan_store8_noabort(i32 %3)
  store i64 -1048576, ptr %min_vruntime_copy, align 8
  %removed = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 20
  tail call void @__raw_spin_lock_init(ptr noundef %removed, ptr noundef nonnull @.str.5, ptr noundef nonnull @init_cfs_rq.__key, i16 noundef signext 2) #20
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @free_fair_sched_group(ptr nocapture noundef readonly %tg) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call18 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_possible_mask) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %0 = load i32, ptr @nr_cpu_ids, align 4
  %cmp19 = icmp ult i32 %call18, %0
  br i1 %cmp19, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %entry
  %cfs_rq = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 2
  %se = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 1
  br label %for.body

for.body:                                         ; preds = %if.end6, %for.body.lr.ph
  %call20 = phi i32 [ %call18, %for.body.lr.ph ], [ %call, %if.end6 ]
  %1 = ptrtoint ptr %cfs_rq to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %cfs_rq, align 4
  %tobool.not = icmp eq ptr %2, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %arrayidx = getelementptr ptr, ptr %2, i32 %call20
  %3 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %arrayidx, align 4
  tail call void @kfree(ptr noundef %4) #20
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %5 = ptrtoint ptr %se to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %se, align 8
  %tobool2.not = icmp eq ptr %6, null
  br i1 %tobool2.not, label %if.end6, label %if.then3

if.then3:                                         ; preds = %if.end
  %arrayidx5 = getelementptr ptr, ptr %6, i32 %call20
  %7 = ptrtoint ptr %arrayidx5 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %arrayidx5, align 4
  tail call void @kfree(ptr noundef %8) #20
  br label %if.end6

if.end6:                                          ; preds = %if.then3, %if.end
  %call = tail call i32 @cpumask_next(i32 noundef %call20, ptr noundef nonnull @__cpu_possible_mask) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %9 = load i32, ptr @nr_cpu_ids, align 4
  %cmp = icmp ult i32 %call, %9
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %if.end6, %entry
  %cfs_rq7 = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 2
  %10 = ptrtoint ptr %cfs_rq7 to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %cfs_rq7, align 4
  tail call void @kfree(ptr noundef %11) #20
  %se8 = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 1
  %12 = ptrtoint ptr %se8 to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %se8, align 8
  tail call void @kfree(ptr noundef %13) #20
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @kfree(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @alloc_fair_sched_group(ptr noundef %tg, ptr nocapture noundef readonly %parent) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %0 = load i32, ptr @nr_cpu_ids, align 4
  %1 = tail call { i32, i1 } @llvm.umul.with.overflow.i32(i32 %0, i32 4) #20
  %2 = extractvalue { i32, i1 } %1, 1
  br i1 %2, label %kcalloc.exit.thread, label %if.end7.i.i, !prof !260

kcalloc.exit.thread:                              ; preds = %entry
  %cfs_rq180 = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 2
  %3 = ptrtoint ptr %cfs_rq180 to i32
  call void @__asan_store4_noabort(i32 %3)
  store ptr null, ptr %cfs_rq180, align 4
  br label %cleanup

if.end7.i.i:                                      ; preds = %entry
  %4 = extractvalue { i32, i1 } %1, 0
  %call8.i.i = tail call noalias align 128 ptr @__kmalloc(i32 noundef %4, i32 noundef 3520) #25
  %cfs_rq1 = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 2
  %5 = ptrtoint ptr %cfs_rq1 to i32
  call void @__asan_store4_noabort(i32 %5)
  store ptr %call8.i.i, ptr %cfs_rq1, align 4
  %tobool.not = icmp eq ptr %call8.i.i, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %if.end7.i.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %6 = load i32, ptr @nr_cpu_ids, align 4
  %7 = tail call { i32, i1 } @llvm.umul.with.overflow.i32(i32 %6, i32 4) #20
  %8 = extractvalue { i32, i1 } %7, 1
  br i1 %8, label %kcalloc.exit70.thread, label %if.end7.i.i68, !prof !260

kcalloc.exit70.thread:                            ; preds = %if.end
  %se488 = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 1
  %9 = ptrtoint ptr %se488 to i32
  call void @__asan_store4_noabort(i32 %9)
  store ptr null, ptr %se488, align 8
  br label %cleanup

if.end7.i.i68:                                    ; preds = %if.end
  %10 = extractvalue { i32, i1 } %7, 0
  %call8.i.i67 = tail call noalias align 128 ptr @__kmalloc(i32 noundef %10, i32 noundef 3520) #25
  %se4 = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 1
  %11 = ptrtoint ptr %se4 to i32
  call void @__asan_store4_noabort(i32 %11)
  store ptr %call8.i.i67, ptr %se4, align 8
  %tobool6.not = icmp eq ptr %call8.i.i67, null
  br i1 %tobool6.not, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end7.i.i68
  %shares = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 3
  %12 = ptrtoint ptr %shares to i32
  call void @__asan_store4_noabort(i32 %12)
  store i32 1024, ptr %shares, align 16
  %cfs_bandwidth.i = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 16
  tail call void @__raw_spin_lock_init(ptr noundef %cfs_bandwidth.i, ptr noundef nonnull @.str, ptr noundef nonnull @init_cfs_bandwidth.__key, i16 noundef signext 2) #20
  %runtime.i = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 16, i32 3
  %13 = ptrtoint ptr %runtime.i to i32
  call void @__asan_store8_noabort(i32 %13)
  store i64 0, ptr %runtime.i, align 8
  %quota.i = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 16, i32 2
  %14 = ptrtoint ptr %quota.i to i32
  call void @__asan_store8_noabort(i32 %14)
  store i64 -1, ptr %quota.i, align 8
  %period.i = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 16, i32 1
  %15 = ptrtoint ptr %period.i to i32
  call void @__asan_store8_noabort(i32 %15)
  store i64 100000000, ptr %period.i, align 8
  %burst.i = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 16, i32 4
  %16 = ptrtoint ptr %burst.i to i32
  call void @__asan_store8_noabort(i32 %16)
  store i64 0, ptr %burst.i, align 8
  %throttled_cfs_rq.i = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 16, i32 12
  %17 = ptrtoint ptr %throttled_cfs_rq.i to i32
  call void @__asan_store4_noabort(i32 %17)
  store volatile ptr %throttled_cfs_rq.i, ptr %throttled_cfs_rq.i, align 4
  %prev.i.i = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 16, i32 12, i32 1
  %18 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_store4_noabort(i32 %18)
  store ptr %throttled_cfs_rq.i, ptr %prev.i.i, align 4
  %period_timer.i = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 16, i32 10
  tail call void @hrtimer_init(ptr noundef %period_timer.i, i32 noundef 1, i32 noundef 2) #20
  %function.i = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 16, i32 10, i32 2
  %19 = ptrtoint ptr %function.i to i32
  call void @__asan_store4_noabort(i32 %19)
  store ptr @sched_cfs_period_timer, ptr %function.i, align 8
  %slack_timer.i = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 16, i32 11
  tail call void @hrtimer_init(ptr noundef %slack_timer.i, i32 noundef 1, i32 noundef 1) #20
  %function4.i = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 16, i32 11, i32 2
  %20 = ptrtoint ptr %function4.i to i32
  call void @__asan_store4_noabort(i32 %20)
  store ptr @sched_cfs_slack_timer, ptr %function4.i, align 8
  %slack_started.i = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 16, i32 9
  %21 = ptrtoint ptr %slack_started.i to i32
  call void @__asan_store1_noabort(i32 %21)
  store i8 0, ptr %slack_started.i, align 2
  %call1095 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_possible_mask) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %22 = load i32, ptr @nr_cpu_ids, align 4
  %cmp96 = icmp ult i32 %call1095, %22
  br i1 %cmp96, label %for.body.lr.ph, label %cleanup

for.body.lr.ph:                                   ; preds = %if.end8
  %se19 = getelementptr inbounds %struct.task_group, ptr %parent, i32 0, i32 1
  br label %for.body

for.body:                                         ; preds = %init_entity_runnable_average.exit, %for.body.lr.ph
  %call1097 = phi i32 [ %call1095, %for.body.lr.ph ], [ %call10, %init_entity_runnable_average.exit ]
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 10) to i32))
  %23 = load ptr, ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 10), align 4
  %call.i.i.i = tail call noalias align 8 ptr @kmem_cache_alloc_trace(ptr noundef %23, i32 noundef 3520, i32 noundef 640) #26
  %tobool12.not = icmp eq ptr %call.i.i.i, null
  br i1 %tobool12.not, label %cleanup, label %if.end14

if.end14:                                         ; preds = %for.body
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 9) to i32))
  %24 = load ptr, ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 9), align 4
  %call.i.i.i74 = tail call noalias align 8 ptr @kmem_cache_alloc_trace(ptr noundef %24, i32 noundef 3520, i32 noundef 512) #26
  %tobool16.not = icmp eq ptr %call.i.i.i74, null
  br i1 %tobool16.not, label %err_free_rq, label %if.end.i

if.end.i:                                         ; preds = %if.end14
  %tasks_timeline.i = getelementptr inbounds %struct.cfs_rq, ptr %call.i.i.i, i32 0, i32 10
  %25 = ptrtoint ptr %tasks_timeline.i to i32
  call void @__asan_store4_noabort(i32 %25)
  store ptr null, ptr %tasks_timeline.i, align 64
  %.compoundliteral.sroa.2.0.tasks_timeline.sroa_idx.i = getelementptr inbounds %struct.cfs_rq, ptr %call.i.i.i, i32 0, i32 10, i32 1
  %26 = ptrtoint ptr %.compoundliteral.sroa.2.0.tasks_timeline.sroa_idx.i to i32
  call void @__asan_store4_noabort(i32 %26)
  store ptr null, ptr %.compoundliteral.sroa.2.0.tasks_timeline.sroa_idx.i, align 4
  %min_vruntime.i = getelementptr inbounds %struct.cfs_rq, ptr %call.i.i.i, i32 0, i32 6
  %27 = ptrtoint ptr %min_vruntime.i to i32
  call void @__asan_store8_noabort(i32 %27)
  store i64 -1048576, ptr %min_vruntime.i, align 32
  %min_vruntime_copy.i = getelementptr inbounds %struct.cfs_rq, ptr %call.i.i.i, i32 0, i32 9
  %28 = ptrtoint ptr %min_vruntime_copy.i to i32
  call void @__asan_store8_noabort(i32 %28)
  store i64 -1048576, ptr %min_vruntime_copy.i, align 8
  %removed.i = getelementptr inbounds %struct.cfs_rq, ptr %call.i.i.i, i32 0, i32 20
  tail call void @__raw_spin_lock_init(ptr noundef %removed.i, ptr noundef nonnull @.str.5, ptr noundef nonnull @init_cfs_rq.__key, i16 noundef signext 2) #20
  %29 = ptrtoint ptr %se19 to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %se19, align 8
  %arrayidx = getelementptr ptr, ptr %30, i32 %call1097
  %31 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %arrayidx, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call1097
  %33 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %34, ptrtoint (ptr @runqueues to i32)
  %35 = inttoptr i32 %add.i to ptr
  %tg2.i = getelementptr inbounds %struct.cfs_rq, ptr %call.i.i.i, i32 0, i32 30
  %36 = ptrtoint ptr %tg2.i to i32
  call void @__asan_store4_noabort(i32 %36)
  store ptr %tg, ptr %tg2.i, align 4
  %rq3.i = getelementptr inbounds %struct.cfs_rq, ptr %call.i.i.i, i32 0, i32 27
  %37 = ptrtoint ptr %rq3.i to i32
  call void @__asan_store4_noabort(i32 %37)
  store ptr %35, ptr %rq3.i, align 4
  %runtime_enabled.i.i = getelementptr inbounds %struct.cfs_rq, ptr %call.i.i.i, i32 0, i32 32
  %38 = ptrtoint ptr %runtime_enabled.i.i to i32
  call void @__asan_store4_noabort(i32 %38)
  store i32 0, ptr %runtime_enabled.i.i, align 4
  %throttled_list.i.i = getelementptr inbounds %struct.cfs_rq, ptr %call.i.i.i, i32 0, i32 39
  %39 = ptrtoint ptr %throttled_list.i.i to i32
  call void @__asan_store4_noabort(i32 %39)
  store volatile ptr %throttled_list.i.i, ptr %throttled_list.i.i, align 8
  %prev.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %call.i.i.i, i32 0, i32 39, i32 1
  %40 = ptrtoint ptr %prev.i.i.i to i32
  call void @__asan_store4_noabort(i32 %40)
  store ptr %throttled_list.i.i, ptr %prev.i.i.i, align 4
  %41 = ptrtoint ptr %cfs_rq1 to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load ptr, ptr %cfs_rq1, align 4
  %arrayidx5.i = getelementptr ptr, ptr %42, i32 %call1097
  %43 = ptrtoint ptr %arrayidx5.i to i32
  call void @__asan_store4_noabort(i32 %43)
  store ptr %call.i.i.i, ptr %arrayidx5.i, align 4
  %44 = ptrtoint ptr %se4 to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load ptr, ptr %se4, align 8
  %arrayidx7.i = getelementptr ptr, ptr %45, i32 %call1097
  %46 = ptrtoint ptr %arrayidx7.i to i32
  call void @__asan_store4_noabort(i32 %46)
  store ptr %call.i.i.i74, ptr %arrayidx7.i, align 4
  %tobool8.not.i = icmp eq ptr %32, null
  br i1 %tobool8.not.i, label %if.then9.i, label %if.else.i

if.then9.i:                                       ; preds = %if.end.i
  %cfs.i = getelementptr inbounds %struct.rq, ptr %35, i32 0, i32 14
  %cfs_rq10.i = getelementptr inbounds %struct.sched_entity, ptr %call.i.i.i74, i32 0, i32 11
  %47 = ptrtoint ptr %cfs_rq10.i to i32
  call void @__asan_store4_noabort(i32 %47)
  store ptr %cfs.i, ptr %cfs_rq10.i, align 16
  br label %init_entity_runnable_average.exit

if.else.i:                                        ; preds = %if.end.i
  %my_q.i = getelementptr inbounds %struct.sched_entity, ptr %32, i32 0, i32 12
  %48 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load ptr, ptr %my_q.i, align 4
  %cfs_rq11.i = getelementptr inbounds %struct.sched_entity, ptr %call.i.i.i74, i32 0, i32 11
  %50 = ptrtoint ptr %cfs_rq11.i to i32
  call void @__asan_store4_noabort(i32 %50)
  store ptr %49, ptr %cfs_rq11.i, align 16
  %depth12.i = getelementptr inbounds %struct.sched_entity, ptr %32, i32 0, i32 9
  %51 = ptrtoint ptr %depth12.i to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load i32, ptr %depth12.i, align 8
  %add13.i = add i32 %52, 1
  br label %init_entity_runnable_average.exit

init_entity_runnable_average.exit:                ; preds = %if.else.i, %if.then9.i
  %add13.sink.i = phi i32 [ 0, %if.then9.i ], [ %add13.i, %if.else.i ]
  %53 = getelementptr inbounds %struct.sched_entity, ptr %call.i.i.i74, i32 0, i32 9
  %54 = ptrtoint ptr %53 to i32
  call void @__asan_store4_noabort(i32 %54)
  store i32 %add13.sink.i, ptr %53, align 8
  %my_q16.i = getelementptr inbounds %struct.sched_entity, ptr %call.i.i.i74, i32 0, i32 12
  %55 = ptrtoint ptr %my_q16.i to i32
  call void @__asan_store4_noabort(i32 %55)
  store ptr %call.i.i.i, ptr %my_q16.i, align 4
  %56 = ptrtoint ptr %call.i.i.i74 to i32
  call void @__asan_store4_noabort(i32 %56)
  store i32 1024, ptr %call.i.i.i74, align 8
  %inv_weight.i.i = getelementptr inbounds %struct.load_weight, ptr %call.i.i.i74, i32 0, i32 1
  %57 = ptrtoint ptr %inv_weight.i.i to i32
  call void @__asan_store4_noabort(i32 %57)
  store i32 0, ptr %inv_weight.i.i, align 4
  %parent17.i = getelementptr inbounds %struct.sched_entity, ptr %call.i.i.i74, i32 0, i32 10
  %58 = ptrtoint ptr %parent17.i to i32
  call void @__asan_store4_noabort(i32 %58)
  store ptr %32, ptr %parent17.i, align 4
  %avg.i = getelementptr inbounds %struct.sched_entity, ptr %call.i.i.i74, i32 0, i32 15
  %59 = call ptr @memset(ptr %avg.i, i32 0, i32 128)
  %call10 = tail call i32 @cpumask_next(i32 noundef %call1097, ptr noundef nonnull @__cpu_possible_mask) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %60 = load i32, ptr @nr_cpu_ids, align 4
  %cmp = icmp ult i32 %call10, %60
  br i1 %cmp, label %for.body, label %cleanup

err_free_rq:                                      ; preds = %if.end14
  tail call void @kfree(ptr noundef nonnull %call.i.i.i) #20
  br label %cleanup

cleanup:                                          ; preds = %err_free_rq, %init_entity_runnable_average.exit, %for.body, %if.end8, %if.end7.i.i68, %kcalloc.exit70.thread, %if.end7.i.i, %kcalloc.exit.thread
  %retval.0 = phi i32 [ 0, %if.end7.i.i68 ], [ 0, %if.end7.i.i ], [ 0, %err_free_rq ], [ 0, %kcalloc.exit.thread ], [ 0, %kcalloc.exit70.thread ], [ 1, %if.end8 ], [ 1, %init_entity_runnable_average.exit ], [ 0, %for.body ]
  ret i32 %retval.0
}

; Function Attrs: nofree norecurse nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @init_tg_cfs_entry(ptr noundef %tg, ptr noundef %cfs_rq, ptr noundef %se, i32 noundef %cpu, ptr noundef %parent) local_unnamed_addr #10 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %cpu
  %0 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %arrayidx, align 4
  %add = add i32 %1, ptrtoint (ptr @runqueues to i32)
  %2 = inttoptr i32 %add to ptr
  %tg2 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 30
  %3 = ptrtoint ptr %tg2 to i32
  call void @__asan_store4_noabort(i32 %3)
  store ptr %tg, ptr %tg2, align 4
  %rq3 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %4 = ptrtoint ptr %rq3 to i32
  call void @__asan_store4_noabort(i32 %4)
  store ptr %2, ptr %rq3, align 4
  %runtime_enabled.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 32
  %5 = ptrtoint ptr %runtime_enabled.i to i32
  call void @__asan_store4_noabort(i32 %5)
  store i32 0, ptr %runtime_enabled.i, align 4
  %throttled_list.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 39
  %6 = ptrtoint ptr %throttled_list.i to i32
  call void @__asan_store4_noabort(i32 %6)
  store volatile ptr %throttled_list.i, ptr %throttled_list.i, align 4
  %prev.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 39, i32 1
  %7 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_store4_noabort(i32 %7)
  store ptr %throttled_list.i, ptr %prev.i.i, align 4
  %cfs_rq4 = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 2
  %8 = ptrtoint ptr %cfs_rq4 to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %cfs_rq4, align 4
  %arrayidx5 = getelementptr ptr, ptr %9, i32 %cpu
  %10 = ptrtoint ptr %arrayidx5 to i32
  call void @__asan_store4_noabort(i32 %10)
  store ptr %cfs_rq, ptr %arrayidx5, align 4
  %se6 = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 1
  %11 = ptrtoint ptr %se6 to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %se6, align 8
  %arrayidx7 = getelementptr ptr, ptr %12, i32 %cpu
  %13 = ptrtoint ptr %arrayidx7 to i32
  call void @__asan_store4_noabort(i32 %13)
  store ptr %se, ptr %arrayidx7, align 4
  %tobool.not = icmp eq ptr %se, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %tobool8.not = icmp eq ptr %parent, null
  br i1 %tobool8.not, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.end
  %cfs = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 14
  %cfs_rq10 = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 11
  %14 = ptrtoint ptr %cfs_rq10 to i32
  call void @__asan_store4_noabort(i32 %14)
  store ptr %cfs, ptr %cfs_rq10, align 16
  br label %if.end15

if.else:                                          ; preds = %if.end
  %my_q = getelementptr inbounds %struct.sched_entity, ptr %parent, i32 0, i32 12
  %15 = ptrtoint ptr %my_q to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %my_q, align 4
  %cfs_rq11 = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 11
  %17 = ptrtoint ptr %cfs_rq11 to i32
  call void @__asan_store4_noabort(i32 %17)
  store ptr %16, ptr %cfs_rq11, align 16
  %depth12 = getelementptr inbounds %struct.sched_entity, ptr %parent, i32 0, i32 9
  %18 = ptrtoint ptr %depth12 to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %depth12, align 8
  %add13 = add i32 %19, 1
  br label %if.end15

if.end15:                                         ; preds = %if.else, %if.then9
  %add13.sink = phi i32 [ 0, %if.then9 ], [ %add13, %if.else ]
  %20 = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 9
  %21 = ptrtoint ptr %20 to i32
  call void @__asan_store4_noabort(i32 %21)
  store i32 %add13.sink, ptr %20, align 8
  %my_q16 = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 12
  %22 = ptrtoint ptr %my_q16 to i32
  call void @__asan_store4_noabort(i32 %22)
  store ptr %cfs_rq, ptr %my_q16, align 4
  %23 = ptrtoint ptr %se to i32
  call void @__asan_store4_noabort(i32 %23)
  store i32 1024, ptr %se, align 4
  %inv_weight.i = getelementptr inbounds %struct.load_weight, ptr %se, i32 0, i32 1
  %24 = ptrtoint ptr %inv_weight.i to i32
  call void @__asan_store4_noabort(i32 %24)
  store i32 0, ptr %inv_weight.i, align 4
  %parent17 = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 10
  %25 = ptrtoint ptr %parent17 to i32
  call void @__asan_store4_noabort(i32 %25)
  store ptr %parent, ptr %parent17, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @online_fair_sched_group(ptr nocapture noundef readonly %tg) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call21 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_possible_mask) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %0 = load i32, ptr @nr_cpu_ids, align 4
  %cmp22 = icmp ult i32 %call21, %0
  br i1 %cmp22, label %do.body.lr.ph, label %for.end

do.body.lr.ph:                                    ; preds = %entry
  %se2 = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 1
  br label %do.body

do.body:                                          ; preds = %rq_unlock_irq.exit, %do.body.lr.ph
  %call23 = phi i32 [ %call21, %do.body.lr.ph ], [ %call, %rq_unlock_irq.exit ]
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call23
  %1 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %arrayidx, align 4
  %add = add i32 %2, ptrtoint (ptr @runqueues to i32)
  %3 = inttoptr i32 %add to ptr
  %4 = ptrtoint ptr %se2 to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %se2, align 8
  %arrayidx3 = getelementptr ptr, ptr %5, i32 %call23
  %6 = ptrtoint ptr %arrayidx3 to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %arrayidx3, align 4
  %8 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #20, !srcloc !280
  %and.i.i.i.i = and i32 %8, 128
  %tobool.not.i.i = icmp eq i32 %and.i.i.i.i, 0
  tail call void asm sideeffect "\09cpsid i\09\09\09@ arch_local_irq_disable", "~{memory},~{cc}"() #20, !srcloc !285
  br i1 %tobool.not.i.i, label %if.then.i.i, label %raw_spin_rq_lock_irq.exit.i

if.then.i.i:                                      ; preds = %do.body
  tail call void @trace_hardirqs_off() #20
  br label %raw_spin_rq_lock_irq.exit.i

raw_spin_rq_lock_irq.exit.i:                      ; preds = %if.then.i.i, %do.body
  tail call void @raw_spin_rq_lock_nested(ptr noundef %3, i32 noundef 0) #20
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %3, i32 0, i32 81
  %9 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %10, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %raw_spin_rq_lock_irq.exit.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %3, i32 0, i32 79
  %11 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %raw_spin_rq_lock_irq.exit.i
  %retval.0.i.i.i = phi ptr [ %12, %if.then.i.i.i ], [ %3, %raw_spin_rq_lock_irq.exit.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call1.i.i = tail call i32 @lock_pin_lock(ptr noundef %dep_map.i.i) #20
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %3, i32 0, i32 25
  %13 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %clock_update_flags.i.i, align 4
  %and.i.i = and i32 %14, 3
  store i32 %and.i.i, ptr %clock_update_flags.i.i, align 4
  %balance_callback.i.i = getelementptr inbounds %struct.rq, ptr %3, i32 0, i32 39
  %15 = ptrtoint ptr %balance_callback.i.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %balance_callback.i.i, align 8
  %tobool.not.i2.i = icmp ne ptr %16, null
  %cmp.i.i = icmp ne ptr %16, @balance_push_callback
  %spec.select.i.i = and i1 %tobool.not.i2.i, %cmp.i.i
  br i1 %spec.select.i.i, label %land.rhs6.i.i, label %rq_lock_irq.exit

land.rhs6.i.i:                                    ; preds = %__rq_lockp.exit.i.i
  %.b48.i.i = load i1, ptr @rq_pin_lock.__already_done, align 1
  br i1 %.b48.i.i, label %rq_lock_irq.exit, label %if.then.i3.i, !prof !259

if.then.i3.i:                                     ; preds = %land.rhs6.i.i
  store i1 true, ptr @rq_pin_lock.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1545, i32 noundef 9, ptr noundef nonnull @.str.35) #20
  br label %rq_lock_irq.exit

rq_lock_irq.exit:                                 ; preds = %if.then.i3.i, %land.rhs6.i.i, %__rq_lockp.exit.i.i
  tail call void @update_rq_clock(ptr noundef %3) #20
  tail call fastcc void @attach_entity_cfs_rq(ptr noundef %7)
  tail call fastcc void @sync_throttle(ptr noundef %tg, i32 noundef %call23)
  %17 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i15 = icmp eq i32 %18, 0
  br i1 %tobool.not.i.i.i15, label %rq_unlock_irq.exit, label %if.then.i.i.i17

if.then.i.i.i17:                                  ; preds = %rq_lock_irq.exit
  %core.i.i.i16 = getelementptr inbounds %struct.rq, ptr %3, i32 0, i32 79
  %19 = ptrtoint ptr %core.i.i.i16 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %core.i.i.i16, align 8
  br label %rq_unlock_irq.exit

rq_unlock_irq.exit:                               ; preds = %if.then.i.i.i17, %rq_lock_irq.exit
  %retval.0.i.i.i18 = phi ptr [ %20, %if.then.i.i.i17 ], [ %3, %rq_lock_irq.exit ]
  %dep_map.i.i19 = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i18, i32 0, i32 4
  %21 = insertvalue [1 x i32] undef, i32 %call1.i.i, 0
  tail call void @lock_unpin_lock(ptr noundef %dep_map.i.i19, [1 x i32] %21) #20
  tail call void @raw_spin_rq_unlock(ptr noundef %3) #20
  tail call void @trace_hardirqs_on() #20
  tail call void asm sideeffect "\09cpsie i\09\09\09@ arch_local_irq_enable", "~{memory},~{cc}"() #20, !srcloc !286
  %call = tail call i32 @cpumask_next(i32 noundef %call23, ptr noundef nonnull @__cpu_possible_mask) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %22 = load i32, ptr @nr_cpu_ids, align 4
  %cmp = icmp ult i32 %call, %22
  br i1 %cmp, label %do.body, label %for.end

for.end:                                          ; preds = %rq_unlock_irq.exit, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @sync_throttle(ptr nocapture noundef readonly %tg, i32 noundef %cpu) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@sync_throttle, %if.end)) #20
          to label %cleanup [label %if.end], !srcloc !261

if.end:                                           ; preds = %entry
  %parent = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 12
  %0 = ptrtoint ptr %parent to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %parent, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %cfs_rq3 = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 2
  %2 = ptrtoint ptr %cfs_rq3 to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %cfs_rq3, align 4
  %arrayidx = getelementptr ptr, ptr %3, i32 %cpu
  %4 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %arrayidx, align 4
  %cfs_rq5 = getelementptr inbounds %struct.task_group, ptr %1, i32 0, i32 2
  %6 = ptrtoint ptr %cfs_rq5 to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %cfs_rq5, align 4
  %arrayidx6 = getelementptr ptr, ptr %7, i32 %cpu
  %8 = ptrtoint ptr %arrayidx6 to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %arrayidx6, align 4
  %throttle_count = getelementptr inbounds %struct.cfs_rq, ptr %9, i32 0, i32 38
  %10 = ptrtoint ptr %throttle_count to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %throttle_count, align 4
  %throttle_count7 = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 38
  %12 = ptrtoint ptr %throttle_count7 to i32
  call void @__asan_store4_noabort(i32 %12)
  store i32 %11, ptr %throttle_count7, align 4
  %arrayidx9 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %cpu
  %13 = ptrtoint ptr %arrayidx9 to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %arrayidx9, align 4
  %add = add i32 %14, ptrtoint (ptr @runqueues to i32)
  %15 = inttoptr i32 %add to ptr
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %16 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i = icmp eq i32 %16, 0
  br i1 %tobool.not.i.i, label %lockdep_assert_rq_held.exit.i, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %if.end2
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %15, i32 0, i32 81
  %17 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %18, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.rhs.i.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %15, i32 0, i32 79
  %19 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %land.rhs.i.i
  %retval.0.i.i.i17 = phi ptr [ %20, %if.then.i.i.i ], [ %15, %land.rhs.i.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i17, i32 0, i32 4
  %call.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i, i32 noundef -1) #20
  %cmp.not.i.i = icmp eq i32 %call.i.i.i, 0
  br i1 %cmp.not.i.i, label %do.end.i.i, label %lockdep_assert_rq_held.exit.i, !prof !260

do.end.i.i:                                       ; preds = %__rq_lockp.exit.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i

lockdep_assert_rq_held.exit.i:                    ; preds = %do.end.i.i, %__rq_lockp.exit.i.i, %if.end2
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %15, i32 0, i32 25
  %21 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load i32, ptr %clock_update_flags.i.i, align 4
  %cmp.i.i = icmp ult i32 %22, 2
  br i1 %cmp.i.i, label %land.rhs.i3.i, label %rq_clock_task.exit

land.rhs.i3.i:                                    ; preds = %lockdep_assert_rq_held.exit.i
  %.b37.i.i = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i, label %rq_clock_task.exit, label %if.then.i.i, !prof !259

if.then.i.i:                                      ; preds = %land.rhs.i3.i
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %rq_clock_task.exit

rq_clock_task.exit:                               ; preds = %if.then.i.i, %land.rhs.i3.i, %lockdep_assert_rq_held.exit.i
  %clock_task.i = getelementptr inbounds %struct.rq, ptr %15, i32 0, i32 28
  %23 = ptrtoint ptr %clock_task.i to i32
  call void @__asan_load8_noabort(i32 %23)
  %24 = load i64, ptr %clock_task.i, align 128
  %throttled_clock_task = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 35
  %25 = ptrtoint ptr %throttled_clock_task to i32
  call void @__asan_store8_noabort(i32 %25)
  store i64 %24, ptr %throttled_clock_task, align 8
  br label %cleanup

cleanup:                                          ; preds = %rq_clock_task.exit, %if.end, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @unregister_fair_sched_group(ptr noundef %tg) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %throttled_cfs_rq.i = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 16, i32 12
  %0 = ptrtoint ptr %throttled_cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %throttled_cfs_rq.i, align 8
  %tobool.not.i = icmp eq ptr %1, null
  br i1 %tobool.not.i, label %destroy_cfs_bandwidth.exit, label %if.end.i

if.end.i:                                         ; preds = %entry
  %period_timer.i = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 16, i32 10
  %call.i = tail call i32 @hrtimer_cancel(ptr noundef %period_timer.i) #20
  %slack_timer.i = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 16, i32 11
  %call1.i = tail call i32 @hrtimer_cancel(ptr noundef %slack_timer.i) #20
  br label %destroy_cfs_bandwidth.exit

destroy_cfs_bandwidth.exit:                       ; preds = %if.end.i, %entry
  %call135 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_possible_mask) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %2 = load i32, ptr @nr_cpu_ids, align 4
  %cmp36 = icmp ult i32 %call135, %2
  br i1 %cmp36, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %destroy_cfs_bandwidth.exit
  %se = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 1
  %cfs_rq = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 2
  br label %for.body

for.body:                                         ; preds = %for.cond.backedge, %for.body.lr.ph
  %call137 = phi i32 [ %call135, %for.body.lr.ph ], [ %call1, %for.cond.backedge ]
  %3 = ptrtoint ptr %se to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %se, align 8
  %arrayidx = getelementptr ptr, ptr %4, i32 %call137
  %5 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %arrayidx, align 4
  %tobool.not = icmp eq ptr %6, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %cfs_rq.i.i = getelementptr inbounds %struct.sched_entity, ptr %6, i32 0, i32 11
  %7 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %cfs_rq.i.i, align 16
  %load_last_update_time_copy.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %8, i32 0, i32 18
  %avg.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %8, i32 0, i32 17
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %do.body.i.i.i, %if.then
  %9 = ptrtoint ptr %load_last_update_time_copy.i.i.i to i32
  call void @__asan_load8_noabort(i32 %9)
  %10 = load i64, ptr %load_last_update_time_copy.i.i.i, align 128
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !287
  %11 = ptrtoint ptr %avg.i.i.i to i32
  call void @__asan_load8_noabort(i32 %11)
  %12 = load i64, ptr %avg.i.i.i, align 128
  %cmp.not.i.i.i = icmp eq i64 %12, %10
  br i1 %cmp.not.i.i.i, label %remove_entity_load_avg.exit, label %do.body.i.i.i

remove_entity_load_avg.exit:                      ; preds = %do.body.i.i.i
  %call2.i.i = tail call i32 @__update_load_avg_blocked_se(i64 noundef %10, ptr noundef nonnull %6) #20
  %removed.i = getelementptr inbounds %struct.cfs_rq, ptr %8, i32 0, i32 20
  %call1.i27 = tail call i32 @_raw_spin_lock_irqsave(ptr noundef %removed.i) #20
  %nr.i = getelementptr inbounds %struct.cfs_rq, ptr %8, i32 0, i32 20, i32 1
  %13 = ptrtoint ptr %nr.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %nr.i, align 4
  %inc.i = add i32 %14, 1
  store i32 %inc.i, ptr %nr.i, align 4
  %util_avg.i = getelementptr inbounds %struct.sched_entity, ptr %6, i32 0, i32 15, i32 7
  %15 = ptrtoint ptr %util_avg.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %util_avg.i, align 8
  %util_avg4.i = getelementptr inbounds %struct.cfs_rq, ptr %8, i32 0, i32 20, i32 3
  %17 = ptrtoint ptr %util_avg4.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %util_avg4.i, align 4
  %add.i = add i32 %18, %16
  store i32 %add.i, ptr %util_avg4.i, align 4
  %load_avg.i = getelementptr inbounds %struct.sched_entity, ptr %6, i32 0, i32 15, i32 5
  %19 = ptrtoint ptr %load_avg.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %load_avg.i, align 32
  %load_avg7.i = getelementptr inbounds %struct.cfs_rq, ptr %8, i32 0, i32 20, i32 2
  %21 = ptrtoint ptr %load_avg7.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load i32, ptr %load_avg7.i, align 16
  %add8.i = add i32 %22, %20
  store i32 %add8.i, ptr %load_avg7.i, align 16
  %runnable_avg.i = getelementptr inbounds %struct.sched_entity, ptr %6, i32 0, i32 15, i32 6
  %23 = ptrtoint ptr %runnable_avg.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %runnable_avg.i, align 4
  %runnable_avg11.i = getelementptr inbounds %struct.cfs_rq, ptr %8, i32 0, i32 20, i32 4
  %25 = ptrtoint ptr %runnable_avg11.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %runnable_avg11.i, align 8
  %add12.i = add i32 %26, %24
  store i32 %add12.i, ptr %runnable_avg11.i, align 8
  tail call void @_raw_spin_unlock_irqrestore(ptr noundef %removed.i, i32 noundef %call1.i27) #20
  br label %if.end

if.end:                                           ; preds = %remove_entity_load_avg.exit, %for.body
  %27 = ptrtoint ptr %cfs_rq to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %cfs_rq, align 4
  %arrayidx4 = getelementptr ptr, ptr %28, i32 %call137
  %29 = ptrtoint ptr %arrayidx4 to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %arrayidx4, align 4
  %on_list = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 28
  %31 = ptrtoint ptr %on_list to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %on_list, align 32
  %tobool5.not = icmp eq i32 %32, 0
  br i1 %tobool5.not, label %for.cond.backedge, label %do.body

do.body:                                          ; preds = %if.end
  %arrayidx9 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call137
  %33 = ptrtoint ptr %arrayidx9 to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %arrayidx9, align 4
  %add = add i32 %34, ptrtoint (ptr @runqueues to i32)
  %35 = inttoptr i32 %add to ptr
  %36 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #20, !srcloc !279
  %and.i.i = and i32 %36, 128
  %tobool.not.i28 = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i28, label %if.then.i, label %_raw_spin_rq_lock_irqsave.exit

if.then.i:                                        ; preds = %do.body
  tail call void @trace_hardirqs_off() #20
  br label %_raw_spin_rq_lock_irqsave.exit

_raw_spin_rq_lock_irqsave.exit:                   ; preds = %if.then.i, %do.body
  tail call void @raw_spin_rq_lock_nested(ptr noundef %35, i32 noundef 0) #20
  %37 = ptrtoint ptr %cfs_rq to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load ptr, ptr %cfs_rq, align 4
  %arrayidx15 = getelementptr ptr, ptr %38, i32 %call137
  %39 = ptrtoint ptr %arrayidx15 to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load ptr, ptr %arrayidx15, align 4
  %on_list.i = getelementptr inbounds %struct.cfs_rq, ptr %40, i32 0, i32 28
  %41 = ptrtoint ptr %on_list.i to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load i32, ptr %on_list.i, align 32
  %tobool.not.i29 = icmp eq i32 %42, 0
  br i1 %tobool.not.i29, label %list_del_leaf_cfs_rq.exit, label %if.then.i30

if.then.i30:                                      ; preds = %_raw_spin_rq_lock_irqsave.exit
  %rq.i.i = getelementptr inbounds %struct.cfs_rq, ptr %40, i32 0, i32 27
  %43 = ptrtoint ptr %rq.i.i to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load ptr, ptr %rq.i.i, align 4
  %tmp_alone_branch.i = getelementptr inbounds %struct.rq, ptr %44, i32 0, i32 18
  %45 = ptrtoint ptr %tmp_alone_branch.i to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load ptr, ptr %tmp_alone_branch.i, align 128
  %leaf_cfs_rq_list.i = getelementptr inbounds %struct.cfs_rq, ptr %40, i32 0, i32 29
  %cmp.i = icmp eq ptr %46, %leaf_cfs_rq_list.i
  br i1 %cmp.i, label %if.then1.i, label %if.end.i31

if.then1.i:                                       ; preds = %if.then.i30
  %prev.i = getelementptr inbounds %struct.cfs_rq, ptr %40, i32 0, i32 29, i32 1
  %47 = ptrtoint ptr %prev.i to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load ptr, ptr %prev.i, align 4
  %49 = ptrtoint ptr %tmp_alone_branch.i to i32
  call void @__asan_store4_noabort(i32 %49)
  store ptr %48, ptr %tmp_alone_branch.i, align 128
  br label %if.end.i31

if.end.i31:                                       ; preds = %if.then1.i, %if.then.i30
  %call.i.i.i = tail call zeroext i1 @__list_del_entry_valid(ptr noundef %leaf_cfs_rq_list.i) #20
  br i1 %call.i.i.i, label %if.end.i.i.i, label %list_del_rcu.exit.i

if.end.i.i.i:                                     ; preds = %if.end.i31
  %prev.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %40, i32 0, i32 29, i32 1
  %50 = ptrtoint ptr %prev.i.i.i to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load ptr, ptr %prev.i.i.i, align 4
  %52 = ptrtoint ptr %leaf_cfs_rq_list.i to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load ptr, ptr %leaf_cfs_rq_list.i, align 4
  %prev1.i.i.i.i = getelementptr inbounds %struct.list_head, ptr %53, i32 0, i32 1
  %54 = ptrtoint ptr %prev1.i.i.i.i to i32
  call void @__asan_store4_noabort(i32 %54)
  store ptr %51, ptr %prev1.i.i.i.i, align 4
  %55 = ptrtoint ptr %51 to i32
  call void @__asan_store4_noabort(i32 %55)
  store volatile ptr %53, ptr %51, align 4
  br label %list_del_rcu.exit.i

list_del_rcu.exit.i:                              ; preds = %if.end.i.i.i, %if.end.i31
  %prev.i.i = getelementptr inbounds %struct.cfs_rq, ptr %40, i32 0, i32 29, i32 1
  %56 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_store4_noabort(i32 %56)
  store ptr inttoptr (i32 290 to ptr), ptr %prev.i.i, align 4
  %57 = ptrtoint ptr %on_list.i to i32
  call void @__asan_store4_noabort(i32 %57)
  store i32 0, ptr %on_list.i, align 32
  br label %list_del_leaf_cfs_rq.exit

list_del_leaf_cfs_rq.exit:                        ; preds = %list_del_rcu.exit.i, %_raw_spin_rq_lock_irqsave.exit
  tail call void @raw_spin_rq_unlock(ptr noundef %35) #20
  br i1 %tobool.not.i28, label %if.then.i34, label %do.body2.i

if.then.i34:                                      ; preds = %list_del_leaf_cfs_rq.exit
  tail call void @trace_hardirqs_on() #20
  br label %do.body2.i

do.body2.i:                                       ; preds = %if.then.i34, %list_del_leaf_cfs_rq.exit
  %58 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #20, !srcloc !280
  %and.i.i.i = and i32 %58, 128
  %tobool10.not.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool10.not.i, label %if.then14.i, label %raw_spin_rq_unlock_irqrestore.exit, !prof !260

if.then14.i:                                      ; preds = %do.body2.i
  tail call void @warn_bogus_irq_restore() #20
  br label %raw_spin_rq_unlock_irqrestore.exit

raw_spin_rq_unlock_irqrestore.exit:               ; preds = %if.then14.i, %do.body2.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %36) #20, !srcloc !281
  br label %for.cond.backedge

for.cond.backedge:                                ; preds = %raw_spin_rq_unlock_irqrestore.exit, %if.end
  %call1 = tail call i32 @cpumask_next(i32 noundef %call137, ptr noundef nonnull @__cpu_possible_mask) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %59 = load i32, ptr @nr_cpu_ids, align 4
  %cmp = icmp ult i32 %call1, %59
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.cond.backedge, %destroy_cfs_bandwidth.exit
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @sched_group_set_shares(ptr nocapture noundef %tg, i32 noundef %shares) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call void @mutex_lock_nested(ptr noundef nonnull @shares_mutex, i32 noundef 0) #20
  %idle.i = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 4
  %0 = ptrtoint ptr %idle.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %idle.i, align 4
  %cmp.i = icmp slt i32 %1, 1
  br i1 %cmp.i, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  %call1 = tail call fastcc i32 @__sched_group_set_shares(ptr noundef %tg, i32 noundef %shares)
  br label %if.end

if.end:                                           ; preds = %if.else, %entry
  %ret.0 = phi i32 [ %call1, %if.else ], [ -22, %entry ]
  tail call void @mutex_unlock(ptr noundef nonnull @shares_mutex) #20
  ret i32 %ret.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @mutex_lock_nested(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @__sched_group_set_shares(ptr nocapture noundef %tg, i32 noundef %shares) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %0 = load i32, ptr @debug_locks, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %call.i = tail call i32 @lock_is_held_type(ptr noundef getelementptr inbounds (%struct.mutex, ptr @shares_mutex, i32 0, i32 5), i32 noundef -1) #20
  %cmp.not = icmp eq i32 %call.i, 0
  br i1 %cmp.not, label %do.end, label %if.end, !prof !260

do.end:                                           ; preds = %land.rhs
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 11582, i32 noundef 9, ptr noundef null) #20
  br label %if.end

if.end:                                           ; preds = %do.end, %land.rhs, %entry
  %se = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 1
  %1 = ptrtoint ptr %se to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %se, align 8
  %3 = ptrtoint ptr %2 to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %2, align 4
  %tobool24.not = icmp eq ptr %4, null
  br i1 %tobool24.not, label %cleanup, label %if.end26

if.end26:                                         ; preds = %if.end
  %5 = tail call i32 @llvm.umax.i32(i32 %shares, i32 2)
  %6 = tail call i32 @llvm.umin.i32(i32 %5, i32 262144)
  %shares35 = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 3
  %7 = ptrtoint ptr %shares35 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %shares35, align 16
  %cmp36 = icmp eq i32 %8, %6
  br i1 %cmp36, label %cleanup, label %if.end38

if.end38:                                         ; preds = %if.end26
  %9 = ptrtoint ptr %shares35 to i32
  call void @__asan_store4_noabort(i32 %9)
  store i32 %6, ptr %shares35, align 16
  %call4092 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_possible_mask) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %10 = load i32, ptr @nr_cpu_ids, align 4
  %cmp4193 = icmp ult i32 %call4092, %10
  br i1 %cmp4193, label %for.body, label %cleanup

for.body:                                         ; preds = %rq_unlock_irqrestore.exit, %if.end38
  %call4094 = phi i32 [ %call40, %rq_unlock_irqrestore.exit ], [ %call4092, %if.end38 ]
  %arrayidx47 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call4094
  %11 = ptrtoint ptr %arrayidx47 to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %arrayidx47, align 4
  %add = add i32 %12, ptrtoint (ptr @runqueues to i32)
  %13 = inttoptr i32 %add to ptr
  %14 = ptrtoint ptr %se to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %se, align 8
  %arrayidx50 = getelementptr ptr, ptr %15, i32 %call4094
  %16 = ptrtoint ptr %arrayidx50 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %arrayidx50, align 4
  %18 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #20, !srcloc !279
  %and.i.i.i = and i32 %18, 128
  %tobool.not.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i.i, label %if.then.i.i, label %_raw_spin_rq_lock_irqsave.exit.i

if.then.i.i:                                      ; preds = %for.body
  tail call void @trace_hardirqs_off() #20
  br label %_raw_spin_rq_lock_irqsave.exit.i

_raw_spin_rq_lock_irqsave.exit.i:                 ; preds = %if.then.i.i, %for.body
  tail call void @raw_spin_rq_lock_nested(ptr noundef %13, i32 noundef 0) #20
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %13, i32 0, i32 81
  %19 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %20, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %_raw_spin_rq_lock_irqsave.exit.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %13, i32 0, i32 79
  %21 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %_raw_spin_rq_lock_irqsave.exit.i
  %retval.0.i.i.i = phi ptr [ %22, %if.then.i.i.i ], [ %13, %_raw_spin_rq_lock_irqsave.exit.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call1.i.i = tail call i32 @lock_pin_lock(ptr noundef %dep_map.i.i) #20
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %13, i32 0, i32 25
  %23 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %clock_update_flags.i.i, align 4
  %and.i.i = and i32 %24, 3
  store i32 %and.i.i, ptr %clock_update_flags.i.i, align 4
  %balance_callback.i.i = getelementptr inbounds %struct.rq, ptr %13, i32 0, i32 39
  %25 = ptrtoint ptr %balance_callback.i.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load ptr, ptr %balance_callback.i.i, align 8
  %tobool.not.i3.i = icmp ne ptr %26, null
  %cmp.i.i = icmp ne ptr %26, @balance_push_callback
  %spec.select.i.i = and i1 %tobool.not.i3.i, %cmp.i.i
  br i1 %spec.select.i.i, label %land.rhs6.i.i, label %rq_lock_irqsave.exit

land.rhs6.i.i:                                    ; preds = %__rq_lockp.exit.i.i
  %.b48.i.i = load i1, ptr @rq_pin_lock.__already_done, align 1
  br i1 %.b48.i.i, label %rq_lock_irqsave.exit, label %if.then.i4.i, !prof !259

if.then.i4.i:                                     ; preds = %land.rhs6.i.i
  store i1 true, ptr @rq_pin_lock.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1545, i32 noundef 9, ptr noundef nonnull @.str.35) #20
  br label %rq_lock_irqsave.exit

rq_lock_irqsave.exit:                             ; preds = %if.then.i4.i, %land.rhs6.i.i, %__rq_lockp.exit.i.i
  tail call void @update_rq_clock(ptr noundef %13) #20
  %tobool52.not89 = icmp eq ptr %17, null
  br i1 %tobool52.not89, label %if.end.i.i, label %for.body53

for.body53:                                       ; preds = %update_cfs_group.exit, %rq_lock_irqsave.exit
  %se48.090 = phi ptr [ %51, %update_cfs_group.exit ], [ %17, %rq_lock_irqsave.exit ]
  %cfs_rq.i = getelementptr inbounds %struct.sched_entity, ptr %se48.090, i32 0, i32 11
  %27 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %cfs_rq.i, align 16
  tail call fastcc void @update_load_avg(ptr noundef %28, ptr noundef nonnull %se48.090, i32 noundef 1)
  %my_q.i.i = getelementptr inbounds %struct.sched_entity, ptr %se48.090, i32 0, i32 12
  %29 = ptrtoint ptr %my_q.i.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %my_q.i.i, align 4
  %tobool.not.i = icmp eq ptr %30, null
  br i1 %tobool.not.i, label %update_cfs_group.exit, label %if.end.i

if.end.i:                                         ; preds = %for.body53
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@__sched_group_set_shares, %land.rhs.i.i)) #20
          to label %if.end4.i [label %land.rhs.i.i], !srcloc !261

land.rhs.i.i:                                     ; preds = %if.end.i
  %throttle_count.i.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 38
  %31 = ptrtoint ptr %throttle_count.i.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %throttle_count.i.i, align 4
  %tobool.i.not.i = icmp eq i32 %32, 0
  br i1 %tobool.i.not.i, label %if.end4.i, label %update_cfs_group.exit

if.end4.i:                                        ; preds = %land.rhs.i.i, %if.end.i
  %tg1.i.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 30
  %33 = ptrtoint ptr %tg1.i.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load ptr, ptr %tg1.i.i, align 4
  %shares2.i.i = getelementptr inbounds %struct.task_group, ptr %34, i32 0, i32 3
  %35 = ptrtoint ptr %shares2.i.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load volatile i32, ptr %shares2.i.i, align 16
  %37 = ptrtoint ptr %30 to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %30, align 128
  %load_avg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 17, i32 5
  %39 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load i32, ptr %load_avg.i.i, align 32
  %41 = tail call i32 @llvm.umax.i32(i32 %38, i32 %40) #20
  %load_avg5.i.i = getelementptr inbounds %struct.task_group, ptr %34, i32 0, i32 6
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %load_avg5.i.i, i32 noundef 4) #20
  %42 = ptrtoint ptr %load_avg5.i.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load volatile i32, ptr %load_avg5.i.i, align 4
  %tg_load_avg_contrib.i.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 21
  %44 = ptrtoint ptr %tg_load_avg_contrib.i.i to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load i32, ptr %tg_load_avg_contrib.i.i, align 128
  %sub.i.i = sub i32 %43, %45
  %add.i.i = add i32 %sub.i.i, %41
  %mul.i.i = mul i32 %41, %36
  %tobool.not.i.i75 = icmp eq i32 %add.i.i, 0
  br i1 %tobool.not.i.i75, label %calc_group_shares.exit.i, label %if.then.i.i76

if.then.i.i76:                                    ; preds = %if.end4.i
  %div.i.i = sdiv i32 %mul.i.i, %add.i.i
  br label %calc_group_shares.exit.i

calc_group_shares.exit.i:                         ; preds = %if.then.i.i76, %if.end4.i
  %shares.0.i.i = phi i32 [ %div.i.i, %if.then.i.i76 ], [ %mul.i.i, %if.end4.i ]
  %46 = tail call i32 @llvm.smax.i32(i32 %shares.0.i.i, i32 2) #20
  %47 = tail call i32 @llvm.smin.i32(i32 %46, i32 %36) #20
  %48 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load ptr, ptr %cfs_rq.i, align 16
  tail call fastcc void @reweight_entity(ptr noundef %49, ptr noundef nonnull %se48.090, i32 noundef %47) #20
  br label %update_cfs_group.exit

update_cfs_group.exit:                            ; preds = %calc_group_shares.exit.i, %land.rhs.i.i, %for.body53
  %parent = getelementptr inbounds %struct.sched_entity, ptr %se48.090, i32 0, i32 10
  %50 = ptrtoint ptr %parent to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load ptr, ptr %parent, align 4
  %tobool52.not = icmp eq ptr %51, null
  br i1 %tobool52.not, label %if.end.i.i, label %for.body53

if.end.i.i:                                       ; preds = %update_cfs_group.exit, %rq_lock_irqsave.exit
  %52 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i81 = icmp eq i32 %53, 0
  br i1 %tobool.not.i.i.i81, label %rq_unpin_lock.exit.i, label %if.then.i.i.i83

if.then.i.i.i83:                                  ; preds = %if.end.i.i
  %core.i.i.i82 = getelementptr inbounds %struct.rq, ptr %13, i32 0, i32 79
  %54 = ptrtoint ptr %core.i.i.i82 to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load ptr, ptr %core.i.i.i82, align 8
  br label %rq_unpin_lock.exit.i

rq_unpin_lock.exit.i:                             ; preds = %if.then.i.i.i83, %if.end.i.i
  %retval.0.i.i.i84 = phi ptr [ %55, %if.then.i.i.i83 ], [ %13, %if.end.i.i ]
  %dep_map.i.i85 = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i84, i32 0, i32 4
  %56 = insertvalue [1 x i32] undef, i32 %call1.i.i, 0
  tail call void @lock_unpin_lock(ptr noundef %dep_map.i.i85, [1 x i32] %56) #20
  tail call void @raw_spin_rq_unlock(ptr noundef %13) #20
  br i1 %tobool.not.i.i, label %if.then.i3.i, label %do.body2.i.i

if.then.i3.i:                                     ; preds = %rq_unpin_lock.exit.i
  tail call void @trace_hardirqs_on() #20
  br label %do.body2.i.i

do.body2.i.i:                                     ; preds = %if.then.i3.i, %rq_unpin_lock.exit.i
  %57 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #20, !srcloc !280
  %and.i.i.i.i = and i32 %57, 128
  %tobool10.not.i.i = icmp eq i32 %and.i.i.i.i, 0
  br i1 %tobool10.not.i.i, label %if.then14.i.i, label %rq_unlock_irqrestore.exit, !prof !260

if.then14.i.i:                                    ; preds = %do.body2.i.i
  tail call void @warn_bogus_irq_restore() #20
  br label %rq_unlock_irqrestore.exit

rq_unlock_irqrestore.exit:                        ; preds = %if.then14.i.i, %do.body2.i.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %18) #20, !srcloc !281
  %call40 = tail call i32 @cpumask_next(i32 noundef %call4094, ptr noundef nonnull @__cpu_possible_mask) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %58 = load i32, ptr @nr_cpu_ids, align 4
  %cmp41 = icmp ult i32 %call40, %58
  br i1 %cmp41, label %for.body, label %cleanup

cleanup:                                          ; preds = %rq_unlock_irqrestore.exit, %if.end38, %if.end26, %if.end
  %retval.0 = phi i32 [ -22, %if.end ], [ 0, %if.end26 ], [ 0, %if.end38 ], [ 0, %rq_unlock_irqrestore.exit ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @mutex_unlock(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @sched_group_set_idle(ptr noundef %tg, i32 noundef %idle) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %cmp = icmp eq ptr %tg, @root_task_group
  %0 = icmp ugt i32 %idle, 1
  %or.cond = or i1 %cmp, %0
  br i1 %or.cond, label %cleanup103, label %if.end4

if.end4:                                          ; preds = %entry
  tail call void @mutex_lock_nested(ptr noundef nonnull @shares_mutex, i32 noundef 0) #20
  %idle5 = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 4
  %1 = ptrtoint ptr %idle5 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %idle5, align 4
  %cmp6 = icmp eq i32 %2, %idle
  br i1 %cmp6, label %cleanup103.sink.split, label %if.end8

if.end8:                                          ; preds = %if.end4
  %3 = ptrtoint ptr %idle5 to i32
  call void @__asan_store4_noabort(i32 %3)
  store i32 %idle, ptr %idle5, align 4
  %call170 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_possible_mask) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %4 = load i32, ptr @nr_cpu_ids, align 4
  %cmp10171 = icmp ult i32 %call170, %4
  br i1 %cmp10171, label %for.body.lr.ph, label %for.end95

for.body.lr.ph:                                   ; preds = %if.end8
  %se12 = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 1
  %cfs_rq = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 2
  %cmp.i139 = icmp ne i32 %idle, 0
  %. = select i1 %cmp.i139, i32 1, i32 -1
  br label %for.body

for.body:                                         ; preds = %rq_unlock_irqrestore.exit, %for.body.lr.ph
  %call172 = phi i32 [ %call170, %for.body.lr.ph ], [ %call, %rq_unlock_irqrestore.exit ]
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call172
  %5 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %arrayidx, align 4
  %add = add i32 %6, ptrtoint (ptr @runqueues to i32)
  %7 = inttoptr i32 %add to ptr
  %8 = ptrtoint ptr %se12 to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %se12, align 8
  %arrayidx13 = getelementptr ptr, ptr %9, i32 %call172
  %10 = ptrtoint ptr %arrayidx13 to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %arrayidx13, align 4
  %12 = ptrtoint ptr %cfs_rq to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %cfs_rq, align 4
  %arrayidx14 = getelementptr ptr, ptr %13, i32 %call172
  %14 = ptrtoint ptr %arrayidx14 to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %arrayidx14, align 4
  %idle.i = getelementptr inbounds %struct.cfs_rq, ptr %15, i32 0, i32 31
  %16 = ptrtoint ptr %idle.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %idle.i, align 16
  %cmp.i = icmp slt i32 %17, 1
  %18 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #20, !srcloc !279
  %and.i.i.i = and i32 %18, 128
  %tobool.not.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i.i, label %if.then.i.i, label %_raw_spin_rq_lock_irqsave.exit.i

if.then.i.i:                                      ; preds = %for.body
  tail call void @trace_hardirqs_off() #20
  br label %_raw_spin_rq_lock_irqsave.exit.i

_raw_spin_rq_lock_irqsave.exit.i:                 ; preds = %if.then.i.i, %for.body
  tail call void @raw_spin_rq_lock_nested(ptr noundef %7, i32 noundef 0) #20
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %7, i32 0, i32 81
  %19 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %20, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %_raw_spin_rq_lock_irqsave.exit.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %7, i32 0, i32 79
  %21 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %_raw_spin_rq_lock_irqsave.exit.i
  %retval.0.i.i.i = phi ptr [ %22, %if.then.i.i.i ], [ %7, %_raw_spin_rq_lock_irqsave.exit.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call1.i.i = tail call i32 @lock_pin_lock(ptr noundef %dep_map.i.i) #20
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %7, i32 0, i32 25
  %23 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %clock_update_flags.i.i, align 4
  %and.i.i = and i32 %24, 3
  store i32 %and.i.i, ptr %clock_update_flags.i.i, align 4
  %balance_callback.i.i = getelementptr inbounds %struct.rq, ptr %7, i32 0, i32 39
  %25 = ptrtoint ptr %balance_callback.i.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load ptr, ptr %balance_callback.i.i, align 8
  %tobool.not.i3.i = icmp ne ptr %26, null
  %cmp.i.i = icmp ne ptr %26, @balance_push_callback
  %spec.select.i.i = and i1 %tobool.not.i3.i, %cmp.i.i
  br i1 %spec.select.i.i, label %land.rhs6.i.i, label %rq_lock_irqsave.exit

land.rhs6.i.i:                                    ; preds = %__rq_lockp.exit.i.i
  %.b48.i.i = load i1, ptr @rq_pin_lock.__already_done, align 1
  br i1 %.b48.i.i, label %rq_lock_irqsave.exit, label %if.then.i4.i, !prof !259

if.then.i4.i:                                     ; preds = %land.rhs6.i.i
  store i1 true, ptr @rq_pin_lock.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1545, i32 noundef 9, ptr noundef nonnull @.str.35) #20
  br label %rq_lock_irqsave.exit

rq_lock_irqsave.exit:                             ; preds = %if.then.i4.i, %land.rhs6.i.i, %__rq_lockp.exit.i.i
  %27 = ptrtoint ptr %idle.i to i32
  call void @__asan_store4_noabort(i32 %27)
  store i32 %idle, ptr %idle.i, align 16
  %cmp19 = xor i1 %cmp.i139, %cmp.i
  br i1 %cmp19, label %land.rhs, label %if.end66.critedge

land.rhs:                                         ; preds = %rq_lock_irqsave.exit
  %.b136 = load i1, ptr @sched_group_set_idle.__already_done, align 1
  br i1 %.b136, label %if.end.i.i, label %if.then30, !prof !259

if.then30:                                        ; preds = %land.rhs
  store i1 true, ptr @sched_group_set_idle.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 11658, i32 noundef 9, ptr noundef null) #20
  br label %if.end.i.i

if.end66.critedge:                                ; preds = %rq_lock_irqsave.exit
  %on_rq = getelementptr inbounds %struct.sched_entity, ptr %11, i32 0, i32 3
  %28 = ptrtoint ptr %on_rq to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %on_rq, align 4
  %tobool67.not = icmp eq i32 %29, 0
  br i1 %tobool67.not, label %if.end75, label %if.then68

if.then68:                                        ; preds = %if.end66.critedge
  %cfs_rq.i = getelementptr inbounds %struct.sched_entity, ptr %11, i32 0, i32 11
  %30 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %cfs_rq.i, align 16
  %idle_nr_running = getelementptr inbounds %struct.cfs_rq, ptr %31, i32 0, i32 3
  %32 = ptrtoint ptr %idle_nr_running to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %idle_nr_running, align 16
  %inc = add i32 %33, %.
  store i32 %inc, ptr %idle_nr_running, align 16
  br label %if.end75

if.end75:                                         ; preds = %if.then68, %if.end66.critedge
  %h_nr_running = getelementptr inbounds %struct.cfs_rq, ptr %15, i32 0, i32 2
  %34 = ptrtoint ptr %h_nr_running to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load i32, ptr %h_nr_running, align 4
  %idle_h_nr_running = getelementptr inbounds %struct.cfs_rq, ptr %15, i32 0, i32 4
  %36 = ptrtoint ptr %idle_h_nr_running to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load i32, ptr %idle_h_nr_running, align 4
  %sub = sub i32 %35, %37
  %38 = ptrtoint ptr %idle.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load i32, ptr %idle.i, align 16
  %cmp.i145 = icmp slt i32 %39, 1
  %mul = sub i32 0, %sub
  %spec.select = select i1 %cmp.i145, i32 %mul, i32 %sub
  %tobool81.not168 = icmp eq ptr %11, null
  br i1 %tobool81.not168, label %if.end.i.i, label %for.body82

for.body82:                                       ; preds = %for.inc, %if.end75
  %se.0169 = phi ptr [ %49, %for.inc ], [ %11, %if.end75 ]
  %on_rq85 = getelementptr inbounds %struct.sched_entity, ptr %se.0169, i32 0, i32 3
  %40 = ptrtoint ptr %on_rq85 to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %on_rq85, align 4
  %tobool86.not = icmp eq i32 %41, 0
  br i1 %tobool86.not, label %if.end.i.i, label %if.end88

if.end88:                                         ; preds = %for.body82
  %cfs_rq.i147 = getelementptr inbounds %struct.sched_entity, ptr %se.0169, i32 0, i32 11
  %42 = ptrtoint ptr %cfs_rq.i147 to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load ptr, ptr %cfs_rq.i147, align 16
  %idle_h_nr_running89 = getelementptr inbounds %struct.cfs_rq, ptr %43, i32 0, i32 4
  %44 = ptrtoint ptr %idle_h_nr_running89 to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load i32, ptr %idle_h_nr_running89, align 4
  %add90 = add i32 %45, %spec.select
  store i32 %add90, ptr %idle_h_nr_running89, align 4
  %idle.i148 = getelementptr inbounds %struct.cfs_rq, ptr %43, i32 0, i32 31
  %46 = ptrtoint ptr %idle.i148 to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load i32, ptr %idle.i148, align 16
  %cmp.i149 = icmp slt i32 %47, 1
  br i1 %cmp.i149, label %for.inc, label %if.end.i.i

for.inc:                                          ; preds = %if.end88
  %parent = getelementptr inbounds %struct.sched_entity, ptr %se.0169, i32 0, i32 10
  %48 = ptrtoint ptr %parent to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load ptr, ptr %parent, align 4
  %tobool81.not = icmp eq ptr %49, null
  br i1 %tobool81.not, label %if.end.i.i, label %for.body82

if.end.i.i:                                       ; preds = %for.inc, %if.end88, %for.body82, %if.end75, %if.then30, %land.rhs
  %50 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i155 = icmp eq i32 %51, 0
  br i1 %tobool.not.i.i.i155, label %rq_unpin_lock.exit.i, label %if.then.i.i.i157

if.then.i.i.i157:                                 ; preds = %if.end.i.i
  %core.i.i.i156 = getelementptr inbounds %struct.rq, ptr %7, i32 0, i32 79
  %52 = ptrtoint ptr %core.i.i.i156 to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load ptr, ptr %core.i.i.i156, align 8
  br label %rq_unpin_lock.exit.i

rq_unpin_lock.exit.i:                             ; preds = %if.then.i.i.i157, %if.end.i.i
  %retval.0.i.i.i158 = phi ptr [ %53, %if.then.i.i.i157 ], [ %7, %if.end.i.i ]
  %dep_map.i.i159 = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i158, i32 0, i32 4
  %54 = insertvalue [1 x i32] undef, i32 %call1.i.i, 0
  tail call void @lock_unpin_lock(ptr noundef %dep_map.i.i159, [1 x i32] %54) #20
  tail call void @raw_spin_rq_unlock(ptr noundef %7) #20
  br i1 %tobool.not.i.i, label %if.then.i3.i, label %do.body2.i.i

if.then.i3.i:                                     ; preds = %rq_unpin_lock.exit.i
  tail call void @trace_hardirqs_on() #20
  br label %do.body2.i.i

do.body2.i.i:                                     ; preds = %if.then.i3.i, %rq_unpin_lock.exit.i
  %55 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #20, !srcloc !280
  %and.i.i.i.i = and i32 %55, 128
  %tobool10.not.i.i = icmp eq i32 %and.i.i.i.i, 0
  br i1 %tobool10.not.i.i, label %if.then14.i.i, label %rq_unlock_irqrestore.exit, !prof !260

if.then14.i.i:                                    ; preds = %do.body2.i.i
  tail call void @warn_bogus_irq_restore() #20
  br label %rq_unlock_irqrestore.exit

rq_unlock_irqrestore.exit:                        ; preds = %if.then14.i.i, %do.body2.i.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %18) #20, !srcloc !281
  %call = tail call i32 @cpumask_next(i32 noundef %call172, ptr noundef nonnull @__cpu_possible_mask) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %56 = load i32, ptr @nr_cpu_ids, align 4
  %cmp10 = icmp ult i32 %call, %56
  br i1 %cmp10, label %for.body, label %for.end95thread-pre-split

for.end95thread-pre-split:                        ; preds = %rq_unlock_irqrestore.exit
  %57 = ptrtoint ptr %idle5 to i32
  call void @__asan_load4_noabort(i32 %57)
  %.pr = load i32, ptr %idle5, align 4
  br label %for.end95

for.end95:                                        ; preds = %for.end95thread-pre-split, %if.end8
  %58 = phi i32 [ %.pr, %for.end95thread-pre-split ], [ %idle, %if.end8 ]
  %cmp.i164 = icmp slt i32 %58, 1
  %.174 = select i1 %cmp.i164, i32 1024, i32 3
  %call101 = tail call fastcc i32 @__sched_group_set_shares(ptr noundef %tg, i32 noundef %.174)
  br label %cleanup103.sink.split

cleanup103.sink.split:                            ; preds = %for.end95, %if.end4
  tail call void @mutex_unlock(ptr noundef nonnull @shares_mutex) #20
  br label %cleanup103

cleanup103:                                       ; preds = %cleanup103.sink.split, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ 0, %cleanup103.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @enqueue_task_fair(ptr noundef %rq, ptr noundef %p, i32 noundef %flags) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %ue.sroa.0.i.i = alloca i32, align 8
  %ue.sroa.5.i.i = alloca i32, align 4
  %se1 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %policy.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 31
  %0 = ptrtoint ptr %policy.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %policy.i, align 4
  %cmp.i.i = icmp eq i32 %1, 5
  %conv.i.i = zext i1 %cmp.i.i to i32
  %and = and i32 %flags, 1
  %tobool.not = icmp eq i32 %and, 0
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 20), i32 1), ptr blockaddress(@enqueue_task_fair, %util_est_enqueue.exit)) #20
          to label %if.end.i [label %util_est_enqueue.exit], !srcloc !261

if.end.i:                                         ; preds = %entry
  %cfs = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 14
  %util_est.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 14, i32 17, i32 9
  %2 = ptrtoint ptr %util_est.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %util_est.i, align 16
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.0.i.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.5.i.i)
  %util_est.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9
  %4 = ptrtoint ptr %util_est.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %ue.sroa.0.0.copyload.i.i = load volatile i32, ptr %util_est.i.i, align 16
  %5 = ptrtoint ptr %ue.sroa.0.i.i to i32
  call void @__asan_store4_noabort(i32 %5)
  store volatile i32 %ue.sroa.0.0.copyload.i.i, ptr %ue.sroa.0.i.i, align 8
  %ue.sroa.5.0.util_est.sroa_idx.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9, i32 1
  %6 = ptrtoint ptr %ue.sroa.5.0.util_est.sroa_idx.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %ue.sroa.5.0.copyload.i.i = load volatile i32, ptr %ue.sroa.5.0.util_est.sroa_idx.i.i, align 4
  %7 = ptrtoint ptr %ue.sroa.5.i.i to i32
  call void @__asan_store4_noabort(i32 %7)
  store volatile i32 %ue.sroa.5.0.copyload.i.i, ptr %ue.sroa.5.i.i, align 4
  %and.i.i = and i32 %ue.sroa.0.0.copyload.i.i, 2147483647
  %8 = tail call i32 @llvm.umax.i32(i32 %ue.sroa.5.0.copyload.i.i, i32 %and.i.i) #20
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.0.i.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.5.i.i)
  %add.i = add i32 %8, %3
  %9 = ptrtoint ptr %util_est.i to i32
  call void @__asan_store4_noabort(i32 %9)
  store volatile i32 %add.i, ptr %util_est.i, align 16
  tail call fastcc void @trace_sched_util_est_cfs_tp(ptr noundef %cfs) #20
  br label %util_est_enqueue.exit

util_est_enqueue.exit:                            ; preds = %if.end.i, %entry
  %in_iowait = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 65
  %10 = ptrtoint ptr %in_iowait to i32
  call void @__asan_load2_noabort(i32 %10)
  %bf.load = load i16, ptr %in_iowait, align 8
  %11 = and i16 %bf.load, 8192
  %tobool2.not = icmp eq i16 %11, 0
  br i1 %tobool2.not, label %if.end, label %if.then

if.then:                                          ; preds = %util_est_enqueue.exit
  tail call fastcc void @cpufreq_update_util(ptr noundef %rq, i32 noundef 1)
  br label %if.end

if.end:                                           ; preds = %if.then, %util_est_enqueue.exit
  %tobool3.not131 = icmp eq ptr %se1, null
  br i1 %tobool3.not131, label %for.end40, label %for.body

for.body:                                         ; preds = %if.end16, %if.end
  %idle_h_nr_running.0134 = phi i32 [ %spec.select, %if.end16 ], [ %conv.i.i, %if.end ]
  %se.0133 = phi ptr [ %26, %if.end16 ], [ %se1, %if.end ]
  %flags.addr.0132 = phi i32 [ 1, %if.end16 ], [ %flags, %if.end ]
  %on_rq = getelementptr inbounds %struct.sched_entity, ptr %se.0133, i32 0, i32 3
  %12 = ptrtoint ptr %on_rq to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %on_rq, align 4
  %tobool4.not = icmp eq i32 %13, 0
  br i1 %tobool4.not, label %if.end6, label %for.body19

if.end6:                                          ; preds = %for.body
  %cfs_rq.i = getelementptr inbounds %struct.sched_entity, ptr %se.0133, i32 0, i32 11
  %14 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %cfs_rq.i, align 16
  tail call fastcc void @enqueue_entity(ptr noundef %15, ptr noundef nonnull %se.0133, i32 noundef %flags.addr.0132)
  %h_nr_running = getelementptr inbounds %struct.cfs_rq, ptr %15, i32 0, i32 2
  %16 = ptrtoint ptr %h_nr_running to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %h_nr_running, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %h_nr_running, align 4
  %idle_h_nr_running8 = getelementptr inbounds %struct.cfs_rq, ptr %15, i32 0, i32 4
  %18 = ptrtoint ptr %idle_h_nr_running8 to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %idle_h_nr_running8, align 4
  %add = add i32 %19, %idle_h_nr_running.0134
  store i32 %add, ptr %idle_h_nr_running8, align 4
  %idle.i = getelementptr inbounds %struct.cfs_rq, ptr %15, i32 0, i32 31
  %20 = ptrtoint ptr %idle.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %idle.i, align 16
  %cmp.i = icmp slt i32 %21, 1
  %spec.select = select i1 %cmp.i, i32 %idle_h_nr_running.0134, i32 1
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@enqueue_task_fair, %land.rhs.i)) #20
          to label %cfs_rq_throttled.exit [label %land.rhs.i], !srcloc !261

land.rhs.i:                                       ; preds = %if.end6
  %throttled.i = getelementptr inbounds %struct.cfs_rq, ptr %15, i32 0, i32 37
  %22 = ptrtoint ptr %throttled.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load i32, ptr %throttled.i, align 8
  %tobool.i = icmp ne i32 %23, 0
  %phi.cast.i = zext i1 %tobool.i to i32
  br label %cfs_rq_throttled.exit

cfs_rq_throttled.exit:                            ; preds = %land.rhs.i, %if.end6
  %24 = phi i32 [ %phi.cast.i, %land.rhs.i ], [ 0, %if.end6 ]
  %tobool14.not = icmp eq i32 %24, 0
  br i1 %tobool14.not, label %if.end16, label %enqueue_throttle

if.end16:                                         ; preds = %cfs_rq_throttled.exit
  %parent = getelementptr inbounds %struct.sched_entity, ptr %se.0133, i32 0, i32 10
  %25 = ptrtoint ptr %parent to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load ptr, ptr %parent, align 4
  %tobool3.not = icmp eq ptr %26, null
  br i1 %tobool3.not, label %for.end40, label %for.body

for.body19:                                       ; preds = %for.inc38, %for.body
  %idle_h_nr_running.2140 = phi i32 [ %spec.select92, %for.inc38 ], [ %idle_h_nr_running.0134, %for.body ]
  %se.1139 = phi ptr [ %67, %for.inc38 ], [ %se.0133, %for.body ]
  %cfs_rq.i93 = getelementptr inbounds %struct.sched_entity, ptr %se.1139, i32 0, i32 11
  %27 = ptrtoint ptr %cfs_rq.i93 to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %cfs_rq.i93, align 16
  tail call fastcc void @update_load_avg(ptr noundef %28, ptr noundef nonnull %se.1139, i32 noundef 1)
  %my_q.i = getelementptr inbounds %struct.sched_entity, ptr %se.1139, i32 0, i32 12
  %29 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i = icmp eq ptr %30, null
  br i1 %tobool.not.i, label %update_cfs_group.exit, label %se_update_runnable.exit

se_update_runnable.exit:                          ; preds = %for.body19
  %h_nr_running.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 2
  %31 = ptrtoint ptr %h_nr_running.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %h_nr_running.i, align 4
  %runnable_weight.i = getelementptr inbounds %struct.sched_entity, ptr %se.1139, i32 0, i32 13
  %33 = ptrtoint ptr %runnable_weight.i to i32
  call void @__asan_store4_noabort(i32 %33)
  store i32 %32, ptr %runnable_weight.i, align 8
  %34 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %34)
  %.pr = load ptr, ptr %my_q.i, align 4
  %tobool.not.i95 = icmp eq ptr %.pr, null
  br i1 %tobool.not.i95, label %update_cfs_group.exit, label %if.end.i96

if.end.i96:                                       ; preds = %se_update_runnable.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@enqueue_task_fair, %land.rhs.i.i)) #20
          to label %if.end4.i [label %land.rhs.i.i], !srcloc !261

land.rhs.i.i:                                     ; preds = %if.end.i96
  %throttle_count.i.i = getelementptr inbounds %struct.cfs_rq, ptr %.pr, i32 0, i32 38
  %35 = ptrtoint ptr %throttle_count.i.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %throttle_count.i.i, align 4
  %tobool.i.not.i = icmp eq i32 %36, 0
  br i1 %tobool.i.not.i, label %if.end4.i, label %update_cfs_group.exit

if.end4.i:                                        ; preds = %land.rhs.i.i, %if.end.i96
  %tg1.i.i = getelementptr inbounds %struct.cfs_rq, ptr %.pr, i32 0, i32 30
  %37 = ptrtoint ptr %tg1.i.i to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load ptr, ptr %tg1.i.i, align 4
  %shares2.i.i = getelementptr inbounds %struct.task_group, ptr %38, i32 0, i32 3
  %39 = ptrtoint ptr %shares2.i.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load volatile i32, ptr %shares2.i.i, align 16
  %41 = ptrtoint ptr %.pr to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load i32, ptr %.pr, align 128
  %load_avg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %.pr, i32 0, i32 17, i32 5
  %43 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load i32, ptr %load_avg.i.i, align 32
  %45 = tail call i32 @llvm.umax.i32(i32 %42, i32 %44) #20
  %load_avg5.i.i = getelementptr inbounds %struct.task_group, ptr %38, i32 0, i32 6
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %load_avg5.i.i, i32 noundef 4) #20
  %46 = ptrtoint ptr %load_avg5.i.i to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load volatile i32, ptr %load_avg5.i.i, align 4
  %tg_load_avg_contrib.i.i = getelementptr inbounds %struct.cfs_rq, ptr %.pr, i32 0, i32 21
  %48 = ptrtoint ptr %tg_load_avg_contrib.i.i to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load i32, ptr %tg_load_avg_contrib.i.i, align 128
  %sub.i.i = sub i32 %47, %49
  %add.i.i = add i32 %sub.i.i, %45
  %mul.i.i = mul i32 %45, %40
  %tobool.not.i.i = icmp eq i32 %add.i.i, 0
  br i1 %tobool.not.i.i, label %calc_group_shares.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.end4.i
  %div.i.i = sdiv i32 %mul.i.i, %add.i.i
  br label %calc_group_shares.exit.i

calc_group_shares.exit.i:                         ; preds = %if.then.i.i, %if.end4.i
  %shares.0.i.i = phi i32 [ %div.i.i, %if.then.i.i ], [ %mul.i.i, %if.end4.i ]
  %50 = tail call i32 @llvm.smax.i32(i32 %shares.0.i.i, i32 2) #20
  %51 = tail call i32 @llvm.smin.i32(i32 %50, i32 %40) #20
  %52 = ptrtoint ptr %cfs_rq.i93 to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load ptr, ptr %cfs_rq.i93, align 16
  tail call fastcc void @reweight_entity(ptr noundef %53, ptr noundef nonnull %se.1139, i32 noundef %51) #20
  br label %update_cfs_group.exit

update_cfs_group.exit:                            ; preds = %calc_group_shares.exit.i, %land.rhs.i.i, %se_update_runnable.exit, %for.body19
  %h_nr_running21 = getelementptr inbounds %struct.cfs_rq, ptr %28, i32 0, i32 2
  %54 = ptrtoint ptr %h_nr_running21 to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load i32, ptr %h_nr_running21, align 4
  %inc22 = add i32 %55, 1
  store i32 %inc22, ptr %h_nr_running21, align 4
  %idle_h_nr_running23 = getelementptr inbounds %struct.cfs_rq, ptr %28, i32 0, i32 4
  %56 = ptrtoint ptr %idle_h_nr_running23 to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load i32, ptr %idle_h_nr_running23, align 4
  %add24 = add i32 %57, %idle_h_nr_running.2140
  store i32 %add24, ptr %idle_h_nr_running23, align 4
  %idle.i97 = getelementptr inbounds %struct.cfs_rq, ptr %28, i32 0, i32 31
  %58 = ptrtoint ptr %idle.i97 to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load i32, ptr %idle.i97, align 16
  %cmp.i98 = icmp slt i32 %59, 1
  %spec.select92 = select i1 %cmp.i98, i32 %idle_h_nr_running.2140, i32 1
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@enqueue_task_fair, %land.rhs.i103)) #20
          to label %cfs_rq_throttled.exit104 [label %land.rhs.i103], !srcloc !261

land.rhs.i103:                                    ; preds = %update_cfs_group.exit
  %throttled.i100 = getelementptr inbounds %struct.cfs_rq, ptr %28, i32 0, i32 37
  %60 = ptrtoint ptr %throttled.i100 to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load i32, ptr %throttled.i100, align 8
  %tobool.i101 = icmp ne i32 %61, 0
  %phi.cast.i102 = zext i1 %tobool.i101 to i32
  br label %cfs_rq_throttled.exit104

cfs_rq_throttled.exit104:                         ; preds = %land.rhs.i103, %update_cfs_group.exit
  %62 = phi i32 [ %phi.cast.i102, %land.rhs.i103 ], [ 0, %update_cfs_group.exit ]
  %tobool30.not = icmp eq i32 %62, 0
  br i1 %tobool30.not, label %if.end32, label %enqueue_throttle

if.end32:                                         ; preds = %cfs_rq_throttled.exit104
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@enqueue_task_fair, %land.rhs.i107)) #20
          to label %throttled_hierarchy.exit [label %land.rhs.i107], !srcloc !261

land.rhs.i107:                                    ; preds = %if.end32
  %throttle_count.i = getelementptr inbounds %struct.cfs_rq, ptr %28, i32 0, i32 38
  %63 = ptrtoint ptr %throttle_count.i to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load i32, ptr %throttle_count.i, align 4
  %tobool.i105 = icmp ne i32 %64, 0
  %phi.cast.i106 = zext i1 %tobool.i105 to i32
  br label %throttled_hierarchy.exit

throttled_hierarchy.exit:                         ; preds = %land.rhs.i107, %if.end32
  %65 = phi i32 [ %phi.cast.i106, %land.rhs.i107 ], [ 0, %if.end32 ]
  %tobool34.not = icmp eq i32 %65, 0
  br i1 %tobool34.not, label %for.inc38, label %if.then35

if.then35:                                        ; preds = %throttled_hierarchy.exit
  %call36 = tail call fastcc zeroext i1 @list_add_leaf_cfs_rq(ptr noundef %28)
  br label %for.inc38

for.inc38:                                        ; preds = %if.then35, %throttled_hierarchy.exit
  %parent39 = getelementptr inbounds %struct.sched_entity, ptr %se.1139, i32 0, i32 10
  %66 = ptrtoint ptr %parent39 to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load ptr, ptr %parent39, align 4
  %tobool18.not = icmp eq ptr %67, null
  br i1 %tobool18.not, label %for.end40, label %for.body19

for.end40:                                        ; preds = %for.inc38, %if.end16, %if.end
  %nr_running.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 1
  %68 = ptrtoint ptr %nr_running.i to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load i32, ptr %nr_running.i, align 4
  %add.i108 = add i32 %69, 1
  store i32 %add.i108, ptr %nr_running.i, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_update_nr_running_tp, i32 0, i32 1), ptr blockaddress(@enqueue_task_fair, %if.then.i109)) #20
          to label %if.end.i111 [label %if.then.i109], !srcloc !261

if.then.i109:                                     ; preds = %for.end40
  tail call void @call_trace_sched_update_nr_running(ptr noundef %rq, i32 noundef 1) #20
  br label %if.end.i111

if.end.i111:                                      ; preds = %if.then.i109, %for.end40
  %cmp.i110 = icmp ult i32 %69, 2
  br i1 %cmp.i110, label %land.lhs.true.i, label %add_nr_running.exit

land.lhs.true.i:                                  ; preds = %if.end.i111
  %70 = ptrtoint ptr %nr_running.i to i32
  call void @__asan_load4_noabort(i32 %70)
  %71 = load i32, ptr %nr_running.i, align 4
  %cmp3.i = icmp ugt i32 %71, 1
  br i1 %cmp3.i, label %do.end.i, label %add_nr_running.exit

do.end.i:                                         ; preds = %land.lhs.true.i
  %rd.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 35
  %72 = ptrtoint ptr %rd.i to i32
  call void @__asan_load4_noabort(i32 %72)
  %73 = load ptr, ptr %rd.i, align 8
  %overload.i = getelementptr inbounds %struct.root_domain, ptr %73, i32 0, i32 5
  %74 = ptrtoint ptr %overload.i to i32
  call void @__asan_load4_noabort(i32 %74)
  %75 = load volatile i32, ptr %overload.i, align 8
  %tobool.not.i112 = icmp eq i32 %75, 0
  br i1 %tobool.not.i112, label %do.body10.i, label %add_nr_running.exit

do.body10.i:                                      ; preds = %do.end.i
  %76 = ptrtoint ptr %overload.i to i32
  call void @__asan_store4_noabort(i32 %76)
  store volatile i32 1, ptr %overload.i, align 8
  br label %add_nr_running.exit

add_nr_running.exit:                              ; preds = %do.body10.i, %do.end.i, %land.lhs.true.i, %if.end.i111
  br i1 %tobool.not, label %enqueue_throttle, label %if.then42

if.then42:                                        ; preds = %add_nr_running.exit
  %rd.i113 = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 35
  %77 = ptrtoint ptr %rd.i113 to i32
  call void @__asan_load4_noabort(i32 %77)
  %78 = load ptr, ptr %rd.i113, align 8
  %overutilized.i = getelementptr inbounds %struct.root_domain, ptr %78, i32 0, i32 6
  %79 = ptrtoint ptr %overutilized.i to i32
  call void @__asan_load4_noabort(i32 %79)
  %80 = load volatile i32, ptr %overutilized.i, align 4
  %tobool.not.i114 = icmp eq i32 %80, 0
  br i1 %tobool.not.i114, label %land.lhs.true.i115, label %enqueue_throttle

land.lhs.true.i115:                               ; preds = %if.then42
  %cpu.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 46
  %81 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %81)
  %82 = load i32, ptr %cpu.i, align 4
  %arrayidx.i.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %82
  %83 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %83)
  %84 = load i32, ptr %arrayidx.i.i.i, align 4
  %add.i.i.i = add i32 %84, ptrtoint (ptr @runqueues to i32)
  %85 = inttoptr i32 %add.i.i.i to ptr
  %util_avg.i.i.i = getelementptr inbounds %struct.rq, ptr %85, i32 0, i32 14, i32 17, i32 7
  %86 = ptrtoint ptr %util_avg.i.i.i to i32
  call void @__asan_load4_noabort(i32 %86)
  %87 = load volatile i32, ptr %util_avg.i.i.i, align 8
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 20), i32 1), ptr blockaddress(@enqueue_task_fair, %cpu_overutilized.exit.i)) #20
          to label %if.then.i.i.i [label %cpu_overutilized.exit.i], !srcloc !261

if.then.i.i.i:                                    ; preds = %land.lhs.true.i115
  %util_est.i.i.i = getelementptr inbounds %struct.rq, ptr %85, i32 0, i32 14, i32 17, i32 9
  %88 = ptrtoint ptr %util_est.i.i.i to i32
  call void @__asan_load4_noabort(i32 %88)
  %89 = load volatile i32, ptr %util_est.i.i.i, align 16
  %90 = tail call i32 @llvm.umax.i32(i32 %87, i32 %89) #20
  br label %cpu_overutilized.exit.i

cpu_overutilized.exit.i:                          ; preds = %if.then.i.i.i, %land.lhs.true.i115
  %util.0.i.i.i = phi i32 [ %90, %if.then.i.i.i ], [ %87, %land.lhs.true.i115 ]
  %91 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %91)
  %92 = load i32, ptr %arrayidx.i.i.i, align 4
  %add.i.i.i.i = add i32 %92, ptrtoint (ptr @runqueues to i32)
  %93 = inttoptr i32 %add.i.i.i.i to ptr
  %cpu_capacity_orig.i.i.i.i = getelementptr inbounds %struct.rq, ptr %93, i32 0, i32 38
  %94 = ptrtoint ptr %cpu_capacity_orig.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %94)
  %95 = load i32, ptr %cpu_capacity_orig.i.i.i.i, align 4
  %96 = tail call i32 @llvm.umin.i32(i32 %util.0.i.i.i, i32 %95) #20
  %mul.i.i116 = mul i32 %96, 1280
  %cpu_capacity.i.i.i = getelementptr inbounds %struct.rq, ptr %93, i32 0, i32 37
  %97 = ptrtoint ptr %cpu_capacity.i.i.i to i32
  call void @__asan_load4_noabort(i32 %97)
  %98 = load i32, ptr %cpu_capacity.i.i.i, align 16
  %mul2.i.i = shl i32 %98, 10
  %cmp.i.not.i = icmp ult i32 %mul.i.i116, %mul2.i.i
  br i1 %cmp.i.not.i, label %enqueue_throttle, label %do.body4.i

do.body4.i:                                       ; preds = %cpu_overutilized.exit.i
  %99 = ptrtoint ptr %rd.i113 to i32
  call void @__asan_load4_noabort(i32 %99)
  %100 = load ptr, ptr %rd.i113, align 8
  %overutilized6.i = getelementptr inbounds %struct.root_domain, ptr %100, i32 0, i32 6
  %101 = ptrtoint ptr %overutilized6.i to i32
  call void @__asan_store4_noabort(i32 %101)
  store volatile i32 2, ptr %overutilized6.i, align 4
  %102 = load ptr, ptr %rd.i113, align 8
  tail call fastcc void @trace_sched_overutilized_tp(ptr noundef %102, i1 noundef zeroext true) #20
  br label %enqueue_throttle

enqueue_throttle:                                 ; preds = %do.body4.i, %cpu_overutilized.exit.i, %if.then42, %add_nr_running.exit, %cfs_rq_throttled.exit104, %cfs_rq_throttled.exit
  %se.2 = phi ptr [ null, %add_nr_running.exit ], [ null, %if.then42 ], [ null, %cpu_overutilized.exit.i ], [ null, %do.body4.i ], [ %se.1139, %cfs_rq_throttled.exit104 ], [ %se.0133, %cfs_rq_throttled.exit ]
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@enqueue_task_fair, %for.cond46)) #20
          to label %if.end56 [label %for.cond46], !srcloc !261

for.cond46:                                       ; preds = %for.inc53, %enqueue_throttle
  %se.3 = phi ptr [ %106, %for.inc53 ], [ %se.2, %enqueue_throttle ]
  %tobool47.not = icmp eq ptr %se.3, null
  br i1 %tobool47.not, label %if.end56, label %for.body48

for.body48:                                       ; preds = %for.cond46
  %cfs_rq.i118 = getelementptr inbounds %struct.sched_entity, ptr %se.3, i32 0, i32 11
  %103 = ptrtoint ptr %cfs_rq.i118 to i32
  call void @__asan_load4_noabort(i32 %103)
  %104 = load ptr, ptr %cfs_rq.i118, align 16
  %call50 = tail call fastcc zeroext i1 @list_add_leaf_cfs_rq(ptr noundef %104)
  br i1 %call50, label %if.end56, label %for.inc53

for.inc53:                                        ; preds = %for.body48
  %parent54 = getelementptr inbounds %struct.sched_entity, ptr %se.3, i32 0, i32 10
  %105 = ptrtoint ptr %parent54 to i32
  call void @__asan_load4_noabort(i32 %105)
  %106 = load ptr, ptr %parent54, align 4
  br label %for.cond46

if.end56:                                         ; preds = %for.body48, %for.cond46, %enqueue_throttle
  %tmp_alone_branch.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 18
  %107 = ptrtoint ptr %tmp_alone_branch.i to i32
  call void @__asan_load4_noabort(i32 %107)
  %108 = load ptr, ptr %tmp_alone_branch.i, align 128
  %leaf_cfs_rq_list.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 17
  %cmp.not.i = icmp eq ptr %108, %leaf_cfs_rq_list.i
  br i1 %cmp.not.i, label %assert_list_leaf_cfs_rq.exit, label %land.rhs.i119

land.rhs.i119:                                    ; preds = %if.end56
  %.b38.i = load i1, ptr @assert_list_leaf_cfs_rq.__already_done, align 1
  br i1 %.b38.i, label %assert_list_leaf_cfs_rq.exit, label %if.then.i120, !prof !259

if.then.i120:                                     ; preds = %land.rhs.i119
  store i1 true, ptr @assert_list_leaf_cfs_rq.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 387, i32 noundef 9, ptr noundef nonnull @.str.18) #20
  br label %assert_list_leaf_cfs_rq.exit

assert_list_leaf_cfs_rq.exit:                     ; preds = %if.then.i120, %land.rhs.i119, %if.end56
  %curr1.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 20
  %109 = ptrtoint ptr %curr1.i to i32
  call void @__asan_load4_noabort(i32 %109)
  %110 = load ptr, ptr %curr1.i, align 8
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 6), ptr blockaddress(@enqueue_task_fair, %if.end.i.i)) #20
          to label %hrtick_update.exit [label %if.end.i.i], !srcloc !261

if.end.i.i:                                       ; preds = %assert_list_leaf_cfs_rq.exit
  %cpu.i.i.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 46
  %111 = ptrtoint ptr %cpu.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %111)
  %112 = load i32, ptr %cpu.i.i.i.i, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %113 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i.i.i.i = icmp ugt i32 %113, %112
  br i1 %cmp.not.i.i.i.i.i.i.i, label %cpu_active.exit.i.i.i, label %land.rhs.i.i.i.i.i.i.i

land.rhs.i.i.i.i.i.i.i:                           ; preds = %if.end.i.i
  %.b37.i.i.i.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i.i.i.i, label %cpu_active.exit.i.i.i, label %if.then.i.i.i.i.i.i.i, !prof !259

if.then.i.i.i.i.i.i.i:                            ; preds = %land.rhs.i.i.i.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_active.exit.i.i.i

cpu_active.exit.i.i.i:                            ; preds = %if.then.i.i.i.i.i.i.i, %land.rhs.i.i.i.i.i.i.i, %if.end.i.i
  %div3.i.i.i.i.i.i = lshr i32 %112, 5
  %arrayidx.i.i.i.i.i.i = getelementptr i32, ptr @__cpu_active_mask, i32 %div3.i.i.i.i.i.i
  %114 = ptrtoint ptr %arrayidx.i.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %114)
  %115 = load volatile i32, ptr %arrayidx.i.i.i.i.i.i, align 4
  %and.i.i.i.i.i.i = and i32 %112, 31
  %116 = shl nuw i32 1, %and.i.i.i.i.i.i
  %117 = and i32 %115, %116
  %tobool.i.not.i.i.i = icmp eq i32 %117, 0
  br i1 %tobool.i.not.i.i.i, label %hrtick_update.exit, label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %cpu_active.exit.i.i.i
  %base.i.i.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 66, i32 3
  %118 = ptrtoint ptr %base.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %118)
  %119 = load ptr, ptr %base.i.i.i.i, align 4
  %120 = ptrtoint ptr %119 to i32
  call void @__asan_load4_noabort(i32 %120)
  %121 = load ptr, ptr %119, align 8
  %hres_active.i.i.i.i = getelementptr inbounds %struct.hrtimer_cpu_base, ptr %121, i32 0, i32 4
  %122 = ptrtoint ptr %hres_active.i.i.i.i to i32
  call void @__asan_load1_noabort(i32 %122)
  %bf.load.i.i.i.i = load i8, ptr %hres_active.i.i.i.i, align 8
  %phi.cmp.i = icmp sgt i8 %bf.load.i.i.i.i, -1
  br i1 %phi.cmp.i, label %hrtick_update.exit, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.end.i.i.i
  %sched_class.i = getelementptr inbounds %struct.task_struct, ptr %110, i32 0, i32 21
  %123 = ptrtoint ptr %sched_class.i to i32
  call void @__asan_load4_noabort(i32 %123)
  %124 = load ptr, ptr %sched_class.i, align 32
  %cmp.not.i121 = icmp eq ptr %124, @fair_sched_class
  br i1 %cmp.not.i121, label %if.end.i125, label %hrtick_update.exit

if.end.i125:                                      ; preds = %lor.lhs.false.i
  %cfs_rq.i.i122 = getelementptr inbounds %struct.task_struct, ptr %110, i32 0, i32 18, i32 11
  %125 = ptrtoint ptr %cfs_rq.i.i122 to i32
  call void @__asan_load4_noabort(i32 %125)
  %126 = load ptr, ptr %cfs_rq.i.i122, align 16
  %nr_running.i123 = getelementptr inbounds %struct.cfs_rq, ptr %126, i32 0, i32 1
  %127 = ptrtoint ptr %nr_running.i123 to i32
  call void @__asan_load4_noabort(i32 %127)
  %128 = load i32, ptr %nr_running.i123, align 8
  %129 = load i32, ptr @sched_nr_latency, align 4
  %cmp3.i124 = icmp ult i32 %128, %129
  br i1 %cmp3.i124, label %if.then4.i, label %hrtick_update.exit

if.then4.i:                                       ; preds = %if.end.i125
  tail call fastcc void @hrtick_start_fair(ptr noundef %rq, ptr noundef %110) #20
  br label %hrtick_update.exit

hrtick_update.exit:                               ; preds = %if.then4.i, %if.end.i125, %lor.lhs.false.i, %if.end.i.i.i, %cpu_active.exit.i.i.i, %assert_list_leaf_cfs_rq.exit
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @dequeue_task_fair(ptr noundef %rq, ptr noundef %p, i32 noundef %flags) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %ue.sroa.0.i = alloca i32, align 8
  %ue.sroa.14.i = alloca i32, align 4
  %ue.sroa.0.i.i = alloca i32, align 8
  %ue.sroa.5.i.i = alloca i32, align 4
  %se1 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %and = and i32 %flags, 1
  %policy.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 31
  %0 = ptrtoint ptr %policy.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %policy.i, align 4
  %cmp.i.i = icmp eq i32 %1, 5
  %conv.i.i = zext i1 %cmp.i.i to i32
  %nr_running.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 1
  %2 = ptrtoint ptr %nr_running.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %nr_running.i, align 4
  %idle_h_nr_running.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 14, i32 4
  %4 = ptrtoint ptr %idle_h_nr_running.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %idle_h_nr_running.i, align 4
  %cmp.i = icmp ne i32 %3, %5
  %tobool.i = icmp eq i32 %3, 0
  %tobool.not = or i1 %tobool.i, %cmp.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 20), i32 1), ptr blockaddress(@dequeue_task_fair, %util_est_dequeue.exit)) #20
          to label %if.end.i [label %util_est_dequeue.exit], !srcloc !261

if.end.i:                                         ; preds = %entry
  %cfs = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 14
  %util_est.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 14, i32 17, i32 9
  %6 = ptrtoint ptr %util_est.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %util_est.i, align 16
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.0.i.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.5.i.i)
  %util_est.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9
  %8 = ptrtoint ptr %util_est.i.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %ue.sroa.0.0.copyload.i.i = load volatile i32, ptr %util_est.i.i, align 16
  %9 = ptrtoint ptr %ue.sroa.0.i.i to i32
  call void @__asan_store4_noabort(i32 %9)
  store volatile i32 %ue.sroa.0.0.copyload.i.i, ptr %ue.sroa.0.i.i, align 8
  %ue.sroa.5.0.util_est.sroa_idx.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9, i32 1
  %10 = ptrtoint ptr %ue.sroa.5.0.util_est.sroa_idx.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %ue.sroa.5.0.copyload.i.i = load volatile i32, ptr %ue.sroa.5.0.util_est.sroa_idx.i.i, align 4
  %11 = ptrtoint ptr %ue.sroa.5.i.i to i32
  call void @__asan_store4_noabort(i32 %11)
  store volatile i32 %ue.sroa.5.0.copyload.i.i, ptr %ue.sroa.5.i.i, align 4
  %and.i.i = and i32 %ue.sroa.0.0.copyload.i.i, 2147483647
  %12 = tail call i32 @llvm.umax.i32(i32 %ue.sroa.5.0.copyload.i.i, i32 %and.i.i) #20
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.0.i.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.5.i.i)
  %13 = tail call i32 @llvm.usub.sat.i32(i32 %7, i32 %12) #20
  %14 = ptrtoint ptr %util_est.i to i32
  call void @__asan_store4_noabort(i32 %14)
  store volatile i32 %13, ptr %util_est.i, align 16
  tail call fastcc void @trace_sched_util_est_cfs_tp(ptr noundef %cfs) #20
  br label %util_est_dequeue.exit

util_est_dequeue.exit:                            ; preds = %if.end.i, %entry
  %tobool3.not139 = icmp eq ptr %se1, null
  br i1 %tobool3.not139, label %for.end41, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %util_est_dequeue.exit
  %15 = or i32 %flags, 1
  br label %for.body

for.body:                                         ; preds = %if.end22, %for.body.lr.ph
  %idle_h_nr_running.0142 = phi i32 [ %conv.i.i, %for.body.lr.ph ], [ %spec.select, %if.end22 ]
  %se.0141 = phi ptr [ %se1, %for.body.lr.ph ], [ %30, %if.end22 ]
  %flags.addr.0140 = phi i32 [ %flags, %for.body.lr.ph ], [ %15, %if.end22 ]
  %cfs_rq.i = getelementptr inbounds %struct.sched_entity, ptr %se.0141, i32 0, i32 11
  %16 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %cfs_rq.i, align 16
  tail call fastcc void @dequeue_entity(ptr noundef %17, ptr noundef nonnull %se.0141, i32 noundef %flags.addr.0140)
  %h_nr_running = getelementptr inbounds %struct.cfs_rq, ptr %17, i32 0, i32 2
  %18 = ptrtoint ptr %h_nr_running to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %h_nr_running, align 4
  %dec = add i32 %19, -1
  store i32 %dec, ptr %h_nr_running, align 4
  %idle_h_nr_running5 = getelementptr inbounds %struct.cfs_rq, ptr %17, i32 0, i32 4
  %20 = ptrtoint ptr %idle_h_nr_running5 to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %idle_h_nr_running5, align 4
  %sub = sub i32 %21, %idle_h_nr_running.0142
  store i32 %sub, ptr %idle_h_nr_running5, align 4
  %idle.i = getelementptr inbounds %struct.cfs_rq, ptr %17, i32 0, i32 31
  %22 = ptrtoint ptr %idle.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load i32, ptr %idle.i, align 16
  %cmp.i88 = icmp slt i32 %23, 1
  %spec.select = select i1 %cmp.i88, i32 %idle_h_nr_running.0142, i32 1
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@dequeue_task_fair, %land.rhs.i)) #20
          to label %cfs_rq_throttled.exit [label %land.rhs.i], !srcloc !261

land.rhs.i:                                       ; preds = %for.body
  %throttled.i = getelementptr inbounds %struct.cfs_rq, ptr %17, i32 0, i32 37
  %24 = ptrtoint ptr %throttled.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %throttled.i, align 8
  %tobool.i89 = icmp ne i32 %25, 0
  %phi.cast.i = zext i1 %tobool.i89 to i32
  br label %cfs_rq_throttled.exit

cfs_rq_throttled.exit:                            ; preds = %land.rhs.i, %for.body
  %26 = phi i32 [ %phi.cast.i, %land.rhs.i ], [ 0, %for.body ]
  %tobool9.not = icmp eq i32 %26, 0
  br i1 %tobool9.not, label %if.end11, label %dequeue_throttle

if.end11:                                         ; preds = %cfs_rq_throttled.exit
  %27 = ptrtoint ptr %17 to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load i32, ptr %17, align 128
  %tobool12.not = icmp eq i32 %28, 0
  %parent = getelementptr inbounds %struct.sched_entity, ptr %se.0141, i32 0, i32 10
  %29 = ptrtoint ptr %parent to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %parent, align 4
  br i1 %tobool12.not, label %if.end22, label %if.then13

if.then13:                                        ; preds = %if.end11
  %tobool15.not = icmp eq i32 %and, 0
  br i1 %tobool15.not, label %for.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then13
  %tobool16.not = icmp eq ptr %30, null
  br i1 %tobool16.not, label %for.end41, label %land.lhs.true17

land.lhs.true17:                                  ; preds = %land.lhs.true
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@dequeue_task_fair, %land.rhs.i92)) #20
          to label %throttled_hierarchy.exit [label %land.rhs.i92], !srcloc !261

land.rhs.i92:                                     ; preds = %land.lhs.true17
  %throttle_count.i = getelementptr inbounds %struct.cfs_rq, ptr %17, i32 0, i32 38
  %31 = ptrtoint ptr %throttle_count.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %throttle_count.i, align 4
  %tobool.i90 = icmp ne i32 %32, 0
  %phi.cast.i91 = zext i1 %tobool.i90 to i32
  br label %throttled_hierarchy.exit

throttled_hierarchy.exit:                         ; preds = %land.rhs.i92, %land.lhs.true17
  %33 = phi i32 [ %phi.cast.i91, %land.rhs.i92 ], [ 0, %land.lhs.true17 ]
  %tobool19.not = icmp eq i32 %33, 0
  br i1 %tobool19.not, label %for.body.i, label %for.body25.preheader

for.body.i:                                       ; preds = %if.end43.i, %throttled_hierarchy.exit
  %se.addr.055.i = phi ptr [ %46, %if.end43.i ], [ %30, %throttled_hierarchy.exit ]
  %on_rq.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055.i, i32 0, i32 3
  %34 = ptrtoint ptr %on_rq.i to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load i32, ptr %on_rq.i, align 4
  %tobool1.not.i = icmp eq i32 %35, 0
  br i1 %tobool1.not.i, label %land.rhs.i93, label %if.end40.critedge.i

land.rhs.i93:                                     ; preds = %for.body.i
  %.b52.i = load i1, ptr @set_next_buddy.__already_done, align 1
  br i1 %.b52.i, label %for.end, label %if.then.i, !prof !259

if.then.i:                                        ; preds = %land.rhs.i93
  store i1 true, ptr @set_next_buddy.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 7065, i32 noundef 9, ptr noundef nonnull @.str.42) #20
  br label %for.end

if.end40.critedge.i:                              ; preds = %for.body.i
  %my_q.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055.i, i32 0, i32 12
  %36 = ptrtoint ptr %my_q.i.i to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load ptr, ptr %my_q.i.i, align 4
  %tobool.not.i.i = icmp eq ptr %37, null
  br i1 %tobool.not.i.i, label %se_is_idle.exit.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.end40.critedge.i
  %idle.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %37, i32 0, i32 31
  %38 = ptrtoint ptr %idle.i.i.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load i32, ptr %idle.i.i.i, align 16
  %cmp.i.i.i = icmp sgt i32 %39, 0
  br i1 %cmp.i.i.i, label %for.end, label %if.end43.i

se_is_idle.exit.i:                                ; preds = %if.end40.critedge.i
  %policy.i.i.i = getelementptr i8, ptr %se.addr.055.i, i32 900
  %40 = ptrtoint ptr %policy.i.i.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %policy.i.i.i, align 4
  %cmp.i.i.i.i = icmp eq i32 %41, 5
  br i1 %cmp.i.i.i.i, label %for.end, label %if.end43.i

if.end43.i:                                       ; preds = %se_is_idle.exit.i, %if.end.i.i
  %cfs_rq.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055.i, i32 0, i32 11
  %42 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load ptr, ptr %cfs_rq.i.i, align 16
  %next.i = getelementptr inbounds %struct.cfs_rq, ptr %43, i32 0, i32 12
  %44 = ptrtoint ptr %next.i to i32
  call void @__asan_store4_noabort(i32 %44)
  store ptr %se.addr.055.i, ptr %next.i, align 4
  %parent.i94 = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055.i, i32 0, i32 10
  %45 = ptrtoint ptr %parent.i94 to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load ptr, ptr %parent.i94, align 4
  %tobool.not.i = icmp eq ptr %46, null
  br i1 %tobool.not.i, label %for.end, label %for.body.i

if.end22:                                         ; preds = %if.end11
  %tobool3.not = icmp eq ptr %30, null
  br i1 %tobool3.not, label %for.end41, label %for.body

for.end:                                          ; preds = %if.end43.i, %se_is_idle.exit.i, %if.end.i.i, %if.then.i, %land.rhs.i93, %if.then13
  %tobool24.not143 = icmp eq ptr %30, null
  br i1 %tobool24.not143, label %for.end41, label %for.body25.preheader

for.body25.preheader:                             ; preds = %for.end, %throttled_hierarchy.exit
  br label %for.body25

for.body25:                                       ; preds = %for.inc39, %for.body25.preheader
  %idle_h_nr_running.3146 = phi i32 [ %spec.select87, %for.inc39 ], [ %spec.select, %for.body25.preheader ]
  %se.2144 = phi ptr [ %84, %for.inc39 ], [ %30, %for.body25.preheader ]
  %cfs_rq.i95 = getelementptr inbounds %struct.sched_entity, ptr %se.2144, i32 0, i32 11
  %47 = ptrtoint ptr %cfs_rq.i95 to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load ptr, ptr %cfs_rq.i95, align 16
  tail call fastcc void @update_load_avg(ptr noundef %48, ptr noundef nonnull %se.2144, i32 noundef 1)
  %my_q.i = getelementptr inbounds %struct.sched_entity, ptr %se.2144, i32 0, i32 12
  %49 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i96 = icmp eq ptr %50, null
  br i1 %tobool.not.i96, label %update_cfs_group.exit, label %se_update_runnable.exit

se_update_runnable.exit:                          ; preds = %for.body25
  %h_nr_running.i = getelementptr inbounds %struct.cfs_rq, ptr %50, i32 0, i32 2
  %51 = ptrtoint ptr %h_nr_running.i to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load i32, ptr %h_nr_running.i, align 4
  %runnable_weight.i = getelementptr inbounds %struct.sched_entity, ptr %se.2144, i32 0, i32 13
  %53 = ptrtoint ptr %runnable_weight.i to i32
  call void @__asan_store4_noabort(i32 %53)
  store i32 %52, ptr %runnable_weight.i, align 8
  %54 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %54)
  %.pr = load ptr, ptr %my_q.i, align 4
  %tobool.not.i100 = icmp eq ptr %.pr, null
  br i1 %tobool.not.i100, label %update_cfs_group.exit, label %if.end.i101

if.end.i101:                                      ; preds = %se_update_runnable.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@dequeue_task_fair, %land.rhs.i.i)) #20
          to label %if.end4.i [label %land.rhs.i.i], !srcloc !261

land.rhs.i.i:                                     ; preds = %if.end.i101
  %throttle_count.i.i = getelementptr inbounds %struct.cfs_rq, ptr %.pr, i32 0, i32 38
  %55 = ptrtoint ptr %throttle_count.i.i to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load i32, ptr %throttle_count.i.i, align 4
  %tobool.i.not.i = icmp eq i32 %56, 0
  br i1 %tobool.i.not.i, label %if.end4.i, label %update_cfs_group.exit

if.end4.i:                                        ; preds = %land.rhs.i.i, %if.end.i101
  %tg1.i.i = getelementptr inbounds %struct.cfs_rq, ptr %.pr, i32 0, i32 30
  %57 = ptrtoint ptr %tg1.i.i to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load ptr, ptr %tg1.i.i, align 4
  %shares2.i.i = getelementptr inbounds %struct.task_group, ptr %58, i32 0, i32 3
  %59 = ptrtoint ptr %shares2.i.i to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load volatile i32, ptr %shares2.i.i, align 16
  %61 = ptrtoint ptr %.pr to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load i32, ptr %.pr, align 128
  %load_avg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %.pr, i32 0, i32 17, i32 5
  %63 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load i32, ptr %load_avg.i.i, align 32
  %65 = tail call i32 @llvm.umax.i32(i32 %62, i32 %64) #20
  %load_avg5.i.i = getelementptr inbounds %struct.task_group, ptr %58, i32 0, i32 6
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %load_avg5.i.i, i32 noundef 4) #20
  %66 = ptrtoint ptr %load_avg5.i.i to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load volatile i32, ptr %load_avg5.i.i, align 4
  %tg_load_avg_contrib.i.i = getelementptr inbounds %struct.cfs_rq, ptr %.pr, i32 0, i32 21
  %68 = ptrtoint ptr %tg_load_avg_contrib.i.i to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load i32, ptr %tg_load_avg_contrib.i.i, align 128
  %sub.i.i = sub i32 %67, %69
  %add.i.i = add i32 %sub.i.i, %65
  %mul.i.i = mul i32 %65, %60
  %tobool.not.i.i102 = icmp eq i32 %add.i.i, 0
  br i1 %tobool.not.i.i102, label %calc_group_shares.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.end4.i
  %div.i.i = sdiv i32 %mul.i.i, %add.i.i
  br label %calc_group_shares.exit.i

calc_group_shares.exit.i:                         ; preds = %if.then.i.i, %if.end4.i
  %shares.0.i.i = phi i32 [ %div.i.i, %if.then.i.i ], [ %mul.i.i, %if.end4.i ]
  %70 = tail call i32 @llvm.smax.i32(i32 %shares.0.i.i, i32 2) #20
  %71 = tail call i32 @llvm.smin.i32(i32 %70, i32 %60) #20
  %72 = ptrtoint ptr %cfs_rq.i95 to i32
  call void @__asan_load4_noabort(i32 %72)
  %73 = load ptr, ptr %cfs_rq.i95, align 16
  tail call fastcc void @reweight_entity(ptr noundef %73, ptr noundef nonnull %se.2144, i32 noundef %71) #20
  br label %update_cfs_group.exit

update_cfs_group.exit:                            ; preds = %calc_group_shares.exit.i, %land.rhs.i.i, %se_update_runnable.exit, %for.body25
  %h_nr_running27 = getelementptr inbounds %struct.cfs_rq, ptr %48, i32 0, i32 2
  %74 = ptrtoint ptr %h_nr_running27 to i32
  call void @__asan_load4_noabort(i32 %74)
  %75 = load i32, ptr %h_nr_running27, align 4
  %dec28 = add i32 %75, -1
  store i32 %dec28, ptr %h_nr_running27, align 4
  %idle_h_nr_running29 = getelementptr inbounds %struct.cfs_rq, ptr %48, i32 0, i32 4
  %76 = ptrtoint ptr %idle_h_nr_running29 to i32
  call void @__asan_load4_noabort(i32 %76)
  %77 = load i32, ptr %idle_h_nr_running29, align 4
  %sub30 = sub i32 %77, %idle_h_nr_running.3146
  store i32 %sub30, ptr %idle_h_nr_running29, align 4
  %idle.i104 = getelementptr inbounds %struct.cfs_rq, ptr %48, i32 0, i32 31
  %78 = ptrtoint ptr %idle.i104 to i32
  call void @__asan_load4_noabort(i32 %78)
  %79 = load i32, ptr %idle.i104, align 16
  %cmp.i105 = icmp slt i32 %79, 1
  %spec.select87 = select i1 %cmp.i105, i32 %idle_h_nr_running.3146, i32 1
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@dequeue_task_fair, %land.rhs.i110)) #20
          to label %cfs_rq_throttled.exit111 [label %land.rhs.i110], !srcloc !261

land.rhs.i110:                                    ; preds = %update_cfs_group.exit
  %throttled.i107 = getelementptr inbounds %struct.cfs_rq, ptr %48, i32 0, i32 37
  %80 = ptrtoint ptr %throttled.i107 to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load i32, ptr %throttled.i107, align 8
  %tobool.i108 = icmp ne i32 %81, 0
  %phi.cast.i109 = zext i1 %tobool.i108 to i32
  br label %cfs_rq_throttled.exit111

cfs_rq_throttled.exit111:                         ; preds = %land.rhs.i110, %update_cfs_group.exit
  %82 = phi i32 [ %phi.cast.i109, %land.rhs.i110 ], [ 0, %update_cfs_group.exit ]
  %tobool36.not = icmp eq i32 %82, 0
  br i1 %tobool36.not, label %for.inc39, label %dequeue_throttle

for.inc39:                                        ; preds = %cfs_rq_throttled.exit111
  %parent40 = getelementptr inbounds %struct.sched_entity, ptr %se.2144, i32 0, i32 10
  %83 = ptrtoint ptr %parent40 to i32
  call void @__asan_load4_noabort(i32 %83)
  %84 = load ptr, ptr %parent40, align 4
  %tobool24.not = icmp eq ptr %84, null
  br i1 %tobool24.not, label %for.end41, label %for.body25

for.end41:                                        ; preds = %for.inc39, %for.end, %if.end22, %land.lhs.true, %util_est_dequeue.exit
  %85 = ptrtoint ptr %nr_running.i to i32
  call void @__asan_load4_noabort(i32 %85)
  %86 = load i32, ptr %nr_running.i, align 4
  %sub.i = add i32 %86, -1
  store i32 %sub.i, ptr %nr_running.i, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_update_nr_running_tp, i32 0, i32 1), ptr blockaddress(@dequeue_task_fair, %if.then.i113)) #20
          to label %sub_nr_running.exit [label %if.then.i113], !srcloc !261

if.then.i113:                                     ; preds = %for.end41
  tail call void @call_trace_sched_update_nr_running(ptr noundef %rq, i32 noundef -1) #20
  br label %sub_nr_running.exit

sub_nr_running.exit:                              ; preds = %if.then.i113, %for.end41
  br i1 %tobool.not, label %land.rhs, label %dequeue_throttle

land.rhs:                                         ; preds = %sub_nr_running.exit
  %87 = ptrtoint ptr %nr_running.i to i32
  call void @__asan_load4_noabort(i32 %87)
  %88 = load i32, ptr %nr_running.i, align 4
  %89 = ptrtoint ptr %idle_h_nr_running.i to i32
  call void @__asan_load4_noabort(i32 %89)
  %90 = load i32, ptr %idle_h_nr_running.i, align 4
  %cmp.i117 = icmp eq i32 %88, %90
  %tobool.i118 = icmp ne i32 %88, 0
  %narrow.i119 = and i1 %tobool.i118, %cmp.i117
  br i1 %narrow.i119, label %if.then47, label %dequeue_throttle, !prof !260

if.then47:                                        ; preds = %land.rhs
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %91 = load volatile i32, ptr @jiffies, align 128
  %next_balance = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 23
  %92 = ptrtoint ptr %next_balance to i32
  call void @__asan_store4_noabort(i32 %92)
  store i32 %91, ptr %next_balance, align 4
  br label %dequeue_throttle

dequeue_throttle:                                 ; preds = %if.then47, %land.rhs, %sub_nr_running.exit, %cfs_rq_throttled.exit111, %cfs_rq_throttled.exit
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.0.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.14.i)
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 20), i32 1), ptr blockaddress(@dequeue_task_fair, %util_est_update.exit)) #20
          to label %static_branch_UTIL_EST.exit.i [label %util_est_update.exit], !srcloc !261

static_branch_UTIL_EST.exit.i:                    ; preds = %dequeue_throttle
  %tobool50.not = icmp eq i32 %and, 0
  br i1 %tobool50.not, label %util_est_update.exit, label %if.end2.i

if.end2.i:                                        ; preds = %static_branch_UTIL_EST.exit.i
  %util_est.i120 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9
  %93 = ptrtoint ptr %util_est.i120 to i32
  call void @__asan_load4_noabort(i32 %93)
  %ue.sroa.0.0.copyload.i = load i32, ptr %util_est.i120, align 16
  %ue.sroa.14.0.util_est.sroa_idx.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9, i32 1
  %94 = ptrtoint ptr %ue.sroa.14.0.util_est.sroa_idx.i to i32
  call void @__asan_load4_noabort(i32 %94)
  %ue.sroa.14.0.copyload.i = load i32, ptr %ue.sroa.14.0.util_est.sroa_idx.i, align 4
  %95 = ptrtoint ptr %ue.sroa.14.i to i32
  call void @__asan_store4_noabort(i32 %95)
  store i32 %ue.sroa.14.0.copyload.i, ptr %ue.sroa.14.i, align 4
  %tobool3.not.i = icmp sgt i32 %ue.sroa.0.0.copyload.i, -1
  br i1 %tobool3.not.i, label %if.end5.i, label %util_est_update.exit

if.end5.i:                                        ; preds = %if.end2.i
  %util_avg.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 7
  %96 = ptrtoint ptr %util_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %96)
  %97 = load volatile i32, ptr %util_avg.i.i, align 8
  %98 = ptrtoint ptr %ue.sroa.0.i to i32
  call void @__asan_store4_noabort(i32 %98)
  store i32 %97, ptr %ue.sroa.0.i, align 8
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 21), i32 1), ptr blockaddress(@dequeue_task_fair, %if.end16.i)) #20
          to label %if.then10.i [label %if.end16.i], !srcloc !261

if.then10.i:                                      ; preds = %if.end5.i
  %99 = ptrtoint ptr %ue.sroa.14.i to i32
  call void @__asan_load4_noabort(i32 %99)
  %ue.sroa.14.i.0.ue.sroa.14.i.0.ue.sroa.14.0.ue.sroa.14.0.ue.sroa.14.0.ue.sroa.14.4..i = load i32, ptr %ue.sroa.14.i, align 4
  %100 = ptrtoint ptr %ue.sroa.0.i to i32
  call void @__asan_load4_noabort(i32 %100)
  %ue.sroa.0.i.0.ue.sroa.0.i.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.51.i = load i32, ptr %ue.sroa.0.i, align 8
  %cmp.i121 = icmp ult i32 %ue.sroa.14.i.0.ue.sroa.14.i.0.ue.sroa.14.0.ue.sroa.14.0.ue.sroa.14.0.ue.sroa.14.4..i, %ue.sroa.0.i.0.ue.sroa.0.i.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.51.i
  br i1 %cmp.i121, label %if.then12.i, label %if.end16.i

if.then12.i:                                      ; preds = %if.then10.i
  %101 = ptrtoint ptr %ue.sroa.14.i to i32
  call void @__asan_store4_noabort(i32 %101)
  store i32 %ue.sroa.0.i.0.ue.sroa.0.i.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.51.i, ptr %ue.sroa.14.i, align 4
  br label %done.i

if.end16.i:                                       ; preds = %if.then10.i, %if.end5.i
  %102 = ptrtoint ptr %ue.sroa.0.i to i32
  call void @__asan_load4_noabort(i32 %102)
  %ue.sroa.0.i.0.ue.sroa.0.i.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.53.i = load i32, ptr %ue.sroa.0.i, align 8
  %103 = ptrtoint ptr %ue.sroa.14.i to i32
  call void @__asan_load4_noabort(i32 %103)
  %ue.sroa.14.i.0.ue.sroa.14.i.0.ue.sroa.14.0.ue.sroa.14.0.ue.sroa.14.0.ue.sroa.14.4.58.i = load i32, ptr %ue.sroa.14.i, align 4
  %sub.i122 = sub i32 %ue.sroa.0.i.0.ue.sroa.0.i.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.53.i, %ue.sroa.14.i.0.ue.sroa.14.i.0.ue.sroa.14.0.ue.sroa.14.0.ue.sroa.14.0.ue.sroa.14.4.58.i
  %sub.i.i123 = add i32 %sub.i122, 9
  %cmp.i.i124 = icmp ult i32 %sub.i.i123, 19
  br i1 %cmp.i.i124, label %if.then22.i, label %if.end26.i

if.then22.i:                                      ; preds = %if.end16.i
  %sub20.i = add nuw i32 %ue.sroa.0.0.copyload.i, 9
  %sub.i70.i = sub i32 %sub20.i, %ue.sroa.0.i.0.ue.sroa.0.i.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.53.i
  %cmp.i71.i = icmp ult i32 %sub.i70.i, 19
  br i1 %cmp.i71.i, label %util_est_update.exit, label %done.i

if.end26.i:                                       ; preds = %if.end16.i
  %104 = ptrtoint ptr %util_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %104)
  %105 = load volatile i32, ptr %util_avg.i.i, align 8
  %rq.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 14, i32 27
  %106 = ptrtoint ptr %rq.i.i to i32
  call void @__asan_load4_noabort(i32 %106)
  %107 = load ptr, ptr %rq.i.i, align 4
  %cpu.i.i = getelementptr inbounds %struct.rq, ptr %107, i32 0, i32 46
  %108 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %108)
  %109 = load i32, ptr %cpu.i.i, align 4
  %arrayidx.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %109
  %110 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %110)
  %111 = load i32, ptr %arrayidx.i.i, align 4
  %add.i.i125 = add i32 %111, ptrtoint (ptr @runqueues to i32)
  %112 = inttoptr i32 %add.i.i125 to ptr
  %cpu_capacity_orig.i.i = getelementptr inbounds %struct.rq, ptr %112, i32 0, i32 38
  %113 = ptrtoint ptr %cpu_capacity_orig.i.i to i32
  call void @__asan_load4_noabort(i32 %113)
  %114 = load i32, ptr %cpu_capacity_orig.i.i, align 4
  %cmp31.i = icmp ugt i32 %105, %114
  br i1 %cmp31.i, label %util_est_update.exit, label %if.end33.i

if.end33.i:                                       ; preds = %if.end26.i
  %115 = lshr i32 %sub.i122, 2
  %116 = add i32 %115, %ue.sroa.14.i.0.ue.sroa.14.i.0.ue.sroa.14.0.ue.sroa.14.0.ue.sroa.14.0.ue.sroa.14.4.58.i
  %shr.i = and i32 %116, 1073741823
  %117 = ptrtoint ptr %ue.sroa.14.i to i32
  call void @__asan_store4_noabort(i32 %117)
  store i32 %shr.i, ptr %ue.sroa.14.i, align 4
  br label %done.i

done.i:                                           ; preds = %if.end33.i, %if.then22.i, %if.then12.i
  %118 = ptrtoint ptr %ue.sroa.0.i to i32
  call void @__asan_load4_noabort(i32 %118)
  %ue.sroa.0.i.0.ue.sroa.0.i.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.55.i = load i32, ptr %ue.sroa.0.i, align 8
  %or.i = or i32 %ue.sroa.0.i.0.ue.sroa.0.i.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.55.i, -2147483648
  store i32 %or.i, ptr %ue.sroa.0.i, align 8
  %ue.sroa.0.i.0.ue.sroa.0.i.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.copyload56.i = load volatile i32, ptr %ue.sroa.0.i, align 8
  %119 = ptrtoint ptr %util_est.i120 to i32
  call void @__asan_store4_noabort(i32 %119)
  store volatile i32 %ue.sroa.0.i.0.ue.sroa.0.i.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.ue.sroa.0.0.copyload56.i, ptr %util_est.i120, align 16
  %120 = ptrtoint ptr %ue.sroa.14.i to i32
  call void @__asan_load4_noabort(i32 %120)
  %ue.sroa.14.i.0.ue.sroa.14.i.0.ue.sroa.14.0.ue.sroa.14.0.ue.sroa.14.0.ue.sroa.14.0.copyload57.i = load volatile i32, ptr %ue.sroa.14.i, align 4
  %121 = ptrtoint ptr %ue.sroa.14.0.util_est.sroa_idx.i to i32
  call void @__asan_store4_noabort(i32 %121)
  store volatile i32 %ue.sroa.14.i.0.ue.sroa.14.i.0.ue.sroa.14.0.ue.sroa.14.0.ue.sroa.14.0.ue.sroa.14.0.copyload57.i, ptr %ue.sroa.14.0.util_est.sroa_idx.i, align 4
  tail call fastcc void @trace_sched_util_est_se_tp(ptr noundef %se1) #20
  br label %util_est_update.exit

util_est_update.exit:                             ; preds = %done.i, %if.end26.i, %if.then22.i, %if.end2.i, %static_branch_UTIL_EST.exit.i, %dequeue_throttle
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.0.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.14.i)
  %curr1.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 20
  %122 = ptrtoint ptr %curr1.i to i32
  call void @__asan_load4_noabort(i32 %122)
  %123 = load ptr, ptr %curr1.i, align 8
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 6), ptr blockaddress(@dequeue_task_fair, %if.end.i.i126)) #20
          to label %hrtick_update.exit [label %if.end.i.i126], !srcloc !261

if.end.i.i126:                                    ; preds = %util_est_update.exit
  %cpu.i.i.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 46
  %124 = ptrtoint ptr %cpu.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %124)
  %125 = load i32, ptr %cpu.i.i.i.i, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %126 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i.i.i.i = icmp ugt i32 %126, %125
  br i1 %cmp.not.i.i.i.i.i.i.i, label %cpu_active.exit.i.i.i, label %land.rhs.i.i.i.i.i.i.i

land.rhs.i.i.i.i.i.i.i:                           ; preds = %if.end.i.i126
  %.b37.i.i.i.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i.i.i.i, label %cpu_active.exit.i.i.i, label %if.then.i.i.i.i.i.i.i, !prof !259

if.then.i.i.i.i.i.i.i:                            ; preds = %land.rhs.i.i.i.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_active.exit.i.i.i

cpu_active.exit.i.i.i:                            ; preds = %if.then.i.i.i.i.i.i.i, %land.rhs.i.i.i.i.i.i.i, %if.end.i.i126
  %div3.i.i.i.i.i.i = lshr i32 %125, 5
  %arrayidx.i.i.i.i.i.i = getelementptr i32, ptr @__cpu_active_mask, i32 %div3.i.i.i.i.i.i
  %127 = ptrtoint ptr %arrayidx.i.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %127)
  %128 = load volatile i32, ptr %arrayidx.i.i.i.i.i.i, align 4
  %and.i.i.i.i.i.i = and i32 %125, 31
  %129 = shl nuw i32 1, %and.i.i.i.i.i.i
  %130 = and i32 %128, %129
  %tobool.i.not.i.i.i = icmp eq i32 %130, 0
  br i1 %tobool.i.not.i.i.i, label %hrtick_update.exit, label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %cpu_active.exit.i.i.i
  %base.i.i.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 66, i32 3
  %131 = ptrtoint ptr %base.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %131)
  %132 = load ptr, ptr %base.i.i.i.i, align 4
  %133 = ptrtoint ptr %132 to i32
  call void @__asan_load4_noabort(i32 %133)
  %134 = load ptr, ptr %132, align 8
  %hres_active.i.i.i.i = getelementptr inbounds %struct.hrtimer_cpu_base, ptr %134, i32 0, i32 4
  %135 = ptrtoint ptr %hres_active.i.i.i.i to i32
  call void @__asan_load1_noabort(i32 %135)
  %bf.load.i.i.i.i = load i8, ptr %hres_active.i.i.i.i, align 8
  %phi.cmp.i = icmp sgt i8 %bf.load.i.i.i.i, -1
  br i1 %phi.cmp.i, label %hrtick_update.exit, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.end.i.i.i
  %sched_class.i = getelementptr inbounds %struct.task_struct, ptr %123, i32 0, i32 21
  %136 = ptrtoint ptr %sched_class.i to i32
  call void @__asan_load4_noabort(i32 %136)
  %137 = load ptr, ptr %sched_class.i, align 32
  %cmp.not.i = icmp eq ptr %137, @fair_sched_class
  br i1 %cmp.not.i, label %if.end.i129, label %hrtick_update.exit

if.end.i129:                                      ; preds = %lor.lhs.false.i
  %cfs_rq.i.i127 = getelementptr inbounds %struct.task_struct, ptr %123, i32 0, i32 18, i32 11
  %138 = ptrtoint ptr %cfs_rq.i.i127 to i32
  call void @__asan_load4_noabort(i32 %138)
  %139 = load ptr, ptr %cfs_rq.i.i127, align 16
  %nr_running.i128 = getelementptr inbounds %struct.cfs_rq, ptr %139, i32 0, i32 1
  %140 = ptrtoint ptr %nr_running.i128 to i32
  call void @__asan_load4_noabort(i32 %140)
  %141 = load i32, ptr %nr_running.i128, align 8
  %142 = load i32, ptr @sched_nr_latency, align 4
  %cmp3.i = icmp ult i32 %141, %142
  br i1 %cmp3.i, label %if.then4.i, label %hrtick_update.exit

if.then4.i:                                       ; preds = %if.end.i129
  tail call fastcc void @hrtick_start_fair(ptr noundef %rq, ptr noundef %123) #20
  br label %hrtick_update.exit

hrtick_update.exit:                               ; preds = %if.then4.i, %if.end.i129, %lor.lhs.false.i, %if.end.i.i.i, %cpu_active.exit.i.i.i, %util_est_update.exit
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @yield_task_fair(ptr noundef %rq) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %curr1 = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 20
  %0 = ptrtoint ptr %curr1 to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %curr1, align 8
  %cfs_rq.i = getelementptr inbounds %struct.task_struct, ptr %1, i32 0, i32 18, i32 11
  %2 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %cfs_rq.i, align 16
  %se2 = getelementptr inbounds %struct.task_struct, ptr %1, i32 0, i32 18
  %nr_running = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 1
  %4 = ptrtoint ptr %nr_running to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %nr_running, align 4
  %cmp = icmp eq i32 %5, 1
  br i1 %cmp, label %cleanup, label %if.end, !prof !260

if.end:                                           ; preds = %entry
  %last.i = getelementptr inbounds %struct.cfs_rq, ptr %3, i32 0, i32 13
  %6 = ptrtoint ptr %last.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %last.i, align 16
  %cmp.i = icmp eq ptr %7, %se2
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end
  %tobool.not8.i.i = icmp eq ptr %se2, null
  br i1 %tobool.not8.i.i, label %clear_buddies.exit, label %for.body.i.i

for.body.i.i:                                     ; preds = %for.inc.i.i, %if.then.i
  %se.addr.09.i.i = phi ptr [ %14, %for.inc.i.i ], [ %se2, %if.then.i ]
  %cfs_rq.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i.i, i32 0, i32 11
  %8 = ptrtoint ptr %cfs_rq.i.i.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %cfs_rq.i.i.i, align 16
  %last.i.i = getelementptr inbounds %struct.cfs_rq, ptr %9, i32 0, i32 13
  %10 = ptrtoint ptr %last.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %last.i.i, align 16
  %cmp.not.i.i = icmp eq ptr %11, %se.addr.09.i.i
  br i1 %cmp.not.i.i, label %for.inc.i.i, label %if.end.i

for.inc.i.i:                                      ; preds = %for.body.i.i
  %12 = ptrtoint ptr %last.i.i to i32
  call void @__asan_store4_noabort(i32 %12)
  store ptr null, ptr %last.i.i, align 16
  %parent.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i.i, i32 0, i32 10
  %13 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i = icmp eq ptr %14, null
  br i1 %tobool.not.i.i, label %if.end.i, label %for.body.i.i

if.end.i:                                         ; preds = %for.inc.i.i, %for.body.i.i, %if.end
  %next.i = getelementptr inbounds %struct.cfs_rq, ptr %3, i32 0, i32 12
  %15 = ptrtoint ptr %next.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %next.i, align 4
  %cmp1.i = icmp ne ptr %16, %se2
  %tobool.not8.i14.i = icmp eq ptr %se2, null
  %or.cond.i = or i1 %tobool.not8.i14.i, %cmp1.i
  br i1 %or.cond.i, label %if.end3.i, label %for.body.i18.i

for.body.i18.i:                                   ; preds = %for.inc.i21.i, %if.end.i
  %se.addr.09.i15.i = phi ptr [ %23, %for.inc.i21.i ], [ %se2, %if.end.i ]
  %cfs_rq.i.i16.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i15.i, i32 0, i32 11
  %17 = ptrtoint ptr %cfs_rq.i.i16.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %cfs_rq.i.i16.i, align 16
  %next.i.i = getelementptr inbounds %struct.cfs_rq, ptr %18, i32 0, i32 12
  %19 = ptrtoint ptr %next.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %next.i.i, align 4
  %cmp.not.i17.i = icmp eq ptr %20, %se.addr.09.i15.i
  br i1 %cmp.not.i17.i, label %for.inc.i21.i, label %if.end3.i

for.inc.i21.i:                                    ; preds = %for.body.i18.i
  %21 = ptrtoint ptr %next.i.i to i32
  call void @__asan_store4_noabort(i32 %21)
  store ptr null, ptr %next.i.i, align 4
  %parent.i19.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i15.i, i32 0, i32 10
  %22 = ptrtoint ptr %parent.i19.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %parent.i19.i, align 4
  %tobool.not.i20.i = icmp eq ptr %23, null
  br i1 %tobool.not.i20.i, label %if.end3.i, label %for.body.i18.i

if.end3.i:                                        ; preds = %for.inc.i21.i, %for.body.i18.i, %if.end.i
  %skip.i = getelementptr inbounds %struct.cfs_rq, ptr %3, i32 0, i32 14
  %24 = ptrtoint ptr %skip.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %skip.i, align 4
  %cmp4.i = icmp ne ptr %25, %se2
  %or.cond33.i = or i1 %tobool.not8.i14.i, %cmp4.i
  br i1 %or.cond33.i, label %clear_buddies.exit, label %for.body.i26.i

for.body.i26.i:                                   ; preds = %for.inc.i29.i, %if.end3.i
  %se.addr.09.i23.i = phi ptr [ %32, %for.inc.i29.i ], [ %se2, %if.end3.i ]
  %cfs_rq.i.i24.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i23.i, i32 0, i32 11
  %26 = ptrtoint ptr %cfs_rq.i.i24.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load ptr, ptr %cfs_rq.i.i24.i, align 16
  %skip.i.i = getelementptr inbounds %struct.cfs_rq, ptr %27, i32 0, i32 14
  %28 = ptrtoint ptr %skip.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load ptr, ptr %skip.i.i, align 4
  %cmp.not.i25.i = icmp eq ptr %29, %se.addr.09.i23.i
  br i1 %cmp.not.i25.i, label %for.inc.i29.i, label %clear_buddies.exit

for.inc.i29.i:                                    ; preds = %for.body.i26.i
  %30 = ptrtoint ptr %skip.i.i to i32
  call void @__asan_store4_noabort(i32 %30)
  store ptr null, ptr %skip.i.i, align 4
  %parent.i27.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i23.i, i32 0, i32 10
  %31 = ptrtoint ptr %parent.i27.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %parent.i27.i, align 4
  %tobool.not.i28.i = icmp eq ptr %32, null
  br i1 %tobool.not.i28.i, label %clear_buddies.exit, label %for.body.i26.i

clear_buddies.exit:                               ; preds = %for.inc.i29.i, %for.body.i26.i, %if.end3.i, %if.then.i
  %policy = getelementptr inbounds %struct.task_struct, ptr %1, i32 0, i32 31
  %33 = ptrtoint ptr %policy to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %policy, align 4
  %cmp4.not = icmp eq i32 %34, 3
  br i1 %cmp4.not, label %if.end6, label %if.then5

if.then5:                                         ; preds = %clear_buddies.exit
  tail call void @update_rq_clock(ptr noundef %rq) #20
  tail call fastcc void @update_curr(ptr noundef %3)
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %35 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i16 = icmp eq i32 %35, 0
  br i1 %tobool.not.i.i16, label %rq_clock_skip_update.exit, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %if.then5
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 81
  %36 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %37, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.rhs.i.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 79
  %38 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %land.rhs.i.i
  %retval.0.i.i.i = phi ptr [ %39, %if.then.i.i.i ], [ %rq, %land.rhs.i.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i, i32 noundef -1) #20
  %cmp.not.i.i17 = icmp eq i32 %call.i.i.i, 0
  br i1 %cmp.not.i.i17, label %do.end.i.i, label %rq_clock_skip_update.exit, !prof !260

do.end.i.i:                                       ; preds = %__rq_lockp.exit.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %rq_clock_skip_update.exit

rq_clock_skip_update.exit:                        ; preds = %do.end.i.i, %__rq_lockp.exit.i.i, %if.then5
  %clock_update_flags.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 25
  %40 = ptrtoint ptr %clock_update_flags.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %clock_update_flags.i, align 4
  %or.i = or i32 %41, 1
  store i32 %or.i, ptr %clock_update_flags.i, align 4
  br label %if.end6

if.end6:                                          ; preds = %rq_clock_skip_update.exit, %clear_buddies.exit
  %tobool.not4.i = icmp eq ptr %se2, null
  br i1 %tobool.not4.i, label %cleanup, label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %if.end6
  %se.addr.05.i = phi ptr [ %46, %for.body.i ], [ %se2, %if.end6 ]
  %cfs_rq.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.05.i, i32 0, i32 11
  %42 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load ptr, ptr %cfs_rq.i.i, align 16
  %skip.i18 = getelementptr inbounds %struct.cfs_rq, ptr %43, i32 0, i32 14
  %44 = ptrtoint ptr %skip.i18 to i32
  call void @__asan_store4_noabort(i32 %44)
  store ptr %se.addr.05.i, ptr %skip.i18, align 4
  %parent.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.05.i, i32 0, i32 10
  %45 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load ptr, ptr %parent.i, align 4
  %tobool.not.i = icmp eq ptr %46, null
  br i1 %tobool.not.i, label %cleanup, label %for.body.i

cleanup:                                          ; preds = %for.body.i, %if.end6, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal zeroext i1 @yield_to_task_fair(ptr noundef %rq, ptr noundef %p) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %se1 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %on_rq = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 3
  %0 = ptrtoint ptr %on_rq to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %on_rq, align 4
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %cfs_rq.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %2 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %cfs_rq.i, align 16
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@yield_to_task_fair, %land.rhs.i)) #20
          to label %if.end [label %land.rhs.i], !srcloc !261

land.rhs.i:                                       ; preds = %lor.lhs.false
  %throttle_count.i = getelementptr inbounds %struct.cfs_rq, ptr %3, i32 0, i32 38
  %4 = ptrtoint ptr %throttle_count.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %throttle_count.i, align 4
  %tobool.i.not = icmp eq i32 %5, 0
  br i1 %tobool.i.not, label %if.end, label %cleanup

if.end:                                           ; preds = %land.rhs.i, %lor.lhs.false
  %tobool.not54.i = icmp eq ptr %se1, null
  br i1 %tobool.not54.i, label %set_next_buddy.exit, label %for.body.i

for.body.i:                                       ; preds = %if.end43.i, %if.end
  %se.addr.055.i = phi ptr [ %18, %if.end43.i ], [ %se1, %if.end ]
  %on_rq.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055.i, i32 0, i32 3
  %6 = ptrtoint ptr %on_rq.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %on_rq.i, align 4
  %tobool1.not.i = icmp eq i32 %7, 0
  br i1 %tobool1.not.i, label %land.rhs.i6, label %if.end40.critedge.i

land.rhs.i6:                                      ; preds = %for.body.i
  %.b52.i = load i1, ptr @set_next_buddy.__already_done, align 1
  br i1 %.b52.i, label %set_next_buddy.exit, label %if.then.i, !prof !259

if.then.i:                                        ; preds = %land.rhs.i6
  store i1 true, ptr @set_next_buddy.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 7065, i32 noundef 9, ptr noundef nonnull @.str.42) #20
  br label %set_next_buddy.exit

if.end40.critedge.i:                              ; preds = %for.body.i
  %my_q.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055.i, i32 0, i32 12
  %8 = ptrtoint ptr %my_q.i.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %my_q.i.i, align 4
  %tobool.not.i.i = icmp eq ptr %9, null
  br i1 %tobool.not.i.i, label %se_is_idle.exit.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.end40.critedge.i
  %idle.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %9, i32 0, i32 31
  %10 = ptrtoint ptr %idle.i.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %idle.i.i.i, align 16
  %cmp.i.i.i = icmp sgt i32 %11, 0
  br i1 %cmp.i.i.i, label %set_next_buddy.exit, label %if.end43.i

se_is_idle.exit.i:                                ; preds = %if.end40.critedge.i
  %policy.i.i.i = getelementptr i8, ptr %se.addr.055.i, i32 900
  %12 = ptrtoint ptr %policy.i.i.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %policy.i.i.i, align 4
  %cmp.i.i.i.i = icmp eq i32 %13, 5
  br i1 %cmp.i.i.i.i, label %set_next_buddy.exit, label %if.end43.i

if.end43.i:                                       ; preds = %se_is_idle.exit.i, %if.end.i.i
  %cfs_rq.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055.i, i32 0, i32 11
  %14 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %cfs_rq.i.i, align 16
  %next.i = getelementptr inbounds %struct.cfs_rq, ptr %15, i32 0, i32 12
  %16 = ptrtoint ptr %next.i to i32
  call void @__asan_store4_noabort(i32 %16)
  store ptr %se.addr.055.i, ptr %next.i, align 4
  %parent.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055.i, i32 0, i32 10
  %17 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %parent.i, align 4
  %tobool.not.i = icmp eq ptr %18, null
  br i1 %tobool.not.i, label %set_next_buddy.exit, label %for.body.i

set_next_buddy.exit:                              ; preds = %if.end43.i, %se_is_idle.exit.i, %if.end.i.i, %if.then.i, %land.rhs.i6, %if.end
  tail call void @yield_task_fair(ptr noundef %rq)
  br label %cleanup

cleanup:                                          ; preds = %set_next_buddy.exit, %land.rhs.i, %entry
  %retval.0 = phi i1 [ true, %set_next_buddy.exit ], [ false, %land.rhs.i ], [ false, %entry ]
  ret i1 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @check_preempt_wakeup(ptr noundef %rq, ptr noundef %p, i32 noundef %wake_flags) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %curr1 = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 20
  %0 = ptrtoint ptr %curr1 to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %curr1, align 8
  %se2 = getelementptr inbounds %struct.task_struct, ptr %1, i32 0, i32 18
  %se3 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %cfs_rq.i = getelementptr inbounds %struct.task_struct, ptr %1, i32 0, i32 18, i32 11
  %2 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %cfs_rq.i, align 16
  %nr_running = getelementptr inbounds %struct.cfs_rq, ptr %3, i32 0, i32 1
  %4 = ptrtoint ptr %nr_running to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %nr_running, align 8
  %6 = load i32, ptr @sched_nr_latency, align 4
  %cmp.not = icmp ult i32 %5, %6
  %cmp4 = icmp eq ptr %1, %p
  br i1 %cmp4, label %cleanup, label %if.end, !prof !260

if.end:                                           ; preds = %entry
  %cfs_rq.i141 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %7 = ptrtoint ptr %cfs_rq.i141 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %cfs_rq.i141, align 16
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@check_preempt_wakeup, %land.rhs.i)) #20
          to label %throttled_hierarchy.exit [label %land.rhs.i], !srcloc !261

land.rhs.i:                                       ; preds = %if.end
  %throttle_count.i = getelementptr inbounds %struct.cfs_rq, ptr %8, i32 0, i32 38
  %9 = ptrtoint ptr %throttle_count.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %throttle_count.i, align 4
  %tobool.i = icmp ne i32 %10, 0
  %phi.cast.i = zext i1 %tobool.i to i32
  br label %throttled_hierarchy.exit

throttled_hierarchy.exit:                         ; preds = %land.rhs.i, %if.end
  %11 = phi i32 [ %phi.cast.i, %land.rhs.i ], [ 0, %if.end ]
  %tobool9.not = icmp eq i32 %11, 0
  br i1 %tobool9.not, label %if.end17, label %cleanup, !prof !259

if.end17:                                         ; preds = %throttled_hierarchy.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 2), ptr blockaddress(@check_preempt_wakeup, %l_yes.i.i.i)) #20
          to label %static_branch_NEXT_BUDDY.exit [label %l_yes.i.i.i], !srcloc !261

l_yes.i.i.i:                                      ; preds = %if.end17
  br label %static_branch_NEXT_BUDDY.exit

static_branch_NEXT_BUDDY.exit:                    ; preds = %l_yes.i.i.i, %if.end17
  %retval.0.i.i.i = phi i1 [ %cmp.not, %l_yes.i.i.i ], [ true, %if.end17 ]
  %and = and i32 %wake_flags, 4
  %tobool22.not = icmp ne i32 %and, 0
  %12 = or i1 %tobool22.not, %retval.0.i.i.i
  %tobool.not54.i = icmp eq ptr %se3, null
  %or.cond = select i1 %12, i1 true, i1 %tobool.not54.i
  br i1 %or.cond, label %if.end24, label %for.body.i

for.body.i:                                       ; preds = %if.end43.i, %static_branch_NEXT_BUDDY.exit
  %se.addr.055.i = phi ptr [ %25, %if.end43.i ], [ %se3, %static_branch_NEXT_BUDDY.exit ]
  %on_rq.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055.i, i32 0, i32 3
  %13 = ptrtoint ptr %on_rq.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %on_rq.i, align 4
  %tobool1.not.i = icmp eq i32 %14, 0
  br i1 %tobool1.not.i, label %land.rhs.i142, label %if.end40.critedge.i

land.rhs.i142:                                    ; preds = %for.body.i
  %.b52.i = load i1, ptr @set_next_buddy.__already_done, align 1
  br i1 %.b52.i, label %if.end24, label %if.then.i, !prof !259

if.then.i:                                        ; preds = %land.rhs.i142
  store i1 true, ptr @set_next_buddy.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 7065, i32 noundef 9, ptr noundef nonnull @.str.42) #20
  br label %if.end24

if.end40.critedge.i:                              ; preds = %for.body.i
  %my_q.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055.i, i32 0, i32 12
  %15 = ptrtoint ptr %my_q.i.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %my_q.i.i, align 4
  %tobool.not.i.i = icmp eq ptr %16, null
  br i1 %tobool.not.i.i, label %se_is_idle.exit.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.end40.critedge.i
  %idle.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %16, i32 0, i32 31
  %17 = ptrtoint ptr %idle.i.i.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %idle.i.i.i, align 16
  %cmp.i.i.i = icmp sgt i32 %18, 0
  br i1 %cmp.i.i.i, label %if.end24, label %if.end43.i

se_is_idle.exit.i:                                ; preds = %if.end40.critedge.i
  %policy.i.i.i = getelementptr i8, ptr %se.addr.055.i, i32 900
  %19 = ptrtoint ptr %policy.i.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %policy.i.i.i, align 4
  %cmp.i.i.i.i = icmp eq i32 %20, 5
  br i1 %cmp.i.i.i.i, label %if.end24, label %if.end43.i

if.end43.i:                                       ; preds = %se_is_idle.exit.i, %if.end.i.i
  %cfs_rq.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055.i, i32 0, i32 11
  %21 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %cfs_rq.i.i, align 16
  %next.i = getelementptr inbounds %struct.cfs_rq, ptr %22, i32 0, i32 12
  %23 = ptrtoint ptr %next.i to i32
  call void @__asan_store4_noabort(i32 %23)
  store ptr %se.addr.055.i, ptr %next.i, align 4
  %parent.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055.i, i32 0, i32 10
  %24 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %parent.i, align 4
  %tobool.not.i = icmp eq ptr %25, null
  br i1 %tobool.not.i, label %if.end24, label %for.body.i

if.end24:                                         ; preds = %if.end43.i, %se_is_idle.exit.i, %if.end.i.i, %if.then.i, %land.rhs.i142, %static_branch_NEXT_BUDDY.exit
  %stack.i.i = getelementptr inbounds %struct.task_struct, ptr %1, i32 0, i32 1
  %26 = ptrtoint ptr %stack.i.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load ptr, ptr %stack.i.i, align 4
  %28 = ptrtoint ptr %27 to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %27, align 4
  %30 = and i32 %29, 2
  %tobool26.not = icmp eq i32 %30, 0
  br i1 %tobool26.not, label %if.end28, label %cleanup

if.end28:                                         ; preds = %if.end24
  %policy.i = getelementptr inbounds %struct.task_struct, ptr %1, i32 0, i32 31
  %31 = ptrtoint ptr %policy.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %policy.i, align 4
  %cmp.i.i.not = icmp eq i32 %32, 5
  br i1 %cmp.i.i.not, label %land.lhs.true37, label %if.end49, !prof !260

land.lhs.true37:                                  ; preds = %if.end28
  %policy.i143 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 31
  %33 = ptrtoint ptr %policy.i143 to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %policy.i143, align 4
  %cmp.i.i144.not = icmp eq i32 %34, 5
  br i1 %cmp.i.i144.not, label %if.end49, label %preempt, !prof !260

if.end49:                                         ; preds = %land.lhs.true37, %if.end28
  %policy = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 31
  %35 = ptrtoint ptr %policy to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %policy, align 4
  %cmp50.not = icmp eq i32 %36, 0
  br i1 %cmp50.not, label %lor.lhs.false, label %cleanup, !prof !259

lor.lhs.false:                                    ; preds = %if.end49
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 5), i32 1), ptr blockaddress(@check_preempt_wakeup, %cleanup)) #20
          to label %if.end60 [label %cleanup], !srcloc !261

if.end60:                                         ; preds = %lor.lhs.false
  %depth.i = getelementptr inbounds %struct.task_struct, ptr %1, i32 0, i32 18, i32 9
  %37 = ptrtoint ptr %depth.i to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %depth.i, align 8
  %depth1.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 9
  %39 = ptrtoint ptr %depth1.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load i32, ptr %depth1.i, align 8
  %cmp32.i = icmp sgt i32 %38, %40
  br i1 %cmp32.i, label %while.body.i, label %while.cond2.preheader.i

while.cond2.preheader.i:                          ; preds = %if.end60
  %cmp334.i = icmp sgt i32 %40, %38
  br i1 %cmp334.i, label %while.body4.i, label %while.cond8.preheader.i

while.body.i:                                     ; preds = %while.body.i, %if.end60
  %se.0 = phi ptr [ %42, %while.body.i ], [ %se2, %if.end60 ]
  %se_depth.033.i = phi i32 [ %dec.i, %while.body.i ], [ %38, %if.end60 ]
  %dec.i = add nsw i32 %se_depth.033.i, -1
  %parent.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.0, i32 0, i32 10
  %41 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load ptr, ptr %parent.i.i, align 4
  %cmp.i = icmp sgt i32 %dec.i, %40
  br i1 %cmp.i, label %while.body.i, label %while.cond8.preheader.i

while.cond8.preheader.i:                          ; preds = %while.body4.i, %while.body.i, %while.cond2.preheader.i
  %se.1 = phi ptr [ %se2, %while.cond2.preheader.i ], [ %42, %while.body.i ], [ %se2, %while.body4.i ]
  %pse.0 = phi ptr [ %se3, %while.cond2.preheader.i ], [ %se3, %while.body.i ], [ %48, %while.body4.i ]
  %cfs_rq.i36.i = getelementptr inbounds %struct.sched_entity, ptr %se.1, i32 0, i32 11
  %43 = ptrtoint ptr %cfs_rq.i36.i to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load ptr, ptr %cfs_rq.i36.i, align 16
  %cfs_rq1.i37.i = getelementptr inbounds %struct.sched_entity, ptr %pse.0, i32 0, i32 11
  %45 = ptrtoint ptr %cfs_rq1.i37.i to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load ptr, ptr %cfs_rq1.i37.i, align 16
  %cmp.i38.i = icmp ne ptr %44, %46
  %tobool.not3139.i = icmp eq ptr %44, null
  %tobool.not40.i = or i1 %tobool.not3139.i, %cmp.i38.i
  br i1 %tobool.not40.i, label %while.body10.i, label %find_matching_se.exit

while.body4.i:                                    ; preds = %while.body4.i, %while.cond2.preheader.i
  %pse.1 = phi ptr [ %48, %while.body4.i ], [ %se3, %while.cond2.preheader.i ]
  %pse_depth.035.i = phi i32 [ %dec5.i, %while.body4.i ], [ %40, %while.cond2.preheader.i ]
  %dec5.i = add nsw i32 %pse_depth.035.i, -1
  %parent.i28.i = getelementptr inbounds %struct.sched_entity, ptr %pse.1, i32 0, i32 10
  %47 = ptrtoint ptr %parent.i28.i to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load ptr, ptr %parent.i28.i, align 4
  %cmp3.i = icmp sgt i32 %dec5.i, %38
  br i1 %cmp3.i, label %while.body4.i, label %while.cond8.preheader.i

while.body10.i:                                   ; preds = %while.body10.i, %while.cond8.preheader.i
  %pse.2 = phi ptr [ %53, %while.body10.i ], [ %pse.0, %while.cond8.preheader.i ]
  %49 = phi ptr [ %51, %while.body10.i ], [ %se.1, %while.cond8.preheader.i ]
  %parent.i29.i = getelementptr inbounds %struct.sched_entity, ptr %49, i32 0, i32 10
  %50 = ptrtoint ptr %parent.i29.i to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load ptr, ptr %parent.i29.i, align 4
  %parent.i30.i = getelementptr inbounds %struct.sched_entity, ptr %pse.2, i32 0, i32 10
  %52 = ptrtoint ptr %parent.i30.i to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load ptr, ptr %parent.i30.i, align 4
  %cfs_rq.i.i146 = getelementptr inbounds %struct.sched_entity, ptr %51, i32 0, i32 11
  %54 = ptrtoint ptr %cfs_rq.i.i146 to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load ptr, ptr %cfs_rq.i.i146, align 16
  %cfs_rq1.i.i = getelementptr inbounds %struct.sched_entity, ptr %53, i32 0, i32 11
  %56 = ptrtoint ptr %cfs_rq1.i.i to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load ptr, ptr %cfs_rq1.i.i, align 16
  %cmp.i.i147 = icmp ne ptr %55, %57
  %tobool.not31.i = icmp eq ptr %55, null
  %tobool.not.i148 = or i1 %tobool.not31.i, %cmp.i.i147
  br i1 %tobool.not.i148, label %while.body10.i, label %find_matching_se.exit

find_matching_se.exit:                            ; preds = %while.body10.i, %while.cond8.preheader.i
  %se.2 = phi ptr [ %se.1, %while.cond8.preheader.i ], [ %51, %while.body10.i ]
  %pse.3 = phi ptr [ %pse.0, %while.cond8.preheader.i ], [ %53, %while.body10.i ]
  %tobool61.not = icmp eq ptr %pse.3, null
  br i1 %tobool61.not, label %do.body71, label %do.end77, !prof !260

do.body71:                                        ; preds = %find_matching_se.exit
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22kernel/sched/fair.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 7134, 0\0A.popsection", ""() #20, !srcloc !288
  unreachable

do.end77:                                         ; preds = %find_matching_se.exit
  %my_q.i = getelementptr inbounds %struct.sched_entity, ptr %se.2, i32 0, i32 12
  %58 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i149 = icmp eq ptr %59, null
  br i1 %tobool.not.i149, label %task_of.exit.i, label %if.end.i

task_of.exit.i:                                   ; preds = %do.end77
  %policy.i.i = getelementptr i8, ptr %se.2, i32 900
  %60 = ptrtoint ptr %policy.i.i to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load i32, ptr %policy.i.i, align 4
  %cmp.i.i.i150 = icmp eq i32 %61, 5
  br label %se_is_idle.exit

if.end.i:                                         ; preds = %do.end77
  %idle.i.i = getelementptr inbounds %struct.cfs_rq, ptr %59, i32 0, i32 31
  %62 = ptrtoint ptr %idle.i.i to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load i32, ptr %idle.i.i, align 16
  %cmp.i.i151 = icmp sgt i32 %63, 0
  br label %se_is_idle.exit

se_is_idle.exit:                                  ; preds = %if.end.i, %task_of.exit.i
  %retval.0.in.i = phi i1 [ %cmp.i.i151, %if.end.i ], [ %cmp.i.i.i150, %task_of.exit.i ]
  %my_q.i152 = getelementptr inbounds %struct.sched_entity, ptr %pse.3, i32 0, i32 12
  %64 = ptrtoint ptr %my_q.i152 to i32
  call void @__asan_load4_noabort(i32 %64)
  %65 = load ptr, ptr %my_q.i152, align 4
  %tobool.not.i153 = icmp eq ptr %65, null
  br i1 %tobool.not.i153, label %task_of.exit.i156, label %if.end.i159

task_of.exit.i156:                                ; preds = %se_is_idle.exit
  %policy.i.i154 = getelementptr i8, ptr %pse.3, i32 900
  %66 = ptrtoint ptr %policy.i.i154 to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load i32, ptr %policy.i.i154, align 4
  %cmp.i.i.i155 = icmp eq i32 %67, 5
  br label %se_is_idle.exit162

if.end.i159:                                      ; preds = %se_is_idle.exit
  %idle.i.i157 = getelementptr inbounds %struct.cfs_rq, ptr %65, i32 0, i32 31
  %68 = ptrtoint ptr %idle.i.i157 to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load i32, ptr %idle.i.i157, align 16
  %cmp.i.i158 = icmp sgt i32 %69, 0
  br label %se_is_idle.exit162

se_is_idle.exit162:                               ; preds = %if.end.i159, %task_of.exit.i156
  %retval.0.in.i160 = phi i1 [ %cmp.i.i158, %if.end.i159 ], [ %cmp.i.i.i155, %task_of.exit.i156 ]
  %tobool82.not = xor i1 %retval.0.in.i160, true
  %or.cond135 = select i1 %retval.0.in.i, i1 %tobool82.not, i1 false
  br i1 %or.cond135, label %preempt, label %if.end84

if.end84:                                         ; preds = %se_is_idle.exit162
  %70 = xor i1 %retval.0.in.i, %retval.0.in.i160
  br i1 %70, label %cleanup, label %if.end88

if.end88:                                         ; preds = %if.end84
  %cfs_rq.i163 = getelementptr inbounds %struct.sched_entity, ptr %se.2, i32 0, i32 11
  %71 = ptrtoint ptr %cfs_rq.i163 to i32
  call void @__asan_load4_noabort(i32 %71)
  %72 = load ptr, ptr %cfs_rq.i163, align 16
  tail call fastcc void @update_curr(ptr noundef %72)
  %vruntime.i = getelementptr inbounds %struct.sched_entity, ptr %se.2, i32 0, i32 6
  %73 = ptrtoint ptr %vruntime.i to i32
  call void @__asan_load8_noabort(i32 %73)
  %74 = load i64, ptr %vruntime.i, align 16
  %vruntime1.i = getelementptr inbounds %struct.sched_entity, ptr %pse.3, i32 0, i32 6
  %75 = ptrtoint ptr %vruntime1.i to i32
  call void @__asan_load8_noabort(i32 %75)
  %76 = load i64, ptr %vruntime1.i, align 16
  %sub.i = sub i64 %74, %76
  %cmp.i164 = icmp slt i64 %sub.i, 1
  br i1 %cmp.i164, label %cleanup, label %if.end.i166

if.end.i166:                                      ; preds = %if.end88
  %77 = load i32, ptr @sysctl_sched_wakeup_granularity, align 4
  %conv.i.i165 = zext i32 %77 to i64
  %78 = ptrtoint ptr %pse.3 to i32
  call void @__asan_load4_noabort(i32 %78)
  %79 = load i32, ptr %pse.3, align 128
  %cmp.not.i.i.i = icmp eq i32 %79, 1024
  br i1 %cmp.not.i.i.i, label %wakeup_preempt_entity.exit, label %if.then.i.i.i, !prof !259

if.then.i.i.i:                                    ; preds = %if.end.i166
  %inv_weight.i.i.i.i = getelementptr inbounds %struct.load_weight, ptr %pse.3, i32 0, i32 1
  %80 = ptrtoint ptr %inv_weight.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load i32, ptr %inv_weight.i.i.i.i, align 4
  %tobool.not.i33.i.i.i = icmp eq i32 %81, 0
  br i1 %tobool.not.i33.i.i.i, label %if.end.i.i.i.i, label %__update_inv_weight.exit.i.i.i, !prof !260

if.end.i.i.i.i:                                   ; preds = %if.then.i.i.i
  %tobool3.not.i.i.i.i = icmp eq i32 %79, 0
  br i1 %tobool3.not.i.i.i.i, label %if.end15.i.i.i.i, label %if.else.i.i.i.i, !prof !260

if.else.i.i.i.i:                                  ; preds = %if.end.i.i.i.i
  %div.i.i.i.i = udiv i32 -1, %79
  br label %if.end15.i.i.i.i

if.end15.i.i.i.i:                                 ; preds = %if.else.i.i.i.i, %if.end.i.i.i.i
  %storemerge.i.i.i.i = phi i32 [ %div.i.i.i.i, %if.else.i.i.i.i ], [ -1, %if.end.i.i.i.i ]
  %82 = ptrtoint ptr %inv_weight.i.i.i.i to i32
  call void @__asan_store4_noabort(i32 %82)
  store i32 %storemerge.i.i.i.i, ptr %inv_weight.i.i.i.i, align 4
  br label %__update_inv_weight.exit.i.i.i

__update_inv_weight.exit.i.i.i:                   ; preds = %if.end15.i.i.i.i, %if.then.i.i.i
  %83 = phi i32 [ %storemerge.i.i.i.i, %if.end15.i.i.i.i ], [ %81, %if.then.i.i.i ]
  %conv1.i.i.i.i = zext i32 %83 to i64
  %mul.i.i.i.i = shl nuw nsw i64 %conv1.i.i.i.i, 10
  %tobool9.not.i.i.i = icmp ult i32 %83, 4194304
  %extract.t32.i.i.i = trunc i64 %mul.i.i.i.i to i32
  br i1 %tobool9.not.i.i.i, label %__calc_delta.exit.i.i, label %if.then10.i.i.i

if.then10.i.i.i:                                  ; preds = %__update_inv_weight.exit.i.i.i
  %shr7.i.i.i = lshr i32 %83, 22
  %84 = tail call i32 @llvm.ctlz.i32(i32 %shr7.i.i.i, i1 true) #20, !range !258
  %sub.i.i.i.i = sub nuw nsw i32 32, %84
  %sh_prom13.i.i.i = zext i32 %sub.i.i.i.i to i64
  %shr14.i.i.i = lshr i64 %mul.i.i.i.i, %sh_prom13.i.i.i
  %extract.t.i.i.i = trunc i64 %shr14.i.i.i to i32
  br label %__calc_delta.exit.i.i

__calc_delta.exit.i.i:                            ; preds = %if.then10.i.i.i, %__update_inv_weight.exit.i.i.i
  %fact.1.off0.i.i.i = phi i32 [ %extract.t.i.i.i, %if.then10.i.i.i ], [ %extract.t32.i.i.i, %__update_inv_weight.exit.i.i.i ]
  %shift.1.i.i.i = phi i32 [ %84, %if.then10.i.i.i ], [ 32, %__update_inv_weight.exit.i.i.i ]
  %conv1.i.i.i.i.i = zext i32 %fact.1.off0.i.i.i to i64
  %mul.i.i.i.i.i = mul nuw i64 %conv1.i.i.i.i.i, %conv.i.i165
  %sh_prom.i.i.i.i = zext i32 %shift.1.i.i.i to i64
  %shr2.i.i.i.i = lshr i64 %mul.i.i.i.i.i, %sh_prom.i.i.i.i
  %.pre.i = and i64 %shr2.i.i.i.i, 4294967295
  br label %wakeup_preempt_entity.exit

wakeup_preempt_entity.exit:                       ; preds = %__calc_delta.exit.i.i, %if.end.i166
  %conv.pre-phi.i = phi i64 [ %conv.i.i165, %if.end.i166 ], [ %.pre.i, %__calc_delta.exit.i.i ]
  %cmp2.i = icmp ugt i64 %sub.i, %conv.pre-phi.i
  br i1 %cmp2.i, label %if.then93, label %cleanup

if.then93:                                        ; preds = %wakeup_preempt_entity.exit
  br i1 %12, label %if.then95, label %preempt

if.then95:                                        ; preds = %if.then93
  tail call fastcc void @set_next_buddy(ptr noundef nonnull %pse.3)
  br label %preempt

preempt:                                          ; preds = %if.then95, %if.then93, %se_is_idle.exit162, %land.lhs.true37
  %se.3 = phi ptr [ %se.2, %se_is_idle.exit162 ], [ %se.2, %if.then95 ], [ %se.2, %if.then93 ], [ %se2, %land.lhs.true37 ]
  tail call void @resched_curr(ptr noundef %rq) #20
  %on_rq = getelementptr inbounds %struct.sched_entity, ptr %se.3, i32 0, i32 3
  %85 = ptrtoint ptr %on_rq to i32
  call void @__asan_load4_noabort(i32 %85)
  %86 = load i32, ptr %on_rq, align 4
  %tobool98.not = icmp eq i32 %86, 0
  br i1 %tobool98.not, label %cleanup, label %lor.rhs, !prof !260

lor.rhs:                                          ; preds = %preempt
  %idle = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 21
  %87 = ptrtoint ptr %idle to i32
  call void @__asan_load4_noabort(i32 %87)
  %88 = load ptr, ptr %idle, align 4
  %cmp99 = icmp eq ptr %1, %88
  br i1 %cmp99, label %cleanup, label %if.end108, !prof !260

if.end108:                                        ; preds = %lor.rhs
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 3), i32 1), ptr blockaddress(@check_preempt_wakeup, %cleanup)) #20
          to label %static_branch_LAST_BUDDY.exit [label %cleanup], !srcloc !261

static_branch_LAST_BUDDY.exit:                    ; preds = %if.end108
  br i1 %cmp.not, label %cleanup, label %land.lhs.true113

land.lhs.true113:                                 ; preds = %static_branch_LAST_BUDDY.exit
  %my_q = getelementptr inbounds %struct.sched_entity, ptr %se.3, i32 0, i32 12
  %89 = ptrtoint ptr %my_q to i32
  call void @__asan_load4_noabort(i32 %89)
  %90 = load ptr, ptr %my_q, align 4
  %tobool114.not = icmp ne ptr %90, null
  %tobool.not54.i168 = icmp eq ptr %se.3, null
  %or.cond213 = select i1 %tobool114.not, i1 true, i1 %tobool.not54.i168
  br i1 %or.cond213, label %cleanup, label %for.body.i172

for.body.i172:                                    ; preds = %if.end43.i188, %land.lhs.true113
  %se.addr.055.i169 = phi ptr [ %103, %if.end43.i188 ], [ %se.3, %land.lhs.true113 ]
  %on_rq.i170 = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055.i169, i32 0, i32 3
  %91 = ptrtoint ptr %on_rq.i170 to i32
  call void @__asan_load4_noabort(i32 %91)
  %92 = load i32, ptr %on_rq.i170, align 4
  %tobool1.not.i171 = icmp eq i32 %92, 0
  br i1 %tobool1.not.i171, label %land.rhs.i174, label %if.end40.critedge.i178

land.rhs.i174:                                    ; preds = %for.body.i172
  %.b52.i173 = load i1, ptr @set_last_buddy.__already_done, align 1
  br i1 %.b52.i173, label %cleanup, label %if.then.i175, !prof !259

if.then.i175:                                     ; preds = %land.rhs.i174
  store i1 true, ptr @set_last_buddy.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 7054, i32 noundef 9, ptr noundef nonnull @.str.42) #20
  br label %cleanup

if.end40.critedge.i178:                           ; preds = %for.body.i172
  %my_q.i.i176 = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055.i169, i32 0, i32 12
  %93 = ptrtoint ptr %my_q.i.i176 to i32
  call void @__asan_load4_noabort(i32 %93)
  %94 = load ptr, ptr %my_q.i.i176, align 4
  %tobool.not.i.i177 = icmp eq ptr %94, null
  br i1 %tobool.not.i.i177, label %se_is_idle.exit.i184, label %if.end.i.i181

if.end.i.i181:                                    ; preds = %if.end40.critedge.i178
  %idle.i.i.i179 = getelementptr inbounds %struct.cfs_rq, ptr %94, i32 0, i32 31
  %95 = ptrtoint ptr %idle.i.i.i179 to i32
  call void @__asan_load4_noabort(i32 %95)
  %96 = load i32, ptr %idle.i.i.i179, align 16
  %cmp.i.i.i180 = icmp sgt i32 %96, 0
  br i1 %cmp.i.i.i180, label %cleanup, label %if.end43.i188

se_is_idle.exit.i184:                             ; preds = %if.end40.critedge.i178
  %policy.i.i.i182 = getelementptr i8, ptr %se.addr.055.i169, i32 900
  %97 = ptrtoint ptr %policy.i.i.i182 to i32
  call void @__asan_load4_noabort(i32 %97)
  %98 = load i32, ptr %policy.i.i.i182, align 4
  %cmp.i.i.i.i183 = icmp eq i32 %98, 5
  br i1 %cmp.i.i.i.i183, label %cleanup, label %if.end43.i188

if.end43.i188:                                    ; preds = %se_is_idle.exit.i184, %if.end.i.i181
  %cfs_rq.i.i185 = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055.i169, i32 0, i32 11
  %99 = ptrtoint ptr %cfs_rq.i.i185 to i32
  call void @__asan_load4_noabort(i32 %99)
  %100 = load ptr, ptr %cfs_rq.i.i185, align 16
  %last.i = getelementptr inbounds %struct.cfs_rq, ptr %100, i32 0, i32 13
  %101 = ptrtoint ptr %last.i to i32
  call void @__asan_store4_noabort(i32 %101)
  store ptr %se.addr.055.i169, ptr %last.i, align 16
  %parent.i186 = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055.i169, i32 0, i32 10
  %102 = ptrtoint ptr %parent.i186 to i32
  call void @__asan_load4_noabort(i32 %102)
  %103 = load ptr, ptr %parent.i186, align 4
  %tobool.not.i187 = icmp eq ptr %103, null
  br i1 %tobool.not.i187, label %cleanup, label %for.body.i172

cleanup:                                          ; preds = %if.end43.i188, %se_is_idle.exit.i184, %if.end.i.i181, %if.then.i175, %land.rhs.i174, %land.lhs.true113, %static_branch_LAST_BUDDY.exit, %if.end108, %lor.rhs, %preempt, %wakeup_preempt_entity.exit, %if.end88, %if.end84, %lor.lhs.false, %if.end49, %if.end24, %throttled_hierarchy.exit, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal ptr @__pick_next_task_fair(ptr noundef %rq) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call ptr @pick_next_task_fair(ptr noundef %rq, ptr noundef null, ptr noundef null)
  ret ptr %call
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @put_prev_task_fair(ptr nocapture noundef readnone %rq, ptr noundef %prev) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %se1 = getelementptr inbounds %struct.task_struct, ptr %prev, i32 0, i32 18
  %tobool.not5 = icmp eq ptr %se1, null
  br i1 %tobool.not5, label %for.end, label %for.body

for.body:                                         ; preds = %for.body, %entry
  %se.06 = phi ptr [ %3, %for.body ], [ %se1, %entry ]
  %cfs_rq.i = getelementptr inbounds %struct.sched_entity, ptr %se.06, i32 0, i32 11
  %0 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %cfs_rq.i, align 16
  tail call fastcc void @put_prev_entity(ptr noundef %1, ptr noundef nonnull %se.06)
  %parent = getelementptr inbounds %struct.sched_entity, ptr %se.06, i32 0, i32 10
  %2 = ptrtoint ptr %parent to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %parent, align 4
  %tobool.not = icmp eq ptr %3, null
  br i1 %tobool.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @set_next_task_fair(ptr noundef %rq, ptr noundef %p, i1 noundef zeroext %first) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %se1 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %on_rq.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 12
  %0 = ptrtoint ptr %on_rq.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %on_rq.i, align 4
  %cmp.i.not = icmp eq i32 %1, 1
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %group_node = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 2
  %cfs_tasks = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 48
  %call.i.i = tail call zeroext i1 @__list_del_entry_valid(ptr noundef %group_node) #20
  br i1 %call.i.i, label %if.end.i.i10, label %__list_del_entry.exit.i

if.end.i.i10:                                     ; preds = %if.then
  %prev.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 2, i32 1
  %2 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %prev.i.i, align 4
  %4 = ptrtoint ptr %group_node to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %group_node, align 4
  %prev1.i.i.i = getelementptr inbounds %struct.list_head, ptr %5, i32 0, i32 1
  %6 = ptrtoint ptr %prev1.i.i.i to i32
  call void @__asan_store4_noabort(i32 %6)
  store ptr %3, ptr %prev1.i.i.i, align 4
  %7 = ptrtoint ptr %3 to i32
  call void @__asan_store4_noabort(i32 %7)
  store volatile ptr %5, ptr %3, align 4
  br label %__list_del_entry.exit.i

__list_del_entry.exit.i:                          ; preds = %if.end.i.i10, %if.then
  %8 = ptrtoint ptr %cfs_tasks to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %cfs_tasks, align 4
  %call.i.i.i = tail call zeroext i1 @__list_add_valid(ptr noundef %group_node, ptr noundef %cfs_tasks, ptr noundef %9) #20
  br i1 %call.i.i.i, label %if.end.i.i.i11, label %if.end

if.end.i.i.i11:                                   ; preds = %__list_del_entry.exit.i
  %prev1.i.i2.i = getelementptr inbounds %struct.list_head, ptr %9, i32 0, i32 1
  %10 = ptrtoint ptr %prev1.i.i2.i to i32
  call void @__asan_store4_noabort(i32 %10)
  store ptr %group_node, ptr %prev1.i.i2.i, align 4
  %11 = ptrtoint ptr %group_node to i32
  call void @__asan_store4_noabort(i32 %11)
  store ptr %9, ptr %group_node, align 4
  %prev3.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 2, i32 1
  %12 = ptrtoint ptr %prev3.i.i.i to i32
  call void @__asan_store4_noabort(i32 %12)
  store ptr %cfs_tasks, ptr %prev3.i.i.i, align 4
  %13 = ptrtoint ptr %cfs_tasks to i32
  call void @__asan_store4_noabort(i32 %13)
  store volatile ptr %group_node, ptr %cfs_tasks, align 4
  br label %if.end

if.end:                                           ; preds = %if.end.i.i.i11, %__list_del_entry.exit.i, %entry
  %tobool2.not12 = icmp eq ptr %se1, null
  br i1 %tobool2.not12, label %for.end, label %for.body

for.body:                                         ; preds = %account_cfs_rq_runtime.exit, %if.end
  %se.013 = phi ptr [ %42, %account_cfs_rq_runtime.exit ], [ %se1, %if.end ]
  %cfs_rq.i = getelementptr inbounds %struct.sched_entity, ptr %se.013, i32 0, i32 11
  %14 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %cfs_rq.i, align 16
  tail call fastcc void @set_next_entity(ptr noundef %15, ptr noundef nonnull %se.013)
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@set_next_task_fair, %lor.lhs.false.i)) #20
          to label %account_cfs_rq_runtime.exit [label %lor.lhs.false.i], !srcloc !261

lor.lhs.false.i:                                  ; preds = %for.body
  %runtime_enabled.i = getelementptr inbounds %struct.cfs_rq, ptr %15, i32 0, i32 32
  %16 = ptrtoint ptr %runtime_enabled.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %runtime_enabled.i, align 4
  %tobool.not.i = icmp eq i32 %17, 0
  br i1 %tobool.not.i, label %account_cfs_rq_runtime.exit, label %if.end.i

if.end.i:                                         ; preds = %lor.lhs.false.i
  %runtime_remaining.i.i = getelementptr inbounds %struct.cfs_rq, ptr %15, i32 0, i32 33
  %18 = ptrtoint ptr %runtime_remaining.i.i to i32
  call void @__asan_load8_noabort(i32 %18)
  %19 = load i64, ptr %runtime_remaining.i.i, align 8
  %cmp.i.i = icmp sgt i64 %19, 0
  br i1 %cmp.i.i, label %account_cfs_rq_runtime.exit, label %if.end.i.i, !prof !259

if.end.i.i:                                       ; preds = %if.end.i
  %throttled.i.i = getelementptr inbounds %struct.cfs_rq, ptr %15, i32 0, i32 37
  %20 = ptrtoint ptr %throttled.i.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %throttled.i.i, align 8
  %tobool3.not.i.i = icmp eq i32 %21, 0
  br i1 %tobool3.not.i.i, label %if.end5.i.i, label %account_cfs_rq_runtime.exit

if.end5.i.i:                                      ; preds = %if.end.i.i
  %tg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %15, i32 0, i32 30
  %22 = ptrtoint ptr %tg.i.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %tg.i.i, align 4
  %cfs_bandwidth.i.i.i = getelementptr inbounds %struct.task_group, ptr %23, i32 0, i32 16
  tail call void @_raw_spin_lock(ptr noundef %cfs_bandwidth.i.i.i) #20
  %24 = load i32, ptr @sysctl_sched_cfs_bandwidth_slice, align 4
  %conv.i.i.i = zext i32 %24 to i64
  %mul.i.i.i = mul nuw nsw i64 %conv.i.i.i, 1000
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %25 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i.i = icmp eq i32 %25, 0
  br i1 %tobool.not.i.i.i, label %if.end.i.i.i, label %land.rhs.i.i.i

land.rhs.i.i.i:                                   ; preds = %if.end5.i.i
  %dep_map.i.i.i = getelementptr inbounds %struct.task_group, ptr %23, i32 0, i32 16, i32 0, i32 4
  %call.i.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i.i, i32 noundef -1) #20
  %cmp.not.i.i.i = icmp eq i32 %call.i.i.i.i, 0
  br i1 %cmp.not.i.i.i, label %do.end.i.i.i, label %if.end.i.i.i, !prof !260

do.end.i.i.i:                                     ; preds = %land.rhs.i.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 4699, i32 noundef 9, ptr noundef null) #20
  br label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %do.end.i.i.i, %land.rhs.i.i.i, %if.end5.i.i
  %26 = ptrtoint ptr %runtime_remaining.i.i to i32
  call void @__asan_load8_noabort(i32 %26)
  %27 = load i64, ptr %runtime_remaining.i.i, align 8
  %sub.i.i.i = sub i64 %mul.i.i.i, %27
  %quota.i.i.i = getelementptr inbounds %struct.task_group, ptr %23, i32 0, i32 16, i32 2
  %28 = ptrtoint ptr %quota.i.i.i to i32
  call void @__asan_load8_noabort(i32 %28)
  %29 = load i64, ptr %quota.i.i.i, align 8
  %cmp24.i.i.i = icmp eq i64 %29, -1
  br i1 %cmp24.i.i.i, label %assign_cfs_rq_runtime.exit.i, label %if.else.i.i.i

if.else.i.i.i:                                    ; preds = %if.end.i.i.i
  tail call void @start_cfs_bandwidth(ptr noundef %cfs_bandwidth.i.i.i) #20
  %runtime.i.i.i = getelementptr inbounds %struct.task_group, ptr %23, i32 0, i32 16, i32 3
  %30 = ptrtoint ptr %runtime.i.i.i to i32
  call void @__asan_load8_noabort(i32 %30)
  %31 = load i64, ptr %runtime.i.i.i, align 8
  %cmp26.not.i.i.i = icmp eq i64 %31, 0
  br i1 %cmp26.not.i.i.i, label %assign_cfs_rq_runtime.exit.i, label %if.then27.i.i.i

if.then27.i.i.i:                                  ; preds = %if.else.i.i.i
  %32 = tail call i64 @llvm.umin.i64(i64 %31, i64 %sub.i.i.i) #20
  %sub32.i.i.i = sub i64 %31, %32
  %33 = ptrtoint ptr %runtime.i.i.i to i32
  call void @__asan_store8_noabort(i32 %33)
  store i64 %sub32.i.i.i, ptr %runtime.i.i.i, align 8
  %idle.i.i.i = getelementptr inbounds %struct.task_group, ptr %23, i32 0, i32 16, i32 7
  %34 = ptrtoint ptr %idle.i.i.i to i32
  call void @__asan_store1_noabort(i32 %34)
  store i8 0, ptr %idle.i.i.i, align 8
  br label %assign_cfs_rq_runtime.exit.i

assign_cfs_rq_runtime.exit.i:                     ; preds = %if.then27.i.i.i, %if.else.i.i.i, %if.end.i.i.i
  %amount.0.i.i.i = phi i64 [ %32, %if.then27.i.i.i ], [ 0, %if.else.i.i.i ], [ %sub.i.i.i, %if.end.i.i.i ]
  %35 = ptrtoint ptr %runtime_remaining.i.i to i32
  call void @__asan_load8_noabort(i32 %35)
  %36 = load i64, ptr %runtime_remaining.i.i, align 8
  %add.i.i.i = add i64 %36, %amount.0.i.i.i
  store i64 %add.i.i.i, ptr %runtime_remaining.i.i, align 8
  %cmp37.i.i.i = icmp slt i64 %add.i.i.i, 1
  tail call void @_raw_spin_unlock(ptr noundef %cfs_bandwidth.i.i.i) #20
  br i1 %cmp37.i.i.i, label %land.lhs.true.i.i, label %account_cfs_rq_runtime.exit

land.lhs.true.i.i:                                ; preds = %assign_cfs_rq_runtime.exit.i
  %curr.i.i = getelementptr inbounds %struct.cfs_rq, ptr %15, i32 0, i32 11
  %37 = ptrtoint ptr %curr.i.i to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load ptr, ptr %curr.i.i, align 8
  %tobool7.not.i.i = icmp eq ptr %38, null
  br i1 %tobool7.not.i.i, label %account_cfs_rq_runtime.exit, label %if.then14.i.i, !prof !260

if.then14.i.i:                                    ; preds = %land.lhs.true.i.i
  %rq.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %15, i32 0, i32 27
  %39 = ptrtoint ptr %rq.i.i.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load ptr, ptr %rq.i.i.i, align 4
  tail call void @resched_curr(ptr noundef %40) #20
  br label %account_cfs_rq_runtime.exit

account_cfs_rq_runtime.exit:                      ; preds = %if.then14.i.i, %land.lhs.true.i.i, %assign_cfs_rq_runtime.exit.i, %if.end.i.i, %if.end.i, %lor.lhs.false.i, %for.body
  %parent = getelementptr inbounds %struct.sched_entity, ptr %se.013, i32 0, i32 10
  %41 = ptrtoint ptr %parent to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load ptr, ptr %parent, align 4
  %tobool2.not = icmp eq ptr %42, null
  br i1 %tobool2.not, label %for.end, label %for.body

for.end:                                          ; preds = %account_cfs_rq_runtime.exit, %if.end
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @balance_fair(ptr noundef %rq, ptr nocapture noundef readnone %prev, ptr nocapture noundef %rf) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %nr_running = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 1
  %0 = ptrtoint ptr %nr_running to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %nr_running, align 4
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call = tail call fastcc i32 @newidle_balance(ptr noundef %rq, ptr noundef %rf)
  %cmp = icmp ne i32 %call, 0
  %conv = zext i1 %cmp to i32
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %conv, %if.end ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @select_task_rq_fair(ptr noundef %p, i32 noundef %prev_cpu, i32 noundef %wake_flags) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %and = and i32 %wake_flags, 16
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %0 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i to ptr
  %task = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 2
  %2 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %task, align 8
  %flags = getelementptr inbounds %struct.task_struct, ptr %3, i32 0, i32 3
  %4 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %flags, align 4
  %and1 = and i32 %5, 4
  %tobool2.not = icmp eq i32 %and1, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %6 = phi i1 [ false, %entry ], [ %tobool2.not, %land.rhs ]
  %land.ext = zext i1 %6 to i32
  %7 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i159 = and i32 %7, -16384
  %8 = inttoptr i32 %and.i159 to ptr
  %cpu4 = getelementptr inbounds %struct.thread_info, ptr %8, i32 0, i32 3
  %9 = ptrtoint ptr %cpu4 to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %cpu4, align 4
  %and5 = and i32 %wake_flags, 15
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %11 = load i32, ptr @debug_locks, align 4
  %tobool6.not = icmp eq i32 %11, 0
  br i1 %tobool6.not, label %if.end, label %land.rhs7

land.rhs7:                                        ; preds = %land.end
  %dep_map = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 128, i32 4
  %call.i160 = tail call i32 @lock_is_held_type(ptr noundef %dep_map, i32 noundef -1) #20
  %cmp.not = icmp eq i32 %call.i160, 0
  br i1 %cmp.not, label %do.end, label %if.end, !prof !260

do.end:                                           ; preds = %land.rhs7
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 6871, i32 noundef 9, ptr noundef null) #20
  br label %if.end

if.end:                                           ; preds = %do.end, %land.rhs7, %land.end
  %and36 = and i32 %wake_flags, 8
  %tobool37.not = icmp eq i32 %and36, 0
  br i1 %tobool37.not, label %if.end53, label %if.then38

if.then38:                                        ; preds = %if.end
  %12 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i = and i32 %12, -16384
  %13 = inttoptr i32 %and.i.i to ptr
  %task.i = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 2
  %14 = ptrtoint ptr %task.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %task.i, align 8
  %wakee_flip_decay_ts.i = getelementptr inbounds %struct.task_struct, ptr %15, i32 0, i32 8
  %16 = ptrtoint ptr %wakee_flip_decay_ts.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %wakee_flip_decay_ts.i, align 4
  %add.i = add i32 %17, 100
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %18 = load volatile i32, ptr @jiffies, align 128
  %sub.i = sub i32 %add.i, %18
  %cmp.i = icmp slt i32 %sub.i, 0
  br i1 %cmp.i, label %if.then.i161, label %if.end.i

if.then.i161:                                     ; preds = %if.then38
  %wakee_flips.i = getelementptr inbounds %struct.task_struct, ptr %15, i32 0, i32 7
  %19 = ptrtoint ptr %wakee_flips.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %wakee_flips.i, align 32
  %shr.i = lshr i32 %20, 1
  store i32 %shr.i, ptr %wakee_flips.i, align 32
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %21 = load volatile i32, ptr @jiffies, align 128
  %22 = ptrtoint ptr %task.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %task.i, align 8
  %wakee_flip_decay_ts5.i = getelementptr inbounds %struct.task_struct, ptr %23, i32 0, i32 8
  %24 = ptrtoint ptr %wakee_flip_decay_ts5.i to i32
  call void @__asan_store4_noabort(i32 %24)
  store i32 %21, ptr %wakee_flip_decay_ts5.i, align 4
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i161, %if.then38
  %25 = ptrtoint ptr %task.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load ptr, ptr %task.i, align 8
  %last_wakee.i = getelementptr inbounds %struct.task_struct, ptr %26, i32 0, i32 9
  %27 = ptrtoint ptr %last_wakee.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %last_wakee.i, align 8
  %cmp8.not.i = icmp eq ptr %28, %p
  br i1 %cmp8.not.i, label %record_wakee.exit, label %if.then9.i

if.then9.i:                                       ; preds = %if.end.i
  %29 = ptrtoint ptr %last_wakee.i to i32
  call void @__asan_store4_noabort(i32 %29)
  store ptr %p, ptr %last_wakee.i, align 8
  %30 = ptrtoint ptr %task.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %task.i, align 8
  %wakee_flips15.i = getelementptr inbounds %struct.task_struct, ptr %31, i32 0, i32 7
  %32 = ptrtoint ptr %wakee_flips15.i to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %wakee_flips15.i, align 32
  %inc.i = add i32 %33, 1
  store i32 %inc.i, ptr %wakee_flips15.i, align 32
  br label %record_wakee.exit

record_wakee.exit:                                ; preds = %if.then9.i, %if.end.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_energy_present, ptr blockaddress(@select_task_rq_fair, %if.then40)) #20
          to label %if.end45 [label %if.then40], !srcloc !261

if.then40:                                        ; preds = %record_wakee.exit
  %call41 = tail call fastcc i32 @find_energy_efficient_cpu(ptr noundef %p, i32 noundef %prev_cpu)
  %cmp42 = icmp sgt i32 %call41, -1
  br i1 %cmp42, label %cleanup, label %if.end45

if.end45:                                         ; preds = %if.then40, %record_wakee.exit
  %34 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i162 = and i32 %34, -16384
  %35 = inttoptr i32 %and.i.i162 to ptr
  %task.i163 = getelementptr inbounds %struct.thread_info, ptr %35, i32 0, i32 2
  %36 = ptrtoint ptr %task.i163 to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load ptr, ptr %task.i163, align 8
  %wakee_flips.i164 = getelementptr inbounds %struct.task_struct, ptr %37, i32 0, i32 7
  %38 = ptrtoint ptr %wakee_flips.i164 to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load i32, ptr %wakee_flips.i164, align 32
  %wakee_flips1.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 7
  %40 = ptrtoint ptr %wakee_flips1.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %wakee_flips1.i, align 32
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %35, i32 0, i32 3
  %42 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load i32, ptr %cpu.i, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %43
  %44 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load i32, ptr %arrayidx.i, align 4
  %add.i165 = add i32 %45, ptrtoint (ptr @sd_llc_size to i32)
  %46 = inttoptr i32 %add.i165 to ptr
  %47 = ptrtoint ptr %46 to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load i32, ptr %46, align 4
  %49 = tail call i32 @llvm.umin.i32(i32 %39, i32 %41) #20
  %50 = tail call i32 @llvm.umax.i32(i32 %39, i32 %41) #20
  %cmp14.i = icmp ult i32 %49, %48
  %mul.i = mul i32 %48, %49
  %cmp15.i = icmp ult i32 %50, %mul.i
  %or.cond.i = select i1 %cmp14.i, i1 true, i1 %cmp15.i
  br i1 %or.cond.i, label %land.rhs48, label %if.end53

land.rhs48:                                       ; preds = %if.end45
  %cpus_ptr = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 33
  %51 = ptrtoint ptr %cpus_ptr to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load ptr, ptr %cpus_ptr, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %53 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i = icmp ugt i32 %53, %10
  br i1 %cmp.not.i.i.i, label %cpumask_test_cpu.exit, label %land.rhs.i.i.i

land.rhs.i.i.i:                                   ; preds = %land.rhs48
  %.b37.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i, label %cpumask_test_cpu.exit, label %if.then.i.i.i, !prof !259

if.then.i.i.i:                                    ; preds = %land.rhs.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpumask_test_cpu.exit

cpumask_test_cpu.exit:                            ; preds = %if.then.i.i.i, %land.rhs.i.i.i, %land.rhs48
  %div3.i.i = lshr i32 %10, 5
  %arrayidx.i.i = getelementptr i32, ptr %52, i32 %div3.i.i
  %54 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load volatile i32, ptr %arrayidx.i.i, align 4
  %and.i.i166 = and i32 %10, 31
  %56 = lshr i32 %55, %and.i.i166
  %57 = and i32 %56, 1
  br label %if.end53

if.end53:                                         ; preds = %cpumask_test_cpu.exit, %if.end45, %if.end
  %want_affine.0 = phi i32 [ 0, %if.end ], [ 0, %if.end45 ], [ %57, %cpumask_test_cpu.exit ]
  %58 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i = and i32 %58, -16384
  %59 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %59, i32 0, i32 1
  %60 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %61, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !268
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #20
  %call.i = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end53
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 696, ptr noundef nonnull @.str.28) #20
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %if.end53
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %10
  %62 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load i32, ptr %arrayidx, align 4
  %add = add i32 %63, ptrtoint (ptr @runqueues to i32)
  %64 = inttoptr i32 %add to ptr
  %sd63 = getelementptr inbounds %struct.rq, ptr %64, i32 0, i32 36
  %65 = ptrtoint ptr %sd63 to i32
  call void @__asan_load4_noabort(i32 %65)
  %66 = load volatile ptr, ptr %sd63, align 4
  %call.i167 = tail call i32 @lock_is_held_type(ptr noundef getelementptr inbounds (%struct.mutex, ptr @sched_domains_mutex, i32 0, i32 5), i32 noundef -1) #20
  %tobool66.not = icmp eq i32 %call.i167, 0
  br i1 %tobool66.not, label %lor.lhs.false, label %do.end76

lor.lhs.false:                                    ; preds = %rcu_read_lock.exit
  %call67 = tail call i32 @rcu_read_lock_held() #20
  %tobool68.not = icmp eq i32 %call67, 0
  br i1 %tobool68.not, label %land.lhs.true, label %do.end76

land.lhs.true:                                    ; preds = %lor.lhs.false
  %call69 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool70.not = icmp eq i32 %call69, 0
  br i1 %tobool70.not, label %do.end76, label %land.lhs.true71

land.lhs.true71:                                  ; preds = %land.lhs.true
  %.b158 = load i1, ptr @select_task_rq_fair.__warned, align 1
  br i1 %.b158, label %do.end76, label %if.then73

if.then73:                                        ; preds = %land.lhs.true71
  store i1 true, ptr @select_task_rq_fair.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 6886, ptr noundef nonnull @.str.16) #20
  br label %do.end76

do.end76:                                         ; preds = %if.then73, %land.lhs.true71, %land.lhs.true, %lor.lhs.false, %rcu_read_lock.exit
  %tobool78.not194 = icmp eq ptr %66, null
  br i1 %tobool78.not194, label %if.else111, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %do.end76
  %tobool79.not = icmp eq i32 %want_affine.0, 0
  %div3.i.i172 = lshr i32 %prev_cpu, 5
  %and.i.i174 = and i32 %prev_cpu, 31
  %67 = shl nuw i32 1, %and.i.i174
  %tobool79.not.not = xor i1 %tobool79.not, true
  br label %for.body

for.body:                                         ; preds = %for.inc, %for.body.lr.ph
  %tmp.0196 = phi ptr [ %66, %for.body.lr.ph ], [ %77, %for.inc ]
  %sd.0195 = phi ptr [ null, %for.body.lr.ph ], [ %tmp.0.mux, %for.inc ]
  %flags94 = getelementptr inbounds %struct.sched_domain, ptr %tmp.0196, i32 0, i32 9
  %68 = ptrtoint ptr %flags94 to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load i32, ptr %flags94, align 4
  br i1 %tobool79.not, label %if.end93, label %land.lhs.true80

land.lhs.true80:                                  ; preds = %for.body
  %and82 = and i32 %69, 16
  %tobool83.not = icmp eq i32 %and82, 0
  br i1 %tobool83.not, label %if.end93.thread, label %land.lhs.true84

land.lhs.true84:                                  ; preds = %land.lhs.true80
  %span.i = getelementptr inbounds %struct.sched_domain, ptr %tmp.0196, i32 0, i32 41
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %70 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i168 = icmp ugt i32 %70, %prev_cpu
  br i1 %cmp.not.i.i.i168, label %cpumask_test_cpu.exit177, label %land.rhs.i.i.i170

land.rhs.i.i.i170:                                ; preds = %land.lhs.true84
  %.b37.i.i.i169 = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i169, label %cpumask_test_cpu.exit177, label %if.then.i.i.i171, !prof !259

if.then.i.i.i171:                                 ; preds = %land.rhs.i.i.i170
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpumask_test_cpu.exit177

cpumask_test_cpu.exit177:                         ; preds = %if.then.i.i.i171, %land.rhs.i.i.i170, %land.lhs.true84
  %arrayidx.i.i173 = getelementptr i32, ptr %span.i, i32 %div3.i.i172
  %71 = ptrtoint ptr %arrayidx.i.i173 to i32
  call void @__asan_load4_noabort(i32 %71)
  %72 = load volatile i32, ptr %arrayidx.i.i173, align 4
  %73 = and i32 %72, %67
  %tobool87.not = icmp eq i32 %73, 0
  br i1 %tobool87.not, label %if.end93.thread, label %if.then88

if.then88:                                        ; preds = %cpumask_test_cpu.exit177
  %cmp89.not = icmp eq i32 %10, %prev_cpu
  br i1 %cmp89.not, label %if.else111, label %if.then90

if.then90:                                        ; preds = %if.then88
  %call91 = tail call fastcc i32 @wake_affine(ptr noundef nonnull %tmp.0196, ptr noundef %p, i32 noundef %10, i32 noundef %prev_cpu, i32 noundef %land.ext)
  br label %if.else111

if.end93.thread:                                  ; preds = %cpumask_test_cpu.exit177, %land.lhs.true80
  %flags94200 = getelementptr inbounds %struct.sched_domain, ptr %tmp.0196, i32 0, i32 9
  %74 = ptrtoint ptr %flags94200 to i32
  call void @__asan_load4_noabort(i32 %74)
  %75 = load i32, ptr %flags94200, align 4
  %and95201 = and i32 %75, %and5
  %tobool96.not202 = icmp ne i32 %and95201, 0
  br label %for.inc

if.end93:                                         ; preds = %for.body
  %and95 = and i32 %69, %and5
  %tobool96.not = icmp ne i32 %and95, 0
  %brmerge = select i1 %tobool96.not, i1 true, i1 %tobool79.not.not
  br i1 %brmerge, label %for.inc, label %for.end

for.inc:                                          ; preds = %if.end93, %if.end93.thread
  %tobool96.not204 = phi i1 [ %tobool96.not202, %if.end93.thread ], [ %tobool96.not, %if.end93 ]
  %tmp.0.mux = select i1 %tobool96.not204, ptr %tmp.0196, ptr %sd.0195
  %76 = ptrtoint ptr %tmp.0196 to i32
  call void @__asan_load4_noabort(i32 %76)
  %77 = load ptr, ptr %tmp.0196, align 8
  %tobool78.not = icmp eq ptr %77, null
  br i1 %tobool78.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %if.end93
  %sd.0.lcssa = phi ptr [ %tmp.0.mux, %for.inc ], [ %sd.0195, %if.end93 ]
  %tobool102.not = icmp eq ptr %sd.0.lcssa, null
  br i1 %tobool102.not, label %if.else111, label %if.then109, !prof !259

if.then109:                                       ; preds = %for.end
  %call110 = tail call fastcc i32 @find_idlest_cpu(ptr noundef nonnull %sd.0.lcssa, ptr noundef %p, i32 noundef %10, i32 noundef %prev_cpu, i32 noundef %and5)
  br label %if.end117

if.else111:                                       ; preds = %for.end, %if.then90, %if.then88, %do.end76
  %new_cpu.3191 = phi i32 [ %prev_cpu, %for.end ], [ %prev_cpu, %if.then88 ], [ %call91, %if.then90 ], [ %prev_cpu, %do.end76 ]
  br i1 %tobool37.not, label %if.end117, label %if.then114

if.then114:                                       ; preds = %if.else111
  %call115 = tail call fastcc i32 @select_idle_sibling(ptr noundef %p, i32 noundef %prev_cpu, i32 noundef %new_cpu.3191)
  br label %if.end117

if.end117:                                        ; preds = %if.then114, %if.else111, %if.then109
  %new_cpu.4 = phi i32 [ %call110, %if.then109 ], [ %call115, %if.then114 ], [ %new_cpu.3191, %if.else111 ]
  %call.i178 = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i178, label %rcu_read_unlock.exit, label %land.lhs.true.i181

land.lhs.true.i181:                               ; preds = %if.end117
  %call1.i179 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i180 = icmp eq i32 %call1.i179, 0
  br i1 %tobool.not.i180, label %rcu_read_unlock.exit, label %land.lhs.true2.i183

land.lhs.true2.i183:                              ; preds = %land.lhs.true.i181
  %.b4.i182 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i182, label %rcu_read_unlock.exit, label %if.then.i184

if.then.i184:                                     ; preds = %land.lhs.true2.i183
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i184, %land.lhs.true2.i183, %land.lhs.true.i181, %if.end117
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %78 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i185 = and i32 %78, -16384
  %79 = inttoptr i32 %and.i.i.i.i.i185 to ptr
  %preempt_count.i.i.i.i186 = getelementptr inbounds %struct.thread_info, ptr %79, i32 0, i32 1
  %80 = ptrtoint ptr %preempt_count.i.i.i.i186 to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load volatile i32, ptr %preempt_count.i.i.i.i186, align 4
  %sub.i.i.i = add i32 %81, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i186, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  br label %cleanup

cleanup:                                          ; preds = %rcu_read_unlock.exit, %if.then40
  %retval.0 = phi i32 [ %new_cpu.4, %rcu_read_unlock.exit ], [ %call41, %if.then40 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal ptr @pick_task_fair(ptr noundef %rq) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %cfs = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 14
  %nr_running = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 14, i32 1
  %0 = ptrtoint ptr %nr_running to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %nr_running, align 8
  %tobool.not37 = icmp eq i32 %1, 0
  br i1 %tobool.not37, label %cleanup16, label %do.body

do.body:                                          ; preds = %do.body.backedge, %entry
  %cfs_rq.0 = phi ptr [ %cfs_rq.0.be, %do.body.backedge ], [ %cfs, %entry ]
  %curr1 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.0, i32 0, i32 11
  %2 = ptrtoint ptr %curr1 to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %curr1, align 8
  %tobool2.not = icmp eq ptr %3, null
  br i1 %tobool2.not, label %do.cond, label %if.then3

if.then3:                                         ; preds = %do.body
  %on_rq = getelementptr inbounds %struct.sched_entity, ptr %3, i32 0, i32 3
  %4 = ptrtoint ptr %on_rq to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %on_rq, align 4
  %tobool4.not = icmp eq i32 %5, 0
  br i1 %tobool4.not, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.then3
  tail call fastcc void @update_curr(ptr noundef %cfs_rq.0)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.then3
  %curr.0 = phi ptr [ %3, %if.then5 ], [ null, %if.then3 ]
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@pick_task_fair, %if.end.i)) #20
          to label %do.cond [label %if.end.i], !srcloc !261

if.end.i:                                         ; preds = %if.end6
  %runtime_enabled.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.0, i32 0, i32 32
  %6 = ptrtoint ptr %runtime_enabled.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %runtime_enabled.i, align 4
  %tobool.not.i = icmp eq i32 %7, 0
  br i1 %tobool.not.i, label %do.cond, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %if.end.i
  %runtime_remaining.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.0, i32 0, i32 33
  %8 = ptrtoint ptr %runtime_remaining.i to i32
  call void @__asan_load8_noabort(i32 %8)
  %9 = load i64, ptr %runtime_remaining.i, align 8
  %cmp.i = icmp sgt i64 %9, 0
  br i1 %cmp.i, label %do.cond, label %if.end4.i, !prof !259

if.end4.i:                                        ; preds = %lor.rhs.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@pick_task_fair, %land.rhs.i.i)) #20
          to label %if.end8.i [label %land.rhs.i.i], !srcloc !261

land.rhs.i.i:                                     ; preds = %if.end4.i
  %throttled.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.0, i32 0, i32 37
  %10 = ptrtoint ptr %throttled.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %throttled.i.i, align 8
  %tobool.i.not.i = icmp eq i32 %11, 0
  br i1 %tobool.i.not.i, label %if.end8.i, label %cleanup, !prof !270

if.end8.i:                                        ; preds = %land.rhs.i.i, %if.end4.i
  %call9.i = tail call fastcc zeroext i1 @throttle_cfs_rq(ptr noundef %cfs_rq.0) #20
  br i1 %call9.i, label %cleanup, label %do.cond, !prof !260

cleanup:                                          ; preds = %if.end8.i, %land.rhs.i.i
  %12 = ptrtoint ptr %nr_running to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %nr_running, align 8
  %tobool.not = icmp eq i32 %13, 0
  br i1 %tobool.not, label %cleanup16, label %do.body.backedge

do.cond:                                          ; preds = %if.end8.i, %lor.rhs.i, %if.end.i, %if.end6, %do.body
  %curr.1 = phi ptr [ null, %do.body ], [ %curr.0, %if.end8.i ], [ %curr.0, %if.end6 ], [ %curr.0, %lor.rhs.i ], [ %curr.0, %if.end.i ]
  %call12 = tail call fastcc ptr @pick_next_entity(ptr noundef %cfs_rq.0, ptr noundef %curr.1)
  %my_q.i = getelementptr inbounds %struct.sched_entity, ptr %call12, i32 0, i32 12
  %14 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %my_q.i, align 4
  %tobool14.not = icmp eq ptr %15, null
  br i1 %tobool14.not, label %do.end, label %do.body.backedge

do.body.backedge:                                 ; preds = %do.cond, %cleanup
  %cfs_rq.0.be = phi ptr [ %15, %do.cond ], [ %cfs, %cleanup ]
  br label %do.body

do.end:                                           ; preds = %do.cond
  %my_q.i.le = getelementptr inbounds %struct.sched_entity, ptr %call12, i32 0, i32 12
  %16 = ptrtoint ptr %my_q.i.le to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %my_q.i.le, align 4
  %tobool.not.i27 = icmp eq ptr %17, null
  br i1 %tobool.not.i27, label %task_of.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %do.end
  %.b42.i = load i1, ptr @task_of.__already_done, align 1
  br i1 %.b42.i, label %task_of.exit, label %if.then.i, !prof !259

if.then.i:                                        ; preds = %land.rhs.i
  store i1 true, ptr @task_of.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1376, i32 noundef 9, ptr noundef nonnull @.str.31) #20
  br label %task_of.exit

task_of.exit:                                     ; preds = %if.then.i, %land.rhs.i, %do.end
  %add.ptr.i = getelementptr i8, ptr %call12, i32 -128
  br label %cleanup16

cleanup16:                                        ; preds = %task_of.exit, %cleanup, %entry
  %retval.0 = phi ptr [ %add.ptr.i, %task_of.exit ], [ null, %entry ], [ null, %cleanup ]
  ret ptr %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @migrate_task_rq_fair(ptr noundef %p, i32 noundef %new_cpu) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = ptrtoint ptr %p to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile i32, ptr %p, align 128
  %cmp = icmp eq i32 %1, 512
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %cfs_rq.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %2 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %cfs_rq.i, align 16
  %min_vruntime_copy3 = getelementptr inbounds %struct.cfs_rq, ptr %3, i32 0, i32 9
  %min_vruntime9 = getelementptr inbounds %struct.cfs_rq, ptr %3, i32 0, i32 6
  br label %do.body2

do.body2:                                         ; preds = %do.body2, %if.then
  %4 = ptrtoint ptr %min_vruntime_copy3 to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %min_vruntime_copy3, align 8
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !289
  %6 = ptrtoint ptr %min_vruntime9 to i32
  call void @__asan_load8_noabort(i32 %6)
  %7 = load i64, ptr %min_vruntime9, align 32
  %cmp11.not = icmp eq i64 %7, %5
  br i1 %cmp11.not, label %do.end12, label %do.body2

do.end12:                                         ; preds = %do.body2
  %vruntime = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 6
  %8 = ptrtoint ptr %vruntime to i32
  call void @__asan_load8_noabort(i32 %8)
  %9 = load i64, ptr %vruntime, align 16
  %sub = sub i64 %9, %5
  store i64 %sub, ptr %vruntime, align 16
  br label %if.end

if.end:                                           ; preds = %do.end12, %entry
  %on_rq = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 12
  %10 = ptrtoint ptr %on_rq to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %on_rq, align 4
  %cmp13 = icmp eq i32 %11, 2
  br i1 %cmp13, label %do.body15, label %if.else

do.body15:                                        ; preds = %if.end
  %stack.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 1
  %12 = ptrtoint ptr %stack.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %stack.i, align 4
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 3
  %14 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %cpu.i, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %15
  %16 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %arrayidx, align 4
  %add = add i32 %17, ptrtoint (ptr @runqueues to i32)
  %18 = inttoptr i32 %add to ptr
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %19 = load i32, ptr @debug_locks, align 4
  %tobool.not.i = icmp eq i32 %19, 0
  br i1 %tobool.not.i, label %lockdep_assert_rq_held.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %do.body15
  %core_enabled.i.i = getelementptr inbounds %struct.rq, ptr %18, i32 0, i32 81
  %20 = ptrtoint ptr %core_enabled.i.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %core_enabled.i.i, align 128
  %tobool.not.i.i = icmp eq i32 %21, 0
  br i1 %tobool.not.i.i, label %__rq_lockp.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.rhs.i
  %core.i.i = getelementptr inbounds %struct.rq, ptr %18, i32 0, i32 79
  %22 = ptrtoint ptr %core.i.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %core.i.i, align 8
  br label %__rq_lockp.exit.i

__rq_lockp.exit.i:                                ; preds = %if.then.i.i, %land.rhs.i
  %retval.0.i.i = phi ptr [ %23, %if.then.i.i ], [ %18, %land.rhs.i ]
  %dep_map.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i, i32 0, i32 4
  %call.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i, i32 noundef -1) #20
  %cmp.not.i = icmp eq i32 %call.i.i, 0
  br i1 %cmp.not.i, label %do.end.i, label %lockdep_assert_rq_held.exit, !prof !260

do.end.i:                                         ; preds = %__rq_lockp.exit.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit

lockdep_assert_rq_held.exit:                      ; preds = %do.end.i, %__rq_lockp.exit.i, %do.body15
  %se21 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  tail call fastcc void @detach_entity_cfs_rq(ptr noundef %se21)
  br label %if.end23

if.else:                                          ; preds = %if.end
  %cfs_rq.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %24 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %cfs_rq.i.i, align 16
  %load_last_update_time_copy.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %25, i32 0, i32 18
  %avg.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %25, i32 0, i32 17
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %do.body.i.i.i, %if.else
  %26 = ptrtoint ptr %load_last_update_time_copy.i.i.i to i32
  call void @__asan_load8_noabort(i32 %26)
  %27 = load i64, ptr %load_last_update_time_copy.i.i.i, align 128
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !287
  %28 = ptrtoint ptr %avg.i.i.i to i32
  call void @__asan_load8_noabort(i32 %28)
  %29 = load i64, ptr %avg.i.i.i, align 128
  %cmp.not.i.i.i = icmp eq i64 %29, %27
  br i1 %cmp.not.i.i.i, label %remove_entity_load_avg.exit, label %do.body.i.i.i

remove_entity_load_avg.exit:                      ; preds = %do.body.i.i.i
  %se22 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %call2.i.i = tail call i32 @__update_load_avg_blocked_se(i64 noundef %27, ptr noundef %se22) #20
  %removed.i = getelementptr inbounds %struct.cfs_rq, ptr %25, i32 0, i32 20
  %call1.i = tail call i32 @_raw_spin_lock_irqsave(ptr noundef %removed.i) #20
  %nr.i = getelementptr inbounds %struct.cfs_rq, ptr %25, i32 0, i32 20, i32 1
  %30 = ptrtoint ptr %nr.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load i32, ptr %nr.i, align 4
  %inc.i = add i32 %31, 1
  store i32 %inc.i, ptr %nr.i, align 4
  %util_avg.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 7
  %32 = ptrtoint ptr %util_avg.i to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %util_avg.i, align 8
  %util_avg4.i = getelementptr inbounds %struct.cfs_rq, ptr %25, i32 0, i32 20, i32 3
  %34 = ptrtoint ptr %util_avg4.i to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load i32, ptr %util_avg4.i, align 4
  %add.i = add i32 %35, %33
  store i32 %add.i, ptr %util_avg4.i, align 4
  %load_avg.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 5
  %36 = ptrtoint ptr %load_avg.i to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load i32, ptr %load_avg.i, align 32
  %load_avg7.i = getelementptr inbounds %struct.cfs_rq, ptr %25, i32 0, i32 20, i32 2
  %38 = ptrtoint ptr %load_avg7.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load i32, ptr %load_avg7.i, align 16
  %add8.i = add i32 %39, %37
  store i32 %add8.i, ptr %load_avg7.i, align 16
  %runnable_avg.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 6
  %40 = ptrtoint ptr %runnable_avg.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %runnable_avg.i, align 4
  %runnable_avg11.i = getelementptr inbounds %struct.cfs_rq, ptr %25, i32 0, i32 20, i32 4
  %42 = ptrtoint ptr %runnable_avg11.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load i32, ptr %runnable_avg11.i, align 8
  %add12.i = add i32 %43, %41
  store i32 %add12.i, ptr %runnable_avg11.i, align 8
  tail call void @_raw_spin_unlock_irqrestore(ptr noundef %removed.i, i32 noundef %call1.i) #20
  br label %if.end23

if.end23:                                         ; preds = %remove_entity_load_avg.exit, %lockdep_assert_rq_held.exit
  %avg = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15
  %44 = ptrtoint ptr %avg to i32
  call void @__asan_store8_noabort(i32 %44)
  store i64 0, ptr %avg, align 128
  %exec_start = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 4
  %45 = ptrtoint ptr %exec_start to i32
  call void @__asan_store8_noabort(i32 %45)
  store i64 0, ptr %exec_start, align 32
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @set_cpus_allowed_common(ptr noundef, ptr noundef, i32 noundef) #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @rq_online_fair(ptr noundef %rq) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call.i.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @__num_online_cpus, i32 noundef 4) #20
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__num_online_cpus to i32))
  %0 = load volatile i32, ptr @__num_online_cpus, align 4
  %1 = tail call i32 @llvm.umin.i32(i32 %0, i32 8) #20
  %2 = load i32, ptr @sysctl_sched_tunable_scaling, align 4
  switch i32 %2, label %cond.end11.i.i [
    i32 0, label %update_sysctl.exit
    i32 2, label %sw.bb1.i.i
  ]

sw.bb1.i.i:                                       ; preds = %entry
  br label %update_sysctl.exit

cond.end11.i.i:                                   ; preds = %entry
  %tobool.not.i.i.i.i = icmp eq i32 %1, 0
  %3 = tail call i32 @llvm.ctlz.i32(i32 %1, i1 true) #20, !range !258
  %sub.i.op.i.i.i.op = sub nuw nsw i32 32, %3
  %add.i.i = select i1 %tobool.not.i.i.i.i, i32 0, i32 %sub.i.op.i.i.i.op
  br label %update_sysctl.exit

update_sysctl.exit:                               ; preds = %cond.end11.i.i, %sw.bb1.i.i, %entry
  %factor.0.i.i = phi i32 [ %add.i.i, %cond.end11.i.i ], [ %1, %sw.bb1.i.i ], [ 1, %entry ]
  %4 = load i32, ptr @normalized_sysctl_sched_min_granularity, align 4
  %mul.i = mul i32 %4, %factor.0.i.i
  store i32 %mul.i, ptr @sysctl_sched_min_granularity, align 4
  %5 = load i32, ptr @normalized_sysctl_sched_latency, align 4
  %mul1.i = mul i32 %5, %factor.0.i.i
  store i32 %mul1.i, ptr @sysctl_sched_latency, align 4
  %6 = load i32, ptr @normalized_sysctl_sched_wakeup_granularity, align 4
  %mul2.i = mul i32 %6, %factor.0.i.i
  store i32 %mul2.i, ptr @sysctl_sched_wakeup_granularity, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %7 = load i32, ptr @debug_locks, align 4
  %tobool.not.i28.i = icmp eq i32 %7, 0
  br i1 %tobool.not.i28.i, label %lockdep_assert_rq_held.exit.i, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %update_sysctl.exit
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 81
  %8 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %9, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.rhs.i.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 79
  %10 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %land.rhs.i.i
  %retval.0.i.i.i = phi ptr [ %11, %if.then.i.i.i ], [ %rq, %land.rhs.i.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i, i32 noundef -1) #20
  %cmp.not.i.i = icmp eq i32 %call.i.i.i, 0
  br i1 %cmp.not.i.i, label %do.end.i.i, label %lockdep_assert_rq_held.exit.i, !prof !260

do.end.i.i:                                       ; preds = %__rq_lockp.exit.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i

lockdep_assert_rq_held.exit.i:                    ; preds = %do.end.i.i, %__rq_lockp.exit.i.i, %update_sysctl.exit
  %12 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i.i = and i32 %12, -16384
  %13 = inttoptr i32 %and.i.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 1
  %14 = ptrtoint ptr %preempt_count.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %preempt_count.i.i.i.i.i, align 4
  %add.i.i.i.i = add i32 %15, 1
  store volatile i32 %add.i.i.i.i, ptr %preempt_count.i.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !268
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #20
  %call.i.i = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i.i, label %rcu_read_lock.exit.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %lockdep_assert_rq_held.exit.i
  %call1.i.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i.i = icmp eq i32 %call1.i.i, 0
  br i1 %tobool.not.i.i, label %rcu_read_lock.exit.i, label %land.lhs.true2.i.i

land.lhs.true2.i.i:                               ; preds = %land.lhs.true.i.i
  %.b4.i.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i.i, label %rcu_read_lock.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true2.i.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 696, ptr noundef nonnull @.str.28) #20
  br label %rcu_read_lock.exit.i

rcu_read_lock.exit.i:                             ; preds = %if.then.i.i, %land.lhs.true2.i.i, %land.lhs.true.i.i, %lockdep_assert_rq_held.exit.i
  %call.i = tail call i32 @rcu_read_lock_any_held() #20
  %tobool.not.i = icmp eq i32 %call.i, 0
  br i1 %tobool.not.i, label %land.lhs.true.i, label %do.end.i

land.lhs.true.i:                                  ; preds = %rcu_read_lock.exit.i
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool2.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool2.not.i, label %do.end.i, label %land.lhs.true3.i

land.lhs.true3.i:                                 ; preds = %land.lhs.true.i
  %.b27.i = load i1, ptr @update_runtime_enabled.__warned, align 1
  br i1 %.b27.i, label %do.end.i, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true3.i
  store i1 true, ptr @update_runtime_enabled.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 5406, ptr noundef nonnull @.str.25) #20
  br label %do.end.i

do.end.i:                                         ; preds = %if.then.i, %land.lhs.true3.i, %land.lhs.true.i, %rcu_read_lock.exit.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @task_groups to i32))
  %.pn39.i = load volatile ptr, ptr @task_groups, align 4
  %cmp.not40.i = icmp eq ptr %.pn39.i, @task_groups
  br i1 %cmp.not40.i, label %for.end.i, label %for.body.lr.ph.i

for.body.lr.ph.i:                                 ; preds = %do.end.i
  %cpu.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 46
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %.pn41.i = phi ptr [ %.pn39.i, %for.body.lr.ph.i ], [ %.pn.i, %for.body.i ]
  %cfs_bandwidth.i = getelementptr i8, ptr %.pn41.i, i32 32
  %cfs_rq9.i = getelementptr i8, ptr %.pn41.i, i32 -228
  %16 = ptrtoint ptr %cfs_rq9.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %cfs_rq9.i, align 4
  %18 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %cpu.i.i, align 4
  %arrayidx.i = getelementptr ptr, ptr %17, i32 %19
  %20 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %arrayidx.i, align 4
  tail call void @_raw_spin_lock(ptr noundef %cfs_bandwidth.i) #20
  %quota.i = getelementptr i8, ptr %.pn41.i, i32 88
  %22 = ptrtoint ptr %quota.i to i32
  call void @__asan_load8_noabort(i32 %22)
  %23 = load i64, ptr %quota.i, align 8
  %cmp11.i = icmp ne i64 %23, -1
  %conv.i = zext i1 %cmp11.i to i32
  %runtime_enabled.i = getelementptr inbounds %struct.cfs_rq, ptr %21, i32 0, i32 32
  %24 = ptrtoint ptr %runtime_enabled.i to i32
  call void @__asan_store4_noabort(i32 %24)
  store i32 %conv.i, ptr %runtime_enabled.i, align 4
  tail call void @_raw_spin_unlock(ptr noundef %cfs_bandwidth.i) #20
  %25 = ptrtoint ptr %.pn41.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %.pn.i = load volatile ptr, ptr %.pn41.i, align 4
  %cmp.not.i = icmp eq ptr %.pn.i, @task_groups
  br i1 %cmp.not.i, label %for.end.i, label %for.body.i

for.end.i:                                        ; preds = %for.body.i, %do.end.i
  %call.i29.i = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i29.i, label %update_runtime_enabled.exit, label %land.lhs.true.i32.i

land.lhs.true.i32.i:                              ; preds = %for.end.i
  %call1.i30.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i31.i = icmp eq i32 %call1.i30.i, 0
  br i1 %tobool.not.i31.i, label %update_runtime_enabled.exit, label %land.lhs.true2.i34.i

land.lhs.true2.i34.i:                             ; preds = %land.lhs.true.i32.i
  %.b4.i33.i = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i33.i, label %update_runtime_enabled.exit, label %if.then.i35.i

if.then.i35.i:                                    ; preds = %land.lhs.true2.i34.i
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %update_runtime_enabled.exit

update_runtime_enabled.exit:                      ; preds = %if.then.i35.i, %land.lhs.true2.i34.i, %land.lhs.true.i32.i, %for.end.i
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %26 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i36.i = and i32 %26, -16384
  %27 = inttoptr i32 %and.i.i.i.i.i36.i to ptr
  %preempt_count.i.i.i.i37.i = getelementptr inbounds %struct.thread_info, ptr %27, i32 0, i32 1
  %28 = ptrtoint ptr %preempt_count.i.i.i.i37.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %preempt_count.i.i.i.i37.i, align 4
  %sub.i.i.i.i = add i32 %29, -1
  store volatile i32 %sub.i.i.i.i, ptr %preempt_count.i.i.i.i37.i, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @rq_offline_fair(ptr noundef %rq) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call.i.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @__num_online_cpus, i32 noundef 4) #20
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__num_online_cpus to i32))
  %0 = load volatile i32, ptr @__num_online_cpus, align 4
  %1 = tail call i32 @llvm.umin.i32(i32 %0, i32 8) #20
  %2 = load i32, ptr @sysctl_sched_tunable_scaling, align 4
  switch i32 %2, label %cond.end11.i.i [
    i32 0, label %update_sysctl.exit
    i32 2, label %sw.bb1.i.i
  ]

sw.bb1.i.i:                                       ; preds = %entry
  br label %update_sysctl.exit

cond.end11.i.i:                                   ; preds = %entry
  %tobool.not.i.i.i.i = icmp eq i32 %1, 0
  %3 = tail call i32 @llvm.ctlz.i32(i32 %1, i1 true) #20, !range !258
  %sub.i.op.i.i.i.op = sub nuw nsw i32 32, %3
  %add.i.i = select i1 %tobool.not.i.i.i.i, i32 0, i32 %sub.i.op.i.i.i.op
  br label %update_sysctl.exit

update_sysctl.exit:                               ; preds = %cond.end11.i.i, %sw.bb1.i.i, %entry
  %factor.0.i.i = phi i32 [ %add.i.i, %cond.end11.i.i ], [ %1, %sw.bb1.i.i ], [ 1, %entry ]
  %4 = load i32, ptr @normalized_sysctl_sched_min_granularity, align 4
  %mul.i = mul i32 %4, %factor.0.i.i
  store i32 %mul.i, ptr @sysctl_sched_min_granularity, align 4
  %5 = load i32, ptr @normalized_sysctl_sched_latency, align 4
  %mul1.i = mul i32 %5, %factor.0.i.i
  store i32 %mul1.i, ptr @sysctl_sched_latency, align 4
  %6 = load i32, ptr @normalized_sysctl_sched_wakeup_granularity, align 4
  %mul2.i = mul i32 %6, %factor.0.i.i
  store i32 %mul2.i, ptr @sysctl_sched_wakeup_granularity, align 4
  tail call fastcc void @unthrottle_offline_cfs_rqs(ptr noundef %rq)
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @task_tick_fair(ptr noundef %rq, ptr noundef %curr, i32 noundef %queued) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %se1 = getelementptr inbounds %struct.task_struct, ptr %curr, i32 0, i32 18
  %tobool.not23 = icmp eq ptr %se1, null
  br i1 %tobool.not23, label %for.end, label %for.body

for.body:                                         ; preds = %for.body, %entry
  %se.024 = phi ptr [ %3, %for.body ], [ %se1, %entry ]
  %cfs_rq.i = getelementptr inbounds %struct.sched_entity, ptr %se.024, i32 0, i32 11
  %0 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %cfs_rq.i, align 16
  tail call fastcc void @entity_tick(ptr noundef %1, ptr noundef nonnull %se.024, i32 noundef %queued)
  %parent = getelementptr inbounds %struct.sched_entity, ptr %se.024, i32 0, i32 10
  %2 = ptrtoint ptr %parent to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %parent, align 4
  %tobool.not = icmp eq ptr %3, null
  br i1 %tobool.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_numa_balancing, ptr blockaddress(@task_tick_fair, %if.then)) #20
          to label %if.end [label %if.then], !srcloc !261

if.then:                                          ; preds = %for.end
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  tail call fastcc void @update_misfit_status(ptr noundef %curr, ptr noundef %rq)
  %stack.i = getelementptr inbounds %struct.task_struct, ptr %curr, i32 0, i32 1
  %4 = ptrtoint ptr %stack.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %stack.i, align 4
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %5, i32 0, i32 3
  %6 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %cpu.i, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %7
  %8 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %arrayidx, align 4
  %add = add i32 %9, ptrtoint (ptr @runqueues to i32)
  %10 = inttoptr i32 %add to ptr
  %rd.i = getelementptr inbounds %struct.rq, ptr %10, i32 0, i32 35
  %11 = ptrtoint ptr %rd.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %rd.i, align 8
  %overutilized.i = getelementptr inbounds %struct.root_domain, ptr %12, i32 0, i32 6
  %13 = ptrtoint ptr %overutilized.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %overutilized.i, align 4
  %tobool.not.i = icmp eq i32 %14, 0
  br i1 %tobool.not.i, label %land.lhs.true.i, label %update_overutilized_status.exit

land.lhs.true.i:                                  ; preds = %if.end
  %cpu.i18 = getelementptr inbounds %struct.rq, ptr %10, i32 0, i32 46
  %15 = ptrtoint ptr %cpu.i18 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %cpu.i18, align 4
  %arrayidx.i.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %16
  %17 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %arrayidx.i.i.i, align 4
  %add.i.i.i = add i32 %18, ptrtoint (ptr @runqueues to i32)
  %19 = inttoptr i32 %add.i.i.i to ptr
  %util_avg.i.i.i = getelementptr inbounds %struct.rq, ptr %19, i32 0, i32 14, i32 17, i32 7
  %20 = ptrtoint ptr %util_avg.i.i.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load volatile i32, ptr %util_avg.i.i.i, align 8
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 20), i32 1), ptr blockaddress(@task_tick_fair, %cpu_overutilized.exit.i)) #20
          to label %if.then.i.i.i [label %cpu_overutilized.exit.i], !srcloc !261

if.then.i.i.i:                                    ; preds = %land.lhs.true.i
  %util_est.i.i.i = getelementptr inbounds %struct.rq, ptr %19, i32 0, i32 14, i32 17, i32 9
  %22 = ptrtoint ptr %util_est.i.i.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %util_est.i.i.i, align 16
  %24 = tail call i32 @llvm.umax.i32(i32 %21, i32 %23) #20
  br label %cpu_overutilized.exit.i

cpu_overutilized.exit.i:                          ; preds = %if.then.i.i.i, %land.lhs.true.i
  %util.0.i.i.i = phi i32 [ %24, %if.then.i.i.i ], [ %21, %land.lhs.true.i ]
  %25 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %arrayidx.i.i.i, align 4
  %add.i.i.i.i = add i32 %26, ptrtoint (ptr @runqueues to i32)
  %27 = inttoptr i32 %add.i.i.i.i to ptr
  %cpu_capacity_orig.i.i.i.i = getelementptr inbounds %struct.rq, ptr %27, i32 0, i32 38
  %28 = ptrtoint ptr %cpu_capacity_orig.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %cpu_capacity_orig.i.i.i.i, align 4
  %30 = tail call i32 @llvm.umin.i32(i32 %util.0.i.i.i, i32 %29) #20
  %mul.i.i = mul i32 %30, 1280
  %cpu_capacity.i.i.i = getelementptr inbounds %struct.rq, ptr %27, i32 0, i32 37
  %31 = ptrtoint ptr %cpu_capacity.i.i.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %cpu_capacity.i.i.i, align 16
  %mul2.i.i = shl i32 %32, 10
  %cmp.i.not.i = icmp ult i32 %mul.i.i, %mul2.i.i
  br i1 %cmp.i.not.i, label %update_overutilized_status.exit, label %do.body4.i

do.body4.i:                                       ; preds = %cpu_overutilized.exit.i
  %33 = ptrtoint ptr %rd.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load ptr, ptr %rd.i, align 8
  %overutilized6.i = getelementptr inbounds %struct.root_domain, ptr %34, i32 0, i32 6
  %35 = ptrtoint ptr %overutilized6.i to i32
  call void @__asan_store4_noabort(i32 %35)
  store volatile i32 2, ptr %overutilized6.i, align 4
  %36 = load ptr, ptr %rd.i, align 8
  tail call fastcc void @trace_sched_overutilized_tp(ptr noundef %36, i1 noundef zeroext true) #20
  br label %update_overutilized_status.exit

update_overutilized_status.exit:                  ; preds = %do.body4.i, %cpu_overutilized.exit.i, %if.end
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__sched_core_enabled, ptr blockaddress(@task_tick_fair, %land.rhs.i.i)) #20
          to label %task_tick_core.exit [label %land.rhs.i.i], !srcloc !261

land.rhs.i.i:                                     ; preds = %update_overutilized_status.exit
  %core_enabled.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 81
  %37 = ptrtoint ptr %core_enabled.i.i to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %core_enabled.i.i, align 128
  %tobool3.i.not.i = icmp eq i32 %38, 0
  br i1 %tobool3.i.not.i, label %task_tick_core.exit, label %if.end.i

if.end.i:                                         ; preds = %land.rhs.i.i
  %core.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 79
  %39 = ptrtoint ptr %core.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load ptr, ptr %core.i, align 8
  %core_forceidle_count.i = getelementptr inbounds %struct.rq, ptr %40, i32 0, i32 87
  %41 = ptrtoint ptr %core_forceidle_count.i to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load i32, ptr %core_forceidle_count.i, align 8
  %tobool.not.i19 = icmp eq i32 %42, 0
  br i1 %tobool.not.i19, label %task_tick_core.exit, label %land.lhs.true.i20

land.lhs.true.i20:                                ; preds = %if.end.i
  %nr_running.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 14, i32 1
  %43 = ptrtoint ptr %nr_running.i to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load i32, ptr %nr_running.i, align 8
  %cmp.i = icmp eq i32 %44, 1
  br i1 %cmp.i, label %land.lhs.true1.i, label %task_tick_core.exit

land.lhs.true1.i:                                 ; preds = %land.lhs.true.i20
  %cfs_rq.i.i.i = getelementptr inbounds %struct.task_struct, ptr %curr, i32 0, i32 18, i32 11
  %45 = ptrtoint ptr %cfs_rq.i.i.i to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load ptr, ptr %cfs_rq.i.i.i, align 16
  %call1.i.i = tail call fastcc i64 @sched_slice(ptr noundef %46, ptr noundef %se1) #20
  %sum_exec_runtime.i.i = getelementptr inbounds %struct.task_struct, ptr %curr, i32 0, i32 18, i32 5
  %47 = ptrtoint ptr %sum_exec_runtime.i.i to i32
  call void @__asan_load8_noabort(i32 %47)
  %48 = load i64, ptr %sum_exec_runtime.i.i, align 8
  %prev_sum_exec_runtime.i.i = getelementptr inbounds %struct.task_struct, ptr %curr, i32 0, i32 18, i32 7
  %49 = ptrtoint ptr %prev_sum_exec_runtime.i.i to i32
  call void @__asan_load8_noabort(i32 %49)
  %50 = load i64, ptr %prev_sum_exec_runtime.i.i, align 8
  %sub.i.i = sub i64 %48, %50
  %mul.i.i21 = shl i64 %sub.i.i, 1
  %cmp.i.i = icmp ugt i64 %mul.i.i21, %call1.i.i
  br i1 %cmp.i.i, label %if.then3.i, label %task_tick_core.exit

if.then3.i:                                       ; preds = %land.lhs.true1.i
  tail call void @resched_curr(ptr noundef %rq) #20
  br label %task_tick_core.exit

task_tick_core.exit:                              ; preds = %if.then3.i, %land.lhs.true1.i, %land.lhs.true.i20, %if.end.i, %land.rhs.i.i, %update_overutilized_status.exit
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @task_fork_fair(ptr noundef %p) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %se1 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %0 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 3
  %2 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %3
  %4 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %arrayidx, align 4
  %add = add i32 %5, ptrtoint (ptr @runqueues to i32)
  %6 = inttoptr i32 %add to ptr
  tail call void @raw_spin_rq_lock_nested(ptr noundef %6, i32 noundef 0) #20
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 81
  %7 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %8, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %entry
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 79
  %9 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %entry
  %retval.0.i.i.i = phi ptr [ %10, %if.then.i.i.i ], [ %6, %entry ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call1.i.i = tail call i32 @lock_pin_lock(ptr noundef %dep_map.i.i) #20
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 25
  %11 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %clock_update_flags.i.i, align 4
  %and.i.i = and i32 %12, 3
  store i32 %and.i.i, ptr %clock_update_flags.i.i, align 4
  %balance_callback.i.i = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 39
  %13 = ptrtoint ptr %balance_callback.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %balance_callback.i.i, align 8
  %tobool.not.i.i = icmp ne ptr %14, null
  %cmp.i.i = icmp ne ptr %14, @balance_push_callback
  %spec.select.i.i = and i1 %tobool.not.i.i, %cmp.i.i
  br i1 %spec.select.i.i, label %land.rhs6.i.i, label %rq_lock.exit

land.rhs6.i.i:                                    ; preds = %__rq_lockp.exit.i.i
  %.b48.i.i = load i1, ptr @rq_pin_lock.__already_done, align 1
  br i1 %.b48.i.i, label %rq_lock.exit, label %if.then.i.i, !prof !259

if.then.i.i:                                      ; preds = %land.rhs6.i.i
  store i1 true, ptr @rq_pin_lock.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1545, i32 noundef 9, ptr noundef nonnull @.str.35) #20
  br label %rq_lock.exit

rq_lock.exit:                                     ; preds = %if.then.i.i, %land.rhs6.i.i, %__rq_lockp.exit.i.i
  tail call void @update_rq_clock(ptr noundef %6) #20
  %task = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 2
  %15 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %task, align 8
  %cfs_rq.i = getelementptr inbounds %struct.task_struct, ptr %16, i32 0, i32 18, i32 11
  %17 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %cfs_rq.i, align 16
  %curr5 = getelementptr inbounds %struct.cfs_rq, ptr %18, i32 0, i32 11
  %19 = ptrtoint ptr %curr5 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %curr5, align 8
  %tobool.not = icmp eq ptr %20, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %rq_lock.exit
  tail call fastcc void @update_curr(ptr noundef %18)
  %vruntime = getelementptr inbounds %struct.sched_entity, ptr %20, i32 0, i32 6
  %21 = ptrtoint ptr %vruntime to i32
  call void @__asan_load8_noabort(i32 %21)
  %22 = load i64, ptr %vruntime, align 16
  %vruntime6 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 6
  %23 = ptrtoint ptr %vruntime6 to i32
  call void @__asan_store8_noabort(i32 %23)
  store i64 %22, ptr %vruntime6, align 16
  br label %if.end

if.end:                                           ; preds = %if.then, %rq_lock.exit
  %min_vruntime.i = getelementptr inbounds %struct.cfs_rq, ptr %18, i32 0, i32 6
  %24 = ptrtoint ptr %min_vruntime.i to i32
  call void @__asan_load8_noabort(i32 %24)
  %25 = load i64, ptr %min_vruntime.i, align 32
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 1), i32 1), ptr blockaddress(@task_fork_fair, %place_entity.exit)) #20
          to label %if.then.i [label %place_entity.exit], !srcloc !261

if.then.i:                                        ; preds = %if.end
  %call.i.i = tail call fastcc i64 @sched_slice(ptr noundef %18, ptr noundef %se1) #20
  %26 = ptrtoint ptr %se1 to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %se1, align 128
  %cmp.not.i.i.i = icmp eq i32 %27, 1024
  br i1 %cmp.not.i.i.i, label %sched_vslice.exit.i, label %if.then.i.i.i37, !prof !259

if.then.i.i.i37:                                  ; preds = %if.then.i
  %inv_weight.i.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 0, i32 1
  %28 = ptrtoint ptr %inv_weight.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %inv_weight.i.i.i.i, align 4
  %tobool.not.i33.i.i.i = icmp eq i32 %29, 0
  br i1 %tobool.not.i33.i.i.i, label %if.end.i.i.i.i, label %__update_inv_weight.exit.i.i.i, !prof !260

if.end.i.i.i.i:                                   ; preds = %if.then.i.i.i37
  %tobool3.not.i.i.i.i = icmp eq i32 %27, 0
  br i1 %tobool3.not.i.i.i.i, label %if.end15.i.i.i.i, label %if.else.i.i.i.i, !prof !260

if.else.i.i.i.i:                                  ; preds = %if.end.i.i.i.i
  %div.i.i.i.i = udiv i32 -1, %27
  br label %if.end15.i.i.i.i

if.end15.i.i.i.i:                                 ; preds = %if.else.i.i.i.i, %if.end.i.i.i.i
  %storemerge.i.i.i.i = phi i32 [ %div.i.i.i.i, %if.else.i.i.i.i ], [ -1, %if.end.i.i.i.i ]
  %30 = ptrtoint ptr %inv_weight.i.i.i.i to i32
  call void @__asan_store4_noabort(i32 %30)
  store i32 %storemerge.i.i.i.i, ptr %inv_weight.i.i.i.i, align 4
  br label %__update_inv_weight.exit.i.i.i

__update_inv_weight.exit.i.i.i:                   ; preds = %if.end15.i.i.i.i, %if.then.i.i.i37
  %31 = phi i32 [ %storemerge.i.i.i.i, %if.end15.i.i.i.i ], [ %29, %if.then.i.i.i37 ]
  %conv1.i.i.i.i = zext i32 %31 to i64
  %mul.i.i.i.i = shl nuw nsw i64 %conv1.i.i.i.i, 10
  %tobool9.not.i.i.i = icmp ult i32 %31, 4194304
  %extract.t32.i.i.i = trunc i64 %mul.i.i.i.i to i32
  br i1 %tobool9.not.i.i.i, label %if.end15.i.i.i, label %if.then10.i.i.i

if.then10.i.i.i:                                  ; preds = %__update_inv_weight.exit.i.i.i
  %shr7.i.i.i = lshr i32 %31, 22
  %32 = tail call i32 @llvm.ctlz.i32(i32 %shr7.i.i.i, i1 true) #20, !range !258
  %sub.i.i.i.i = sub nuw nsw i32 32, %32
  %sh_prom13.i.i.i = zext i32 %sub.i.i.i.i to i64
  %shr14.i.i.i = lshr i64 %mul.i.i.i.i, %sh_prom13.i.i.i
  %extract.t.i.i.i = trunc i64 %shr14.i.i.i to i32
  br label %if.end15.i.i.i

if.end15.i.i.i:                                   ; preds = %if.then10.i.i.i, %__update_inv_weight.exit.i.i.i
  %fact.1.off0.i.i.i = phi i32 [ %extract.t.i.i.i, %if.then10.i.i.i ], [ %extract.t32.i.i.i, %__update_inv_weight.exit.i.i.i ]
  %shift.1.i.i.i = phi i32 [ %32, %if.then10.i.i.i ], [ 32, %__update_inv_weight.exit.i.i.i ]
  %conv.i.i.i.i.i = and i64 %call.i.i, 4294967295
  %conv1.i.i.i.i.i = zext i32 %fact.1.off0.i.i.i to i64
  %mul.i.i.i.i.i = mul nuw i64 %conv.i.i.i.i.i, %conv1.i.i.i.i.i
  %sh_prom.i.i.i.i = zext i32 %shift.1.i.i.i to i64
  %shr2.i.i.i.i = lshr i64 %mul.i.i.i.i.i, %sh_prom.i.i.i.i
  %tobool.not.i34.i.i.i = icmp ult i64 %call.i.i, 4294967296
  br i1 %tobool.not.i34.i.i.i, label %sched_vslice.exit.i, label %if.then.i.i.i.i

if.then.i.i.i.i:                                  ; preds = %if.end15.i.i.i
  %shr.i.i.i.i = lshr i64 %call.i.i, 32
  %mul.i12.i.i.i.i = mul nuw i64 %shr.i.i.i.i, %conv1.i.i.i.i.i
  %sub.i35.i.i.i = sub nuw nsw i32 32, %shift.1.i.i.i
  %sh_prom4.i.i.i.i = zext i32 %sub.i35.i.i.i to i64
  %shl.i.i.i.i = shl i64 %mul.i12.i.i.i.i, %sh_prom4.i.i.i.i
  %add.i.i.i.i = add i64 %shl.i.i.i.i, %shr2.i.i.i.i
  br label %sched_vslice.exit.i

sched_vslice.exit.i:                              ; preds = %if.then.i.i.i.i, %if.end15.i.i.i, %if.then.i
  %delta.addr.0.i.i.i = phi i64 [ %call.i.i, %if.then.i ], [ %add.i.i.i.i, %if.then.i.i.i.i ], [ %shr2.i.i.i.i, %if.end15.i.i.i ]
  %add.i = add i64 %delta.addr.0.i.i.i, %25
  br label %place_entity.exit

place_entity.exit:                                ; preds = %sched_vslice.exit.i, %if.end
  %vruntime.1.i = phi i64 [ %add.i, %sched_vslice.exit.i ], [ %25, %if.end ]
  %vruntime12.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 6
  %33 = ptrtoint ptr %vruntime12.i to i32
  call void @__asan_load8_noabort(i32 %33)
  %34 = load i64, ptr %vruntime12.i, align 16
  %sub.i.i = sub i64 %vruntime.1.i, %34
  %cmp.i.i38 = icmp sgt i64 %sub.i.i, 0
  %spec.select.i.i39 = select i1 %cmp.i.i38, i64 %vruntime.1.i, i64 %34
  store i64 %spec.select.i.i39, ptr %vruntime12.i, align 16
  %35 = load i32, ptr @sysctl_sched_child_runs_first, align 4
  %tobool7.not = icmp eq i32 %35, 0
  %brmerge = select i1 %tobool7.not, i1 true, i1 %tobool.not
  br i1 %brmerge, label %if.end19, label %land.lhs.true9

land.lhs.true9:                                   ; preds = %place_entity.exit
  %vruntime.i = getelementptr inbounds %struct.sched_entity, ptr %20, i32 0, i32 6
  %36 = ptrtoint ptr %vruntime.i to i32
  call void @__asan_load8_noabort(i32 %36)
  %37 = load i64, ptr %vruntime.i, align 16
  %sub.i = sub i64 %37, %spec.select.i.i39
  %cmp.i = icmp slt i64 %sub.i, 0
  br i1 %cmp.i, label %do.body12, label %if.end19

do.body12:                                        ; preds = %land.lhs.true9
  %38 = ptrtoint ptr %vruntime12.i to i32
  call void @__asan_load8_noabort(i32 %38)
  %39 = load i64, ptr %vruntime12.i, align 16
  %40 = ptrtoint ptr %vruntime.i to i32
  call void @__asan_store8_noabort(i32 %40)
  store i64 %39, ptr %vruntime.i, align 16
  store i64 %37, ptr %vruntime12.i, align 16
  tail call void @resched_curr(ptr noundef %6) #20
  br label %if.end19

if.end19:                                         ; preds = %do.body12, %land.lhs.true9, %place_entity.exit
  %41 = ptrtoint ptr %min_vruntime.i to i32
  call void @__asan_load8_noabort(i32 %41)
  %42 = load i64, ptr %min_vruntime.i, align 32
  %43 = ptrtoint ptr %vruntime12.i to i32
  call void @__asan_load8_noabort(i32 %43)
  %44 = load i64, ptr %vruntime12.i, align 16
  %sub = sub i64 %44, %42
  store i64 %sub, ptr %vruntime12.i, align 16
  %45 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i44 = icmp eq i32 %46, 0
  br i1 %tobool.not.i.i.i44, label %rq_unlock.exit, label %if.then.i.i.i46

if.then.i.i.i46:                                  ; preds = %if.end19
  %core.i.i.i45 = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 79
  %47 = ptrtoint ptr %core.i.i.i45 to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load ptr, ptr %core.i.i.i45, align 8
  br label %rq_unlock.exit

rq_unlock.exit:                                   ; preds = %if.then.i.i.i46, %if.end19
  %retval.0.i.i.i47 = phi ptr [ %48, %if.then.i.i.i46 ], [ %6, %if.end19 ]
  %dep_map.i.i48 = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i47, i32 0, i32 4
  %49 = insertvalue [1 x i32] undef, i32 %call1.i.i, 0
  tail call void @lock_unpin_lock(ptr noundef %dep_map.i.i48, [1 x i32] %49) #20
  tail call void @raw_spin_rq_unlock(ptr noundef %6) #20
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @task_dead_fair(ptr noundef %p) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %cfs_rq.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %0 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %cfs_rq.i.i, align 16
  %load_last_update_time_copy.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 18
  %avg.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 17
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %do.body.i.i.i, %entry
  %2 = ptrtoint ptr %load_last_update_time_copy.i.i.i to i32
  call void @__asan_load8_noabort(i32 %2)
  %3 = load i64, ptr %load_last_update_time_copy.i.i.i, align 128
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !287
  %4 = ptrtoint ptr %avg.i.i.i to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %avg.i.i.i, align 128
  %cmp.not.i.i.i = icmp eq i64 %5, %3
  br i1 %cmp.not.i.i.i, label %remove_entity_load_avg.exit, label %do.body.i.i.i

remove_entity_load_avg.exit:                      ; preds = %do.body.i.i.i
  %se = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %call2.i.i = tail call i32 @__update_load_avg_blocked_se(i64 noundef %3, ptr noundef %se) #20
  %removed.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 20
  %call1.i = tail call i32 @_raw_spin_lock_irqsave(ptr noundef %removed.i) #20
  %nr.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 20, i32 1
  %6 = ptrtoint ptr %nr.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %nr.i, align 4
  %inc.i = add i32 %7, 1
  store i32 %inc.i, ptr %nr.i, align 4
  %util_avg.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 7
  %8 = ptrtoint ptr %util_avg.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %util_avg.i, align 8
  %util_avg4.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 20, i32 3
  %10 = ptrtoint ptr %util_avg4.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %util_avg4.i, align 4
  %add.i = add i32 %11, %9
  store i32 %add.i, ptr %util_avg4.i, align 4
  %load_avg.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 5
  %12 = ptrtoint ptr %load_avg.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %load_avg.i, align 32
  %load_avg7.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 20, i32 2
  %14 = ptrtoint ptr %load_avg7.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %load_avg7.i, align 16
  %add8.i = add i32 %15, %13
  store i32 %add8.i, ptr %load_avg7.i, align 16
  %runnable_avg.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 6
  %16 = ptrtoint ptr %runnable_avg.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %runnable_avg.i, align 4
  %runnable_avg11.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 20, i32 4
  %18 = ptrtoint ptr %runnable_avg11.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %runnable_avg11.i, align 8
  %add12.i = add i32 %19, %17
  store i32 %add12.i, ptr %runnable_avg11.i, align 8
  tail call void @_raw_spin_unlock_irqrestore(ptr noundef %removed.i, i32 noundef %call1.i) #20
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @switched_from_fair(ptr nocapture noundef readnone %rq, ptr noundef %p) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %cfs_rq.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %0 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %cfs_rq.i.i, align 16
  %on_rq.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 12
  %2 = ptrtoint ptr %on_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %on_rq.i.i, align 4
  %tobool.not.i.i = icmp eq i32 %3, 0
  br i1 %tobool.not.i.i, label %if.end.i.i, label %detach_task_cfs_rq.exit

if.end.i.i:                                       ; preds = %entry
  %sum_exec_runtime.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 5
  %4 = ptrtoint ptr %sum_exec_runtime.i.i to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %sum_exec_runtime.i.i, align 8
  %tobool2.not.i.i = icmp eq i64 %5, 0
  br i1 %tobool2.not.i.i, label %detach_task_cfs_rq.exit, label %do.end.i.i

do.end.i.i:                                       ; preds = %if.end.i.i
  %6 = ptrtoint ptr %p to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %p, align 128
  %cmp.i.i = icmp eq i32 %7, 512
  br i1 %cmp.i.i, label %land.lhs.true.i.i, label %if.then.i

land.lhs.true.i.i:                                ; preds = %do.end.i.i
  %sched_remote_wakeup.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 65
  %8 = ptrtoint ptr %sched_remote_wakeup.i.i to i32
  call void @__asan_load2_noabort(i32 %8)
  %bf.load.i.i = load i16, ptr %sched_remote_wakeup.i.i, align 8
  %tobool3.not.i.i = icmp sgt i16 %bf.load.i.i, -1
  br i1 %tobool3.not.i.i, label %if.then.i, label %detach_task_cfs_rq.exit

if.then.i:                                        ; preds = %land.lhs.true.i.i, %do.end.i.i
  %min_vruntime.i.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 6
  %9 = ptrtoint ptr %min_vruntime.i.i to i32
  call void @__asan_load8_noabort(i32 %9)
  %10 = load i64, ptr %min_vruntime.i.i, align 32
  %my_q.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 12
  %11 = ptrtoint ptr %my_q.i.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %my_q.i.i.i, align 4
  %tobool.not.i.i.i = icmp eq ptr %12, null
  br i1 %tobool.not.i.i.i, label %task_of.exit.i.i.i, label %if.end.i.i.i

task_of.exit.i.i.i:                               ; preds = %if.then.i
  %policy.i.i.i.i = getelementptr %struct.task_struct, ptr %p, i32 0, i32 31
  %13 = ptrtoint ptr %policy.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %policy.i.i.i.i, align 4
  %cmp.i.i.i.i.i = icmp eq i32 %14, 5
  br label %se_is_idle.exit.i.i

if.end.i.i.i:                                     ; preds = %if.then.i
  %idle.i.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %12, i32 0, i32 31
  %15 = ptrtoint ptr %idle.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %idle.i.i.i.i, align 16
  %cmp.i.i.i.i = icmp sgt i32 %16, 0
  br label %se_is_idle.exit.i.i

se_is_idle.exit.i.i:                              ; preds = %if.end.i.i.i, %task_of.exit.i.i.i
  %retval.0.in.i.i.i = phi i1 [ %cmp.i.i.i.i, %if.end.i.i.i ], [ %cmp.i.i.i.i.i, %task_of.exit.i.i.i ]
  %sysctl_sched_min_granularity.val.i.i = load i32, ptr @sysctl_sched_min_granularity, align 4
  %sysctl_sched_latency.val.i.i = load i32, ptr @sysctl_sched_latency, align 4
  %thresh.0.i.i = select i1 %retval.0.in.i.i.i, i32 %sysctl_sched_min_granularity.val.i.i, i32 %sysctl_sched_latency.val.i.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @sched_feat_keys, i32 1), ptr blockaddress(@switched_from_fair, %place_entity.exit.i)) #20
          to label %17 [label %place_entity.exit.i], !srcloc !261

17:                                               ; preds = %se_is_idle.exit.i.i
  %shr.i.i = lshr i32 %thresh.0.i.i, 1
  br label %place_entity.exit.i

place_entity.exit.i:                              ; preds = %17, %se_is_idle.exit.i.i
  %18 = phi i32 [ %shr.i.i, %17 ], [ %thresh.0.i.i, %se_is_idle.exit.i.i ]
  %conv.i.i = zext i32 %18 to i64
  %sub.i.i = sub i64 %10, %conv.i.i
  %vruntime12.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 6
  %19 = ptrtoint ptr %vruntime12.i.i to i32
  call void @__asan_load8_noabort(i32 %19)
  %20 = load i64, ptr %vruntime12.i.i, align 16
  %sub.i.i.i = sub i64 %sub.i.i, %20
  %cmp.i.i.i = icmp sgt i64 %sub.i.i.i, 0
  %spec.select.i.i.i = select i1 %cmp.i.i.i, i64 %sub.i.i, i64 %20
  store i64 %spec.select.i.i.i, ptr %vruntime12.i.i, align 16
  %21 = ptrtoint ptr %min_vruntime.i.i to i32
  call void @__asan_load8_noabort(i32 %21)
  %22 = load i64, ptr %min_vruntime.i.i, align 32
  %sub.i = sub i64 %spec.select.i.i.i, %22
  store i64 %sub.i, ptr %vruntime12.i.i, align 16
  br label %detach_task_cfs_rq.exit

detach_task_cfs_rq.exit:                          ; preds = %place_entity.exit.i, %land.lhs.true.i.i, %if.end.i.i, %entry
  %se1.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  tail call fastcc void @detach_entity_cfs_rq(ptr noundef %se1.i) #20
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @switched_to_fair(ptr noundef %rq, ptr noundef %p) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %se1.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %cfs_rq.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %0 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %cfs_rq.i.i, align 16
  tail call fastcc void @attach_entity_cfs_rq(ptr noundef %se1.i) #20
  %on_rq.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 12
  %2 = ptrtoint ptr %on_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %on_rq.i.i, align 4
  switch i32 %3, label %if.end4 [
    i32 0, label %if.end.i.i
    i32 1, label %if.then
  ]

if.end.i.i:                                       ; preds = %entry
  %sum_exec_runtime.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 5
  %4 = ptrtoint ptr %sum_exec_runtime.i.i to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %sum_exec_runtime.i.i, align 8
  %tobool2.not.i.i = icmp eq i64 %5, 0
  br i1 %tobool2.not.i.i, label %if.end4, label %do.end.i.i

do.end.i.i:                                       ; preds = %if.end.i.i
  %6 = ptrtoint ptr %p to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %p, align 128
  %cmp.i.i = icmp eq i32 %7, 512
  br i1 %cmp.i.i, label %land.lhs.true.i.i, label %if.then.i

land.lhs.true.i.i:                                ; preds = %do.end.i.i
  %sched_remote_wakeup.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 65
  %8 = ptrtoint ptr %sched_remote_wakeup.i.i to i32
  call void @__asan_load2_noabort(i32 %8)
  %bf.load.i.i = load i16, ptr %sched_remote_wakeup.i.i, align 8
  %tobool3.not.i.i = icmp sgt i16 %bf.load.i.i, -1
  br i1 %tobool3.not.i.i, label %if.then.i, label %if.end4

if.then.i:                                        ; preds = %land.lhs.true.i.i, %do.end.i.i
  %min_vruntime.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 6
  %9 = ptrtoint ptr %min_vruntime.i to i32
  call void @__asan_load8_noabort(i32 %9)
  %10 = load i64, ptr %min_vruntime.i, align 32
  %vruntime.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 6
  %11 = ptrtoint ptr %vruntime.i to i32
  call void @__asan_load8_noabort(i32 %11)
  %12 = load i64, ptr %vruntime.i, align 16
  %add.i = add i64 %12, %10
  store i64 %add.i, ptr %vruntime.i, align 16
  br label %if.end4

if.then:                                          ; preds = %entry
  %curr.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 20
  %13 = ptrtoint ptr %curr.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %curr.i, align 8
  %cmp.i10.not = icmp eq ptr %14, %p
  br i1 %cmp.i10.not, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.then
  tail call void @resched_curr(ptr noundef %rq) #20
  br label %if.end4

if.else:                                          ; preds = %if.then
  tail call void @check_preempt_curr(ptr noundef %rq, ptr noundef %p, i32 noundef 0) #20
  br label %if.end4

if.end4:                                          ; preds = %if.else, %if.then3, %if.then.i, %land.lhs.true.i.i, %if.end.i.i, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @prio_changed_fair(ptr noundef %rq, ptr noundef %p, i32 noundef %oldprio) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %on_rq.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 12
  %0 = ptrtoint ptr %on_rq.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %on_rq.i, align 4
  %cmp.i.not = icmp eq i32 %1, 1
  br i1 %cmp.i.not, label %if.end, label %if.end9

if.end:                                           ; preds = %entry
  %nr_running = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 14, i32 1
  %2 = ptrtoint ptr %nr_running to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %nr_running, align 8
  %cmp = icmp eq i32 %3, 1
  br i1 %cmp, label %if.end9, label %if.end2

if.end2:                                          ; preds = %if.end
  %curr.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 20
  %4 = ptrtoint ptr %curr.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %curr.i, align 8
  %cmp.i16.not = icmp eq ptr %5, %p
  br i1 %cmp.i16.not, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end2
  %prio = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 13
  %6 = ptrtoint ptr %prio to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %prio, align 8
  %cmp6 = icmp sgt i32 %7, %oldprio
  br i1 %cmp6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.then5
  tail call void @resched_curr(ptr noundef %rq) #20
  br label %if.end9

if.else:                                          ; preds = %if.end2
  tail call void @check_preempt_curr(ptr noundef %rq, ptr noundef %p, i32 noundef 0) #20
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then7, %if.then5, %if.end, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @get_rr_interval_fair(ptr nocapture noundef readonly %rq, ptr noundef %task) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %cfs = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 14
  %0 = ptrtoint ptr %cfs to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %cfs, align 128
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %se1 = getelementptr inbounds %struct.task_struct, ptr %task, i32 0, i32 18
  %cfs_rq.i = getelementptr inbounds %struct.task_struct, ptr %task, i32 0, i32 18, i32 11
  %2 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %cfs_rq.i, align 16
  %call2 = tail call fastcc i64 @sched_slice(ptr noundef %3, ptr noundef %se1)
  %conv = trunc i64 %call2 to i32
  %div = udiv i32 %conv, 10000000
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rr_interval.0 = phi i32 [ %div, %if.then ], [ 0, %entry ]
  ret i32 %rr_interval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @update_curr_fair(ptr nocapture noundef readonly %rq) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %curr = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 20
  %0 = ptrtoint ptr %curr to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %curr, align 8
  %cfs_rq.i = getelementptr inbounds %struct.task_struct, ptr %1, i32 0, i32 18, i32 11
  %2 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %cfs_rq.i, align 16
  tail call fastcc void @update_curr(ptr noundef %3)
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @task_change_group_fair(ptr noundef %p, i32 noundef %type) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  switch i32 %type, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %stack.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 1
  %0 = ptrtoint ptr %stack.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %stack.i.i, align 4
  %cpu.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 3
  %2 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %cpu.i.i, align 4
  %sched_task_group.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 25
  %4 = ptrtoint ptr %sched_task_group.i.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %sched_task_group.i.i.i, align 8
  %se.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %cfs_rq.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %6 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %cfs_rq.i.i, align 16
  %cfs_rq2.i.i = getelementptr inbounds %struct.task_group, ptr %5, i32 0, i32 2
  %8 = ptrtoint ptr %cfs_rq2.i.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %cfs_rq2.i.i, align 4
  %arrayidx.i.i = getelementptr ptr, ptr %9, i32 %3
  %10 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %arrayidx.i.i, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 16), i32 1), ptr blockaddress(@task_change_group_fair, %set_task_rq.exit.i)) #20
          to label %if.end.i.i.i [label %set_task_rq.exit.i], !srcloc !261

if.end.i.i.i:                                     ; preds = %sw.bb
  %avg.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15
  %12 = ptrtoint ptr %avg.i.i.i to i32
  call void @__asan_load8_noabort(i32 %12)
  %13 = load i64, ptr %avg.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i64 %13, 0
  %tobool1.not.i.i.i = icmp eq ptr %7, null
  %or.cond.i.i.i = or i1 %tobool1.not.i.i.i, %tobool.not.i.i.i
  br i1 %or.cond.i.i.i, label %set_task_rq.exit.i, label %do.body.preheader.i.i.i

do.body.preheader.i.i.i:                          ; preds = %if.end.i.i.i
  %load_last_update_time_copy.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %7, i32 0, i32 18
  %load_last_update_time_copy4.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %11, i32 0, i32 18
  %avg9.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %7, i32 0, i32 17
  %avg11.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %11, i32 0, i32 17
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %do.body.i.i.i, %do.body.preheader.i.i.i
  %14 = ptrtoint ptr %load_last_update_time_copy.i.i.i to i32
  call void @__asan_load8_noabort(i32 %14)
  %15 = load i64, ptr %load_last_update_time_copy.i.i.i, align 128
  %16 = ptrtoint ptr %load_last_update_time_copy4.i.i.i to i32
  call void @__asan_load8_noabort(i32 %16)
  %17 = load i64, ptr %load_last_update_time_copy4.i.i.i, align 128
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !264
  %18 = ptrtoint ptr %avg9.i.i.i to i32
  call void @__asan_load8_noabort(i32 %18)
  %19 = load i64, ptr %avg9.i.i.i, align 128
  %20 = ptrtoint ptr %avg11.i.i.i to i32
  call void @__asan_load8_noabort(i32 %20)
  %21 = load i64, ptr %avg11.i.i.i, align 128
  %cmp.not.i.i.i = icmp eq i64 %19, %15
  %cmp14.not.i.i.i = icmp eq i64 %21, %17
  %or.cond28.i.i.i = select i1 %cmp.not.i.i.i, i1 %cmp14.not.i.i.i, i1 false
  br i1 %or.cond28.i.i.i, label %do.end15.i.i.i, label %do.body.i.i.i

do.end15.i.i.i:                                   ; preds = %do.body.i.i.i
  %call16.i.i.i = tail call i32 @__update_load_avg_blocked_se(i64 noundef %15, ptr noundef %se.i.i) #20
  %22 = ptrtoint ptr %avg.i.i.i to i32
  call void @__asan_store8_noabort(i32 %22)
  store i64 %17, ptr %avg.i.i.i, align 128
  br label %set_task_rq.exit.i

set_task_rq.exit.i:                               ; preds = %do.end15.i.i.i, %if.end.i.i.i, %sw.bb
  %23 = ptrtoint ptr %cfs_rq2.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %cfs_rq2.i.i, align 4
  %arrayidx4.i.i = getelementptr ptr, ptr %24, i32 %3
  %25 = ptrtoint ptr %arrayidx4.i.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load ptr, ptr %arrayidx4.i.i, align 4
  %27 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_store4_noabort(i32 %27)
  store ptr %26, ptr %cfs_rq.i.i, align 16
  %se7.i.i = getelementptr inbounds %struct.task_group, ptr %5, i32 0, i32 1
  %28 = ptrtoint ptr %se7.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load ptr, ptr %se7.i.i, align 8
  %arrayidx8.i.i = getelementptr ptr, ptr %29, i32 %3
  %30 = ptrtoint ptr %arrayidx8.i.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %arrayidx8.i.i, align 4
  %parent.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 10
  %32 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_store4_noabort(i32 %32)
  store ptr %31, ptr %parent.i.i, align 4
  %rt_rq.i.i = getelementptr inbounds %struct.task_group, ptr %5, i32 0, i32 8
  %33 = ptrtoint ptr %rt_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load ptr, ptr %rt_rq.i.i, align 8
  %arrayidx10.i.i = getelementptr ptr, ptr %34, i32 %3
  %35 = ptrtoint ptr %arrayidx10.i.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load ptr, ptr %arrayidx10.i.i, align 4
  %rt_rq11.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 19, i32 8
  %37 = ptrtoint ptr %rt_rq11.i.i to i32
  call void @__asan_store4_noabort(i32 %37)
  store ptr %36, ptr %rt_rq11.i.i, align 32
  %rt_se.i.i = getelementptr inbounds %struct.task_group, ptr %5, i32 0, i32 7
  %38 = ptrtoint ptr %rt_se.i.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load ptr, ptr %rt_se.i.i, align 4
  %arrayidx12.i.i = getelementptr ptr, ptr %39, i32 %3
  %40 = ptrtoint ptr %arrayidx12.i.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load ptr, ptr %arrayidx12.i.i, align 4
  %parent14.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 19, i32 7
  %42 = ptrtoint ptr %parent14.i.i to i32
  call void @__asan_store4_noabort(i32 %42)
  store ptr %41, ptr %parent14.i.i, align 4
  %tobool.not.i = icmp eq ptr %31, null
  br i1 %tobool.not.i, label %task_set_group_fair.exit, label %cond.true.i

cond.true.i:                                      ; preds = %set_task_rq.exit.i
  %depth.i = getelementptr inbounds %struct.sched_entity, ptr %31, i32 0, i32 9
  %43 = ptrtoint ptr %depth.i to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load i32, ptr %depth.i, align 8
  %add.i = add i32 %44, 1
  br label %task_set_group_fair.exit

task_set_group_fair.exit:                         ; preds = %cond.true.i, %set_task_rq.exit.i
  %cond.i = phi i32 [ %add.i, %cond.true.i ], [ 0, %set_task_rq.exit.i ]
  %depth3.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 9
  %45 = ptrtoint ptr %depth3.i to i32
  call void @__asan_store4_noabort(i32 %45)
  store i32 %cond.i, ptr %depth3.i, align 8
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  tail call fastcc void @task_move_group_fair(ptr noundef %p)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb1, %task_set_group_fair.exit, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @print_cfs_stats(ptr noundef %m, i32 noundef %cpu) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %3, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !268
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #20
  %call.i = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 696, ptr noundef nonnull @.str.28) #20
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %entry
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %cpu
  %4 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %arrayidx, align 4
  %add = add i32 %5, ptrtoint (ptr @runqueues to i32)
  %6 = inttoptr i32 %add to ptr
  %leaf_cfs_rq_list = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 17
  %7 = ptrtoint ptr %leaf_cfs_rq_list to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %leaf_cfs_rq_list, align 8
  %cmp.not41 = icmp eq ptr %8, %leaf_cfs_rq_list
  br i1 %cmp.not41, label %for.end, label %for.body

for.body:                                         ; preds = %for.body, %rcu_read_lock.exit
  %.pn.in42 = phi ptr [ %.pn, %for.body ], [ %8, %rcu_read_lock.exit ]
  %cfs_rq.0 = getelementptr i8, ptr %.pn.in42, i32 -548
  %9 = ptrtoint ptr %.pn.in42 to i32
  call void @__asan_load4_noabort(i32 %9)
  %.pn = load ptr, ptr %.pn.in42, align 4
  tail call void @print_cfs_rq(ptr noundef %m, i32 noundef %cpu, ptr noundef %cfs_rq.0) #20
  %10 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %arrayidx, align 4
  %add17 = add i32 %11, ptrtoint (ptr @runqueues to i32)
  %12 = inttoptr i32 %add17 to ptr
  %leaf_cfs_rq_list18 = getelementptr inbounds %struct.rq, ptr %12, i32 0, i32 17
  %cmp.not = icmp eq ptr %.pn, %leaf_cfs_rq_list18
  br i1 %cmp.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %rcu_read_lock.exit
  %call.i30 = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i30, label %rcu_read_unlock.exit, label %land.lhs.true.i33

land.lhs.true.i33:                                ; preds = %for.end
  %call1.i31 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i32 = icmp eq i32 %call1.i31, 0
  br i1 %tobool.not.i32, label %rcu_read_unlock.exit, label %land.lhs.true2.i35

land.lhs.true2.i35:                               ; preds = %land.lhs.true.i33
  %.b4.i34 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i34, label %rcu_read_unlock.exit, label %if.then.i36

if.then.i36:                                      ; preds = %land.lhs.true2.i35
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i36, %land.lhs.true2.i35, %land.lhs.true.i33, %for.end
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %13 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i37 = and i32 %13, -16384
  %14 = inttoptr i32 %and.i.i.i.i.i37 to ptr
  %preempt_count.i.i.i.i38 = getelementptr inbounds %struct.thread_info, ptr %14, i32 0, i32 1
  %15 = ptrtoint ptr %preempt_count.i.i.i.i38 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %preempt_count.i.i.i.i38, align 4
  %sub.i.i.i = add i32 %16, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i38, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @print_cfs_rq(ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: cold nounwind null_pointer_is_valid optsize sanitize_address sspstrong uwtable(sync)
define dso_local void @init_sched_fair_class() local_unnamed_addr #0 section ".init.text" align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call void @open_softirq(i32 noundef 7, ptr noundef nonnull @run_rebalance_domains) #20
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %0 = load volatile i32, ptr @jiffies, align 128
  store i32 %0, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 4), align 16
  %1 = load volatile i32, ptr @jiffies, align 128
  store i32 %1, ptr getelementptr inbounds (%struct.anon.138, ptr @nohz, i32 0, i32 5), align 4
  %call = tail call zeroext i1 @zalloc_cpumask_var(ptr noundef nonnull @nohz, i32 noundef 2048) #20
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @open_softirq(i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @run_rebalance_domains(ptr nocapture noundef readnone %h) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 3
  %2 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %3
  %4 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %arrayidx, align 4
  %add = add i32 %5, ptrtoint (ptr @runqueues to i32)
  %6 = inttoptr i32 %add to ptr
  %idle_balance = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 41
  %7 = ptrtoint ptr %idle_balance to i32
  call void @__asan_load1_noabort(i32 %7)
  %8 = load i8, ptr %idle_balance, align 1
  %tobool.not = icmp eq i8 %8, 0
  %cond = zext i1 %tobool.not to i32
  %nohz_idle_balance.i = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 40
  %9 = ptrtoint ptr %nohz_idle_balance.i to i32
  call void @__asan_load1_noabort(i32 %9)
  %10 = load i8, ptr %nohz_idle_balance.i, align 4
  %conv.i = zext i8 %10 to i32
  %tobool.not.i = icmp eq i8 %10, 0
  br i1 %tobool.not.i, label %if.end, label %if.end.i

if.end.i:                                         ; preds = %entry
  %11 = ptrtoint ptr %nohz_idle_balance.i to i32
  call void @__asan_store1_noabort(i32 %11)
  store i8 0, ptr %nohz_idle_balance.i, align 4
  br i1 %tobool.not, label %if.end, label %nohz_idle_balance.exit

nohz_idle_balance.exit:                           ; preds = %if.end.i
  tail call fastcc void @_nohz_idle_balance(ptr noundef %6, i32 noundef %conv.i) #20
  br label %cleanup

if.end:                                           ; preds = %if.end.i, %entry
  %cpu3 = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 46
  %12 = ptrtoint ptr %cpu3 to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %cpu3, align 4
  tail call fastcc void @update_blocked_averages(i32 noundef %13)
  tail call fastcc void @rebalance_domains(ptr noundef %6, i32 noundef %cond)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %nohz_idle_balance.exit
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @zalloc_cpumask_var(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync)
define dso_local ptr @sched_trace_cfs_rq_avg(ptr noundef readnone %cfs_rq) #11 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tobool.not = icmp eq ptr %cfs_rq, null
  %avg = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17
  %spec.select = select i1 %tobool.not, ptr null, ptr %avg
  ret ptr %spec.select
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @sched_trace_cfs_rq_path(ptr noundef readonly %cfs_rq, ptr noundef %str, i32 noundef %len) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tobool.not = icmp eq ptr %cfs_rq, null
  %tobool1.not = icmp eq ptr %str, null
  br i1 %tobool.not, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  br i1 %tobool1.not, label %return, label %if.end.i.thread

if.end.i.thread:                                  ; preds = %if.then
  %call = tail call i32 @strlcpy(ptr noundef nonnull %str, ptr noundef nonnull @.str.6, i32 noundef %len) #20
  br label %if.else14.i

if.end3:                                          ; preds = %entry
  br i1 %tobool1.not, label %return, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end3
  %tg.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 30
  %0 = ptrtoint ptr %tg.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %tg.i, align 4
  %autogroup.i.i = getelementptr inbounds %struct.task_group, ptr %1, i32 0, i32 15
  %2 = ptrtoint ptr %autogroup.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %autogroup.i.i, align 4
  %tobool.i.not.i = icmp eq ptr %3, null
  br i1 %tobool.i.not.i, label %land.lhs.true6.critedge.i, label %if.then2.i

if.then2.i:                                       ; preds = %land.lhs.true.i
  %call4.i = tail call i32 @autogroup_path(ptr noundef %1, ptr noundef nonnull %str, i32 noundef %len) #20
  br label %return

land.lhs.true6.critedge.i:                        ; preds = %land.lhs.true.i
  %4 = ptrtoint ptr %1 to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %1, align 128
  %tobool8.not.i = icmp eq ptr %5, null
  br i1 %tobool8.not.i, label %if.else14.i, label %if.then9.i

if.then9.i:                                       ; preds = %land.lhs.true6.critedge.i
  %kn.i.i = getelementptr inbounds %struct.cgroup, ptr %5, i32 0, i32 11
  %6 = ptrtoint ptr %kn.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %kn.i.i, align 8
  %call.i.i.i = tail call i32 @kernfs_path_from_node(ptr noundef %7, ptr noundef null, ptr noundef nonnull %str, i32 noundef %len) #20
  br label %return

if.else14.i:                                      ; preds = %land.lhs.true6.critedge.i, %if.end.i.thread
  %call15.i = tail call i32 @strlcpy(ptr noundef nonnull %str, ptr noundef nonnull @.str.6, i32 noundef %len) #20
  br label %return

return:                                           ; preds = %if.else14.i, %if.then9.i, %if.then2.i, %if.end3, %if.then
  ret ptr %str
}

; Function Attrs: nofree null_pointer_is_valid
declare dso_local i32 @strlcpy(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #12

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync)
define dso_local i32 @sched_trace_cfs_rq_cpu(ptr noundef readonly %cfs_rq) #13 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tobool.not = icmp eq ptr %cfs_rq, null
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %rq.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %0 = ptrtoint ptr %rq.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %rq.i, align 4
  %cpu.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 46
  %2 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu.i, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi i32 [ %3, %cond.true ], [ -1, %entry ]
  ret i32 %cond
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync)
define dso_local ptr @sched_trace_rq_avg_rt(ptr noundef readnone %rq) #11 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tobool.not = icmp eq ptr %rq, null
  %avg_rt = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 50
  %spec.select = select i1 %tobool.not, ptr null, ptr %avg_rt
  ret ptr %spec.select
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync)
define dso_local ptr @sched_trace_rq_avg_dl(ptr noundef readnone %rq) #11 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tobool.not = icmp eq ptr %rq, null
  %avg_dl = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 51
  %spec.select = select i1 %tobool.not, ptr null, ptr %avg_dl
  ret ptr %spec.select
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync)
define dso_local ptr @sched_trace_rq_avg_irq(ptr noundef readnone %rq) #11 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tobool.not = icmp eq ptr %rq, null
  %avg_irq = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 52
  %spec.select = select i1 %tobool.not, ptr null, ptr %avg_irq
  ret ptr %spec.select
}

; Function Attrs: argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync)
define dso_local i32 @sched_trace_rq_cpu(ptr noundef readonly %rq) #2 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tobool.not = icmp eq ptr %rq, null
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %cpu.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 46
  %0 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %cpu.i, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi i32 [ %1, %cond.true ], [ -1, %entry ]
  ret i32 %cond
}

; Function Attrs: argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync)
define dso_local i32 @sched_trace_rq_cpu_capacity(ptr noundef readonly %rq) #2 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tobool.not = icmp eq ptr %rq, null
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %cpu_capacity = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 37
  %0 = ptrtoint ptr %cpu_capacity to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %cpu_capacity, align 16
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi i32 [ %1, %cond.true ], [ -1, %entry ]
  ret i32 %cond
}

; Function Attrs: argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync)
define dso_local ptr @sched_trace_rd_span(ptr noundef readonly %rd) #2 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tobool.not = icmp eq ptr %rd, null
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %span = getelementptr inbounds %struct.root_domain, ptr %rd, i32 0, i32 3
  %0 = ptrtoint ptr %span to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %span, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi ptr [ %1, %cond.true ], [ null, %entry ]
  ret ptr %cond
}

; Function Attrs: argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync)
define dso_local i32 @sched_trace_rq_nr_running(ptr noundef readonly %rq) #2 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tobool.not = icmp eq ptr %rq, null
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %nr_running = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 1
  %0 = ptrtoint ptr %nr_running to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %nr_running, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi i32 [ %1, %cond.true ], [ -1, %entry ]
  ret i32 %cond
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @kstrtoint(ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: cold null_pointer_is_valid
declare dso_local i32 @_printk(ptr noundef, ...) local_unnamed_addr #14

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.ctlz.i32(i32, i1 immarg) #15

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @__list_del_entry_valid(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @check_enqueue_throttle(ptr noundef %cfs_rq) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@check_enqueue_throttle, %if.end)) #20
          to label %if.end10 [label %if.end], !srcloc !261

if.end:                                           ; preds = %entry
  %runtime_enabled = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 32
  %0 = ptrtoint ptr %runtime_enabled to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %runtime_enabled, align 4
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %if.end10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %curr = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 11
  %2 = ptrtoint ptr %curr to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %curr, align 8
  %tobool1.not = icmp eq ptr %3, null
  br i1 %tobool1.not, label %if.end3, label %if.end10

if.end3:                                          ; preds = %lor.lhs.false
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@check_enqueue_throttle, %land.rhs.i)) #20
          to label %if.end7 [label %land.rhs.i], !srcloc !261

land.rhs.i:                                       ; preds = %if.end3
  %throttled.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 37
  %4 = ptrtoint ptr %throttled.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %throttled.i, align 8
  %tobool.i.not = icmp eq i32 %5, 0
  br i1 %tobool.i.not, label %if.end7, label %if.end10

if.end7:                                          ; preds = %land.rhs.i, %if.end3
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@check_enqueue_throttle, %lor.lhs.false.i)) #20
          to label %account_cfs_rq_runtime.exit [label %lor.lhs.false.i], !srcloc !261

lor.lhs.false.i:                                  ; preds = %if.end7
  %6 = ptrtoint ptr %runtime_enabled to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %runtime_enabled, align 4
  %tobool.not.i = icmp eq i32 %7, 0
  br i1 %tobool.not.i, label %account_cfs_rq_runtime.exit, label %if.end.i

if.end.i:                                         ; preds = %lor.lhs.false.i
  %runtime_remaining.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 33
  %8 = ptrtoint ptr %runtime_remaining.i.i to i32
  call void @__asan_load8_noabort(i32 %8)
  %9 = load i64, ptr %runtime_remaining.i.i, align 8
  %cmp.i.i = icmp sgt i64 %9, 0
  br i1 %cmp.i.i, label %account_cfs_rq_runtime.exit, label %if.end.i.i, !prof !259

if.end.i.i:                                       ; preds = %if.end.i
  %throttled.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 37
  %10 = ptrtoint ptr %throttled.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %throttled.i.i, align 8
  %tobool3.not.i.i = icmp eq i32 %11, 0
  br i1 %tobool3.not.i.i, label %if.end5.i.i, label %account_cfs_rq_runtime.exit

if.end5.i.i:                                      ; preds = %if.end.i.i
  %tg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 30
  %12 = ptrtoint ptr %tg.i.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %tg.i.i, align 4
  %cfs_bandwidth.i.i.i = getelementptr inbounds %struct.task_group, ptr %13, i32 0, i32 16
  tail call void @_raw_spin_lock(ptr noundef %cfs_bandwidth.i.i.i) #20
  %14 = load i32, ptr @sysctl_sched_cfs_bandwidth_slice, align 4
  %conv.i.i.i = zext i32 %14 to i64
  %mul.i.i.i = mul nuw nsw i64 %conv.i.i.i, 1000
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %15 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i.i = icmp eq i32 %15, 0
  br i1 %tobool.not.i.i.i, label %if.end.i.i.i, label %land.rhs.i.i.i

land.rhs.i.i.i:                                   ; preds = %if.end5.i.i
  %dep_map.i.i.i = getelementptr inbounds %struct.task_group, ptr %13, i32 0, i32 16, i32 0, i32 4
  %call.i.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i.i, i32 noundef -1) #20
  %cmp.not.i.i.i = icmp eq i32 %call.i.i.i.i, 0
  br i1 %cmp.not.i.i.i, label %do.end.i.i.i, label %if.end.i.i.i, !prof !260

do.end.i.i.i:                                     ; preds = %land.rhs.i.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 4699, i32 noundef 9, ptr noundef null) #20
  br label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %do.end.i.i.i, %land.rhs.i.i.i, %if.end5.i.i
  %16 = ptrtoint ptr %runtime_remaining.i.i to i32
  call void @__asan_load8_noabort(i32 %16)
  %17 = load i64, ptr %runtime_remaining.i.i, align 8
  %sub.i.i.i = sub i64 %mul.i.i.i, %17
  %quota.i.i.i = getelementptr inbounds %struct.task_group, ptr %13, i32 0, i32 16, i32 2
  %18 = ptrtoint ptr %quota.i.i.i to i32
  call void @__asan_load8_noabort(i32 %18)
  %19 = load i64, ptr %quota.i.i.i, align 8
  %cmp24.i.i.i = icmp eq i64 %19, -1
  br i1 %cmp24.i.i.i, label %assign_cfs_rq_runtime.exit.i, label %if.else.i.i.i

if.else.i.i.i:                                    ; preds = %if.end.i.i.i
  tail call void @start_cfs_bandwidth(ptr noundef %cfs_bandwidth.i.i.i) #20
  %runtime.i.i.i = getelementptr inbounds %struct.task_group, ptr %13, i32 0, i32 16, i32 3
  %20 = ptrtoint ptr %runtime.i.i.i to i32
  call void @__asan_load8_noabort(i32 %20)
  %21 = load i64, ptr %runtime.i.i.i, align 8
  %cmp26.not.i.i.i = icmp eq i64 %21, 0
  br i1 %cmp26.not.i.i.i, label %assign_cfs_rq_runtime.exit.i, label %if.then27.i.i.i

if.then27.i.i.i:                                  ; preds = %if.else.i.i.i
  %22 = tail call i64 @llvm.umin.i64(i64 %21, i64 %sub.i.i.i) #20
  %sub32.i.i.i = sub i64 %21, %22
  %23 = ptrtoint ptr %runtime.i.i.i to i32
  call void @__asan_store8_noabort(i32 %23)
  store i64 %sub32.i.i.i, ptr %runtime.i.i.i, align 8
  %idle.i.i.i = getelementptr inbounds %struct.task_group, ptr %13, i32 0, i32 16, i32 7
  %24 = ptrtoint ptr %idle.i.i.i to i32
  call void @__asan_store1_noabort(i32 %24)
  store i8 0, ptr %idle.i.i.i, align 8
  br label %assign_cfs_rq_runtime.exit.i

assign_cfs_rq_runtime.exit.i:                     ; preds = %if.then27.i.i.i, %if.else.i.i.i, %if.end.i.i.i
  %amount.0.i.i.i = phi i64 [ %22, %if.then27.i.i.i ], [ 0, %if.else.i.i.i ], [ %sub.i.i.i, %if.end.i.i.i ]
  %25 = ptrtoint ptr %runtime_remaining.i.i to i32
  call void @__asan_load8_noabort(i32 %25)
  %26 = load i64, ptr %runtime_remaining.i.i, align 8
  %add.i.i.i = add i64 %26, %amount.0.i.i.i
  store i64 %add.i.i.i, ptr %runtime_remaining.i.i, align 8
  %cmp37.i.i.i = icmp slt i64 %add.i.i.i, 1
  tail call void @_raw_spin_unlock(ptr noundef %cfs_bandwidth.i.i.i) #20
  br i1 %cmp37.i.i.i, label %land.lhs.true.i.i, label %account_cfs_rq_runtime.exit

land.lhs.true.i.i:                                ; preds = %assign_cfs_rq_runtime.exit.i
  %27 = ptrtoint ptr %curr to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %curr, align 8
  %tobool7.not.i.i = icmp eq ptr %28, null
  br i1 %tobool7.not.i.i, label %account_cfs_rq_runtime.exit, label %if.then14.i.i, !prof !260

if.then14.i.i:                                    ; preds = %land.lhs.true.i.i
  %rq.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %29 = ptrtoint ptr %rq.i.i.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %rq.i.i.i, align 4
  tail call void @resched_curr(ptr noundef %30) #20
  br label %account_cfs_rq_runtime.exit

account_cfs_rq_runtime.exit:                      ; preds = %if.then14.i.i, %land.lhs.true.i.i, %assign_cfs_rq_runtime.exit.i, %if.end.i.i, %if.end.i, %lor.lhs.false.i, %if.end7
  %runtime_remaining = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 33
  %31 = ptrtoint ptr %runtime_remaining to i32
  call void @__asan_load8_noabort(i32 %31)
  %32 = load i64, ptr %runtime_remaining, align 8
  %cmp = icmp slt i64 %32, 1
  br i1 %cmp, label %if.then8, label %if.end10

if.then8:                                         ; preds = %account_cfs_rq_runtime.exit
  %call9 = tail call fastcc zeroext i1 @throttle_cfs_rq(ptr noundef %cfs_rq)
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %account_cfs_rq_runtime.exit, %land.rhs.i, %lor.lhs.false, %if.end, %entry
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @__kasan_check_read(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @__list_add_valid(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i64 @sched_slice(ptr nocapture noundef readonly %cfs_rq, ptr noundef readonly %se) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %lw.sroa.7 = alloca i32, align 4
  %nr_running1 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 1
  %0 = ptrtoint ptr %nr_running1 to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %nr_running1, align 8
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 23), i32 1), ptr blockaddress(@sched_slice, %if.end)) #20
          to label %if.then [label %if.end], !srcloc !261

if.then:                                          ; preds = %entry
  %rq.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %2 = ptrtoint ptr %rq.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %rq.i, align 4
  %h_nr_running = getelementptr inbounds %struct.rq, ptr %3, i32 0, i32 14, i32 2
  %4 = ptrtoint ptr %h_nr_running to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %h_nr_running, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %nr_running.0 = phi i32 [ %5, %if.then ], [ %1, %entry ]
  %on_rq = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 3
  %6 = ptrtoint ptr %on_rq to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %on_rq, align 4
  %tobool.not = icmp eq i32 %7, 0
  %lnot.ext = zext i1 %tobool.not to i32
  %add = add i32 %nr_running.0, %lnot.ext
  %8 = load i32, ptr @sched_nr_latency, align 4
  %cmp.i = icmp ult i32 %8, %add
  br i1 %cmp.i, label %if.then.i, label %if.else.i, !prof !260

if.then.i:                                        ; preds = %if.end
  %9 = load i32, ptr @sysctl_sched_min_granularity, align 4
  %mul.i = mul i32 %9, %add
  br label %__sched_period.exit

if.else.i:                                        ; preds = %if.end
  %10 = load i32, ptr @sysctl_sched_latency, align 4
  br label %__sched_period.exit

__sched_period.exit:                              ; preds = %if.else.i, %if.then.i
  %retval.0.in.i = phi i32 [ %mul.i, %if.then.i ], [ %10, %if.else.i ]
  %retval.0.i = zext i32 %retval.0.in.i to i64
  %tobool4.not61 = icmp eq ptr %se, null
  br i1 %tobool4.not61, label %for.end, label %for.body

for.body:                                         ; preds = %__calc_delta.exit, %__sched_period.exit
  %se.addr.063 = phi ptr [ %33, %__calc_delta.exit ], [ %se, %__sched_period.exit ]
  %slice.062 = phi i64 [ %ret.0.i.i, %__calc_delta.exit ], [ %retval.0.i, %__sched_period.exit ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %lw.sroa.7)
  %11 = ptrtoint ptr %lw.sroa.7 to i32
  call void @__asan_store4_noabort(i32 %11)
  store i32 -1, ptr %lw.sroa.7, align 4
  %cfs_rq.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.063, i32 0, i32 11
  %12 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %cfs_rq.i, align 16
  %.sroa.gep = getelementptr inbounds %struct.load_weight, ptr %13, i32 0, i32 1
  %on_rq7 = getelementptr inbounds %struct.sched_entity, ptr %se.addr.063, i32 0, i32 3
  %14 = ptrtoint ptr %on_rq7 to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %on_rq7, align 4
  %tobool8.not = icmp eq i32 %15, 0
  br i1 %tobool8.not, label %if.end19.thread, label %if.end19, !prof !260

if.end19.thread:                                  ; preds = %for.body
  %16 = ptrtoint ptr %13 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %13, align 128
  %18 = ptrtoint ptr %se.addr.063 to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %se.addr.063, align 128
  %add.i = add i32 %19, %17
  %20 = ptrtoint ptr %lw.sroa.7 to i32
  call void @__asan_store4_noabort(i32 %20)
  store i32 0, ptr %lw.sroa.7, align 4
  br label %if.end.i.i

if.end19:                                         ; preds = %for.body
  %21 = ptrtoint ptr %.sroa.gep to i32
  call void @__asan_load4_noabort(i32 %21)
  %.pr = load i32, ptr %.sroa.gep, align 4
  %22 = ptrtoint ptr %se.addr.063 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load i32, ptr %se.addr.063, align 128
  %tobool.not.i33.i = icmp eq i32 %.pr, 0
  br i1 %tobool.not.i33.i, label %if.end.i.ithread-pre-split, label %__update_inv_weight.exit.i, !prof !260

if.end.i.ithread-pre-split:                       ; preds = %if.end19
  %24 = ptrtoint ptr %13 to i32
  call void @__asan_load4_noabort(i32 %24)
  %.pr59 = load i32, ptr %13, align 4
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.end.i.ithread-pre-split, %if.end19.thread
  %25 = phi i32 [ %.pr59, %if.end.i.ithread-pre-split ], [ %add.i, %if.end19.thread ]
  %26 = phi i32 [ %23, %if.end.i.ithread-pre-split ], [ %19, %if.end19.thread ]
  %load.0.sroa.phi57 = phi ptr [ %.sroa.gep, %if.end.i.ithread-pre-split ], [ %lw.sroa.7, %if.end19.thread ]
  %tobool3.not.i.i = icmp eq i32 %25, 0
  br i1 %tobool3.not.i.i, label %if.end15.i.i, label %if.else.i.i, !prof !260

if.else.i.i:                                      ; preds = %if.end.i.i
  %div.i.i = udiv i32 -1, %25
  br label %if.end15.i.i

if.end15.i.i:                                     ; preds = %if.else.i.i, %if.end.i.i
  %storemerge.i.i = phi i32 [ %div.i.i, %if.else.i.i ], [ -1, %if.end.i.i ]
  %27 = ptrtoint ptr %load.0.sroa.phi57 to i32
  call void @__asan_store4_noabort(i32 %27)
  store i32 %storemerge.i.i, ptr %load.0.sroa.phi57, align 4
  br label %__update_inv_weight.exit.i

__update_inv_weight.exit.i:                       ; preds = %if.end15.i.i, %if.end19
  %28 = phi i32 [ %26, %if.end15.i.i ], [ %23, %if.end19 ]
  %load.0.sroa.phi58 = phi ptr [ %load.0.sroa.phi57, %if.end15.i.i ], [ %.sroa.gep, %if.end19 ]
  %29 = ptrtoint ptr %load.0.sroa.phi58 to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %load.0.sroa.phi58, align 4
  %conv.i.i = zext i32 %28 to i64
  %conv1.i.i = zext i32 %30 to i64
  %mul.i.i = mul nuw i64 %conv1.i.i, %conv.i.i
  %shr7.i = lshr i64 %mul.i.i, 32
  %conv8.i = trunc i64 %shr7.i to i32
  %tobool9.not.i = icmp eq i32 %conv8.i, 0
  %extract.t32.i = trunc i64 %mul.i.i to i32
  br i1 %tobool9.not.i, label %if.end15.i, label %if.then10.i

if.then10.i:                                      ; preds = %__update_inv_weight.exit.i
  %31 = tail call i32 @llvm.ctlz.i32(i32 %conv8.i, i1 true) #20, !range !258
  %sub.i.i = sub nuw nsw i32 32, %31
  %sh_prom13.i = zext i32 %sub.i.i to i64
  %shr14.i = lshr i64 %mul.i.i, %sh_prom13.i
  %extract.t.i = trunc i64 %shr14.i to i32
  br label %if.end15.i

if.end15.i:                                       ; preds = %if.then10.i, %__update_inv_weight.exit.i
  %fact.1.off0.i = phi i32 [ %extract.t.i, %if.then10.i ], [ %extract.t32.i, %__update_inv_weight.exit.i ]
  %shift.1.i = phi i32 [ %31, %if.then10.i ], [ 32, %__update_inv_weight.exit.i ]
  %conv.i.i.i = and i64 %slice.062, 4294967295
  %conv1.i.i.i = zext i32 %fact.1.off0.i to i64
  %mul.i.i.i = mul nuw i64 %conv.i.i.i, %conv1.i.i.i
  %sh_prom.i.i = zext i32 %shift.1.i to i64
  %shr2.i.i = lshr i64 %mul.i.i.i, %sh_prom.i.i
  %tobool.not.i34.i = icmp ult i64 %slice.062, 4294967296
  br i1 %tobool.not.i34.i, label %__calc_delta.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.end15.i
  %shr.i.i = lshr i64 %slice.062, 32
  %mul.i12.i.i = mul nuw i64 %shr.i.i, %conv1.i.i.i
  %sub.i35.i = sub nuw nsw i32 32, %shift.1.i
  %sh_prom4.i.i = zext i32 %sub.i35.i to i64
  %shl.i.i = shl i64 %mul.i12.i.i, %sh_prom4.i.i
  %add.i.i = add i64 %shl.i.i, %shr2.i.i
  br label %__calc_delta.exit

__calc_delta.exit:                                ; preds = %if.then.i.i, %if.end15.i
  %ret.0.i.i = phi i64 [ %add.i.i, %if.then.i.i ], [ %shr2.i.i, %if.end15.i ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %lw.sroa.7)
  %parent = getelementptr inbounds %struct.sched_entity, ptr %se.addr.063, i32 0, i32 10
  %32 = ptrtoint ptr %parent to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load ptr, ptr %parent, align 4
  %tobool4.not = icmp eq ptr %33, null
  br i1 %tobool4.not, label %for.end, label %for.body

for.end:                                          ; preds = %__calc_delta.exit, %__sched_period.exit
  %slice.0.lcssa = phi i64 [ %retval.0.i, %__sched_period.exit ], [ %ret.0.i.i, %__calc_delta.exit ]
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 24), i32 1), ptr blockaddress(@sched_slice, %if.end31)) #20
          to label %if.then24 [label %if.end31], !srcloc !261

if.then24:                                        ; preds = %for.end
  %my_q.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 12
  %34 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i = icmp eq ptr %35, null
  br i1 %tobool.not.i, label %se_is_idle.exit, label %if.end.i

if.end.i:                                         ; preds = %if.then24
  %idle.i.i = getelementptr inbounds %struct.cfs_rq, ptr %35, i32 0, i32 31
  %36 = ptrtoint ptr %idle.i.i to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load i32, ptr %idle.i.i, align 16
  %cmp.i.i = icmp sgt i32 %37, 0
  br i1 %cmp.i.i, label %land.lhs.true, label %if.else

se_is_idle.exit:                                  ; preds = %if.then24
  %policy.i.i = getelementptr i8, ptr %se, i32 900
  %38 = ptrtoint ptr %policy.i.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load i32, ptr %policy.i.i, align 4
  %cmp.i.i.i = icmp eq i32 %39, 5
  br i1 %cmp.i.i.i, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %se_is_idle.exit, %if.end.i
  %40 = ptrtoint ptr %nr_running1 to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %nr_running1, align 8
  %tobool.not.i50 = icmp eq i32 %41, 0
  br i1 %tobool.not.i50, label %if.end29, label %sched_idle_cfs_rq.exit

sched_idle_cfs_rq.exit:                           ; preds = %land.lhs.true
  %idle_nr_running.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 3
  %42 = ptrtoint ptr %idle_nr_running.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load i32, ptr %idle_nr_running.i, align 16
  %cmp.i51 = icmp eq i32 %41, %43
  br i1 %cmp.i51, label %if.else, label %if.end29

if.else:                                          ; preds = %sched_idle_cfs_rq.exit, %se_is_idle.exit, %if.end.i
  br label %if.end29

if.end29:                                         ; preds = %if.else, %sched_idle_cfs_rq.exit, %land.lhs.true
  %min_gran.0.in = phi ptr [ @sysctl_sched_min_granularity, %if.else ], [ @sysctl_sched_idle_min_granularity, %sched_idle_cfs_rq.exit ], [ @sysctl_sched_idle_min_granularity, %land.lhs.true ]
  %44 = ptrtoint ptr %min_gran.0.in to i32
  call void @__asan_load4_noabort(i32 %44)
  %min_gran.0 = load i32, ptr %min_gran.0.in, align 4
  %conv = zext i32 %min_gran.0 to i64
  %45 = tail call i64 @llvm.umax.i64(i64 %slice.0.lcssa, i64 %conv)
  br label %if.end31

if.end31:                                         ; preds = %if.end29, %for.end
  %slice.1 = phi i64 [ %45, %if.end29 ], [ %slice.0.lcssa, %for.end ]
  ret i64 %slice.1
}

; Function Attrs: argmemonly mustprogress nofree nosync nounwind null_pointer_is_valid sanitize_address sspstrong willreturn uwtable(sync)
define internal fastcc i64 @__calc_delta(i64 noundef %delta_exec, i32 noundef %weight, ptr nocapture noundef %lw) unnamed_addr #5 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %inv_weight.i = getelementptr inbounds %struct.load_weight, ptr %lw, i32 0, i32 1
  %0 = ptrtoint ptr %inv_weight.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %inv_weight.i, align 4
  %tobool.not.i33 = icmp eq i32 %1, 0
  br i1 %tobool.not.i33, label %if.end.i, label %__update_inv_weight.exit, !prof !260

if.end.i:                                         ; preds = %entry
  %2 = ptrtoint ptr %lw to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %lw, align 4
  %tobool3.not.i = icmp eq i32 %3, 0
  br i1 %tobool3.not.i, label %if.end15.i, label %if.else.i, !prof !260

if.else.i:                                        ; preds = %if.end.i
  %div.i = udiv i32 -1, %3
  br label %if.end15.i

if.end15.i:                                       ; preds = %if.else.i, %if.end.i
  %storemerge.i = phi i32 [ %div.i, %if.else.i ], [ -1, %if.end.i ]
  %4 = ptrtoint ptr %inv_weight.i to i32
  call void @__asan_store4_noabort(i32 %4)
  store i32 %storemerge.i, ptr %inv_weight.i, align 4
  br label %__update_inv_weight.exit

__update_inv_weight.exit:                         ; preds = %if.end15.i, %entry
  %5 = ptrtoint ptr %inv_weight.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %inv_weight.i, align 4
  %conv.i = zext i32 %weight to i64
  %conv1.i = zext i32 %6 to i64
  %mul.i = mul nuw i64 %conv1.i, %conv.i
  %shr7 = lshr i64 %mul.i, 32
  %conv8 = trunc i64 %shr7 to i32
  %tobool9.not = icmp eq i32 %conv8, 0
  %extract.t32 = trunc i64 %mul.i to i32
  br i1 %tobool9.not, label %if.end15, label %if.then10

if.then10:                                        ; preds = %__update_inv_weight.exit
  %7 = tail call i32 @llvm.ctlz.i32(i32 %conv8, i1 true) #20, !range !258
  %sub.i = sub nuw nsw i32 32, %7
  %sh_prom13 = zext i32 %sub.i to i64
  %shr14 = lshr i64 %mul.i, %sh_prom13
  %extract.t = trunc i64 %shr14 to i32
  br label %if.end15

if.end15:                                         ; preds = %if.then10, %__update_inv_weight.exit
  %fact.1.off0 = phi i32 [ %extract.t, %if.then10 ], [ %extract.t32, %__update_inv_weight.exit ]
  %shift.1 = phi i32 [ %7, %if.then10 ], [ 32, %__update_inv_weight.exit ]
  %conv.i.i = and i64 %delta_exec, 4294967295
  %conv1.i.i = zext i32 %fact.1.off0 to i64
  %mul.i.i = mul nuw i64 %conv.i.i, %conv1.i.i
  %sh_prom.i = zext i32 %shift.1 to i64
  %shr2.i = lshr i64 %mul.i.i, %sh_prom.i
  %tobool.not.i34 = icmp ult i64 %delta_exec, 4294967296
  br i1 %tobool.not.i34, label %mul_u64_u32_shr.exit, label %if.then.i

if.then.i:                                        ; preds = %if.end15
  %shr.i = lshr i64 %delta_exec, 32
  %mul.i12.i = mul nuw i64 %shr.i, %conv1.i.i
  %sub.i35 = sub nuw nsw i32 32, %shift.1
  %sh_prom4.i = zext i32 %sub.i35 to i64
  %shl.i = shl i64 %mul.i12.i, %sh_prom4.i
  %add.i = add i64 %shl.i, %shr2.i
  br label %mul_u64_u32_shr.exit

mul_u64_u32_shr.exit:                             ; preds = %if.then.i, %if.end15
  %ret.0.i = phi i64 [ %add.i, %if.then.i ], [ %shr2.i, %if.end15 ]
  ret i64 %ret.0.i
}

; Function Attrs: cold null_pointer_is_valid
declare dso_local i32 @_printk_deferred(ptr noundef, ...) local_unnamed_addr #14

; Function Attrs: null_pointer_is_valid
declare dso_local void @__update_stats_wait_start(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @__update_stats_enqueue_sleeper(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @rb_insert_color(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc zeroext i1 @throttle_cfs_rq(ptr noundef %cfs_rq) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %rq.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %0 = ptrtoint ptr %rq.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %rq.i, align 4
  %tg = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 30
  %2 = ptrtoint ptr %tg to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %tg, align 4
  %cfs_bandwidth.i = getelementptr inbounds %struct.task_group, ptr %3, i32 0, i32 16
  tail call void @_raw_spin_lock(ptr noundef %cfs_bandwidth.i) #20
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %4 = load i32, ptr @debug_locks, align 4
  %tobool.not.i102 = icmp eq i32 %4, 0
  br i1 %tobool.not.i102, label %if.end.i, label %land.rhs.i

land.rhs.i:                                       ; preds = %entry
  %dep_map.i = getelementptr inbounds %struct.task_group, ptr %3, i32 0, i32 16, i32 0, i32 4
  %call.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i, i32 noundef -1) #20
  %cmp.not.i = icmp eq i32 %call.i.i, 0
  br i1 %cmp.not.i, label %do.end.i, label %if.end.i, !prof !260

do.end.i:                                         ; preds = %land.rhs.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 4699, i32 noundef 9, ptr noundef null) #20
  br label %if.end.i

if.end.i:                                         ; preds = %do.end.i, %land.rhs.i, %entry
  %runtime_remaining.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 33
  %5 = ptrtoint ptr %runtime_remaining.i to i32
  call void @__asan_load8_noabort(i32 %5)
  %6 = load i64, ptr %runtime_remaining.i, align 8
  %sub.i = sub i64 1, %6
  %quota.i = getelementptr inbounds %struct.task_group, ptr %3, i32 0, i32 16, i32 2
  %7 = ptrtoint ptr %quota.i to i32
  call void @__asan_load8_noabort(i32 %7)
  %8 = load i64, ptr %quota.i, align 8
  %cmp24.i = icmp eq i64 %8, -1
  br i1 %cmp24.i, label %__assign_cfs_rq_runtime.exit, label %if.else.i

if.else.i:                                        ; preds = %if.end.i
  tail call void @start_cfs_bandwidth(ptr noundef %cfs_bandwidth.i) #20
  %runtime.i = getelementptr inbounds %struct.task_group, ptr %3, i32 0, i32 16, i32 3
  %9 = ptrtoint ptr %runtime.i to i32
  call void @__asan_load8_noabort(i32 %9)
  %10 = load i64, ptr %runtime.i, align 8
  %cmp26.not.i = icmp eq i64 %10, 0
  br i1 %cmp26.not.i, label %__assign_cfs_rq_runtime.exit, label %if.then27.i

if.then27.i:                                      ; preds = %if.else.i
  %11 = tail call i64 @llvm.umin.i64(i64 %10, i64 %sub.i) #20
  %sub32.i = sub i64 %10, %11
  %12 = ptrtoint ptr %runtime.i to i32
  call void @__asan_store8_noabort(i32 %12)
  store i64 %sub32.i, ptr %runtime.i, align 8
  %idle.i = getelementptr inbounds %struct.task_group, ptr %3, i32 0, i32 16, i32 7
  %13 = ptrtoint ptr %idle.i to i32
  call void @__asan_store1_noabort(i32 %13)
  store i8 0, ptr %idle.i, align 8
  br label %__assign_cfs_rq_runtime.exit

__assign_cfs_rq_runtime.exit:                     ; preds = %if.then27.i, %if.else.i, %if.end.i
  %amount.0.i = phi i64 [ %11, %if.then27.i ], [ 0, %if.else.i ], [ %sub.i, %if.end.i ]
  %14 = ptrtoint ptr %runtime_remaining.i to i32
  call void @__asan_load8_noabort(i32 %14)
  %15 = load i64, ptr %runtime_remaining.i, align 8
  %add.i = add i64 %15, %amount.0.i
  store i64 %add.i, ptr %runtime_remaining.i, align 8
  %cmp37.i = icmp slt i64 %add.i, 1
  br i1 %cmp37.i, label %if.else, label %if.then5.critedge

if.else:                                          ; preds = %__assign_cfs_rq_runtime.exit
  %throttled_list = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 39
  %throttled_cfs_rq = getelementptr inbounds %struct.task_group, ptr %3, i32 0, i32 16, i32 12
  %prev.i = getelementptr inbounds %struct.task_group, ptr %3, i32 0, i32 16, i32 12, i32 1
  %16 = ptrtoint ptr %prev.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %prev.i, align 4
  %call.i.i103 = tail call zeroext i1 @__list_add_valid(ptr noundef %throttled_list, ptr noundef %17, ptr noundef %throttled_cfs_rq) #20
  br i1 %call.i.i103, label %if.end.i.i, label %list_add_tail_rcu.exit

if.end.i.i:                                       ; preds = %if.else
  %18 = ptrtoint ptr %throttled_list to i32
  call void @__asan_store4_noabort(i32 %18)
  store ptr %throttled_cfs_rq, ptr %throttled_list, align 4
  %prev2.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 39, i32 1
  %19 = ptrtoint ptr %prev2.i.i to i32
  call void @__asan_store4_noabort(i32 %19)
  store ptr %17, ptr %prev2.i.i, align 4
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !265
  %20 = ptrtoint ptr %17 to i32
  call void @__asan_store4_noabort(i32 %20)
  store volatile ptr %throttled_list, ptr %17, align 4
  %21 = ptrtoint ptr %prev.i to i32
  call void @__asan_store4_noabort(i32 %21)
  store ptr %throttled_list, ptr %prev.i, align 4
  br label %list_add_tail_rcu.exit

list_add_tail_rcu.exit:                           ; preds = %if.end.i.i, %if.else
  tail call void @_raw_spin_unlock(ptr noundef %cfs_bandwidth.i) #20
  %22 = ptrtoint ptr %tg to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %tg, align 4
  %se8 = getelementptr inbounds %struct.task_group, ptr %23, i32 0, i32 1
  %24 = ptrtoint ptr %se8 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %se8, align 8
  %26 = ptrtoint ptr %rq.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load ptr, ptr %rq.i, align 4
  %cpu.i = getelementptr inbounds %struct.rq, ptr %27, i32 0, i32 46
  %28 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %cpu.i, align 4
  %arrayidx = getelementptr ptr, ptr %25, i32 %29
  %30 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %arrayidx, align 4
  %32 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i = and i32 %32, -16384
  %33 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %33, i32 0, i32 1
  %34 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %35, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !268
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #20
  %call.i = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %list_add_tail_rcu.exit
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 696, ptr noundef nonnull @.str.28) #20
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %list_add_tail_rcu.exit
  %36 = ptrtoint ptr %tg to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load ptr, ptr %tg, align 4
  %call12 = tail call i32 @walk_tg_tree_from(ptr noundef %37, ptr noundef nonnull @tg_throttle_down, ptr noundef nonnull @tg_nop, ptr noundef %1) #20
  %call.i105 = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i105, label %rcu_read_unlock.exit, label %land.lhs.true.i108

land.lhs.true.i108:                               ; preds = %rcu_read_lock.exit
  %call1.i106 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i107 = icmp eq i32 %call1.i106, 0
  br i1 %tobool.not.i107, label %rcu_read_unlock.exit, label %land.lhs.true2.i110

land.lhs.true2.i110:                              ; preds = %land.lhs.true.i108
  %.b4.i109 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i109, label %rcu_read_unlock.exit, label %if.then.i111

if.then.i111:                                     ; preds = %land.lhs.true2.i110
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i111, %land.lhs.true2.i110, %land.lhs.true.i108, %rcu_read_lock.exit
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %38 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i112 = and i32 %38, -16384
  %39 = inttoptr i32 %and.i.i.i.i.i112 to ptr
  %preempt_count.i.i.i.i113 = getelementptr inbounds %struct.thread_info, ptr %39, i32 0, i32 1
  %40 = ptrtoint ptr %preempt_count.i.i.i.i113 to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load volatile i32, ptr %preempt_count.i.i.i.i113, align 4
  %sub.i.i.i = add i32 %41, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i113, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  %h_nr_running = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 2
  %42 = ptrtoint ptr %h_nr_running to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load i32, ptr %h_nr_running, align 4
  %tobool13.not146 = icmp eq ptr %31, null
  br i1 %tobool13.not146, label %for.end55, label %for.body.preheader

for.body.preheader:                               ; preds = %rcu_read_unlock.exit
  %idle_h_nr_running = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 4
  %44 = ptrtoint ptr %idle_h_nr_running to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load i32, ptr %idle_h_nr_running, align 4
  br label %for.body

if.then5.critedge:                                ; preds = %__assign_cfs_rq_runtime.exit
  tail call void @_raw_spin_unlock(ptr noundef %cfs_bandwidth.i) #20
  br label %cleanup57

for.body:                                         ; preds = %for.inc, %for.body.preheader
  %idle_task_delta.0148 = phi i32 [ %idle_task_delta.1, %for.inc ], [ %45, %for.body.preheader ]
  %se.0147 = phi ptr [ %63, %for.inc ], [ %31, %for.body.preheader ]
  %cfs_rq.i = getelementptr inbounds %struct.sched_entity, ptr %se.0147, i32 0, i32 11
  %46 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load ptr, ptr %cfs_rq.i, align 16
  %on_rq = getelementptr inbounds %struct.sched_entity, ptr %se.0147, i32 0, i32 3
  %48 = ptrtoint ptr %on_rq to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load i32, ptr %on_rq, align 4
  %tobool15.not = icmp eq i32 %49, 0
  br i1 %tobool15.not, label %done, label %if.end17

if.end17:                                         ; preds = %for.body
  tail call fastcc void @dequeue_entity(ptr noundef %47, ptr noundef nonnull %se.0147, i32 noundef 1)
  %my_q.i = getelementptr inbounds %struct.sched_entity, ptr %se.0147, i32 0, i32 12
  %50 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load ptr, ptr %my_q.i, align 4
  %idle.i115 = getelementptr inbounds %struct.cfs_rq, ptr %51, i32 0, i32 31
  %52 = ptrtoint ptr %idle.i115 to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load i32, ptr %idle.i115, align 16
  %cmp.i = icmp slt i32 %53, 1
  br i1 %cmp.i, label %if.end23, label %if.then21

if.then21:                                        ; preds = %if.end17
  %54 = ptrtoint ptr %h_nr_running to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load i32, ptr %h_nr_running, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.end17
  %idle_task_delta.1 = phi i32 [ %55, %if.then21 ], [ %idle_task_delta.0148, %if.end17 ]
  %h_nr_running24 = getelementptr inbounds %struct.cfs_rq, ptr %47, i32 0, i32 2
  %56 = ptrtoint ptr %h_nr_running24 to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load i32, ptr %h_nr_running24, align 4
  %sub = sub i32 %57, %43
  store i32 %sub, ptr %h_nr_running24, align 4
  %idle_h_nr_running25 = getelementptr inbounds %struct.cfs_rq, ptr %47, i32 0, i32 4
  %58 = ptrtoint ptr %idle_h_nr_running25 to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load i32, ptr %idle_h_nr_running25, align 4
  %sub26 = sub i32 %59, %idle_task_delta.1
  store i32 %sub26, ptr %idle_h_nr_running25, align 4
  %60 = ptrtoint ptr %47 to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load i32, ptr %47, align 128
  %tobool27.not = icmp eq i32 %61, 0
  %parent = getelementptr inbounds %struct.sched_entity, ptr %se.0147, i32 0, i32 10
  %62 = ptrtoint ptr %parent to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load ptr, ptr %parent, align 4
  %tobool13.not = icmp eq ptr %63, null
  br i1 %tobool27.not, label %for.inc, label %for.end

for.inc:                                          ; preds = %if.end23
  br i1 %tobool13.not, label %for.end55, label %for.body

for.end:                                          ; preds = %if.end23
  br i1 %tobool13.not, label %for.end55, label %for.body33

for.body33:                                       ; preds = %for.inc53, %for.end
  %idle_task_delta.4152 = phi i32 [ %idle_task_delta.5, %for.inc53 ], [ %idle_task_delta.1, %for.end ]
  %se.3150 = phi ptr [ %84, %for.inc53 ], [ %63, %for.end ]
  %cfs_rq.i117 = getelementptr inbounds %struct.sched_entity, ptr %se.3150, i32 0, i32 11
  %64 = ptrtoint ptr %cfs_rq.i117 to i32
  call void @__asan_load4_noabort(i32 %64)
  %65 = load ptr, ptr %cfs_rq.i117, align 16
  %on_rq36 = getelementptr inbounds %struct.sched_entity, ptr %se.3150, i32 0, i32 3
  %66 = ptrtoint ptr %on_rq36 to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load i32, ptr %on_rq36, align 4
  %tobool37.not = icmp eq i32 %67, 0
  br i1 %tobool37.not, label %done, label %if.end39

if.end39:                                         ; preds = %for.body33
  tail call fastcc void @update_load_avg(ptr noundef %65, ptr noundef nonnull %se.3150, i32 noundef 0)
  %my_q.i118 = getelementptr inbounds %struct.sched_entity, ptr %se.3150, i32 0, i32 12
  %68 = ptrtoint ptr %my_q.i118 to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load ptr, ptr %my_q.i118, align 4
  %tobool.not.i119 = icmp eq ptr %69, null
  br i1 %tobool.not.i119, label %se_update_runnable.exit, label %if.then.i120

if.then.i120:                                     ; preds = %if.end39
  %h_nr_running.i = getelementptr inbounds %struct.cfs_rq, ptr %69, i32 0, i32 2
  %70 = ptrtoint ptr %h_nr_running.i to i32
  call void @__asan_load4_noabort(i32 %70)
  %71 = load i32, ptr %h_nr_running.i, align 4
  %runnable_weight.i = getelementptr inbounds %struct.sched_entity, ptr %se.3150, i32 0, i32 13
  %72 = ptrtoint ptr %runnable_weight.i to i32
  call void @__asan_store4_noabort(i32 %72)
  store i32 %71, ptr %runnable_weight.i, align 8
  br label %se_update_runnable.exit

se_update_runnable.exit:                          ; preds = %if.then.i120, %if.end39
  %73 = ptrtoint ptr %my_q.i118 to i32
  call void @__asan_load4_noabort(i32 %73)
  %74 = load ptr, ptr %my_q.i118, align 4
  %idle.i123 = getelementptr inbounds %struct.cfs_rq, ptr %74, i32 0, i32 31
  %75 = ptrtoint ptr %idle.i123 to i32
  call void @__asan_load4_noabort(i32 %75)
  %76 = load i32, ptr %idle.i123, align 16
  %cmp.i124 = icmp slt i32 %76, 1
  br i1 %cmp.i124, label %for.inc53, label %if.then43

if.then43:                                        ; preds = %se_update_runnable.exit
  %77 = ptrtoint ptr %h_nr_running to i32
  call void @__asan_load4_noabort(i32 %77)
  %78 = load i32, ptr %h_nr_running, align 4
  br label %for.inc53

for.inc53:                                        ; preds = %if.then43, %se_update_runnable.exit
  %idle_task_delta.5 = phi i32 [ %78, %if.then43 ], [ %idle_task_delta.4152, %se_update_runnable.exit ]
  %h_nr_running46 = getelementptr inbounds %struct.cfs_rq, ptr %65, i32 0, i32 2
  %79 = ptrtoint ptr %h_nr_running46 to i32
  call void @__asan_load4_noabort(i32 %79)
  %80 = load i32, ptr %h_nr_running46, align 4
  %sub47 = sub i32 %80, %43
  store i32 %sub47, ptr %h_nr_running46, align 4
  %idle_h_nr_running48 = getelementptr inbounds %struct.cfs_rq, ptr %65, i32 0, i32 4
  %81 = ptrtoint ptr %idle_h_nr_running48 to i32
  call void @__asan_load4_noabort(i32 %81)
  %82 = load i32, ptr %idle_h_nr_running48, align 4
  %sub49 = sub i32 %82, %idle_task_delta.5
  store i32 %sub49, ptr %idle_h_nr_running48, align 4
  %parent54 = getelementptr inbounds %struct.sched_entity, ptr %se.3150, i32 0, i32 10
  %83 = ptrtoint ptr %parent54 to i32
  call void @__asan_load4_noabort(i32 %83)
  %84 = load ptr, ptr %parent54, align 4
  %tobool32.not = icmp eq ptr %84, null
  br i1 %tobool32.not, label %for.end55, label %for.body33

for.end55:                                        ; preds = %for.inc53, %for.end, %for.inc, %rcu_read_unlock.exit
  %nr_running.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 1
  %85 = ptrtoint ptr %nr_running.i to i32
  call void @__asan_load4_noabort(i32 %85)
  %86 = load i32, ptr %nr_running.i, align 4
  %sub.i126 = sub i32 %86, %43
  store i32 %sub.i126, ptr %nr_running.i, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_update_nr_running_tp, i32 0, i32 1), ptr blockaddress(@throttle_cfs_rq, %if.then.i127)) #20
          to label %done [label %if.then.i127], !srcloc !261

if.then.i127:                                     ; preds = %for.end55
  %sub1.i = sub i32 0, %43
  tail call void @call_trace_sched_update_nr_running(ptr noundef %1, i32 noundef %sub1.i) #20
  br label %done

done:                                             ; preds = %if.then.i127, %for.end55, %for.body33, %for.body
  %throttled = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 37
  %87 = ptrtoint ptr %throttled to i32
  call void @__asan_store4_noabort(i32 %87)
  store i32 1, ptr %throttled, align 8
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %88 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i = icmp eq i32 %88, 0
  br i1 %tobool.not.i.i, label %lockdep_assert_rq_held.exit.i, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %done
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 81
  %89 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %89)
  %90 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %90, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.rhs.i.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 79
  %91 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %91)
  %92 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %land.rhs.i.i
  %retval.0.i.i.i = phi ptr [ %92, %if.then.i.i.i ], [ %1, %land.rhs.i.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i, i32 noundef -1) #20
  %cmp.not.i.i = icmp eq i32 %call.i.i.i, 0
  br i1 %cmp.not.i.i, label %do.end.i.i, label %lockdep_assert_rq_held.exit.i, !prof !260

do.end.i.i:                                       ; preds = %__rq_lockp.exit.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i

lockdep_assert_rq_held.exit.i:                    ; preds = %do.end.i.i, %__rq_lockp.exit.i.i, %done
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 25
  %93 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %93)
  %94 = load i32, ptr %clock_update_flags.i.i, align 4
  %cmp.i.i = icmp ult i32 %94, 2
  br i1 %cmp.i.i, label %land.rhs.i3.i, label %rq_clock.exit

land.rhs.i3.i:                                    ; preds = %lockdep_assert_rq_held.exit.i
  %.b37.i.i = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i, label %rq_clock.exit, label %if.then.i.i, !prof !259

if.then.i.i:                                      ; preds = %land.rhs.i3.i
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %rq_clock.exit

rq_clock.exit:                                    ; preds = %if.then.i.i, %land.rhs.i3.i, %lockdep_assert_rq_held.exit.i
  %clock.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 26
  %95 = ptrtoint ptr %clock.i to i32
  call void @__asan_load8_noabort(i32 %95)
  %96 = load i64, ptr %clock.i, align 32
  %throttled_clock = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 34
  %97 = ptrtoint ptr %throttled_clock to i32
  call void @__asan_store8_noabort(i32 %97)
  store i64 %96, ptr %throttled_clock, align 64
  br label %cleanup57

cleanup57:                                        ; preds = %rq_clock.exit, %if.then5.critedge
  ret i1 %cmp37.i
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @tg_throttle_down(ptr nocapture noundef readonly %tg, ptr noundef %data) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %cfs_rq1 = getelementptr inbounds %struct.task_group, ptr %tg, i32 0, i32 2
  %0 = ptrtoint ptr %cfs_rq1 to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %cfs_rq1, align 4
  %cpu.i = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 46
  %2 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu.i, align 4
  %arrayidx = getelementptr ptr, ptr %1, i32 %3
  %4 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %arrayidx, align 4
  %throttle_count = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 38
  %6 = ptrtoint ptr %throttle_count to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %throttle_count, align 4
  %tobool.not = icmp eq i32 %7, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %8 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i = icmp eq i32 %8, 0
  br i1 %tobool.not.i.i, label %lockdep_assert_rq_held.exit.i, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %if.then
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 81
  %9 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %10, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.rhs.i.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 79
  %11 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %land.rhs.i.i
  %retval.0.i.i.i = phi ptr [ %12, %if.then.i.i.i ], [ %data, %land.rhs.i.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i, i32 noundef -1) #20
  %cmp.not.i.i = icmp eq i32 %call.i.i.i, 0
  br i1 %cmp.not.i.i, label %do.end.i.i, label %lockdep_assert_rq_held.exit.i, !prof !260

do.end.i.i:                                       ; preds = %__rq_lockp.exit.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i

lockdep_assert_rq_held.exit.i:                    ; preds = %do.end.i.i, %__rq_lockp.exit.i.i, %if.then
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 25
  %13 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %clock_update_flags.i.i, align 4
  %cmp.i.i = icmp ult i32 %14, 2
  br i1 %cmp.i.i, label %land.rhs.i3.i, label %rq_clock_task.exit

land.rhs.i3.i:                                    ; preds = %lockdep_assert_rq_held.exit.i
  %.b37.i.i = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i, label %rq_clock_task.exit, label %if.then.i.i, !prof !259

if.then.i.i:                                      ; preds = %land.rhs.i3.i
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %rq_clock_task.exit

rq_clock_task.exit:                               ; preds = %if.then.i.i, %land.rhs.i3.i, %lockdep_assert_rq_held.exit.i
  %clock_task.i = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 28
  %15 = ptrtoint ptr %clock_task.i to i32
  call void @__asan_load8_noabort(i32 %15)
  %16 = load i64, ptr %clock_task.i, align 128
  %throttled_clock_task = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 35
  %17 = ptrtoint ptr %throttled_clock_task to i32
  call void @__asan_store8_noabort(i32 %17)
  store i64 %16, ptr %throttled_clock_task, align 8
  %on_list.i = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 28
  %18 = ptrtoint ptr %on_list.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %on_list.i, align 32
  %tobool.not.i = icmp eq i32 %19, 0
  br i1 %tobool.not.i, label %if.end, label %if.then.i

if.then.i:                                        ; preds = %rq_clock_task.exit
  %rq.i.i = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 27
  %20 = ptrtoint ptr %rq.i.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %rq.i.i, align 4
  %tmp_alone_branch.i = getelementptr inbounds %struct.rq, ptr %21, i32 0, i32 18
  %22 = ptrtoint ptr %tmp_alone_branch.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %tmp_alone_branch.i, align 128
  %leaf_cfs_rq_list.i = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 29
  %cmp.i = icmp eq ptr %23, %leaf_cfs_rq_list.i
  br i1 %cmp.i, label %if.then1.i, label %if.end.i

if.then1.i:                                       ; preds = %if.then.i
  %prev.i = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 29, i32 1
  %24 = ptrtoint ptr %prev.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %prev.i, align 4
  %26 = ptrtoint ptr %tmp_alone_branch.i to i32
  call void @__asan_store4_noabort(i32 %26)
  store ptr %25, ptr %tmp_alone_branch.i, align 128
  br label %if.end.i

if.end.i:                                         ; preds = %if.then1.i, %if.then.i
  %call.i.i.i8 = tail call zeroext i1 @__list_del_entry_valid(ptr noundef %leaf_cfs_rq_list.i) #20
  br i1 %call.i.i.i8, label %if.end.i.i.i, label %list_del_rcu.exit.i

if.end.i.i.i:                                     ; preds = %if.end.i
  %prev.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 29, i32 1
  %27 = ptrtoint ptr %prev.i.i.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %prev.i.i.i, align 4
  %29 = ptrtoint ptr %leaf_cfs_rq_list.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %leaf_cfs_rq_list.i, align 4
  %prev1.i.i.i.i = getelementptr inbounds %struct.list_head, ptr %30, i32 0, i32 1
  %31 = ptrtoint ptr %prev1.i.i.i.i to i32
  call void @__asan_store4_noabort(i32 %31)
  store ptr %28, ptr %prev1.i.i.i.i, align 4
  %32 = ptrtoint ptr %28 to i32
  call void @__asan_store4_noabort(i32 %32)
  store volatile ptr %30, ptr %28, align 4
  br label %list_del_rcu.exit.i

list_del_rcu.exit.i:                              ; preds = %if.end.i.i.i, %if.end.i
  %prev.i.i = getelementptr inbounds %struct.cfs_rq, ptr %5, i32 0, i32 29, i32 1
  %33 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_store4_noabort(i32 %33)
  store ptr inttoptr (i32 290 to ptr), ptr %prev.i.i, align 4
  %34 = ptrtoint ptr %on_list.i to i32
  call void @__asan_store4_noabort(i32 %34)
  store i32 0, ptr %on_list.i, align 32
  br label %if.end

if.end:                                           ; preds = %list_del_rcu.exit.i, %rq_clock_task.exit, %entry
  %35 = ptrtoint ptr %throttle_count to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %throttle_count, align 4
  %inc = add i32 %36, 1
  store i32 %inc, ptr %throttle_count, align 4
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @dequeue_entity(ptr noundef %cfs_rq, ptr noundef %se, i32 noundef %flags) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call fastcc void @update_curr(ptr noundef %cfs_rq)
  tail call fastcc void @update_load_avg(ptr noundef %cfs_rq, ptr noundef %se, i32 noundef 1)
  %my_q.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 12
  %0 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i27 = icmp eq ptr %1, null
  br i1 %tobool.not.i27, label %se_update_runnable.exit, label %if.then.i

if.then.i:                                        ; preds = %entry
  %h_nr_running.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 2
  %2 = ptrtoint ptr %h_nr_running.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %h_nr_running.i, align 4
  %runnable_weight.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 13
  %4 = ptrtoint ptr %runnable_weight.i to i32
  call void @__asan_store4_noabort(i32 %4)
  store i32 %3, ptr %runnable_weight.i, align 8
  br label %se_update_runnable.exit

se_update_runnable.exit:                          ; preds = %if.then.i, %entry
  tail call fastcc void @update_stats_dequeue_fair(ptr noundef %cfs_rq, ptr noundef %se, i32 noundef %flags)
  %last.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 13
  %5 = ptrtoint ptr %last.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %last.i, align 16
  %cmp.i = icmp eq ptr %6, %se
  br i1 %cmp.i, label %if.then.i29, label %if.end.i30

if.then.i29:                                      ; preds = %se_update_runnable.exit
  %tobool.not8.i.i = icmp eq ptr %se, null
  br i1 %tobool.not8.i.i, label %clear_buddies.exit, label %for.body.i.i

for.body.i.i:                                     ; preds = %for.inc.i.i, %if.then.i29
  %se.addr.09.i.i = phi ptr [ %13, %for.inc.i.i ], [ %se, %if.then.i29 ]
  %cfs_rq.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i.i, i32 0, i32 11
  %7 = ptrtoint ptr %cfs_rq.i.i.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %cfs_rq.i.i.i, align 16
  %last.i.i = getelementptr inbounds %struct.cfs_rq, ptr %8, i32 0, i32 13
  %9 = ptrtoint ptr %last.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %last.i.i, align 16
  %cmp.not.i.i = icmp eq ptr %10, %se.addr.09.i.i
  br i1 %cmp.not.i.i, label %for.inc.i.i, label %if.end.i30

for.inc.i.i:                                      ; preds = %for.body.i.i
  %11 = ptrtoint ptr %last.i.i to i32
  call void @__asan_store4_noabort(i32 %11)
  store ptr null, ptr %last.i.i, align 16
  %parent.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i.i, i32 0, i32 10
  %12 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i = icmp eq ptr %13, null
  br i1 %tobool.not.i.i, label %if.end.i30, label %for.body.i.i

if.end.i30:                                       ; preds = %for.inc.i.i, %for.body.i.i, %se_update_runnable.exit
  %next.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 12
  %14 = ptrtoint ptr %next.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %next.i, align 4
  %cmp1.i = icmp ne ptr %15, %se
  %tobool.not8.i14.i = icmp eq ptr %se, null
  %or.cond.i = or i1 %tobool.not8.i14.i, %cmp1.i
  br i1 %or.cond.i, label %if.end3.i31, label %for.body.i18.i

for.body.i18.i:                                   ; preds = %for.inc.i21.i, %if.end.i30
  %se.addr.09.i15.i = phi ptr [ %22, %for.inc.i21.i ], [ %se, %if.end.i30 ]
  %cfs_rq.i.i16.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i15.i, i32 0, i32 11
  %16 = ptrtoint ptr %cfs_rq.i.i16.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %cfs_rq.i.i16.i, align 16
  %next.i.i = getelementptr inbounds %struct.cfs_rq, ptr %17, i32 0, i32 12
  %18 = ptrtoint ptr %next.i.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load ptr, ptr %next.i.i, align 4
  %cmp.not.i17.i = icmp eq ptr %19, %se.addr.09.i15.i
  br i1 %cmp.not.i17.i, label %for.inc.i21.i, label %if.end3.i31

for.inc.i21.i:                                    ; preds = %for.body.i18.i
  %20 = ptrtoint ptr %next.i.i to i32
  call void @__asan_store4_noabort(i32 %20)
  store ptr null, ptr %next.i.i, align 4
  %parent.i19.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i15.i, i32 0, i32 10
  %21 = ptrtoint ptr %parent.i19.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %parent.i19.i, align 4
  %tobool.not.i20.i = icmp eq ptr %22, null
  br i1 %tobool.not.i20.i, label %if.end3.i31, label %for.body.i18.i

if.end3.i31:                                      ; preds = %for.inc.i21.i, %for.body.i18.i, %if.end.i30
  %skip.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 14
  %23 = ptrtoint ptr %skip.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %skip.i, align 4
  %cmp4.i = icmp ne ptr %24, %se
  %or.cond33.i = or i1 %tobool.not8.i14.i, %cmp4.i
  br i1 %or.cond33.i, label %clear_buddies.exit, label %for.body.i26.i

for.body.i26.i:                                   ; preds = %for.inc.i29.i, %if.end3.i31
  %se.addr.09.i23.i = phi ptr [ %31, %for.inc.i29.i ], [ %se, %if.end3.i31 ]
  %cfs_rq.i.i24.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i23.i, i32 0, i32 11
  %25 = ptrtoint ptr %cfs_rq.i.i24.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load ptr, ptr %cfs_rq.i.i24.i, align 16
  %skip.i.i = getelementptr inbounds %struct.cfs_rq, ptr %26, i32 0, i32 14
  %27 = ptrtoint ptr %skip.i.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %skip.i.i, align 4
  %cmp.not.i25.i = icmp eq ptr %28, %se.addr.09.i23.i
  br i1 %cmp.not.i25.i, label %for.inc.i29.i, label %clear_buddies.exit

for.inc.i29.i:                                    ; preds = %for.body.i26.i
  %29 = ptrtoint ptr %skip.i.i to i32
  call void @__asan_store4_noabort(i32 %29)
  store ptr null, ptr %skip.i.i, align 4
  %parent.i27.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i23.i, i32 0, i32 10
  %30 = ptrtoint ptr %parent.i27.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %parent.i27.i, align 4
  %tobool.not.i28.i = icmp eq ptr %31, null
  br i1 %tobool.not.i28.i, label %clear_buddies.exit, label %for.body.i26.i

clear_buddies.exit:                               ; preds = %for.inc.i29.i, %for.body.i26.i, %if.end3.i31, %if.then.i29
  %curr = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 11
  %32 = ptrtoint ptr %curr to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load ptr, ptr %curr, align 8
  %cmp.not = icmp eq ptr %33, %se
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %clear_buddies.exit
  %run_node.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 1
  %rb_leftmost.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 10, i32 1
  %34 = ptrtoint ptr %rb_leftmost.i.i to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load ptr, ptr %rb_leftmost.i.i, align 4
  %cmp.i.i32 = icmp eq ptr %35, %run_node.i
  br i1 %cmp.i.i32, label %if.then.i.i, label %__dequeue_entity.exit

if.then.i.i:                                      ; preds = %if.then
  %call.i.i = tail call ptr @rb_next(ptr noundef %run_node.i) #20
  %36 = ptrtoint ptr %rb_leftmost.i.i to i32
  call void @__asan_store4_noabort(i32 %36)
  store ptr %call.i.i, ptr %rb_leftmost.i.i, align 4
  br label %__dequeue_entity.exit

__dequeue_entity.exit:                            ; preds = %if.then.i.i, %if.then
  %tasks_timeline.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 10
  tail call void @rb_erase(ptr noundef %run_node.i, ptr noundef %tasks_timeline.i) #20
  br label %if.end

if.end:                                           ; preds = %__dequeue_entity.exit, %clear_buddies.exit
  %on_rq = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 3
  %37 = ptrtoint ptr %on_rq to i32
  call void @__asan_store4_noabort(i32 %37)
  store i32 0, ptr %on_rq, align 4
  %38 = ptrtoint ptr %se to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load i32, ptr %se, align 128
  %40 = ptrtoint ptr %cfs_rq to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %cfs_rq, align 4
  %sub.i.i33 = sub i32 %41, %39
  store i32 %sub.i.i33, ptr %cfs_rq, align 4
  %inv_weight.i.i = getelementptr inbounds %struct.load_weight, ptr %cfs_rq, i32 0, i32 1
  %42 = ptrtoint ptr %inv_weight.i.i to i32
  call void @__asan_store4_noabort(i32 %42)
  store i32 0, ptr %inv_weight.i.i, align 4
  %43 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i35 = icmp eq ptr %44, null
  br i1 %tobool.not.i35, label %task_of.exit.i, label %if.end.i38

task_of.exit.i:                                   ; preds = %if.end
  %group_node.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 2
  %call.i.i.i = tail call zeroext i1 @__list_del_entry_valid(ptr noundef %group_node.i) #20
  br i1 %call.i.i.i, label %if.end.i.i.i36, label %list_del_init.exit.i

if.end.i.i.i36:                                   ; preds = %task_of.exit.i
  %prev.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 2, i32 1
  %45 = ptrtoint ptr %prev.i.i.i to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load ptr, ptr %prev.i.i.i, align 4
  %47 = ptrtoint ptr %group_node.i to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load ptr, ptr %group_node.i, align 4
  %prev1.i.i.i.i = getelementptr inbounds %struct.list_head, ptr %48, i32 0, i32 1
  %49 = ptrtoint ptr %prev1.i.i.i.i to i32
  call void @__asan_store4_noabort(i32 %49)
  store ptr %46, ptr %prev1.i.i.i.i, align 4
  %50 = ptrtoint ptr %46 to i32
  call void @__asan_store4_noabort(i32 %50)
  store volatile ptr %48, ptr %46, align 4
  br label %list_del_init.exit.i

list_del_init.exit.i:                             ; preds = %if.end.i.i.i36, %task_of.exit.i
  %51 = ptrtoint ptr %group_node.i to i32
  call void @__asan_store4_noabort(i32 %51)
  store volatile ptr %group_node.i, ptr %group_node.i, align 4
  %prev.i3.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 2, i32 1
  %52 = ptrtoint ptr %prev.i3.i.i to i32
  call void @__asan_store4_noabort(i32 %52)
  store ptr %group_node.i, ptr %prev.i3.i.i, align 4
  br label %if.end.i38

if.end.i38:                                       ; preds = %list_del_init.exit.i, %if.end
  %nr_running.i37 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 1
  %53 = ptrtoint ptr %nr_running.i37 to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load i32, ptr %nr_running.i37, align 8
  %dec.i = add i32 %54, -1
  store i32 %dec.i, ptr %nr_running.i37, align 8
  %55 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i16.i = icmp eq ptr %56, null
  br i1 %tobool.not.i16.i, label %se_is_idle.exit.i, label %if.end.i.i39

if.end.i.i39:                                     ; preds = %if.end.i38
  %idle.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %56, i32 0, i32 31
  %57 = ptrtoint ptr %idle.i.i.i to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load i32, ptr %idle.i.i.i, align 16
  %cmp.i.i.i = icmp sgt i32 %58, 0
  br i1 %cmp.i.i.i, label %if.then5.i, label %account_entity_dequeue.exit

se_is_idle.exit.i:                                ; preds = %if.end.i38
  %policy.i.i.i = getelementptr i8, ptr %se, i32 900
  %59 = ptrtoint ptr %policy.i.i.i to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load i32, ptr %policy.i.i.i, align 4
  %cmp.i.i.i.i40 = icmp eq i32 %60, 5
  br i1 %cmp.i.i.i.i40, label %if.then5.i, label %account_entity_dequeue.exit

if.then5.i:                                       ; preds = %se_is_idle.exit.i, %if.end.i.i39
  %idle_nr_running.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 3
  %61 = ptrtoint ptr %idle_nr_running.i to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load i32, ptr %idle_nr_running.i, align 16
  %dec6.i = add i32 %62, -1
  store i32 %dec6.i, ptr %idle_nr_running.i, align 16
  br label %account_entity_dequeue.exit

account_entity_dequeue.exit:                      ; preds = %if.then5.i, %se_is_idle.exit.i, %if.end.i.i39
  %and = and i32 %flags, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.then1, label %if.end2

if.then1:                                         ; preds = %account_entity_dequeue.exit
  %min_vruntime = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 6
  %63 = ptrtoint ptr %min_vruntime to i32
  call void @__asan_load8_noabort(i32 %63)
  %64 = load i64, ptr %min_vruntime, align 32
  %vruntime = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 6
  %65 = ptrtoint ptr %vruntime to i32
  call void @__asan_load8_noabort(i32 %65)
  %66 = load i64, ptr %vruntime, align 16
  %sub = sub i64 %66, %64
  store i64 %sub, ptr %vruntime, align 16
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %account_entity_dequeue.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@dequeue_entity, %if.end.i)) #20
          to label %return_cfs_rq_runtime.exit [label %if.end.i], !srcloc !261

if.end.i:                                         ; preds = %if.end2
  %runtime_enabled.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 32
  %67 = ptrtoint ptr %runtime_enabled.i to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load i32, ptr %runtime_enabled.i, align 4
  %tobool.not.i = icmp eq i32 %68, 0
  br i1 %tobool.not.i, label %return_cfs_rq_runtime.exit, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.end.i
  %69 = ptrtoint ptr %nr_running.i37 to i32
  call void @__asan_load4_noabort(i32 %69)
  %70 = load i32, ptr %nr_running.i37, align 8
  %tobool1.not.i = icmp eq i32 %70, 0
  br i1 %tobool1.not.i, label %if.end3.i, label %return_cfs_rq_runtime.exit

if.end3.i:                                        ; preds = %lor.lhs.false.i
  %tg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 30
  %71 = ptrtoint ptr %tg.i.i to i32
  call void @__asan_load4_noabort(i32 %71)
  %72 = load ptr, ptr %tg.i.i, align 4
  %cfs_bandwidth.i.i.i = getelementptr inbounds %struct.task_group, ptr %72, i32 0, i32 16
  %runtime_remaining.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 33
  %73 = ptrtoint ptr %runtime_remaining.i.i to i32
  call void @__asan_load8_noabort(i32 %73)
  %74 = load i64, ptr %runtime_remaining.i.i, align 8
  %sub.i.i = add i64 %74, -1000000
  %cmp.i.i = icmp slt i64 %sub.i.i, 1
  br i1 %cmp.i.i, label %return_cfs_rq_runtime.exit, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.end3.i
  tail call void @_raw_spin_lock(ptr noundef %cfs_bandwidth.i.i.i) #20
  %quota.i.i = getelementptr inbounds %struct.task_group, ptr %72, i32 0, i32 16, i32 2
  %75 = ptrtoint ptr %quota.i.i to i32
  call void @__asan_load8_noabort(i32 %75)
  %76 = load i64, ptr %quota.i.i, align 8
  %cmp1.not.i.i = icmp eq i64 %76, -1
  br i1 %cmp1.not.i.i, label %if.end9.i.i, label %if.then2.i.i

if.then2.i.i:                                     ; preds = %if.end.i.i
  %runtime.i.i = getelementptr inbounds %struct.task_group, ptr %72, i32 0, i32 16, i32 3
  %77 = ptrtoint ptr %runtime.i.i to i32
  call void @__asan_load8_noabort(i32 %77)
  %78 = load i64, ptr %runtime.i.i, align 8
  %add.i.i = add i64 %78, %sub.i.i
  store i64 %add.i.i, ptr %runtime.i.i, align 8
  %79 = load i32, ptr @sysctl_sched_cfs_bandwidth_slice, align 4
  %conv.i.i.i = zext i32 %79 to i64
  %mul.i.i.i = mul nuw nsw i64 %conv.i.i.i, 1000
  %cmp5.i.i = icmp ugt i64 %add.i.i, %mul.i.i.i
  br i1 %cmp5.i.i, label %land.lhs.true.i.i, label %if.end9.i.i

land.lhs.true.i.i:                                ; preds = %if.then2.i.i
  %throttled_cfs_rq.i.i = getelementptr inbounds %struct.task_group, ptr %72, i32 0, i32 16, i32 12
  %80 = ptrtoint ptr %throttled_cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load volatile ptr, ptr %throttled_cfs_rq.i.i, align 4
  %cmp.i.not.i.i = icmp eq ptr %81, %throttled_cfs_rq.i.i
  br i1 %cmp.i.not.i.i, label %if.end9.i.i, label %if.then7.i.i

if.then7.i.i:                                     ; preds = %land.lhs.true.i.i
  %period_timer.i.i.i.i = getelementptr inbounds %struct.task_group, ptr %72, i32 0, i32 16, i32 10
  %base.i.i.i.i.i = getelementptr inbounds %struct.task_group, ptr %72, i32 0, i32 16, i32 10, i32 3
  %82 = ptrtoint ptr %base.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %82)
  %83 = load ptr, ptr %base.i.i.i.i.i, align 4
  %running.i.i.i.i.i = getelementptr inbounds %struct.hrtimer_clock_base, ptr %83, i32 0, i32 4
  %84 = ptrtoint ptr %running.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %84)
  %85 = load ptr, ptr %running.i.i.i.i.i, align 8
  %cmp.i.not.i.i.i.i = icmp eq ptr %85, %period_timer.i.i.i.i
  br i1 %cmp.i.not.i.i.i.i, label %if.end9.i.i, label %runtime_refresh_within.exit.i.i.i

runtime_refresh_within.exit.i.i.i:                ; preds = %if.then7.i.i
  %expires.i.i.i.i.i = getelementptr inbounds %struct.task_group, ptr %72, i32 0, i32 16, i32 10, i32 0, i32 1
  %86 = ptrtoint ptr %expires.i.i.i.i.i to i32
  call void @__asan_load8_noabort(i32 %86)
  %87 = load i64, ptr %expires.i.i.i.i.i, align 8
  %get_time.i.i.i.i.i = getelementptr inbounds %struct.hrtimer_clock_base, ptr %83, i32 0, i32 6
  %88 = ptrtoint ptr %get_time.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %88)
  %89 = load ptr, ptr %get_time.i.i.i.i.i, align 4
  %call.i.i.i.i.i = tail call i64 %89() #20
  %sub.i.i.i.i.i = sub i64 %87, %call.i.i.i.i.i
  %cmp.i.i.i.i = icmp sgt i64 %sub.i.i.i.i.i, 6999999
  br i1 %cmp.i.i.i.i, label %if.end.i.i.i, label %if.end9.i.i

if.end.i.i.i:                                     ; preds = %runtime_refresh_within.exit.i.i.i
  %slack_started.i.i.i = getelementptr inbounds %struct.task_group, ptr %72, i32 0, i32 16, i32 9
  %90 = ptrtoint ptr %slack_started.i.i.i to i32
  call void @__asan_load1_noabort(i32 %90)
  %91 = load i8, ptr %slack_started.i.i.i, align 2
  %tobool1.not.i.i.i = icmp eq i8 %91, 0
  br i1 %tobool1.not.i.i.i, label %if.end3.i.i.i, label %if.end9.i.i

if.end3.i.i.i:                                    ; preds = %if.end.i.i.i
  %92 = ptrtoint ptr %slack_started.i.i.i to i32
  call void @__asan_store1_noabort(i32 %92)
  store i8 1, ptr %slack_started.i.i.i, align 2
  %slack_timer.i.i.i = getelementptr inbounds %struct.task_group, ptr %72, i32 0, i32 16, i32 11
  tail call void @hrtimer_start_range_ns(ptr noundef %slack_timer.i.i.i, i64 noundef 5000000, i64 noundef 0, i32 noundef 1) #20
  br label %if.end9.i.i

if.end9.i.i:                                      ; preds = %if.end3.i.i.i, %if.end.i.i.i, %runtime_refresh_within.exit.i.i.i, %if.then7.i.i, %land.lhs.true.i.i, %if.then2.i.i, %if.end.i.i
  tail call void @_raw_spin_unlock(ptr noundef %cfs_bandwidth.i.i.i) #20
  %93 = ptrtoint ptr %runtime_remaining.i.i to i32
  call void @__asan_load8_noabort(i32 %93)
  %94 = load i64, ptr %runtime_remaining.i.i, align 8
  %sub12.i.i = sub i64 %94, %sub.i.i
  store i64 %sub12.i.i, ptr %runtime_remaining.i.i, align 8
  br label %return_cfs_rq_runtime.exit

return_cfs_rq_runtime.exit:                       ; preds = %if.end9.i.i, %if.end3.i, %lor.lhs.false.i, %if.end.i, %if.end2
  %95 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %95)
  %96 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i41 = icmp eq ptr %96, null
  br i1 %tobool.not.i41, label %update_cfs_group.exit, label %if.end.i42

if.end.i42:                                       ; preds = %return_cfs_rq_runtime.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@dequeue_entity, %land.rhs.i.i)) #20
          to label %if.end4.i [label %land.rhs.i.i], !srcloc !261

land.rhs.i.i:                                     ; preds = %if.end.i42
  %throttle_count.i.i = getelementptr inbounds %struct.cfs_rq, ptr %96, i32 0, i32 38
  %97 = ptrtoint ptr %throttle_count.i.i to i32
  call void @__asan_load4_noabort(i32 %97)
  %98 = load i32, ptr %throttle_count.i.i, align 4
  %tobool.i.not.i = icmp eq i32 %98, 0
  br i1 %tobool.i.not.i, label %if.end4.i, label %update_cfs_group.exit

if.end4.i:                                        ; preds = %land.rhs.i.i, %if.end.i42
  %tg1.i.i = getelementptr inbounds %struct.cfs_rq, ptr %96, i32 0, i32 30
  %99 = ptrtoint ptr %tg1.i.i to i32
  call void @__asan_load4_noabort(i32 %99)
  %100 = load ptr, ptr %tg1.i.i, align 4
  %shares2.i.i = getelementptr inbounds %struct.task_group, ptr %100, i32 0, i32 3
  %101 = ptrtoint ptr %shares2.i.i to i32
  call void @__asan_load4_noabort(i32 %101)
  %102 = load volatile i32, ptr %shares2.i.i, align 16
  %103 = ptrtoint ptr %96 to i32
  call void @__asan_load4_noabort(i32 %103)
  %104 = load i32, ptr %96, align 128
  %load_avg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %96, i32 0, i32 17, i32 5
  %105 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %105)
  %106 = load i32, ptr %load_avg.i.i, align 32
  %107 = tail call i32 @llvm.umax.i32(i32 %104, i32 %106) #20
  %load_avg5.i.i = getelementptr inbounds %struct.task_group, ptr %100, i32 0, i32 6
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %load_avg5.i.i, i32 noundef 4) #20
  %108 = ptrtoint ptr %load_avg5.i.i to i32
  call void @__asan_load4_noabort(i32 %108)
  %109 = load volatile i32, ptr %load_avg5.i.i, align 4
  %tg_load_avg_contrib.i.i = getelementptr inbounds %struct.cfs_rq, ptr %96, i32 0, i32 21
  %110 = ptrtoint ptr %tg_load_avg_contrib.i.i to i32
  call void @__asan_load4_noabort(i32 %110)
  %111 = load i32, ptr %tg_load_avg_contrib.i.i, align 128
  %sub.i.i43 = sub i32 %109, %111
  %add.i.i44 = add i32 %sub.i.i43, %107
  %mul.i.i = mul i32 %107, %102
  %tobool.not.i.i45 = icmp eq i32 %add.i.i44, 0
  br i1 %tobool.not.i.i45, label %calc_group_shares.exit.i, label %if.then.i.i46

if.then.i.i46:                                    ; preds = %if.end4.i
  %div.i.i = sdiv i32 %mul.i.i, %add.i.i44
  br label %calc_group_shares.exit.i

calc_group_shares.exit.i:                         ; preds = %if.then.i.i46, %if.end4.i
  %shares.0.i.i = phi i32 [ %div.i.i, %if.then.i.i46 ], [ %mul.i.i, %if.end4.i ]
  %112 = tail call i32 @llvm.smax.i32(i32 %shares.0.i.i, i32 2) #20
  %113 = tail call i32 @llvm.smin.i32(i32 %112, i32 %102) #20
  %cfs_rq.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 11
  %114 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %114)
  %115 = load ptr, ptr %cfs_rq.i.i, align 16
  tail call fastcc void @reweight_entity(ptr noundef %115, ptr noundef %se, i32 noundef %113) #20
  br label %update_cfs_group.exit

update_cfs_group.exit:                            ; preds = %calc_group_shares.exit.i, %land.rhs.i.i, %return_cfs_rq_runtime.exit
  %and3 = and i32 %flags, 6
  %cmp4.not = icmp eq i32 %and3, 2
  br i1 %cmp4.not, label %if.end6, label %if.then5

if.then5:                                         ; preds = %update_cfs_group.exit
  %116 = ptrtoint ptr %curr to i32
  call void @__asan_load4_noabort(i32 %116)
  %117 = load ptr, ptr %curr, align 8
  %rb_leftmost.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 10, i32 1
  %118 = ptrtoint ptr %rb_leftmost.i to i32
  call void @__asan_load4_noabort(i32 %118)
  %119 = load ptr, ptr %rb_leftmost.i, align 4
  %min_vruntime.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 6
  %120 = ptrtoint ptr %min_vruntime.i to i32
  call void @__asan_load8_noabort(i32 %120)
  %121 = load i64, ptr %min_vruntime.i, align 32
  %tobool.not.i47 = icmp eq ptr %117, null
  br i1 %tobool.not.i47, label %if.end5.i, label %if.then.i48

if.then.i48:                                      ; preds = %if.then5
  %on_rq.i = getelementptr inbounds %struct.sched_entity, ptr %117, i32 0, i32 3
  %122 = ptrtoint ptr %on_rq.i to i32
  call void @__asan_load4_noabort(i32 %122)
  %123 = load i32, ptr %on_rq.i, align 4
  %tobool2.not.i = icmp eq i32 %123, 0
  br i1 %tobool2.not.i, label %if.end5.i, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i48
  %vruntime4.i = getelementptr inbounds %struct.sched_entity, ptr %117, i32 0, i32 6
  %124 = ptrtoint ptr %vruntime4.i to i32
  call void @__asan_load8_noabort(i32 %124)
  %125 = load i64, ptr %vruntime4.i, align 16
  br label %if.end5.i

if.end5.i:                                        ; preds = %if.then3.i, %if.then.i48, %if.then5
  %vruntime.0.i = phi i64 [ %125, %if.then3.i ], [ %121, %if.then5 ], [ %121, %if.then.i48 ]
  %curr.0.i = phi ptr [ %117, %if.then3.i ], [ null, %if.then5 ], [ null, %if.then.i48 ]
  %tobool6.not.i = icmp eq ptr %119, null
  br i1 %tobool6.not.i, label %update_min_vruntime.exit, label %if.then7.i

if.then7.i:                                       ; preds = %if.end5.i
  %tobool8.not.i = icmp eq ptr %curr.0.i, null
  %vruntime10.i = getelementptr i8, ptr %119, i32 40
  %126 = ptrtoint ptr %vruntime10.i to i32
  call void @__asan_load8_noabort(i32 %126)
  %127 = load i64, ptr %vruntime10.i, align 16
  br i1 %tobool8.not.i, label %update_min_vruntime.exit, label %if.else11.i

if.else11.i:                                      ; preds = %if.then7.i
  %sub.i.i49 = sub i64 %127, %vruntime.0.i
  %cmp.i.i50 = icmp slt i64 %sub.i.i49, 0
  %spec.select.i.i = select i1 %cmp.i.i50, i64 %127, i64 %vruntime.0.i
  br label %update_min_vruntime.exit

update_min_vruntime.exit:                         ; preds = %if.else11.i, %if.then7.i, %if.end5.i
  %vruntime.2.i = phi i64 [ %vruntime.0.i, %if.end5.i ], [ %spec.select.i.i, %if.else11.i ], [ %127, %if.then7.i ]
  %sub.i35.i = sub i64 %vruntime.2.i, %121
  %cmp.i36.i = icmp sgt i64 %sub.i35.i, 0
  %spec.select.i37.i = select i1 %cmp.i36.i, i64 %vruntime.2.i, i64 %121
  %128 = ptrtoint ptr %min_vruntime.i to i32
  call void @__asan_store8_noabort(i32 %128)
  store i64 %spec.select.i37.i, ptr %min_vruntime.i, align 32
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !271
  %129 = ptrtoint ptr %min_vruntime.i to i32
  call void @__asan_load8_noabort(i32 %129)
  %130 = load i64, ptr %min_vruntime.i, align 32
  %min_vruntime_copy.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 9
  %131 = ptrtoint ptr %min_vruntime_copy.i to i32
  call void @__asan_store8_noabort(i32 %131)
  store i64 %130, ptr %min_vruntime_copy.i, align 8
  br label %if.end6

if.end6:                                          ; preds = %update_min_vruntime.exit, %update_cfs_group.exit
  ret void
}

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @update_stats_dequeue_fair(ptr nocapture noundef readonly %cfs_rq, ptr noundef %se, i32 noundef %flags) unnamed_addr #7 align 64 {
entry:
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@update_stats_dequeue_fair, %if.end)) #20
          to label %if.end29 [label %if.end], !srcloc !261

if.end:                                           ; preds = %entry
  %curr = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 11
  %0 = ptrtoint ptr %curr to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %curr, align 8
  %cmp.not = icmp eq ptr %1, %se
  br i1 %cmp.not, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@update_stats_dequeue_fair, %if.end.i)) #20
          to label %if.end4 [label %if.end.i], !srcloc !261

if.end.i:                                         ; preds = %if.then3
  %my_q.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 12
  %2 = ptrtoint ptr %my_q.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %my_q.i.i, align 4
  %tobool.not.i.i = icmp eq ptr %3, null
  %stats.i.i = getelementptr inbounds %struct.sched_entity_stats, ptr %se, i32 0, i32 1
  %stats1.i.i = getelementptr i8, ptr %se, i32 640
  %retval.0.i24.i = select i1 %tobool.not.i.i, ptr %stats1.i.i, ptr %stats.i.i
  %4 = ptrtoint ptr %retval.0.i24.i to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %retval.0.i24.i, align 128
  %tobool4.not.i = icmp eq i64 %5, 0
  br i1 %tobool4.not.i, label %if.end4, label %if.end14.i, !prof !260

if.end14.i:                                       ; preds = %if.end.i
  %add.ptr.i.i = getelementptr i8, ptr %se, i32 -128
  %spec.select.i = select i1 %tobool.not.i.i, ptr %add.ptr.i.i, ptr null
  %rq.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %6 = ptrtoint ptr %rq.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %rq.i.i, align 4
  tail call void @__update_stats_wait_end(ptr noundef %7, ptr noundef %spec.select.i, ptr noundef %retval.0.i24.i) #20
  br label %if.end4

if.end4:                                          ; preds = %if.end14.i, %if.end.i, %if.then3, %if.end
  %and = and i32 %flags, 1
  %tobool5.not = icmp eq i32 %and, 0
  br i1 %tobool5.not, label %if.end29, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end4
  %my_q = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 12
  %8 = ptrtoint ptr %my_q to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %my_q, align 4
  %tobool6.not = icmp eq ptr %9, null
  br i1 %tobool6.not, label %task_of.exit, label %if.end29

task_of.exit:                                     ; preds = %land.lhs.true
  %add.ptr.i = getelementptr i8, ptr %se, i32 -128
  %10 = ptrtoint ptr %add.ptr.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %add.ptr.i, align 128
  %and10 = and i32 %11, 1
  %tobool11.not = icmp eq i32 %and10, 0
  br i1 %tobool11.not, label %if.end18, label %do.body13

do.body13:                                        ; preds = %task_of.exit
  %rq.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %12 = ptrtoint ptr %rq.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %rq.i, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %14 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i39 = icmp eq i32 %14, 0
  br i1 %tobool.not.i.i39, label %lockdep_assert_rq_held.exit.i, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %do.body13
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %13, i32 0, i32 81
  %15 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %16, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.rhs.i.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %13, i32 0, i32 79
  %17 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %land.rhs.i.i
  %retval.0.i.i.i = phi ptr [ %18, %if.then.i.i.i ], [ %13, %land.rhs.i.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i, i32 noundef -1) #20
  %cmp.not.i.i = icmp eq i32 %call.i.i.i, 0
  br i1 %cmp.not.i.i, label %do.end.i.i, label %lockdep_assert_rq_held.exit.i, !prof !260

do.end.i.i:                                       ; preds = %__rq_lockp.exit.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i

lockdep_assert_rq_held.exit.i:                    ; preds = %do.end.i.i, %__rq_lockp.exit.i.i, %do.body13
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %13, i32 0, i32 25
  %19 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %clock_update_flags.i.i, align 4
  %cmp.i.i = icmp ult i32 %20, 2
  br i1 %cmp.i.i, label %land.rhs.i3.i, label %rq_clock.exit

land.rhs.i3.i:                                    ; preds = %lockdep_assert_rq_held.exit.i
  %.b37.i.i = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i, label %rq_clock.exit, label %if.then.i.i, !prof !259

if.then.i.i:                                      ; preds = %land.rhs.i3.i
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %rq_clock.exit

rq_clock.exit:                                    ; preds = %if.then.i.i, %land.rhs.i3.i, %lockdep_assert_rq_held.exit.i
  %clock.i = getelementptr inbounds %struct.rq, ptr %13, i32 0, i32 26
  %21 = ptrtoint ptr %clock.i to i32
  call void @__asan_load8_noabort(i32 %21)
  %22 = load i64, ptr %clock.i, align 32
  %sleep_start = getelementptr i8, ptr %se, i32 688
  %23 = ptrtoint ptr %sleep_start to i32
  call void @__asan_store8_noabort(i32 %23)
  store i64 %22, ptr %sleep_start, align 16
  br label %if.end18

if.end18:                                         ; preds = %rq_clock.exit, %task_of.exit
  %and19 = and i32 %11, 2
  %tobool20.not = icmp eq i32 %and19, 0
  br i1 %tobool20.not, label %if.end29, label %do.body22

do.body22:                                        ; preds = %if.end18
  %rq.i40 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %24 = ptrtoint ptr %rq.i40 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %rq.i40, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %26 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i41 = icmp eq i32 %26, 0
  br i1 %tobool.not.i.i41, label %lockdep_assert_rq_held.exit.i55, label %land.rhs.i.i44

land.rhs.i.i44:                                   ; preds = %do.body22
  %core_enabled.i.i.i42 = getelementptr inbounds %struct.rq, ptr %25, i32 0, i32 81
  %27 = ptrtoint ptr %core_enabled.i.i.i42 to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load i32, ptr %core_enabled.i.i.i42, align 128
  %tobool.not.i.i.i43 = icmp eq i32 %28, 0
  br i1 %tobool.not.i.i.i43, label %__rq_lockp.exit.i.i51, label %if.then.i.i.i46

if.then.i.i.i46:                                  ; preds = %land.rhs.i.i44
  %core.i.i.i45 = getelementptr inbounds %struct.rq, ptr %25, i32 0, i32 79
  %29 = ptrtoint ptr %core.i.i.i45 to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %core.i.i.i45, align 8
  br label %__rq_lockp.exit.i.i51

__rq_lockp.exit.i.i51:                            ; preds = %if.then.i.i.i46, %land.rhs.i.i44
  %retval.0.i.i.i47 = phi ptr [ %30, %if.then.i.i.i46 ], [ %25, %land.rhs.i.i44 ]
  %dep_map.i.i48 = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i47, i32 0, i32 4
  %call.i.i.i49 = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i48, i32 noundef -1) #20
  %cmp.not.i.i50 = icmp eq i32 %call.i.i.i49, 0
  br i1 %cmp.not.i.i50, label %do.end.i.i52, label %lockdep_assert_rq_held.exit.i55, !prof !260

do.end.i.i52:                                     ; preds = %__rq_lockp.exit.i.i51
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i55

lockdep_assert_rq_held.exit.i55:                  ; preds = %do.end.i.i52, %__rq_lockp.exit.i.i51, %do.body22
  %clock_update_flags.i.i53 = getelementptr inbounds %struct.rq, ptr %25, i32 0, i32 25
  %31 = ptrtoint ptr %clock_update_flags.i.i53 to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %clock_update_flags.i.i53, align 4
  %cmp.i.i54 = icmp ult i32 %32, 2
  br i1 %cmp.i.i54, label %land.rhs.i3.i57, label %rq_clock.exit60

land.rhs.i3.i57:                                  ; preds = %lockdep_assert_rq_held.exit.i55
  %.b37.i.i56 = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i56, label %rq_clock.exit60, label %if.then.i.i58, !prof !259

if.then.i.i58:                                    ; preds = %land.rhs.i3.i57
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %rq_clock.exit60

rq_clock.exit60:                                  ; preds = %if.then.i.i58, %land.rhs.i3.i57, %lockdep_assert_rq_held.exit.i55
  %clock.i59 = getelementptr inbounds %struct.rq, ptr %25, i32 0, i32 26
  %33 = ptrtoint ptr %clock.i59 to i32
  call void @__asan_load8_noabort(i32 %33)
  %34 = load i64, ptr %clock.i59, align 32
  %block_start = getelementptr i8, ptr %se, i32 712
  %35 = ptrtoint ptr %block_start to i32
  call void @__asan_store8_noabort(i32 %35)
  store i64 %34, ptr %block_start, align 8
  br label %if.end29

if.end29:                                         ; preds = %rq_clock.exit60, %if.end18, %land.lhs.true, %if.end4, %entry
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @__update_stats_wait_end(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @rb_next(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @rb_erase(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @hrtimer_start_range_ns(ptr noundef, i64 noundef, i64 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @call_trace_sched_update_nr_running(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__update_load_avg_se(i64 noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @update_cfs_rq_load_avg(i64 noundef %now, ptr noundef %cfs_rq) unnamed_addr #7 align 64 {
entry:
  %nr = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 20, i32 1
  %0 = ptrtoint ptr %nr to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %nr, align 4
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %if.end206, label %if.then

if.then:                                          ; preds = %entry
  %removed = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 20
  %period_contrib.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 4
  %2 = ptrtoint ptr %period_contrib.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %period_contrib.i, align 4
  %add.i = add i32 %3, 46718
  tail call void @_raw_spin_lock(ptr noundef %removed) #20
  %util_avg = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 20, i32 3
  %4 = ptrtoint ptr %util_avg to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %util_avg, align 4
  store i32 0, ptr %util_avg, align 4
  %load_avg = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 20, i32 2
  %6 = ptrtoint ptr %load_avg to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %load_avg, align 16
  store i32 0, ptr %load_avg, align 16
  %runnable_avg = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 20, i32 4
  %8 = ptrtoint ptr %runnable_avg to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %runnable_avg, align 8
  store i32 0, ptr %runnable_avg, align 8
  %10 = ptrtoint ptr %nr to i32
  call void @__asan_store4_noabort(i32 %10)
  store i32 0, ptr %nr, align 4
  tail call void @_raw_spin_unlock(ptr noundef %removed) #20
  %load_avg25 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 5
  %11 = ptrtoint ptr %load_avg25 to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %load_avg25, align 4
  %13 = tail call i32 @llvm.usub.sat.i32(i32 %12, i32 %7)
  %14 = ptrtoint ptr %load_avg25 to i32
  call void @__asan_store4_noabort(i32 %14)
  store volatile i32 %13, ptr %load_avg25, align 4
  %load_sum = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 1
  %mul = mul i32 %7, %add.i
  %conv = zext i32 %mul to i64
  %15 = ptrtoint ptr %load_sum to i32
  call void @__asan_load8_noabort(i32 %15)
  %16 = load volatile i64, ptr %load_sum, align 8
  %17 = tail call i64 @llvm.usub.sat.i64(i64 %16, i64 %conv)
  %18 = ptrtoint ptr %load_sum to i32
  call void @__asan_store8_noabort(i32 %18)
  store volatile i64 %17, ptr %load_sum, align 8
  %conv67 = trunc i64 %17 to i32
  %mul69 = mul i32 %13, 46718
  %19 = tail call i32 @llvm.umax.i32(i32 %mul69, i32 %conv67)
  %conv73 = zext i32 %19 to i64
  %20 = ptrtoint ptr %load_sum to i32
  call void @__asan_store8_noabort(i32 %20)
  store i64 %conv73, ptr %load_sum, align 8
  %util_avg77 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 7
  %21 = ptrtoint ptr %util_avg77 to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load volatile i32, ptr %util_avg77, align 4
  %23 = tail call i32 @llvm.usub.sat.i32(i32 %22, i32 %5)
  %24 = ptrtoint ptr %util_avg77 to i32
  call void @__asan_store4_noabort(i32 %24)
  store volatile i32 %23, ptr %util_avg77, align 4
  %util_sum = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 3
  %mul104 = mul i32 %5, %add.i
  %25 = ptrtoint ptr %util_sum to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load volatile i32, ptr %util_sum, align 4
  %27 = tail call i32 @llvm.usub.sat.i32(i32 %26, i32 %mul104)
  %28 = ptrtoint ptr %util_sum to i32
  call void @__asan_store4_noabort(i32 %28)
  store volatile i32 %27, ptr %util_sum, align 4
  %mul129 = mul i32 %23, 46718
  %29 = tail call i32 @llvm.umax.i32(i32 %27, i32 %mul129)
  %30 = ptrtoint ptr %util_sum to i32
  call void @__asan_store4_noabort(i32 %30)
  store i32 %29, ptr %util_sum, align 8
  %runnable_avg140 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 6
  %31 = ptrtoint ptr %runnable_avg140 to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load volatile i32, ptr %runnable_avg140, align 4
  %33 = tail call i32 @llvm.usub.sat.i32(i32 %32, i32 %9)
  %34 = ptrtoint ptr %runnable_avg140 to i32
  call void @__asan_store4_noabort(i32 %34)
  store volatile i32 %33, ptr %runnable_avg140, align 4
  %runnable_sum = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 2
  %mul167 = mul i32 %9, %add.i
  %conv168 = zext i32 %mul167 to i64
  %35 = ptrtoint ptr %runnable_sum to i32
  call void @__asan_load8_noabort(i32 %35)
  %36 = load volatile i64, ptr %runnable_sum, align 8
  %37 = tail call i64 @llvm.usub.sat.i64(i64 %36, i64 %conv168)
  %38 = ptrtoint ptr %runnable_sum to i32
  call void @__asan_store8_noabort(i32 %38)
  store volatile i64 %37, ptr %runnable_sum, align 8
  %conv192 = trunc i64 %37 to i32
  %mul194 = mul i32 %33, 46718
  %39 = tail call i32 @llvm.umax.i32(i32 %mul194, i32 %conv192)
  %conv202 = zext i32 %39 to i64
  %40 = ptrtoint ptr %runnable_sum to i32
  call void @__asan_store8_noabort(i32 %40)
  store i64 %conv202, ptr %runnable_sum, align 16
  %sub205 = sub i32 0, %mul167
  %shr = ashr i32 %sub205, 10
  %propagate.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 22
  %41 = ptrtoint ptr %propagate.i to i32
  call void @__asan_store4_noabort(i32 %41)
  store i32 1, ptr %propagate.i, align 4
  %prop_runnable_sum.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 23
  %42 = ptrtoint ptr %prop_runnable_sum.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load i32, ptr %prop_runnable_sum.i, align 8
  %add.i285 = add i32 %43, %shr
  store i32 %add.i285, ptr %prop_runnable_sum.i, align 8
  br label %if.end206

if.end206:                                        ; preds = %if.then, %entry
  %decayed.0 = phi i32 [ 1, %if.then ], [ 0, %entry ]
  %avg = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17
  %call207 = tail call i32 @__update_load_avg_cfs_rq(i64 noundef %now, ptr noundef %cfs_rq) #20
  %or = or i32 %call207, %decayed.0
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !290
  %44 = ptrtoint ptr %avg to i32
  call void @__asan_load8_noabort(i32 %44)
  %45 = load i64, ptr %avg, align 128
  %load_last_update_time_copy = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 18
  %46 = ptrtoint ptr %load_last_update_time_copy to i32
  call void @__asan_store8_noabort(i32 %46)
  store i64 %45, ptr %load_last_update_time_copy, align 128
  ret i32 %or
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @attach_entity_load_avg(ptr noundef %cfs_rq, ptr nocapture noundef %se) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %avg = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17
  %period_contrib.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 4
  %0 = ptrtoint ptr %period_contrib.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %period_contrib.i, align 4
  %add.i = add i32 %1, 46718
  %2 = ptrtoint ptr %avg to i32
  call void @__asan_load8_noabort(i32 %2)
  %3 = load i64, ptr %avg, align 128
  %avg2 = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15
  %4 = ptrtoint ptr %avg2 to i32
  call void @__asan_store8_noabort(i32 %4)
  store i64 %3, ptr %avg2, align 128
  %5 = load i32, ptr %period_contrib.i, align 4
  %period_contrib6 = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 4
  %6 = ptrtoint ptr %period_contrib6 to i32
  call void @__asan_store4_noabort(i32 %6)
  store i32 %5, ptr %period_contrib6, align 4
  %util_avg = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 7
  %7 = ptrtoint ptr %util_avg to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %util_avg, align 8
  %mul = mul i32 %8, %add.i
  %util_sum = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 3
  %9 = ptrtoint ptr %util_sum to i32
  call void @__asan_store4_noabort(i32 %9)
  store i32 %mul, ptr %util_sum, align 8
  %runnable_avg = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 6
  %10 = ptrtoint ptr %runnable_avg to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %runnable_avg, align 4
  %mul10 = mul i32 %11, %add.i
  %conv = zext i32 %mul10 to i64
  %runnable_sum = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 2
  %12 = ptrtoint ptr %runnable_sum to i32
  call void @__asan_store8_noabort(i32 %12)
  store i64 %conv, ptr %runnable_sum, align 16
  %conv12 = zext i32 %add.i to i64
  %load_sum = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 1
  %13 = ptrtoint ptr %load_sum to i32
  call void @__asan_store8_noabort(i32 %13)
  store i64 %conv12, ptr %load_sum, align 8
  %14 = ptrtoint ptr %se to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %se, align 128
  %tobool.not = icmp eq i32 %15, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %load_avg = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 5
  %16 = ptrtoint ptr %load_avg to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %load_avg, align 32
  %conv16 = zext i32 %17 to i64
  %mul19 = mul nuw i64 %conv16, %conv12
  %cmp164.i.i = icmp ult i64 %mul19, 4294967296
  br i1 %cmp164.i.i, label %if.then168.i.i, label %if.else174.i.i, !prof !259

if.then168.i.i:                                   ; preds = %if.then
  %conv169.i.i = trunc i64 %mul19 to i32
  %div172.i.i = udiv i32 %conv169.i.i, %15
  %conv173.i.i = zext i32 %div172.i.i to i64
  br label %div_u64.exit

if.else174.i.i:                                   ; preds = %if.then
  %18 = tail call { i64, i64 } asm ".ifnc $0,r0; .ifnc $0r0,fpr11; .ifnc $0r0,r11fp; .ifnc $0r0,ipr12; .ifnc $0r0,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09.ifnc $1,r2; .ifnc $1r2,fpr11; .ifnc $1r2,r11fp; .ifnc $1r2,ipr12; .ifnc $1r2,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09.ifnc $2,r4; .ifnc $2r4,fpr11; .ifnc $2r4,r11fp; .ifnc $2r4,ipr12; .ifnc $2r4,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09bl\09__do_div64", "={r0},={r2},{r4},{r0},~{r12},~{lr},~{cc}"(i32 %15, i64 %mul19) #23, !srcloc !263
  %asmresult1.i.i.i = extractvalue { i64, i64 } %18, 1
  br label %div_u64.exit

div_u64.exit:                                     ; preds = %if.else174.i.i, %if.then168.i.i
  %dividend.addr.0.i.i = phi i64 [ %conv173.i.i, %if.then168.i.i ], [ %asmresult1.i.i.i, %if.else174.i.i ]
  %19 = ptrtoint ptr %load_sum to i32
  call void @__asan_store8_noabort(i32 %19)
  store i64 %dividend.addr.0.i.i, ptr %load_sum, align 8
  br label %if.end

if.end:                                           ; preds = %div_u64.exit, %entry
  %load_avg.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 5
  %20 = ptrtoint ptr %load_avg.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %load_avg.i, align 32
  %load_avg2.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 5
  %22 = ptrtoint ptr %load_avg2.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load i32, ptr %load_avg2.i, align 32
  %add.i75 = add i32 %23, %21
  store i32 %add.i75, ptr %load_avg2.i, align 32
  %24 = ptrtoint ptr %se to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %se, align 128
  %conv.i = sext i32 %25 to i64
  %26 = ptrtoint ptr %load_sum to i32
  call void @__asan_load8_noabort(i32 %26)
  %27 = load i64, ptr %load_sum, align 8
  %mul.i = mul i64 %27, %conv.i
  %load_sum5.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 1
  %28 = ptrtoint ptr %load_sum5.i to i32
  call void @__asan_load8_noabort(i32 %28)
  %29 = load i64, ptr %load_sum5.i, align 8
  %add6.i = add i64 %29, %mul.i
  store i64 %add6.i, ptr %load_sum5.i, align 8
  %30 = ptrtoint ptr %util_avg to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load i32, ptr %util_avg, align 8
  %util_avg27 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 7
  %32 = ptrtoint ptr %util_avg27 to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %util_avg27, align 8
  %add = add i32 %33, %31
  store i32 %add, ptr %util_avg27, align 8
  %34 = ptrtoint ptr %util_sum to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load i32, ptr %util_sum, align 8
  %util_sum31 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 3
  %36 = ptrtoint ptr %util_sum31 to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load i32, ptr %util_sum31, align 8
  %add32 = add i32 %37, %35
  store i32 %add32, ptr %util_sum31, align 8
  %38 = ptrtoint ptr %runnable_avg to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load i32, ptr %runnable_avg, align 4
  %runnable_avg36 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 6
  %40 = ptrtoint ptr %runnable_avg36 to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %runnable_avg36, align 4
  %add37 = add i32 %41, %39
  store i32 %add37, ptr %runnable_avg36, align 4
  %42 = ptrtoint ptr %runnable_sum to i32
  call void @__asan_load8_noabort(i32 %42)
  %43 = load i64, ptr %runnable_sum, align 16
  %runnable_sum41 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 17, i32 2
  %44 = ptrtoint ptr %runnable_sum41 to i32
  call void @__asan_load8_noabort(i32 %44)
  %45 = load i64, ptr %runnable_sum41, align 16
  %add42 = add i64 %45, %43
  store i64 %add42, ptr %runnable_sum41, align 16
  %46 = load i64, ptr %load_sum, align 8
  %conv45 = trunc i64 %46 to i32
  %propagate.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 22
  %47 = ptrtoint ptr %propagate.i to i32
  call void @__asan_store4_noabort(i32 %47)
  store i32 1, ptr %propagate.i, align 4
  %prop_runnable_sum.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 23
  %48 = ptrtoint ptr %prop_runnable_sum.i to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load i32, ptr %prop_runnable_sum.i, align 8
  %add.i76 = add i32 %49, %conv45
  store i32 %add.i76, ptr %prop_runnable_sum.i, align 8
  %rq.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %50 = ptrtoint ptr %rq.i.i to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load ptr, ptr %rq.i.i, align 4
  %cfs.i = getelementptr inbounds %struct.rq, ptr %51, i32 0, i32 14
  %cmp.i = icmp eq ptr %cfs.i, %cfs_rq
  br i1 %cmp.i, label %if.then.i, label %cfs_rq_util_change.exit

if.then.i:                                        ; preds = %if.end
  tail call fastcc void @cpufreq_update_util(ptr noundef %51, i32 noundef 0) #20
  br label %cfs_rq_util_change.exit

cfs_rq_util_change.exit:                          ; preds = %if.then.i, %if.end
  tail call fastcc void @trace_pelt_cfs_tp(ptr noundef %cfs_rq)
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__update_load_avg_cfs_rq(i64 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @trace_pelt_cfs_tp(ptr noundef %cfs_rq) unnamed_addr #7 align 64 {
entry:
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_pelt_cfs_tp, i32 0, i32 1), ptr blockaddress(@trace_pelt_cfs_tp, %do.body)) #20
          to label %if.end48 [label %do.body], !srcloc !261

do.body:                                          ; preds = %entry
  %0 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 3
  %2 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %4 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i = icmp ugt i32 %4, %3
  br i1 %cmp.not.i.i.i.i, label %cpu_online.exit, label %land.rhs.i.i.i.i

land.rhs.i.i.i.i:                                 ; preds = %do.body
  %.b37.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i, label %cpu_online.exit, label %if.then.i.i.i.i, !prof !259

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_online.exit

cpu_online.exit:                                  ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i.i, %do.body
  %div3.i.i.i = lshr i32 %3, 5
  %arrayidx.i.i.i = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i
  %5 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %arrayidx.i.i.i, align 4
  %and.i.i.i75 = and i32 %3, 31
  %7 = shl nuw i32 1, %and.i.i.i75
  %8 = and i32 %6, %7
  %tobool.i.not = icmp eq i32 %8, 0
  br i1 %tobool.i.not, label %if.end69, label %cleanup.thread

cleanup.thread:                                   ; preds = %cpu_online.exit
  %9 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i = and i32 %9, -16384
  %10 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %10, i32 0, i32 1
  %11 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %preempt_count.i.i, align 4
  %add.i = add i32 %12, 1
  store volatile i32 %add.i, ptr %preempt_count.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !291
  %call42 = tail call i32 @__traceiter_pelt_cfs_tp(ptr noundef null, ptr noundef %cfs_rq) #20
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !292
  %13 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i73 = and i32 %13, -16384
  %14 = inttoptr i32 %and.i.i.i73 to ptr
  %preempt_count.i.i74 = getelementptr inbounds %struct.thread_info, ptr %14, i32 0, i32 1
  %15 = ptrtoint ptr %preempt_count.i.i74 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %preempt_count.i.i74, align 4
  %sub.i = add i32 %16, -1
  store volatile i32 %sub.i, ptr %preempt_count.i.i74, align 4
  br label %if.end48

if.end48:                                         ; preds = %cleanup.thread, %entry
  %17 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i76 = and i32 %17, -16384
  %18 = inttoptr i32 %and.i76 to ptr
  %cpu50 = getelementptr inbounds %struct.thread_info, ptr %18, i32 0, i32 3
  %19 = ptrtoint ptr %cpu50 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %cpu50, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %21 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i77 = icmp ugt i32 %21, %20
  br i1 %cmp.not.i.i.i.i77, label %cpu_online.exit85, label %land.rhs.i.i.i.i79

land.rhs.i.i.i.i79:                               ; preds = %if.end48
  %.b37.i.i.i.i78 = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i78, label %cpu_online.exit85, label %if.then.i.i.i.i80, !prof !259

if.then.i.i.i.i80:                                ; preds = %land.rhs.i.i.i.i79
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_online.exit85

cpu_online.exit85:                                ; preds = %if.then.i.i.i.i80, %land.rhs.i.i.i.i79, %if.end48
  %div3.i.i.i81 = lshr i32 %20, 5
  %arrayidx.i.i.i82 = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i81
  %22 = ptrtoint ptr %arrayidx.i.i.i82 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %arrayidx.i.i.i82, align 4
  %and.i.i.i83 = and i32 %20, 31
  %24 = shl nuw i32 1, %and.i.i.i83
  %25 = and i32 %23, %24
  %tobool.i84.not = icmp eq i32 %25, 0
  br i1 %tobool.i84.not, label %if.end69, label %if.then52

if.then52:                                        ; preds = %cpu_online.exit85
  %26 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i = and i32 %26, -16384
  %27 = inttoptr i32 %and.i.i.i.i to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %27, i32 0, i32 1
  %28 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %add.i.i = add i32 %29, 1
  store volatile i32 %add.i.i, ptr %preempt_count.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !293
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_pelt_cfs_tp, i32 0, i32 7) to i32))
  %30 = load volatile ptr, ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_pelt_cfs_tp, i32 0, i32 7), align 4
  %call58 = tail call i32 @rcu_read_lock_sched_held() #20
  %tobool59.not = icmp eq i32 %call58, 0
  br i1 %tobool59.not, label %land.lhs.true, label %do.end67

land.lhs.true:                                    ; preds = %if.then52
  %call60 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool61.not = icmp eq i32 %call60, 0
  br i1 %tobool61.not, label %do.end67, label %land.lhs.true62

land.lhs.true62:                                  ; preds = %land.lhs.true
  %.b72 = load i1, ptr @trace_pelt_cfs_tp.__warned, align 1
  br i1 %.b72, label %do.end67, label %if.then64

if.then64:                                        ; preds = %land.lhs.true62
  store i1 true, ptr @trace_pelt_cfs_tp.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.15, i32 noundef 693, ptr noundef nonnull @.str.16) #20
  br label %do.end67

do.end67:                                         ; preds = %if.then64, %land.lhs.true62, %land.lhs.true, %if.then52
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !294
  %31 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i86 = and i32 %31, -16384
  %32 = inttoptr i32 %and.i.i.i.i86 to ptr
  %preempt_count.i.i.i87 = getelementptr inbounds %struct.thread_info, ptr %32, i32 0, i32 1
  %33 = ptrtoint ptr %preempt_count.i.i.i87 to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load volatile i32, ptr %preempt_count.i.i.i87, align 4
  %sub.i.i = add i32 %34, -1
  store volatile i32 %sub.i.i, ptr %preempt_count.i.i.i87, align 4
  br label %if.end69

if.end69:                                         ; preds = %do.end67, %cpu_online.exit85, %cpu_online.exit
  ret void
}

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @trace_pelt_se_tp(ptr noundef %se) unnamed_addr #7 align 64 {
entry:
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_pelt_se_tp, i32 0, i32 1), ptr blockaddress(@trace_pelt_se_tp, %do.body)) #20
          to label %if.end48 [label %do.body], !srcloc !261

do.body:                                          ; preds = %entry
  %0 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 3
  %2 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %4 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i = icmp ugt i32 %4, %3
  br i1 %cmp.not.i.i.i.i, label %cpu_online.exit, label %land.rhs.i.i.i.i

land.rhs.i.i.i.i:                                 ; preds = %do.body
  %.b37.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i, label %cpu_online.exit, label %if.then.i.i.i.i, !prof !259

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_online.exit

cpu_online.exit:                                  ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i.i, %do.body
  %div3.i.i.i = lshr i32 %3, 5
  %arrayidx.i.i.i = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i
  %5 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %arrayidx.i.i.i, align 4
  %and.i.i.i75 = and i32 %3, 31
  %7 = shl nuw i32 1, %and.i.i.i75
  %8 = and i32 %6, %7
  %tobool.i.not = icmp eq i32 %8, 0
  br i1 %tobool.i.not, label %if.end69, label %cleanup.thread

cleanup.thread:                                   ; preds = %cpu_online.exit
  %9 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i = and i32 %9, -16384
  %10 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %10, i32 0, i32 1
  %11 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %preempt_count.i.i, align 4
  %add.i = add i32 %12, 1
  store volatile i32 %add.i, ptr %preempt_count.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !295
  %call42 = tail call i32 @__traceiter_pelt_se_tp(ptr noundef null, ptr noundef %se) #20
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !296
  %13 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i73 = and i32 %13, -16384
  %14 = inttoptr i32 %and.i.i.i73 to ptr
  %preempt_count.i.i74 = getelementptr inbounds %struct.thread_info, ptr %14, i32 0, i32 1
  %15 = ptrtoint ptr %preempt_count.i.i74 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %preempt_count.i.i74, align 4
  %sub.i = add i32 %16, -1
  store volatile i32 %sub.i, ptr %preempt_count.i.i74, align 4
  br label %if.end48

if.end48:                                         ; preds = %cleanup.thread, %entry
  %17 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i76 = and i32 %17, -16384
  %18 = inttoptr i32 %and.i76 to ptr
  %cpu50 = getelementptr inbounds %struct.thread_info, ptr %18, i32 0, i32 3
  %19 = ptrtoint ptr %cpu50 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %cpu50, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %21 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i77 = icmp ugt i32 %21, %20
  br i1 %cmp.not.i.i.i.i77, label %cpu_online.exit85, label %land.rhs.i.i.i.i79

land.rhs.i.i.i.i79:                               ; preds = %if.end48
  %.b37.i.i.i.i78 = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i78, label %cpu_online.exit85, label %if.then.i.i.i.i80, !prof !259

if.then.i.i.i.i80:                                ; preds = %land.rhs.i.i.i.i79
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_online.exit85

cpu_online.exit85:                                ; preds = %if.then.i.i.i.i80, %land.rhs.i.i.i.i79, %if.end48
  %div3.i.i.i81 = lshr i32 %20, 5
  %arrayidx.i.i.i82 = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i81
  %22 = ptrtoint ptr %arrayidx.i.i.i82 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %arrayidx.i.i.i82, align 4
  %and.i.i.i83 = and i32 %20, 31
  %24 = shl nuw i32 1, %and.i.i.i83
  %25 = and i32 %23, %24
  %tobool.i84.not = icmp eq i32 %25, 0
  br i1 %tobool.i84.not, label %if.end69, label %if.then52

if.then52:                                        ; preds = %cpu_online.exit85
  %26 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i = and i32 %26, -16384
  %27 = inttoptr i32 %and.i.i.i.i to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %27, i32 0, i32 1
  %28 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %add.i.i = add i32 %29, 1
  store volatile i32 %add.i.i, ptr %preempt_count.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !293
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_pelt_se_tp, i32 0, i32 7) to i32))
  %30 = load volatile ptr, ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_pelt_se_tp, i32 0, i32 7), align 4
  %call58 = tail call i32 @rcu_read_lock_sched_held() #20
  %tobool59.not = icmp eq i32 %call58, 0
  br i1 %tobool59.not, label %land.lhs.true, label %do.end67

land.lhs.true:                                    ; preds = %if.then52
  %call60 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool61.not = icmp eq i32 %call60, 0
  br i1 %tobool61.not, label %do.end67, label %land.lhs.true62

land.lhs.true62:                                  ; preds = %land.lhs.true
  %.b72 = load i1, ptr @trace_pelt_se_tp.__warned, align 1
  br i1 %.b72, label %do.end67, label %if.then64

if.then64:                                        ; preds = %land.lhs.true62
  store i1 true, ptr @trace_pelt_se_tp.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.15, i32 noundef 713, ptr noundef nonnull @.str.16) #20
  br label %do.end67

do.end67:                                         ; preds = %if.then64, %land.lhs.true62, %land.lhs.true, %if.then52
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !294
  %31 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i86 = and i32 %31, -16384
  %32 = inttoptr i32 %and.i.i.i.i86 to ptr
  %preempt_count.i.i.i87 = getelementptr inbounds %struct.thread_info, ptr %32, i32 0, i32 1
  %33 = ptrtoint ptr %preempt_count.i.i.i87 to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load volatile i32, ptr %preempt_count.i.i.i87, align 4
  %sub.i.i = add i32 %34, -1
  store volatile i32 %sub.i.i, ptr %preempt_count.i.i.i87, align 4
  br label %if.end69

if.end69:                                         ; preds = %do.end67, %cpu_online.exit85, %cpu_online.exit
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__traceiter_pelt_cfs_tp(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @rcu_read_lock_sched_held() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @debug_lockdep_rcu_enabled() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @lockdep_rcu_suspicious(ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__traceiter_pelt_se_tp(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @__kasan_check_write(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: inaccessiblemem_or_argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.prefetch.p0(ptr nocapture readonly, i32 immarg, i32 immarg, i32) #16

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @cpufreq_update_util(ptr noundef %rq, i32 noundef %flags) unnamed_addr #7 align 64 {
entry:
  %cpu.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 46
  %0 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %cpu.i, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %1
  %2 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %arrayidx, align 4
  %add = add i32 %3, ptrtoint (ptr @cpufreq_update_util_data to i32)
  %4 = inttoptr i32 %add to ptr
  %5 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile ptr, ptr %4, align 4
  %call7 = tail call i32 @rcu_read_lock_sched_held() #20
  %tobool.not = icmp eq i32 %call7, 0
  br i1 %tobool.not, label %land.lhs.true, label %do.end13

land.lhs.true:                                    ; preds = %entry
  %call8 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool9.not = icmp eq i32 %call8, 0
  br i1 %tobool9.not, label %do.end13, label %land.lhs.true10

land.lhs.true10:                                  ; preds = %land.lhs.true
  %.b22 = load i1, ptr @cpufreq_update_util.__warned, align 1
  br i1 %.b22, label %do.end13, label %if.then

if.then:                                          ; preds = %land.lhs.true10
  store i1 true, ptr @cpufreq_update_util.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.9, i32 noundef 2836, ptr noundef nonnull @.str.16) #20
  br label %do.end13

do.end13:                                         ; preds = %if.then, %land.lhs.true10, %land.lhs.true, %entry
  %tobool15.not = icmp eq ptr %6, null
  br i1 %tobool15.not, label %if.end18, label %if.then16

if.then16:                                        ; preds = %do.end13
  %7 = ptrtoint ptr %6 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %6, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %9 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i = icmp eq i32 %9, 0
  br i1 %tobool.not.i.i, label %lockdep_assert_rq_held.exit.i, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %if.then16
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 81
  %10 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %11, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.rhs.i.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 79
  %12 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %land.rhs.i.i
  %retval.0.i.i.i = phi ptr [ %13, %if.then.i.i.i ], [ %rq, %land.rhs.i.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i, i32 noundef -1) #20
  %cmp.not.i.i = icmp eq i32 %call.i.i.i, 0
  br i1 %cmp.not.i.i, label %do.end.i.i, label %lockdep_assert_rq_held.exit.i, !prof !260

do.end.i.i:                                       ; preds = %__rq_lockp.exit.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i

lockdep_assert_rq_held.exit.i:                    ; preds = %do.end.i.i, %__rq_lockp.exit.i.i, %if.then16
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 25
  %14 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %clock_update_flags.i.i, align 4
  %cmp.i.i = icmp ult i32 %15, 2
  br i1 %cmp.i.i, label %land.rhs.i3.i, label %rq_clock.exit

land.rhs.i3.i:                                    ; preds = %lockdep_assert_rq_held.exit.i
  %.b37.i.i = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i, label %rq_clock.exit, label %if.then.i.i, !prof !259

if.then.i.i:                                      ; preds = %land.rhs.i3.i
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %rq_clock.exit

rq_clock.exit:                                    ; preds = %if.then.i.i, %land.rhs.i3.i, %lockdep_assert_rq_held.exit.i
  %clock.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 26
  %16 = ptrtoint ptr %clock.i to i32
  call void @__asan_load8_noabort(i32 %16)
  %17 = load i64, ptr %clock.i, align 32
  tail call void %8(ptr noundef nonnull %6, i64 noundef %17, i32 noundef %flags) #20
  br label %if.end18

if.end18:                                         ; preds = %rq_clock.exit, %do.end13
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @_raw_spin_lock_irqsave(ptr noundef) local_unnamed_addr #4 section ".spinlock.text"

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @___ratelimit(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @_raw_spin_unlock_irqrestore(ptr noundef, i32 noundef) local_unnamed_addr #4 section ".spinlock.text"

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @distribute_cfs_runtime(ptr noundef %cfs_b) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %3, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !268
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #20
  %call.i = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 696, ptr noundef nonnull @.str.28) #20
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %entry
  %call = tail call i32 @rcu_read_lock_any_held() #20
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %rcu_read_lock.exit
  %call1 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %do.end, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %land.lhs.true
  %.b109 = load i1, ptr @distribute_cfs_runtime.__warned, align 1
  br i1 %.b109, label %do.end, label %if.then

if.then:                                          ; preds = %land.lhs.true3
  store i1 true, ptr @distribute_cfs_runtime.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 5011, ptr noundef nonnull @.str.25) #20
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true3, %land.lhs.true, %rcu_read_lock.exit
  %throttled_cfs_rq = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 12
  %runtime58 = getelementptr inbounds %struct.cfs_bandwidth, ptr %cfs_b, i32 0, i32 3
  br label %for.cond

for.cond:                                         ; preds = %rq_unlock_irqrestore.exit, %do.end
  %remaining.0 = phi i64 [ 1, %do.end ], [ %remaining.1, %rq_unlock_irqrestore.exit ]
  %.pn.in = phi ptr [ %throttled_cfs_rq, %do.end ], [ %.pn, %rq_unlock_irqrestore.exit ]
  %4 = ptrtoint ptr %.pn.in to i32
  call void @__asan_load4_noabort(i32 %4)
  %.pn = load volatile ptr, ptr %.pn.in, align 8
  %cfs_rq.0 = getelementptr i8, ptr %.pn, i32 -608
  %cmp.not = icmp eq ptr %.pn, %throttled_cfs_rq
  br i1 %cmp.not, label %for.end, label %for.body

for.body:                                         ; preds = %for.cond
  %rq.i = getelementptr i8, ptr %.pn, i32 -68
  %5 = ptrtoint ptr %rq.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %rq.i, align 4
  %7 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #20, !srcloc !279
  %and.i.i.i = and i32 %7, 128
  %tobool.not.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i.i, label %if.then.i.i, label %_raw_spin_rq_lock_irqsave.exit.i

if.then.i.i:                                      ; preds = %for.body
  tail call void @trace_hardirqs_off() #20
  br label %_raw_spin_rq_lock_irqsave.exit.i

_raw_spin_rq_lock_irqsave.exit.i:                 ; preds = %if.then.i.i, %for.body
  tail call void @raw_spin_rq_lock_nested(ptr noundef %6, i32 noundef 0) #20
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 81
  %8 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %9, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %_raw_spin_rq_lock_irqsave.exit.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 79
  %10 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %_raw_spin_rq_lock_irqsave.exit.i
  %retval.0.i.i.i = phi ptr [ %11, %if.then.i.i.i ], [ %6, %_raw_spin_rq_lock_irqsave.exit.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call1.i.i = tail call i32 @lock_pin_lock(ptr noundef %dep_map.i.i) #20
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 25
  %12 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %clock_update_flags.i.i, align 4
  %and.i.i = and i32 %13, 3
  store i32 %and.i.i, ptr %clock_update_flags.i.i, align 4
  %balance_callback.i.i = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 39
  %14 = ptrtoint ptr %balance_callback.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %balance_callback.i.i, align 8
  %tobool.not.i3.i = icmp ne ptr %15, null
  %cmp.i.i = icmp ne ptr %15, @balance_push_callback
  %spec.select.i.i = and i1 %tobool.not.i3.i, %cmp.i.i
  br i1 %spec.select.i.i, label %land.rhs6.i.i, label %rq_lock_irqsave.exit

land.rhs6.i.i:                                    ; preds = %__rq_lockp.exit.i.i
  %.b48.i.i = load i1, ptr @rq_pin_lock.__already_done, align 1
  br i1 %.b48.i.i, label %rq_lock_irqsave.exit, label %if.then.i4.i, !prof !259

if.then.i4.i:                                     ; preds = %land.rhs6.i.i
  store i1 true, ptr @rq_pin_lock.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1545, i32 noundef 9, ptr noundef nonnull @.str.35) #20
  br label %rq_lock_irqsave.exit

rq_lock_irqsave.exit:                             ; preds = %if.then.i4.i, %land.rhs6.i.i, %__rq_lockp.exit.i.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@distribute_cfs_runtime, %land.rhs.i)) #20
          to label %cfs_rq_throttled.exit [label %land.rhs.i], !srcloc !261

land.rhs.i:                                       ; preds = %rq_lock_irqsave.exit
  %throttled.i = getelementptr i8, ptr %.pn, i32 -8
  %16 = ptrtoint ptr %throttled.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %throttled.i, align 8
  %tobool.i = icmp ne i32 %17, 0
  %phi.cast.i = zext i1 %tobool.i to i32
  br label %cfs_rq_throttled.exit

cfs_rq_throttled.exit:                            ; preds = %land.rhs.i, %rq_lock_irqsave.exit
  %18 = phi i32 [ %phi.cast.i, %land.rhs.i ], [ 0, %rq_lock_irqsave.exit ]
  %tobool12.not = icmp eq i32 %18, 0
  br i1 %tobool12.not, label %if.end.i.i, label %if.end14

if.end14:                                         ; preds = %cfs_rq_throttled.exit
  %runtime_remaining = getelementptr i8, ptr %.pn, i32 -40
  %19 = ptrtoint ptr %runtime_remaining to i32
  call void @__asan_load8_noabort(i32 %19)
  %20 = load i64, ptr %runtime_remaining, align 8
  %cmp15 = icmp sgt i64 %20, 0
  br i1 %cmp15, label %land.rhs, label %if.end49

land.rhs:                                         ; preds = %if.end14
  %.b107108 = load i1, ptr @distribute_cfs_runtime.__already_done, align 1
  br i1 %.b107108, label %if.end49, label %if.then23, !prof !259

if.then23:                                        ; preds = %land.rhs
  store i1 true, ptr @distribute_cfs_runtime.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 5020, i32 noundef 9, ptr noundef nonnull @.str.26) #20
  br label %if.end49

if.end49:                                         ; preds = %if.then23, %land.rhs, %if.end14
  tail call void @_raw_spin_lock(ptr noundef %cfs_b) #20
  %21 = ptrtoint ptr %runtime_remaining to i32
  call void @__asan_load8_noabort(i32 %21)
  %22 = load i64, ptr %runtime_remaining, align 8
  %add = sub i64 1, %22
  %23 = ptrtoint ptr %runtime58 to i32
  call void @__asan_load8_noabort(i32 %23)
  %24 = load i64, ptr %runtime58, align 8
  %25 = tail call i64 @llvm.umin.i64(i64 %add, i64 %24)
  %sub64 = sub i64 %24, %25
  %26 = ptrtoint ptr %runtime58 to i32
  call void @__asan_store8_noabort(i32 %26)
  store i64 %sub64, ptr %runtime58, align 8
  tail call void @_raw_spin_unlock(ptr noundef %cfs_b) #20
  %27 = ptrtoint ptr %runtime_remaining to i32
  call void @__asan_load8_noabort(i32 %27)
  %28 = load i64, ptr %runtime_remaining, align 8
  %add68 = add i64 %28, %25
  store i64 %add68, ptr %runtime_remaining, align 8
  %cmp70 = icmp sgt i64 %add68, 0
  br i1 %cmp70, label %if.then71, label %if.end.i.i

if.then71:                                        ; preds = %if.end49
  tail call void @unthrottle_cfs_rq(ptr noundef %cfs_rq.0)
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then71, %if.end49, %cfs_rq_throttled.exit
  %remaining.1 = phi i64 [ %sub64, %if.then71 ], [ %sub64, %if.end49 ], [ %remaining.0, %cfs_rq_throttled.exit ]
  %29 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i114 = icmp eq i32 %30, 0
  br i1 %tobool.not.i.i.i114, label %rq_unpin_lock.exit.i, label %if.then.i.i.i116

if.then.i.i.i116:                                 ; preds = %if.end.i.i
  %core.i.i.i115 = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 79
  %31 = ptrtoint ptr %core.i.i.i115 to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %core.i.i.i115, align 8
  br label %rq_unpin_lock.exit.i

rq_unpin_lock.exit.i:                             ; preds = %if.then.i.i.i116, %if.end.i.i
  %retval.0.i.i.i117 = phi ptr [ %32, %if.then.i.i.i116 ], [ %6, %if.end.i.i ]
  %dep_map.i.i118 = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i117, i32 0, i32 4
  %33 = insertvalue [1 x i32] undef, i32 %call1.i.i, 0
  tail call void @lock_unpin_lock(ptr noundef %dep_map.i.i118, [1 x i32] %33) #20
  tail call void @raw_spin_rq_unlock(ptr noundef %6) #20
  br i1 %tobool.not.i.i, label %if.then.i3.i, label %do.body2.i.i

if.then.i3.i:                                     ; preds = %rq_unpin_lock.exit.i
  tail call void @trace_hardirqs_on() #20
  br label %do.body2.i.i

do.body2.i.i:                                     ; preds = %if.then.i3.i, %rq_unpin_lock.exit.i
  %34 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #20, !srcloc !280
  %and.i.i.i.i = and i32 %34, 128
  %tobool10.not.i.i = icmp eq i32 %and.i.i.i.i, 0
  br i1 %tobool10.not.i.i, label %if.then14.i.i, label %rq_unlock_irqrestore.exit, !prof !260

if.then14.i.i:                                    ; preds = %do.body2.i.i
  tail call void @warn_bogus_irq_restore() #20
  br label %rq_unlock_irqrestore.exit

rq_unlock_irqrestore.exit:                        ; preds = %if.then14.i.i, %do.body2.i.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %7) #20, !srcloc !281
  %tobool74.not = icmp eq i64 %remaining.1, 0
  br i1 %tobool74.not, label %for.end, label %for.cond

for.end:                                          ; preds = %rq_unlock_irqrestore.exit, %for.cond
  %call.i122 = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i122, label %rcu_read_unlock.exit, label %land.lhs.true.i125

land.lhs.true.i125:                               ; preds = %for.end
  %call1.i123 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i124 = icmp eq i32 %call1.i123, 0
  br i1 %tobool.not.i124, label %rcu_read_unlock.exit, label %land.lhs.true2.i127

land.lhs.true2.i127:                              ; preds = %land.lhs.true.i125
  %.b4.i126 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i126, label %rcu_read_unlock.exit, label %if.then.i128

if.then.i128:                                     ; preds = %land.lhs.true2.i127
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i128, %land.lhs.true2.i127, %land.lhs.true.i125, %for.end
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %35 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i129 = and i32 %35, -16384
  %36 = inttoptr i32 %and.i.i.i.i.i129 to ptr
  %preempt_count.i.i.i.i130 = getelementptr inbounds %struct.thread_info, ptr %36, i32 0, i32 1
  %37 = ptrtoint ptr %preempt_count.i.i.i.i130 to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load volatile i32, ptr %preempt_count.i.i.i.i130, align 4
  %sub.i.i.i = add i32 %38, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i130, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @rcu_read_lock_any_held() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @lock_is_held_type(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @hrtimer_forward(ptr noundef, i64 noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @rcu_lock_acquire(ptr nocapture noundef readnone %map) #7 align 64 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  tail call void @lock_acquire(ptr noundef nonnull @rcu_lock_map, i32 noundef 0, i32 noundef 0, i32 noundef 2, i32 noundef 0, ptr noundef null, i32 noundef ptrtoint (ptr blockaddress(@rcu_lock_acquire, %__here) to i32)) #20
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @rcu_is_watching() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @lock_acquire(ptr noundef, i32 noundef, i32 noundef, i32 noundef, i32 noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @rcu_read_lock_held() local_unnamed_addr #4

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @rcu_lock_release(ptr nocapture noundef readnone %map) #7 align 64 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  tail call void @lock_release(ptr noundef nonnull @rcu_lock_map, i32 noundef ptrtoint (ptr blockaddress(@rcu_lock_release, %__here) to i32)) #20
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @rcu_read_unlock_strict() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @lock_release(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @trace_sched_stat_runtime(ptr noundef %tsk, i64 noundef %runtime, i64 noundef %vruntime) unnamed_addr #7 align 64 {
entry:
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_stat_runtime, i32 0, i32 1), ptr blockaddress(@trace_sched_stat_runtime, %do.body)) #20
          to label %if.end48 [label %do.body], !srcloc !261

do.body:                                          ; preds = %entry
  %0 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 3
  %2 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %4 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i = icmp ugt i32 %4, %3
  br i1 %cmp.not.i.i.i.i, label %cpu_online.exit, label %land.rhs.i.i.i.i

land.rhs.i.i.i.i:                                 ; preds = %do.body
  %.b37.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i, label %cpu_online.exit, label %if.then.i.i.i.i, !prof !259

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_online.exit

cpu_online.exit:                                  ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i.i, %do.body
  %div3.i.i.i = lshr i32 %3, 5
  %arrayidx.i.i.i = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i
  %5 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %arrayidx.i.i.i, align 4
  %and.i.i.i75 = and i32 %3, 31
  %7 = shl nuw i32 1, %and.i.i.i75
  %8 = and i32 %6, %7
  %tobool.i.not = icmp eq i32 %8, 0
  br i1 %tobool.i.not, label %if.end69, label %cleanup.thread

cleanup.thread:                                   ; preds = %cpu_online.exit
  %9 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i = and i32 %9, -16384
  %10 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %10, i32 0, i32 1
  %11 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %preempt_count.i.i, align 4
  %add.i = add i32 %12, 1
  store volatile i32 %add.i, ptr %preempt_count.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !297
  %call42 = tail call i32 @__traceiter_sched_stat_runtime(ptr noundef null, ptr noundef %tsk, i64 noundef %runtime, i64 noundef %vruntime) #20
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !298
  %13 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i73 = and i32 %13, -16384
  %14 = inttoptr i32 %and.i.i.i73 to ptr
  %preempt_count.i.i74 = getelementptr inbounds %struct.thread_info, ptr %14, i32 0, i32 1
  %15 = ptrtoint ptr %preempt_count.i.i74 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %preempt_count.i.i74, align 4
  %sub.i = add i32 %16, -1
  store volatile i32 %sub.i, ptr %preempt_count.i.i74, align 4
  br label %if.end48

if.end48:                                         ; preds = %cleanup.thread, %entry
  %17 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i76 = and i32 %17, -16384
  %18 = inttoptr i32 %and.i76 to ptr
  %cpu50 = getelementptr inbounds %struct.thread_info, ptr %18, i32 0, i32 3
  %19 = ptrtoint ptr %cpu50 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %cpu50, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %21 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i77 = icmp ugt i32 %21, %20
  br i1 %cmp.not.i.i.i.i77, label %cpu_online.exit85, label %land.rhs.i.i.i.i79

land.rhs.i.i.i.i79:                               ; preds = %if.end48
  %.b37.i.i.i.i78 = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i78, label %cpu_online.exit85, label %if.then.i.i.i.i80, !prof !259

if.then.i.i.i.i80:                                ; preds = %land.rhs.i.i.i.i79
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_online.exit85

cpu_online.exit85:                                ; preds = %if.then.i.i.i.i80, %land.rhs.i.i.i.i79, %if.end48
  %div3.i.i.i81 = lshr i32 %20, 5
  %arrayidx.i.i.i82 = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i81
  %22 = ptrtoint ptr %arrayidx.i.i.i82 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %arrayidx.i.i.i82, align 4
  %and.i.i.i83 = and i32 %20, 31
  %24 = shl nuw i32 1, %and.i.i.i83
  %25 = and i32 %23, %24
  %tobool.i84.not = icmp eq i32 %25, 0
  br i1 %tobool.i84.not, label %if.end69, label %if.then52

if.then52:                                        ; preds = %cpu_online.exit85
  %26 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i = and i32 %26, -16384
  %27 = inttoptr i32 %and.i.i.i.i to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %27, i32 0, i32 1
  %28 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %add.i.i = add i32 %29, 1
  store volatile i32 %add.i.i, ptr %preempt_count.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !293
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_stat_runtime, i32 0, i32 7) to i32))
  %30 = load volatile ptr, ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_stat_runtime, i32 0, i32 7), align 4
  %call58 = tail call i32 @rcu_read_lock_sched_held() #20
  %tobool59.not = icmp eq i32 %call58, 0
  br i1 %tobool59.not, label %land.lhs.true, label %do.end67

land.lhs.true:                                    ; preds = %if.then52
  %call60 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool61.not = icmp eq i32 %call60, 0
  br i1 %tobool61.not, label %do.end67, label %land.lhs.true62

land.lhs.true62:                                  ; preds = %land.lhs.true
  %.b72 = load i1, ptr @trace_sched_stat_runtime.__warned, align 1
  br i1 %.b72, label %do.end67, label %if.then64

if.then64:                                        ; preds = %land.lhs.true62
  store i1 true, ptr @trace_sched_stat_runtime.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.15, i32 noundef 519, ptr noundef nonnull @.str.16) #20
  br label %do.end67

do.end67:                                         ; preds = %if.then64, %land.lhs.true62, %land.lhs.true, %if.then52
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !294
  %31 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i86 = and i32 %31, -16384
  %32 = inttoptr i32 %and.i.i.i.i86 to ptr
  %preempt_count.i.i.i87 = getelementptr inbounds %struct.thread_info, ptr %32, i32 0, i32 1
  %33 = ptrtoint ptr %preempt_count.i.i.i87 to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load volatile i32, ptr %preempt_count.i.i.i87, align 4
  %sub.i.i = add i32 %34, -1
  store volatile i32 %sub.i.i, ptr %preempt_count.i.i.i87, align 4
  br label %if.end69

if.end69:                                         ; preds = %do.end67, %cpu_online.exit85, %cpu_online.exit
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__traceiter_sched_stat_runtime(ptr noundef, ptr noundef, i64 noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @cpuacct_charge(ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @__cgroup_account_cputime(ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @generic_atomic64_add(i64 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @hrtick_start(ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @uclamp_eff_value(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__msecs_to_jiffies(i32 noundef) local_unnamed_addr #4

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @trace_sched_cpu_capacity_tp(ptr noundef %rq) unnamed_addr #7 align 64 {
entry:
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_cpu_capacity_tp, i32 0, i32 1), ptr blockaddress(@trace_sched_cpu_capacity_tp, %do.body)) #20
          to label %if.end48 [label %do.body], !srcloc !261

do.body:                                          ; preds = %entry
  %0 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 3
  %2 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %4 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i = icmp ugt i32 %4, %3
  br i1 %cmp.not.i.i.i.i, label %cpu_online.exit, label %land.rhs.i.i.i.i

land.rhs.i.i.i.i:                                 ; preds = %do.body
  %.b37.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i, label %cpu_online.exit, label %if.then.i.i.i.i, !prof !259

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_online.exit

cpu_online.exit:                                  ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i.i, %do.body
  %div3.i.i.i = lshr i32 %3, 5
  %arrayidx.i.i.i = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i
  %5 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %arrayidx.i.i.i, align 4
  %and.i.i.i75 = and i32 %3, 31
  %7 = shl nuw i32 1, %and.i.i.i75
  %8 = and i32 %6, %7
  %tobool.i.not = icmp eq i32 %8, 0
  br i1 %tobool.i.not, label %if.end69, label %cleanup.thread

cleanup.thread:                                   ; preds = %cpu_online.exit
  %9 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i = and i32 %9, -16384
  %10 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %10, i32 0, i32 1
  %11 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %preempt_count.i.i, align 4
  %add.i = add i32 %12, 1
  store volatile i32 %add.i, ptr %preempt_count.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !299
  %call42 = tail call i32 @__traceiter_sched_cpu_capacity_tp(ptr noundef null, ptr noundef %rq) #20
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !300
  %13 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i73 = and i32 %13, -16384
  %14 = inttoptr i32 %and.i.i.i73 to ptr
  %preempt_count.i.i74 = getelementptr inbounds %struct.thread_info, ptr %14, i32 0, i32 1
  %15 = ptrtoint ptr %preempt_count.i.i74 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %preempt_count.i.i74, align 4
  %sub.i = add i32 %16, -1
  store volatile i32 %sub.i, ptr %preempt_count.i.i74, align 4
  br label %if.end48

if.end48:                                         ; preds = %cleanup.thread, %entry
  %17 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i76 = and i32 %17, -16384
  %18 = inttoptr i32 %and.i76 to ptr
  %cpu50 = getelementptr inbounds %struct.thread_info, ptr %18, i32 0, i32 3
  %19 = ptrtoint ptr %cpu50 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %cpu50, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %21 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i77 = icmp ugt i32 %21, %20
  br i1 %cmp.not.i.i.i.i77, label %cpu_online.exit85, label %land.rhs.i.i.i.i79

land.rhs.i.i.i.i79:                               ; preds = %if.end48
  %.b37.i.i.i.i78 = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i78, label %cpu_online.exit85, label %if.then.i.i.i.i80, !prof !259

if.then.i.i.i.i80:                                ; preds = %land.rhs.i.i.i.i79
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_online.exit85

cpu_online.exit85:                                ; preds = %if.then.i.i.i.i80, %land.rhs.i.i.i.i79, %if.end48
  %div3.i.i.i81 = lshr i32 %20, 5
  %arrayidx.i.i.i82 = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i81
  %22 = ptrtoint ptr %arrayidx.i.i.i82 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %arrayidx.i.i.i82, align 4
  %and.i.i.i83 = and i32 %20, 31
  %24 = shl nuw i32 1, %and.i.i.i83
  %25 = and i32 %23, %24
  %tobool.i84.not = icmp eq i32 %25, 0
  br i1 %tobool.i84.not, label %if.end69, label %if.then52

if.then52:                                        ; preds = %cpu_online.exit85
  %26 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i = and i32 %26, -16384
  %27 = inttoptr i32 %and.i.i.i.i to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %27, i32 0, i32 1
  %28 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %add.i.i = add i32 %29, 1
  store volatile i32 %add.i.i, ptr %preempt_count.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !293
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_cpu_capacity_tp, i32 0, i32 7) to i32))
  %30 = load volatile ptr, ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_cpu_capacity_tp, i32 0, i32 7), align 4
  %call58 = tail call i32 @rcu_read_lock_sched_held() #20
  %tobool59.not = icmp eq i32 %call58, 0
  br i1 %tobool59.not, label %land.lhs.true, label %do.end67

land.lhs.true:                                    ; preds = %if.then52
  %call60 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool61.not = icmp eq i32 %call60, 0
  br i1 %tobool61.not, label %do.end67, label %land.lhs.true62

land.lhs.true62:                                  ; preds = %land.lhs.true
  %.b72 = load i1, ptr @trace_sched_cpu_capacity_tp.__warned, align 1
  br i1 %.b72, label %do.end67, label %if.then64

if.then64:                                        ; preds = %land.lhs.true62
  store i1 true, ptr @trace_sched_cpu_capacity_tp.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.15, i32 noundef 717, ptr noundef nonnull @.str.16) #20
  br label %do.end67

do.end67:                                         ; preds = %if.then64, %land.lhs.true62, %land.lhs.true, %if.then52
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !294
  %31 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i86 = and i32 %31, -16384
  %32 = inttoptr i32 %and.i.i.i.i86 to ptr
  %preempt_count.i.i.i87 = getelementptr inbounds %struct.thread_info, ptr %32, i32 0, i32 1
  %33 = ptrtoint ptr %preempt_count.i.i.i87 to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load volatile i32, ptr %preempt_count.i.i.i87, align 4
  %sub.i.i = add i32 %34, -1
  store volatile i32 %sub.i.i, ptr %preempt_count.i.i.i87, align 4
  br label %if.end69

if.end69:                                         ; preds = %do.end67, %cpu_online.exit85, %cpu_online.exit
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__traceiter_sched_cpu_capacity_tp(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind readonly
declare i32 @llvm.read_register.i32(metadata) #17

; Function Attrs: null_pointer_is_valid
declare dso_local void @_clear_bit(i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @housekeeping_test_cpu(i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @_set_bit(i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @cpumask_next_wrap(i32 noundef, ptr noundef, i32 noundef, i1 noundef zeroext) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @idle_cpu(i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @rebalance_domains(ptr noundef %rq, i32 noundef %idle) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %continue_balancing = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %continue_balancing) #20
  %0 = ptrtoint ptr %continue_balancing to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 1, ptr %continue_balancing, align 4
  %cpu1 = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 46
  %1 = ptrtoint ptr %cpu1 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %cpu1, align 4
  %cmp.not = icmp eq i32 %idle, 0
  br i1 %cmp.not, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %2
  %3 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %4, ptrtoint (ptr @runqueues to i32)
  %5 = inttoptr i32 %add.i to ptr
  %nr_running.i.i = getelementptr inbounds %struct.rq, ptr %5, i32 0, i32 1
  %6 = ptrtoint ptr %nr_running.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %nr_running.i.i, align 4
  %idle_h_nr_running.i.i = getelementptr inbounds %struct.rq, ptr %5, i32 0, i32 14, i32 4
  %8 = ptrtoint ptr %idle_h_nr_running.i.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %idle_h_nr_running.i.i, align 4
  %cmp.i.i = icmp ne i32 %7, %9
  %tobool.i.i = icmp eq i32 %7, 0
  %tobool.not = or i1 %tobool.i.i, %cmp.i.i
  %phi.cast = zext i1 %tobool.not to i32
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %10 = phi i32 [ 0, %entry ], [ %phi.cast, %land.rhs ]
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %11 = load volatile i32, ptr @jiffies, align 128
  %add = add i32 %11, 6000
  %12 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i = and i32 %12, -16384
  %13 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 1
  %14 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %15, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !268
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #20
  %call.i = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %land.end
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 696, ptr noundef nonnull @.str.28) #20
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %land.end
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %2
  %16 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %arrayidx, align 4
  %add7 = add i32 %17, ptrtoint (ptr @runqueues to i32)
  %18 = inttoptr i32 %add7 to ptr
  %sd8 = getelementptr inbounds %struct.rq, ptr %18, i32 0, i32 36
  %19 = ptrtoint ptr %sd8 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load volatile ptr, ptr %sd8, align 4
  %call.i118 = tail call i32 @lock_is_held_type(ptr noundef getelementptr inbounds (%struct.mutex, ptr @sched_domains_mutex, i32 0, i32 5), i32 noundef -1) #20
  %tobool11.not = icmp eq i32 %call.i118, 0
  br i1 %tobool11.not, label %lor.lhs.false, label %do.end19

lor.lhs.false:                                    ; preds = %rcu_read_lock.exit
  %call12 = tail call i32 @rcu_read_lock_held() #20
  %tobool13.not = icmp eq i32 %call12, 0
  br i1 %tobool13.not, label %land.lhs.true, label %do.end19

land.lhs.true:                                    ; preds = %lor.lhs.false
  %call14 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool15.not = icmp eq i32 %call14, 0
  br i1 %tobool15.not, label %do.end19, label %land.lhs.true16

land.lhs.true16:                                  ; preds = %land.lhs.true
  %.b115 = load i1, ptr @rebalance_domains.__warned, align 1
  br i1 %.b115, label %do.end19, label %if.then

if.then:                                          ; preds = %land.lhs.true16
  store i1 true, ptr @rebalance_domains.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 10275, ptr noundef nonnull @.str.16) #20
  br label %do.end19

do.end19:                                         ; preds = %if.then, %land.lhs.true16, %land.lhs.true, %lor.lhs.false, %rcu_read_lock.exit
  %tobool21.not186 = icmp eq ptr %20, null
  br i1 %tobool21.not186, label %if.end78, label %for.body

for.body:                                         ; preds = %for.inc, %do.end19
  %idle.addr.0200 = phi i32 [ %idle.addr.4, %for.inc ], [ %idle, %do.end19 ]
  %busy.0197 = phi i32 [ %busy.4, %for.inc ], [ %10, %do.end19 ]
  %sd.0192 = phi ptr [ %68, %for.inc ], [ %20, %do.end19 ]
  %next_balance.0190 = phi i32 [ %next_balance.1, %for.inc ], [ %add, %do.end19 ]
  %update_next_balance.0188 = phi i32 [ %update_next_balance.1, %for.inc ], [ 0, %do.end19 ]
  %max_cost.0187 = phi i64 [ %add23169, %for.inc ], [ 0, %do.end19 ]
  %max_newidle_lb_cost.i = getelementptr inbounds %struct.sched_domain, ptr %sd.0192, i32 0, i32 14
  %21 = ptrtoint ptr %max_newidle_lb_cost.i to i32
  call void @__asan_load8_noabort(i32 %21)
  %22 = load i64, ptr %max_newidle_lb_cost.i, align 8
  %last_decay_max_lb_cost2.i = getelementptr inbounds %struct.sched_domain, ptr %sd.0192, i32 0, i32 15
  %23 = ptrtoint ptr %last_decay_max_lb_cost2.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %last_decay_max_lb_cost2.i, align 8
  %add.i119 = add i32 %24, 100
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %25 = load volatile i32, ptr @jiffies, align 128
  %sub.i = sub i32 %add.i119, %25
  %cmp3.i = icmp slt i32 %sub.i, 0
  br i1 %cmp3.i, label %update_newidle_cost.exit, label %update_newidle_cost.exit.thread

update_newidle_cost.exit:                         ; preds = %for.body
  %mul.i = mul i64 %22, 253
  %div16.i = lshr i64 %mul.i, 8
  %26 = ptrtoint ptr %max_newidle_lb_cost.i to i32
  call void @__asan_store8_noabort(i32 %26)
  store i64 %div16.i, ptr %max_newidle_lb_cost.i, align 8
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %27 = load volatile i32, ptr @jiffies, align 128
  %28 = ptrtoint ptr %last_decay_max_lb_cost2.i to i32
  call void @__asan_store4_noabort(i32 %28)
  store i32 %27, ptr %last_decay_max_lb_cost2.i, align 8
  %add23 = add i64 %div16.i, %max_cost.0187
  %29 = ptrtoint ptr %continue_balancing to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %continue_balancing, align 4
  %tobool24.not = icmp eq i32 %30, 0
  br i1 %tobool24.not, label %for.inc, label %if.end29

update_newidle_cost.exit.thread:                  ; preds = %for.body
  %31 = ptrtoint ptr %max_newidle_lb_cost.i to i32
  call void @__asan_load8_noabort(i32 %31)
  %32 = load i64, ptr %max_newidle_lb_cost.i, align 8
  %add23163 = add i64 %32, %max_cost.0187
  %33 = ptrtoint ptr %continue_balancing to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %continue_balancing, align 4
  %tobool24.not164 = icmp eq i32 %34, 0
  br i1 %tobool24.not164, label %if.end78, label %if.end29

if.end29:                                         ; preds = %update_newidle_cost.exit.thread, %update_newidle_cost.exit
  %add23170 = phi i64 [ %add23163, %update_newidle_cost.exit.thread ], [ %add23, %update_newidle_cost.exit ]
  %conv167 = phi i32 [ 0, %update_newidle_cost.exit.thread ], [ 1, %update_newidle_cost.exit ]
  %balance_interval.i = getelementptr inbounds %struct.sched_domain, ptr %sd.0192, i32 0, i32 12
  %35 = ptrtoint ptr %balance_interval.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %balance_interval.i, align 8
  %tobool.not.i120 = icmp eq i32 %busy.0197, 0
  br i1 %tobool.not.i120, label %if.else.i.i, label %if.then.i122

if.then.i122:                                     ; preds = %if.end29
  %busy_factor.i = getelementptr inbounds %struct.sched_domain, ptr %sd.0192, i32 0, i32 5
  %37 = ptrtoint ptr %busy_factor.i to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %busy_factor.i, align 4
  %mul.i121 = mul i32 %38, %36
  br label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i122, %if.end29
  %interval.0.i = phi i32 [ %mul.i121, %if.then.i122 ], [ %36, %if.end29 ]
  %call2.i.i = tail call i32 @__msecs_to_jiffies(i32 noundef %interval.0.i) #20
  %not.tobool.not.i = xor i1 %tobool.not.i120, true
  %sub.i124 = sext i1 %not.tobool.not.i to i32
  %spec.select.i = add i32 %call2.i.i, %sub.i124
  %39 = tail call i32 @llvm.umax.i32(i32 %spec.select.i, i32 1) #20
  %40 = load i32, ptr @max_load_balance_interval, align 4
  %41 = tail call i32 @llvm.umin.i32(i32 %39, i32 %40) #20
  %flags = getelementptr inbounds %struct.sched_domain, ptr %sd.0192, i32 0, i32 9
  %42 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load i32, ptr %flags, align 4
  %and = and i32 %43, 512
  %tobool31.not = icmp eq i32 %and, 0
  br i1 %tobool31.not, label %if.end37, label %if.then32

if.then32:                                        ; preds = %if.else.i.i
  %call.i117 = tail call i32 @_raw_spin_trylock(ptr noundef nonnull @balancing) #20
  %tobool34.not = icmp eq i32 %call.i117, 0
  br i1 %tobool34.not, label %out, label %if.end37

if.end37:                                         ; preds = %if.then32, %if.else.i.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %44 = load volatile i32, ptr @jiffies, align 128
  %last_balance = getelementptr inbounds %struct.sched_domain, ptr %sd.0192, i32 0, i32 11
  %45 = ptrtoint ptr %last_balance to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load i32, ptr %last_balance, align 4
  %47 = add i32 %41, %46
  %sub = sub i32 %44, %47
  %cmp39 = icmp sgt i32 %sub, -1
  br i1 %cmp39, label %if.then41, label %if.end58

if.then41:                                        ; preds = %if.end37
  %call42 = call fastcc i32 @load_balance(i32 noundef %2, ptr noundef %rq, ptr noundef nonnull %sd.0192, i32 noundef %idle.addr.0200, ptr noundef nonnull %continue_balancing)
  %tobool43.not = icmp eq i32 %call42, 0
  br i1 %tobool43.not, label %if.end55, label %if.then44

if.then44:                                        ; preds = %if.then41
  %call45 = tail call i32 @idle_cpu(i32 noundef %2) #20
  %tobool46.not = icmp eq i32 %call45, 0
  %cond = zext i1 %tobool46.not to i32
  br i1 %tobool46.not, label %land.rhs49, label %land.end53

land.rhs49:                                       ; preds = %if.then44
  %48 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load i32, ptr %arrayidx, align 4
  %add.i126 = add i32 %49, ptrtoint (ptr @runqueues to i32)
  %50 = inttoptr i32 %add.i126 to ptr
  %nr_running.i.i127 = getelementptr inbounds %struct.rq, ptr %50, i32 0, i32 1
  %51 = ptrtoint ptr %nr_running.i.i127 to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load i32, ptr %nr_running.i.i127, align 4
  %idle_h_nr_running.i.i128 = getelementptr inbounds %struct.rq, ptr %50, i32 0, i32 14, i32 4
  %53 = ptrtoint ptr %idle_h_nr_running.i.i128 to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load i32, ptr %idle_h_nr_running.i.i128, align 4
  %cmp.i.i129 = icmp ne i32 %52, %54
  %tobool.i.i130 = icmp eq i32 %52, 0
  %tobool51.not = or i1 %tobool.i.i130, %cmp.i.i129
  br label %land.end53

land.end53:                                       ; preds = %land.rhs49, %if.then44
  %55 = phi i1 [ false, %if.then44 ], [ %tobool51.not, %land.rhs49 ]
  %land.ext54 = zext i1 %55 to i32
  br label %if.end55

if.end55:                                         ; preds = %land.end53, %if.then41
  %busy.1 = phi i32 [ %land.ext54, %land.end53 ], [ %busy.0197, %if.then41 ]
  %idle.addr.1 = phi i32 [ %cond, %land.end53 ], [ %idle.addr.0200, %if.then41 ]
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %56 = load volatile i32, ptr @jiffies, align 128
  %57 = ptrtoint ptr %last_balance to i32
  call void @__asan_store4_noabort(i32 %57)
  store i32 %56, ptr %last_balance, align 4
  %58 = ptrtoint ptr %balance_interval.i to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load i32, ptr %balance_interval.i, align 8
  %tobool.not.i133 = icmp eq i32 %busy.1, 0
  br i1 %tobool.not.i133, label %if.else.i.i145, label %if.then.i136

if.then.i136:                                     ; preds = %if.end55
  %busy_factor.i134 = getelementptr inbounds %struct.sched_domain, ptr %sd.0192, i32 0, i32 5
  %60 = ptrtoint ptr %busy_factor.i134 to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load i32, ptr %busy_factor.i134, align 4
  %mul.i135 = mul i32 %61, %59
  br label %if.else.i.i145

if.else.i.i145:                                   ; preds = %if.then.i136, %if.end55
  %interval.0.i137 = phi i32 [ %mul.i135, %if.then.i136 ], [ %59, %if.end55 ]
  %call2.i.i144 = tail call i32 @__msecs_to_jiffies(i32 noundef %interval.0.i137) #20
  %not.tobool.not.i147 = xor i1 %tobool.not.i133, true
  %sub.i148 = sext i1 %not.tobool.not.i147 to i32
  %spec.select.i149 = add i32 %call2.i.i144, %sub.i148
  %62 = tail call i32 @llvm.umax.i32(i32 %spec.select.i149, i32 1) #20
  %63 = load i32, ptr @max_load_balance_interval, align 4
  %64 = tail call i32 @llvm.umin.i32(i32 %62, i32 %63) #20
  br label %if.end58

if.end58:                                         ; preds = %if.else.i.i145, %if.end37
  %interval.0 = phi i32 [ %64, %if.else.i.i145 ], [ %41, %if.end37 ]
  %busy.2 = phi i32 [ %busy.1, %if.else.i.i145 ], [ %busy.0197, %if.end37 ]
  %idle.addr.2 = phi i32 [ %idle.addr.1, %if.else.i.i145 ], [ %idle.addr.0200, %if.end37 ]
  br i1 %tobool31.not, label %out, label %if.then60

if.then60:                                        ; preds = %if.end58
  tail call void @_raw_spin_unlock(ptr noundef nonnull @balancing) #20
  br label %out

out:                                              ; preds = %if.then60, %if.end58, %if.then32
  %interval.1 = phi i32 [ %interval.0, %if.then60 ], [ %interval.0, %if.end58 ], [ %41, %if.then32 ]
  %busy.3 = phi i32 [ %busy.2, %if.then60 ], [ %busy.2, %if.end58 ], [ %busy.0197, %if.then32 ]
  %idle.addr.3 = phi i32 [ %idle.addr.2, %if.then60 ], [ %idle.addr.2, %if.end58 ], [ %idle.addr.0200, %if.then32 ]
  %last_balance62 = getelementptr inbounds %struct.sched_domain, ptr %sd.0192, i32 0, i32 11
  %65 = ptrtoint ptr %last_balance62 to i32
  call void @__asan_load4_noabort(i32 %65)
  %66 = load i32, ptr %last_balance62, align 4
  %add63 = add i32 %66, %interval.1
  %sub64 = sub i32 %add63, %next_balance.0190
  %cmp65 = icmp slt i32 %sub64, 0
  %spec.select = select i1 %cmp65, i32 1, i32 %update_next_balance.0188
  %spec.select116 = select i1 %cmp65, i32 %add63, i32 %next_balance.0190
  br label %for.inc

for.inc:                                          ; preds = %out, %update_newidle_cost.exit
  %add23169 = phi i64 [ %add23170, %out ], [ %add23, %update_newidle_cost.exit ]
  %conv166 = phi i32 [ %conv167, %out ], [ 1, %update_newidle_cost.exit ]
  %update_next_balance.1 = phi i32 [ %spec.select, %out ], [ %update_next_balance.0188, %update_newidle_cost.exit ]
  %next_balance.1 = phi i32 [ %spec.select116, %out ], [ %next_balance.0190, %update_newidle_cost.exit ]
  %busy.4 = phi i32 [ %busy.3, %out ], [ %busy.0197, %update_newidle_cost.exit ]
  %idle.addr.4 = phi i32 [ %idle.addr.3, %out ], [ %idle.addr.0200, %update_newidle_cost.exit ]
  %67 = ptrtoint ptr %sd.0192 to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load ptr, ptr %sd.0192, align 8
  %tobool21.not = icmp eq ptr %68, null
  br i1 %tobool21.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc
  %tobool71.not = icmp eq i32 %conv166, 0
  br i1 %tobool71.not, label %if.end78, label %if.then72

if.then72:                                        ; preds = %for.end
  %69 = load i32, ptr @sysctl_sched_migration_cost, align 4
  %conv73 = zext i32 %69 to i64
  %70 = tail call i64 @llvm.umax.i64(i64 %add23169, i64 %conv73)
  %max_idle_balance_cost = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 58
  %71 = ptrtoint ptr %max_idle_balance_cost to i32
  call void @__asan_store8_noabort(i32 %71)
  store i64 %70, ptr %max_idle_balance_cost, align 32
  br label %if.end78

if.end78:                                         ; preds = %if.then72, %for.end, %update_newidle_cost.exit.thread, %do.end19
  %update_next_balance.0183 = phi i32 [ %update_next_balance.1, %if.then72 ], [ %update_next_balance.1, %for.end ], [ 0, %do.end19 ], [ %update_next_balance.0188, %update_newidle_cost.exit.thread ]
  %next_balance.0181 = phi i32 [ %next_balance.1, %if.then72 ], [ %next_balance.1, %for.end ], [ %add, %do.end19 ], [ %next_balance.0190, %update_newidle_cost.exit.thread ]
  %call.i151 = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i151, label %rcu_read_unlock.exit, label %land.lhs.true.i154

land.lhs.true.i154:                               ; preds = %if.end78
  %call1.i152 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i153 = icmp eq i32 %call1.i152, 0
  br i1 %tobool.not.i153, label %rcu_read_unlock.exit, label %land.lhs.true2.i156

land.lhs.true2.i156:                              ; preds = %land.lhs.true.i154
  %.b4.i155 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i155, label %rcu_read_unlock.exit, label %if.then.i157

if.then.i157:                                     ; preds = %land.lhs.true2.i156
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i157, %land.lhs.true2.i156, %land.lhs.true.i154, %if.end78
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %72 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i158 = and i32 %72, -16384
  %73 = inttoptr i32 %and.i.i.i.i.i158 to ptr
  %preempt_count.i.i.i.i159 = getelementptr inbounds %struct.thread_info, ptr %73, i32 0, i32 1
  %74 = ptrtoint ptr %preempt_count.i.i.i.i159 to i32
  call void @__asan_load4_noabort(i32 %74)
  %75 = load volatile i32, ptr %preempt_count.i.i.i.i159, align 4
  %sub.i.i.i160 = add i32 %75, -1
  store volatile i32 %sub.i.i.i160, ptr %preempt_count.i.i.i.i159, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  %tobool79.not = icmp eq i32 %update_next_balance.0183, 0
  br i1 %tobool79.not, label %if.end85, label %if.then83, !prof !260

if.then83:                                        ; preds = %rcu_read_unlock.exit
  %next_balance84 = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 23
  %76 = ptrtoint ptr %next_balance84 to i32
  call void @__asan_store4_noabort(i32 %76)
  store i32 %next_balance.0181, ptr %next_balance84, align 4
  br label %if.end85

if.end85:                                         ; preds = %if.then83, %rcu_read_unlock.exit
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %continue_balancing) #20
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @update_blocked_averages(i32 noundef %cpu) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %cpu
  %0 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %arrayidx, align 4
  %add = add i32 %1, ptrtoint (ptr @runqueues to i32)
  %2 = inttoptr i32 %add to ptr
  %3 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #20, !srcloc !279
  %and.i.i.i = and i32 %3, 128
  %tobool.not.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i.i, label %if.then.i.i, label %_raw_spin_rq_lock_irqsave.exit.i

if.then.i.i:                                      ; preds = %entry
  tail call void @trace_hardirqs_off() #20
  br label %_raw_spin_rq_lock_irqsave.exit.i

_raw_spin_rq_lock_irqsave.exit.i:                 ; preds = %if.then.i.i, %entry
  tail call void @raw_spin_rq_lock_nested(ptr noundef %2, i32 noundef 0) #20
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 81
  %4 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %5, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %_raw_spin_rq_lock_irqsave.exit.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 79
  %6 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %_raw_spin_rq_lock_irqsave.exit.i
  %retval.0.i.i.i = phi ptr [ %7, %if.then.i.i.i ], [ %2, %_raw_spin_rq_lock_irqsave.exit.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call1.i.i = tail call i32 @lock_pin_lock(ptr noundef %dep_map.i.i) #20
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 25
  %8 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %clock_update_flags.i.i, align 4
  %and.i.i = and i32 %9, 3
  store i32 %and.i.i, ptr %clock_update_flags.i.i, align 4
  %balance_callback.i.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 39
  %10 = ptrtoint ptr %balance_callback.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %balance_callback.i.i, align 8
  %tobool.not.i3.i = icmp ne ptr %11, null
  %cmp.i.i = icmp ne ptr %11, @balance_push_callback
  %spec.select.i.i = and i1 %tobool.not.i3.i, %cmp.i.i
  br i1 %spec.select.i.i, label %land.rhs6.i.i, label %rq_lock_irqsave.exit

land.rhs6.i.i:                                    ; preds = %__rq_lockp.exit.i.i
  %.b48.i.i = load i1, ptr @rq_pin_lock.__already_done, align 1
  br i1 %.b48.i.i, label %rq_lock_irqsave.exit, label %if.then.i4.i, !prof !259

if.then.i4.i:                                     ; preds = %land.rhs6.i.i
  store i1 true, ptr @rq_pin_lock.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1545, i32 noundef 9, ptr noundef nonnull @.str.35) #20
  br label %rq_lock_irqsave.exit

rq_lock_irqsave.exit:                             ; preds = %if.then.i4.i, %land.rhs6.i.i, %__rq_lockp.exit.i.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %12 = load volatile i32, ptr @jiffies, align 128
  %last_blocked_load_update_tick.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 2
  %13 = ptrtoint ptr %last_blocked_load_update_tick.i to i32
  call void @__asan_store4_noabort(i32 %13)
  store volatile i32 %12, ptr %last_blocked_load_update_tick.i, align 16
  tail call void @update_rq_clock(ptr noundef %2) #20
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %14 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i.i23 = icmp eq i32 %14, 0
  br i1 %tobool.not.i.i.i23, label %lockdep_assert_rq_held.exit.i.i, label %land.rhs.i.i.i

land.rhs.i.i.i:                                   ; preds = %rq_lock_irqsave.exit
  %15 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i.i = icmp eq i32 %16, 0
  br i1 %tobool.not.i.i.i.i, label %__rq_lockp.exit.i.i.i, label %if.then.i.i.i.i

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i
  %core.i.i.i.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 79
  %17 = ptrtoint ptr %core.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %core.i.i.i.i, align 8
  br label %__rq_lockp.exit.i.i.i

__rq_lockp.exit.i.i.i:                            ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i
  %retval.0.i.i.i.i = phi ptr [ %18, %if.then.i.i.i.i ], [ %2, %land.rhs.i.i.i ]
  %dep_map.i.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i.i, i32 0, i32 4
  %call.i.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i.i, i32 noundef -1) #20
  %cmp.not.i.i.i = icmp eq i32 %call.i.i.i.i, 0
  br i1 %cmp.not.i.i.i, label %do.end.i.i.i, label %lockdep_assert_rq_held.exit.i.i, !prof !260

do.end.i.i.i:                                     ; preds = %__rq_lockp.exit.i.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i.i

lockdep_assert_rq_held.exit.i.i:                  ; preds = %do.end.i.i.i, %__rq_lockp.exit.i.i.i, %rq_lock_irqsave.exit
  %19 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %clock_update_flags.i.i, align 4
  %cmp.i.i.i = icmp ult i32 %20, 2
  br i1 %cmp.i.i.i, label %land.rhs.i4.i.i, label %rq_clock_pelt.exit.i

land.rhs.i4.i.i:                                  ; preds = %lockdep_assert_rq_held.exit.i.i
  %.b37.i.i.i = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i.i, label %rq_clock_pelt.exit.i, label %if.then.i.i.i24, !prof !259

if.then.i.i.i24:                                  ; preds = %land.rhs.i4.i.i
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %rq_clock_pelt.exit.i

rq_clock_pelt.exit.i:                             ; preds = %if.then.i.i.i24, %land.rhs.i4.i.i, %lockdep_assert_rq_held.exit.i.i
  %clock_pelt.i.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 29
  %21 = ptrtoint ptr %clock_pelt.i.i to i32
  call void @__asan_load8_noabort(i32 %21)
  %22 = load i64, ptr %clock_pelt.i.i, align 8
  %lost_idle_time.i.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 30
  %23 = ptrtoint ptr %lost_idle_time.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %lost_idle_time.i.i, align 16
  %conv.i.i = zext i32 %24 to i64
  %sub.i.i = sub i64 %22, %conv.i.i
  %curr.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 20
  %25 = ptrtoint ptr %curr.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load ptr, ptr %curr.i, align 8
  %sched_class.i = getelementptr inbounds %struct.task_struct, ptr %26, i32 0, i32 21
  %27 = ptrtoint ptr %sched_class.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %sched_class.i, align 32
  %cpu.i.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 46
  %29 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %cpu.i.i, align 4
  %arrayidx.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %30
  %31 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %arrayidx.i.i, align 4
  %add.i.i = add i32 %32, ptrtoint (ptr @thermal_pressure to i32)
  %33 = inttoptr i32 %add.i.i to ptr
  %34 = ptrtoint ptr %33 to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load i32, ptr %33, align 4
  %cmp.i = icmp eq ptr %28, @rt_sched_class
  %conv.i = zext i1 %cmp.i to i32
  %call3.i = tail call i32 @update_rt_rq_load_avg(i64 noundef %sub.i.i, ptr noundef %2, i32 noundef %conv.i) #20
  %cmp4.i = icmp eq ptr %28, @dl_sched_class
  %conv5.i = zext i1 %cmp4.i to i32
  %call6.i = tail call i32 @update_dl_rq_load_avg(i64 noundef %sub.i.i, ptr noundef %2, i32 noundef %conv5.i) #20
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %36 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i.i25.i = icmp eq i32 %36, 0
  br i1 %tobool.not.i.i.i25.i, label %lockdep_assert_rq_held.exit.i.i.i, label %land.rhs.i.i.i.i

land.rhs.i.i.i.i:                                 ; preds = %rq_clock_pelt.exit.i
  %37 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i.i.i = icmp eq i32 %38, 0
  br i1 %tobool.not.i.i.i.i.i, label %__rq_lockp.exit.i.i.i.i, label %if.then.i.i.i.i.i

if.then.i.i.i.i.i:                                ; preds = %land.rhs.i.i.i.i
  %core.i.i.i.i.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 79
  %39 = ptrtoint ptr %core.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load ptr, ptr %core.i.i.i.i.i, align 8
  br label %__rq_lockp.exit.i.i.i.i

__rq_lockp.exit.i.i.i.i:                          ; preds = %if.then.i.i.i.i.i, %land.rhs.i.i.i.i
  %retval.0.i.i.i.i.i = phi ptr [ %40, %if.then.i.i.i.i.i ], [ %2, %land.rhs.i.i.i.i ]
  %dep_map.i.i.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i.i.i, i32 0, i32 4
  %call.i.i.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i.i.i, i32 noundef -1) #20
  %cmp.not.i.i.i.i = icmp eq i32 %call.i.i.i.i.i, 0
  br i1 %cmp.not.i.i.i.i, label %do.end.i.i.i.i, label %lockdep_assert_rq_held.exit.i.i.i, !prof !260

do.end.i.i.i.i:                                   ; preds = %__rq_lockp.exit.i.i.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i.i.i

lockdep_assert_rq_held.exit.i.i.i:                ; preds = %do.end.i.i.i.i, %__rq_lockp.exit.i.i.i.i, %rq_clock_pelt.exit.i
  %41 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load i32, ptr %clock_update_flags.i.i, align 4
  %cmp.i.i.i.i = icmp ult i32 %42, 2
  br i1 %cmp.i.i.i.i, label %land.rhs.i3.i.i.i, label %rq_clock_thermal.exit.i

land.rhs.i3.i.i.i:                                ; preds = %lockdep_assert_rq_held.exit.i.i.i
  %.b37.i.i.i.i = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i.i.i, label %rq_clock_thermal.exit.i, label %if.then.i.i.i26.i, !prof !259

if.then.i.i.i26.i:                                ; preds = %land.rhs.i3.i.i.i
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %rq_clock_thermal.exit.i

rq_clock_thermal.exit.i:                          ; preds = %if.then.i.i.i26.i, %land.rhs.i3.i.i.i, %lockdep_assert_rq_held.exit.i.i.i
  %clock_task.i.i.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 28
  %43 = ptrtoint ptr %clock_task.i.i.i to i32
  call void @__asan_load8_noabort(i32 %43)
  %44 = load i64, ptr %clock_task.i.i.i, align 128
  %45 = load i32, ptr @sched_thermal_decay_shift, align 4
  %sh_prom.i.i = zext i32 %45 to i64
  %shr.i.i = lshr i64 %44, %sh_prom.i.i
  %conv8.i = zext i32 %35 to i64
  %call9.i = tail call i32 @update_thermal_load_avg(i64 noundef %shr.i.i, ptr noundef %2, i64 noundef %conv8.i) #20
  %call11.i = tail call i32 @update_irq_load_avg(ptr noundef %2, i64 noundef 0) #20
  %util_avg.i.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 50, i32 7
  %46 = ptrtoint ptr %util_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load volatile i32, ptr %util_avg.i.i, align 8
  %tobool.not.i.i25 = icmp eq i32 %47, 0
  br i1 %tobool.not.i.i25, label %do.end2.i.i, label %if.then.i

do.end2.i.i:                                      ; preds = %rq_clock_thermal.exit.i
  %util_avg4.i.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 51, i32 7
  %48 = ptrtoint ptr %util_avg4.i.i to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load volatile i32, ptr %util_avg4.i.i, align 8
  %tobool5.not.i.i = icmp eq i32 %49, 0
  br i1 %tobool5.not.i.i, label %if.end7.i.i, label %if.then.i

if.end7.i.i:                                      ; preds = %do.end2.i.i
  %load_avg.i.i.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 53, i32 5
  %50 = ptrtoint ptr %load_avg.i.i.i to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load volatile i32, ptr %load_avg.i.i.i, align 32
  %tobool8.not.i.i = icmp eq i32 %51, 0
  br i1 %tobool8.not.i.i, label %others_have_blocked.exit.i, label %if.then.i

others_have_blocked.exit.i:                       ; preds = %if.end7.i.i
  %util_avg14.i.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 52, i32 7
  %52 = ptrtoint ptr %util_avg14.i.i to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load volatile i32, ptr %util_avg14.i.i, align 8
  %tobool15.not.i.not.i = icmp eq i32 %53, 0
  br i1 %tobool15.not.i.not.i, label %__update_blocked_others.exit, label %if.then.i

if.then.i:                                        ; preds = %others_have_blocked.exit.i, %if.end7.i.i, %do.end2.i.i, %rq_clock_thermal.exit.i
  br label %__update_blocked_others.exit

__update_blocked_others.exit:                     ; preds = %if.then.i, %others_have_blocked.exit.i
  %done.0 = phi i8 [ 1, %others_have_blocked.exit.i ], [ 0, %if.then.i ]
  %or.i = or i32 %call6.i, %call3.i
  %or10.i = or i32 %or.i, %call9.i
  %or12.i = or i32 %or10.i, %call11.i
  %tobool.i = icmp ne i32 %or12.i, 0
  %54 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load i32, ptr %cpu.i.i, align 4
  %leaf_cfs_rq_list.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 17
  %56 = ptrtoint ptr %leaf_cfs_rq_list.i to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load ptr, ptr %leaf_cfs_rq_list.i, align 8
  %cmp.not79.i = icmp eq ptr %57, %leaf_cfs_rq_list.i
  br i1 %cmp.not79.i, label %__update_blocked_fair.exit, label %for.body.lr.ph.i

for.body.lr.ph.i:                                 ; preds = %__update_blocked_others.exit
  %cfs.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 14
  br label %for.body.i

for.body.i:                                       ; preds = %if.end24.i, %for.body.lr.ph.i
  %done.1 = phi i8 [ %done.0, %for.body.lr.ph.i ], [ %done.2, %if.end24.i ]
  %.pn.in81.i = phi ptr [ %57, %for.body.lr.ph.i ], [ %.pn90.i, %if.end24.i ]
  %decayed.0.off080.i = phi i1 [ false, %for.body.lr.ph.i ], [ %decayed.1.off0.i, %if.end24.i ]
  %cfs_rq.089.i = getelementptr i8, ptr %.pn.in81.i, i32 -548
  %58 = ptrtoint ptr %.pn.in81.i to i32
  call void @__asan_load4_noabort(i32 %58)
  %.pn90.i = load ptr, ptr %.pn.in81.i, align 4
  %throttle_count.i.i = getelementptr i8, ptr %.pn.in81.i, i32 56
  %59 = ptrtoint ptr %throttle_count.i.i to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load i32, ptr %throttle_count.i.i, align 4
  %tobool.not.i.i27 = icmp eq i32 %60, 0
  br i1 %tobool.not.i.i27, label %if.end.i.i, label %if.then.i.i29, !prof !259

if.then.i.i29:                                    ; preds = %for.body.i
  %throttled_clock_task.i.i = getelementptr i8, ptr %.pn.in81.i, i32 36
  %61 = ptrtoint ptr %throttled_clock_task.i.i to i32
  call void @__asan_load8_noabort(i32 %61)
  %62 = load i64, ptr %throttled_clock_task.i.i, align 8
  %throttled_clock_task_time.i.i = getelementptr i8, ptr %.pn.in81.i, i32 44
  %63 = ptrtoint ptr %throttled_clock_task_time.i.i to i32
  call void @__asan_load8_noabort(i32 %63)
  %64 = load i64, ptr %throttled_clock_task_time.i.i, align 16
  %sub.i.i28 = sub i64 %62, %64
  br label %cfs_rq_clock_pelt.exit.i

if.end.i.i:                                       ; preds = %for.body.i
  %rq.i.i.i = getelementptr i8, ptr %.pn.in81.i, i32 -8
  %65 = ptrtoint ptr %rq.i.i.i to i32
  call void @__asan_load4_noabort(i32 %65)
  %66 = load ptr, ptr %rq.i.i.i, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %67 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i.i.i30 = icmp eq i32 %67, 0
  br i1 %tobool.not.i.i.i.i30, label %lockdep_assert_rq_held.exit.i.i.i43, label %land.rhs.i.i.i.i33

land.rhs.i.i.i.i33:                               ; preds = %if.end.i.i
  %core_enabled.i.i.i.i.i31 = getelementptr inbounds %struct.rq, ptr %66, i32 0, i32 81
  %68 = ptrtoint ptr %core_enabled.i.i.i.i.i31 to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load i32, ptr %core_enabled.i.i.i.i.i31, align 128
  %tobool.not.i.i.i.i.i32 = icmp eq i32 %69, 0
  br i1 %tobool.not.i.i.i.i.i32, label %__rq_lockp.exit.i.i.i.i40, label %if.then.i.i.i.i.i35

if.then.i.i.i.i.i35:                              ; preds = %land.rhs.i.i.i.i33
  %core.i.i.i.i.i34 = getelementptr inbounds %struct.rq, ptr %66, i32 0, i32 79
  %70 = ptrtoint ptr %core.i.i.i.i.i34 to i32
  call void @__asan_load4_noabort(i32 %70)
  %71 = load ptr, ptr %core.i.i.i.i.i34, align 8
  br label %__rq_lockp.exit.i.i.i.i40

__rq_lockp.exit.i.i.i.i40:                        ; preds = %if.then.i.i.i.i.i35, %land.rhs.i.i.i.i33
  %retval.0.i.i.i.i.i36 = phi ptr [ %71, %if.then.i.i.i.i.i35 ], [ %66, %land.rhs.i.i.i.i33 ]
  %dep_map.i.i.i.i37 = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i.i.i36, i32 0, i32 4
  %call.i.i.i.i.i38 = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i.i.i37, i32 noundef -1) #20
  %cmp.not.i.i.i.i39 = icmp eq i32 %call.i.i.i.i.i38, 0
  br i1 %cmp.not.i.i.i.i39, label %do.end.i.i.i.i41, label %lockdep_assert_rq_held.exit.i.i.i43, !prof !260

do.end.i.i.i.i41:                                 ; preds = %__rq_lockp.exit.i.i.i.i40
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i.i.i43

lockdep_assert_rq_held.exit.i.i.i43:              ; preds = %do.end.i.i.i.i41, %__rq_lockp.exit.i.i.i.i40, %if.end.i.i
  %clock_update_flags.i.i.i.i = getelementptr inbounds %struct.rq, ptr %66, i32 0, i32 25
  %72 = ptrtoint ptr %clock_update_flags.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %72)
  %73 = load i32, ptr %clock_update_flags.i.i.i.i, align 4
  %cmp.i.i.i.i42 = icmp ult i32 %73, 2
  br i1 %cmp.i.i.i.i42, label %land.rhs.i4.i.i.i, label %rq_clock_pelt.exit.i.i

land.rhs.i4.i.i.i:                                ; preds = %lockdep_assert_rq_held.exit.i.i.i43
  %.b37.i.i.i.i44 = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i.i.i44, label %rq_clock_pelt.exit.i.i, label %if.then.i.i.i.i45, !prof !259

if.then.i.i.i.i45:                                ; preds = %land.rhs.i4.i.i.i
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %rq_clock_pelt.exit.i.i

rq_clock_pelt.exit.i.i:                           ; preds = %if.then.i.i.i.i45, %land.rhs.i4.i.i.i, %lockdep_assert_rq_held.exit.i.i.i43
  %clock_pelt.i.i.i = getelementptr inbounds %struct.rq, ptr %66, i32 0, i32 29
  %74 = ptrtoint ptr %clock_pelt.i.i.i to i32
  call void @__asan_load8_noabort(i32 %74)
  %75 = load i64, ptr %clock_pelt.i.i.i, align 8
  %lost_idle_time.i.i.i = getelementptr inbounds %struct.rq, ptr %66, i32 0, i32 30
  %76 = ptrtoint ptr %lost_idle_time.i.i.i to i32
  call void @__asan_load4_noabort(i32 %76)
  %77 = load i32, ptr %lost_idle_time.i.i.i, align 16
  %conv.i.i.i = zext i32 %77 to i64
  %throttled_clock_task_time4.i.i = getelementptr i8, ptr %.pn.in81.i, i32 44
  %78 = ptrtoint ptr %throttled_clock_task_time4.i.i to i32
  call void @__asan_load8_noabort(i32 %78)
  %79 = load i64, ptr %throttled_clock_task_time4.i.i, align 16
  %80 = add i64 %79, %conv.i.i.i
  %sub5.i.i = sub i64 %75, %80
  br label %cfs_rq_clock_pelt.exit.i

cfs_rq_clock_pelt.exit.i:                         ; preds = %rq_clock_pelt.exit.i.i, %if.then.i.i29
  %retval.0.i.i = phi i64 [ %sub.i.i28, %if.then.i.i29 ], [ %sub5.i.i, %rq_clock_pelt.exit.i.i ]
  %call9.i46 = tail call fastcc i32 @update_cfs_rq_load_avg(i64 noundef %retval.0.i.i, ptr noundef %cfs_rq.089.i) #20
  %tobool.not.i = icmp eq i32 %call9.i46, 0
  br i1 %tobool.not.i, label %if.end12.i, label %if.then.i48

if.then.i48:                                      ; preds = %cfs_rq_clock_pelt.exit.i
  %load_avg.i.i = getelementptr i8, ptr %.pn.in81.i, i32 -388
  %81 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %81)
  %82 = load i32, ptr %load_avg.i.i, align 32
  %tg_load_avg_contrib.i.i = getelementptr i8, ptr %.pn.in81.i, i32 -36
  %83 = ptrtoint ptr %tg_load_avg_contrib.i.i to i32
  call void @__asan_load4_noabort(i32 %83)
  %84 = load i32, ptr %tg_load_avg_contrib.i.i, align 128
  %sub.i50.i = sub i32 %82, %84
  %tg.i.i = getelementptr i8, ptr %.pn.in81.i, i32 8
  %85 = ptrtoint ptr %tg.i.i to i32
  call void @__asan_load4_noabort(i32 %85)
  %86 = load ptr, ptr %tg.i.i, align 4
  %cmp.i.i47 = icmp ne ptr %86, @root_task_group
  %87 = tail call i32 @llvm.abs.i32(i32 %sub.i50.i, i1 false) #20
  %div21.i.i = lshr i32 %84, 6
  %cmp4.i.i = icmp ugt i32 %87, %div21.i.i
  %or.cond.i.i = select i1 %cmp.i.i47, i1 %cmp4.i.i, i1 false
  br i1 %or.cond.i.i, label %if.then5.i.i, label %update_tg_load_avg.exit.i

if.then5.i.i:                                     ; preds = %if.then.i48
  %load_avg7.i.i = getelementptr inbounds %struct.task_group, ptr %86, i32 0, i32 6
  %call.i.i.i.i49 = tail call zeroext i1 @__kasan_check_write(ptr noundef %load_avg7.i.i, i32 noundef 4) #20
  tail call void @llvm.prefetch.p0(ptr %load_avg7.i.i, i32 1, i32 3, i32 1) #20
  %88 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %load_avg7.i.i, ptr %load_avg7.i.i, i32 %sub.i50.i, ptr elementtype(i32) %load_avg7.i.i) #20, !srcloc !262
  %89 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %89)
  %90 = load i32, ptr %load_avg.i.i, align 32
  %91 = ptrtoint ptr %tg_load_avg_contrib.i.i to i32
  call void @__asan_store4_noabort(i32 %91)
  store i32 %90, ptr %tg_load_avg_contrib.i.i, align 128
  br label %update_tg_load_avg.exit.i

update_tg_load_avg.exit.i:                        ; preds = %if.then5.i.i, %if.then.i48
  %cmp10.i = icmp eq ptr %cfs_rq.089.i, %cfs.i
  %spec.select.i = select i1 %cmp10.i, i1 true, i1 %decayed.0.off080.i
  br label %if.end12.i

if.end12.i:                                       ; preds = %update_tg_load_avg.exit.i, %cfs_rq_clock_pelt.exit.i
  %decayed.1.off0.i = phi i1 [ %decayed.0.off080.i, %cfs_rq_clock_pelt.exit.i ], [ %spec.select.i, %update_tg_load_avg.exit.i ]
  %tg.i = getelementptr i8, ptr %.pn.in81.i, i32 8
  %92 = ptrtoint ptr %tg.i to i32
  call void @__asan_load4_noabort(i32 %92)
  %93 = load ptr, ptr %tg.i, align 4
  %se13.i = getelementptr inbounds %struct.task_group, ptr %93, i32 0, i32 1
  %94 = ptrtoint ptr %se13.i to i32
  call void @__asan_load4_noabort(i32 %94)
  %95 = load ptr, ptr %se13.i, align 8
  %arrayidx.i = getelementptr ptr, ptr %95, i32 %55
  %96 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %96)
  %97 = load ptr, ptr %arrayidx.i, align 4
  %tobool14.not.i = icmp eq ptr %97, null
  br i1 %tobool14.not.i, label %if.end18.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end12.i
  %my_q.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %97, i32 0, i32 12
  %98 = ptrtoint ptr %my_q.i.i.i to i32
  call void @__asan_load4_noabort(i32 %98)
  %99 = load ptr, ptr %my_q.i.i.i, align 4
  %load_avg.i51.i = getelementptr inbounds %struct.sched_entity, ptr %97, i32 0, i32 15, i32 5
  %100 = ptrtoint ptr %load_avg.i51.i to i32
  call void @__asan_load4_noabort(i32 %100)
  %101 = load i32, ptr %load_avg.i51.i, align 32
  %tobool.not.i52.i = icmp eq i32 %101, 0
  br i1 %tobool.not.i52.i, label %lor.lhs.false.i.i, label %if.then16.i

lor.lhs.false.i.i:                                ; preds = %land.lhs.true.i
  %util_avg.i.i50 = getelementptr inbounds %struct.sched_entity, ptr %97, i32 0, i32 15, i32 7
  %102 = ptrtoint ptr %util_avg.i.i50 to i32
  call void @__asan_load4_noabort(i32 %102)
  %103 = load i32, ptr %util_avg.i.i50, align 8
  %tobool2.not.i.i = icmp eq i32 %103, 0
  br i1 %tobool2.not.i.i, label %skip_blocked_update.exit.i, label %if.then16.i

skip_blocked_update.exit.i:                       ; preds = %lor.lhs.false.i.i
  %propagate.i.i = getelementptr inbounds %struct.cfs_rq, ptr %99, i32 0, i32 22
  %104 = ptrtoint ptr %propagate.i.i to i32
  call void @__asan_load4_noabort(i32 %104)
  %105 = load i32, ptr %propagate.i.i, align 4
  %tobool3.not.i.i = icmp eq i32 %105, 0
  br i1 %tobool3.not.i.i, label %if.end18.i, label %if.then16.i

if.then16.i:                                      ; preds = %skip_blocked_update.exit.i, %lor.lhs.false.i.i, %land.lhs.true.i
  %cfs_rq.i.i = getelementptr inbounds %struct.sched_entity, ptr %97, i32 0, i32 11
  %106 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %106)
  %107 = load ptr, ptr %cfs_rq.i.i, align 16
  tail call fastcc void @update_load_avg(ptr noundef %107, ptr noundef nonnull %97, i32 noundef 1) #20
  br label %if.end18.i

if.end18.i:                                       ; preds = %if.then16.i, %skip_blocked_update.exit.i, %if.end12.i
  %108 = ptrtoint ptr %cfs_rq.089.i to i32
  call void @__asan_load4_noabort(i32 %108)
  %109 = load i32, ptr %cfs_rq.089.i, align 128
  %tobool.not.i55.i = icmp eq i32 %109, 0
  br i1 %tobool.not.i55.i, label %if.end.i56.i, label %if.end21.i

if.end.i56.i:                                     ; preds = %if.end18.i
  %load_sum.i.i = getelementptr i8, ptr %.pn.in81.i, i32 -412
  %110 = ptrtoint ptr %load_sum.i.i to i32
  call void @__asan_load8_noabort(i32 %110)
  %111 = load i64, ptr %load_sum.i.i, align 8
  %tobool1.not.i.i = icmp eq i64 %111, 0
  br i1 %tobool1.not.i.i, label %if.end3.i.i, label %if.end21.i

if.end3.i.i:                                      ; preds = %if.end.i56.i
  %util_sum.i.i = getelementptr i8, ptr %.pn.in81.i, i32 -396
  %112 = ptrtoint ptr %util_sum.i.i to i32
  call void @__asan_load4_noabort(i32 %112)
  %113 = load i32, ptr %util_sum.i.i, align 8
  %tobool5.not.i.i51 = icmp eq i32 %113, 0
  br i1 %tobool5.not.i.i51, label %if.end7.i.i52, label %if.end21.i

if.end7.i.i52:                                    ; preds = %if.end3.i.i
  %runnable_sum.i.i = getelementptr i8, ptr %.pn.in81.i, i32 -404
  %114 = ptrtoint ptr %runnable_sum.i.i to i32
  call void @__asan_load8_noabort(i32 %114)
  %115 = load i64, ptr %runnable_sum.i.i, align 16
  %tobool9.not.i.i = icmp eq i64 %115, 0
  br i1 %tobool9.not.i.i, label %if.end11.i.i, label %if.end21.i

if.end11.i.i:                                     ; preds = %if.end7.i.i52
  %on_list.i.i.i = getelementptr i8, ptr %.pn.in81.i, i32 -4
  %116 = ptrtoint ptr %on_list.i.i.i to i32
  call void @__asan_load4_noabort(i32 %116)
  %117 = load i32, ptr %on_list.i.i.i, align 32
  %tobool.not.i.i.i53 = icmp eq i32 %117, 0
  br i1 %tobool.not.i.i.i53, label %if.else.i.i.i, label %if.then.i.i.i54

if.then.i.i.i54:                                  ; preds = %if.end11.i.i
  %prev1.i.i.i = getelementptr i8, ptr %.pn.in81.i, i32 4
  br label %child_cfs_rq_on_list.exit.i.i

if.else.i.i.i:                                    ; preds = %if.end11.i.i
  %rq.i.i.i.i = getelementptr i8, ptr %.pn.in81.i, i32 -8
  %118 = ptrtoint ptr %rq.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %118)
  %119 = load ptr, ptr %rq.i.i.i.i, align 4
  %tmp_alone_branch.i.i.i = getelementptr inbounds %struct.rq, ptr %119, i32 0, i32 18
  br label %child_cfs_rq_on_list.exit.i.i

child_cfs_rq_on_list.exit.i.i:                    ; preds = %if.else.i.i.i, %if.then.i.i.i54
  %prev.0.in.i.i.i = phi ptr [ %prev1.i.i.i, %if.then.i.i.i54 ], [ %tmp_alone_branch.i.i.i, %if.else.i.i.i ]
  %120 = ptrtoint ptr %prev.0.in.i.i.i to i32
  call void @__asan_load4_noabort(i32 %120)
  %prev.0.i.i.i = load ptr, ptr %prev.0.in.i.i.i, align 4
  %tg.i.i.i = getelementptr i8, ptr %prev.0.i.i.i, i32 8
  %121 = ptrtoint ptr %tg.i.i.i to i32
  call void @__asan_load4_noabort(i32 %121)
  %122 = load ptr, ptr %tg.i.i.i, align 4
  %parent.i.i.i = getelementptr inbounds %struct.task_group, ptr %122, i32 0, i32 12
  %123 = ptrtoint ptr %parent.i.i.i to i32
  call void @__asan_load4_noabort(i32 %123)
  %124 = load ptr, ptr %parent.i.i.i, align 8
  %125 = ptrtoint ptr %tg.i to i32
  call void @__asan_load4_noabort(i32 %125)
  %126 = load ptr, ptr %tg.i, align 4
  %cmp.i.i.i55 = icmp eq ptr %124, %126
  br i1 %cmp.i.i.i55, label %if.end21.i, label %if.end13.i.i

if.end13.i.i:                                     ; preds = %child_cfs_rq_on_list.exit.i.i
  %load_avg.i57.i = getelementptr i8, ptr %.pn.in81.i, i32 -388
  %127 = ptrtoint ptr %load_avg.i57.i to i32
  call void @__asan_load4_noabort(i32 %127)
  %128 = load i32, ptr %load_avg.i57.i, align 32
  %tobool15.not.i.i = icmp eq i32 %128, 0
  br i1 %tobool15.not.i.i, label %lor.lhs.false.i59.i, label %land.rhs.i.i

lor.lhs.false.i59.i:                              ; preds = %if.end13.i.i
  %util_avg.i58.i = getelementptr i8, ptr %.pn.in81.i, i32 -380
  %129 = ptrtoint ptr %util_avg.i58.i to i32
  call void @__asan_load4_noabort(i32 %129)
  %130 = load i32, ptr %util_avg.i58.i, align 8
  %tobool17.not.i.i = icmp eq i32 %130, 0
  br i1 %tobool17.not.i.i, label %lor.rhs.i.i, label %land.rhs.i.i

lor.rhs.i.i:                                      ; preds = %lor.lhs.false.i59.i
  %runnable_avg.i.i = getelementptr i8, ptr %.pn.in81.i, i32 -384
  %131 = ptrtoint ptr %runnable_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %131)
  %132 = load i32, ptr %runnable_avg.i.i, align 4
  %tobool19.not.i.i = icmp eq i32 %132, 0
  br i1 %tobool19.not.i.i, label %if.then20.i, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %lor.rhs.i.i, %lor.lhs.false.i59.i, %if.end13.i.i
  %.b66.i.i = load i1, ptr @cfs_rq_is_decayed.__already_done, align 1
  br i1 %.b66.i.i, label %if.then20.i, label %if.then27.i.i, !prof !259

if.then27.i.i:                                    ; preds = %land.rhs.i.i
  store i1 true, ptr @cfs_rq_is_decayed.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 3302, i32 noundef 9, ptr noundef nonnull @.str.11) #20
  br label %if.then20.i

if.then20.i:                                      ; preds = %if.then27.i.i, %land.rhs.i.i, %lor.rhs.i.i
  %133 = ptrtoint ptr %on_list.i.i.i to i32
  call void @__asan_load4_noabort(i32 %133)
  %134 = load i32, ptr %on_list.i.i.i, align 32
  %tobool.not.i61.i = icmp eq i32 %134, 0
  br i1 %tobool.not.i61.i, label %if.end21.i, label %if.then.i64.i

if.then.i64.i:                                    ; preds = %if.then20.i
  %rq.i.i62.i = getelementptr i8, ptr %.pn.in81.i, i32 -8
  %135 = ptrtoint ptr %rq.i.i62.i to i32
  call void @__asan_load4_noabort(i32 %135)
  %136 = load ptr, ptr %rq.i.i62.i, align 4
  %tmp_alone_branch.i.i = getelementptr inbounds %struct.rq, ptr %136, i32 0, i32 18
  %137 = ptrtoint ptr %tmp_alone_branch.i.i to i32
  call void @__asan_load4_noabort(i32 %137)
  %138 = load ptr, ptr %tmp_alone_branch.i.i, align 128
  %cmp.i63.i = icmp eq ptr %138, %.pn.in81.i
  br i1 %cmp.i63.i, label %if.then1.i.i, label %if.end.i66.i

if.then1.i.i:                                     ; preds = %if.then.i64.i
  %prev.i.i = getelementptr i8, ptr %.pn.in81.i, i32 4
  %139 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_load4_noabort(i32 %139)
  %140 = load ptr, ptr %prev.i.i, align 4
  %141 = ptrtoint ptr %tmp_alone_branch.i.i to i32
  call void @__asan_store4_noabort(i32 %141)
  store ptr %140, ptr %tmp_alone_branch.i.i, align 128
  br label %if.end.i66.i

if.end.i66.i:                                     ; preds = %if.then1.i.i, %if.then.i64.i
  %call.i.i.i65.i = tail call zeroext i1 @__list_del_entry_valid(ptr noundef %.pn.in81.i) #20
  br i1 %call.i.i.i65.i, label %if.end.i.i.i.i, label %list_del_rcu.exit.i.i

if.end.i.i.i.i:                                   ; preds = %if.end.i66.i
  %prev.i.i.i.i = getelementptr i8, ptr %.pn.in81.i, i32 4
  %142 = ptrtoint ptr %prev.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %142)
  %143 = load ptr, ptr %prev.i.i.i.i, align 4
  %144 = ptrtoint ptr %.pn.in81.i to i32
  call void @__asan_load4_noabort(i32 %144)
  %145 = load ptr, ptr %.pn.in81.i, align 4
  %prev1.i.i.i.i.i = getelementptr inbounds %struct.list_head, ptr %145, i32 0, i32 1
  %146 = ptrtoint ptr %prev1.i.i.i.i.i to i32
  call void @__asan_store4_noabort(i32 %146)
  store ptr %143, ptr %prev1.i.i.i.i.i, align 4
  %147 = ptrtoint ptr %143 to i32
  call void @__asan_store4_noabort(i32 %147)
  store volatile ptr %145, ptr %143, align 4
  br label %list_del_rcu.exit.i.i

list_del_rcu.exit.i.i:                            ; preds = %if.end.i.i.i.i, %if.end.i66.i
  %prev.i.i.i = getelementptr i8, ptr %.pn.in81.i, i32 4
  %148 = ptrtoint ptr %prev.i.i.i to i32
  call void @__asan_store4_noabort(i32 %148)
  store ptr inttoptr (i32 290 to ptr), ptr %prev.i.i.i, align 4
  %149 = ptrtoint ptr %on_list.i.i.i to i32
  call void @__asan_store4_noabort(i32 %149)
  store i32 0, ptr %on_list.i.i.i, align 32
  br label %if.end21.i

if.end21.i:                                       ; preds = %list_del_rcu.exit.i.i, %if.then20.i, %child_cfs_rq_on_list.exit.i.i, %if.end7.i.i52, %if.end3.i.i, %if.end.i56.i, %if.end18.i
  %load_avg.i67.i = getelementptr i8, ptr %.pn.in81.i, i32 -388
  %150 = ptrtoint ptr %load_avg.i67.i to i32
  call void @__asan_load4_noabort(i32 %150)
  %151 = load i32, ptr %load_avg.i67.i, align 32
  %tobool.not.i68.i = icmp eq i32 %151, 0
  br i1 %tobool.not.i68.i, label %cfs_rq_has_blocked.exit.i, label %if.then23.i

cfs_rq_has_blocked.exit.i:                        ; preds = %if.end21.i
  %util_avg.i69.i = getelementptr i8, ptr %.pn.in81.i, i32 -380
  %152 = ptrtoint ptr %util_avg.i69.i to i32
  call void @__asan_load4_noabort(i32 %152)
  %153 = load i32, ptr %util_avg.i69.i, align 8
  %tobool2.not.i70.not.i = icmp eq i32 %153, 0
  br i1 %tobool2.not.i70.not.i, label %if.end24.i, label %if.then23.i

if.then23.i:                                      ; preds = %cfs_rq_has_blocked.exit.i, %if.end21.i
  br label %if.end24.i

if.end24.i:                                       ; preds = %if.then23.i, %cfs_rq_has_blocked.exit.i
  %done.2 = phi i8 [ %done.1, %cfs_rq_has_blocked.exit.i ], [ 0, %if.then23.i ]
  %cmp.not.i = icmp eq ptr %.pn90.i, %leaf_cfs_rq_list.i
  br i1 %cmp.not.i, label %__update_blocked_fair.exit, label %for.body.i

__update_blocked_fair.exit:                       ; preds = %if.end24.i, %__update_blocked_others.exit
  %done.3 = phi i8 [ %done.0, %__update_blocked_others.exit ], [ %done.2, %if.end24.i ]
  %decayed.0.off0.lcssa.i = phi i1 [ false, %__update_blocked_others.exit ], [ %decayed.1.off0.i, %if.end24.i ]
  %or822 = or i1 %tobool.i, %decayed.0.off0.lcssa.i
  %tobool11.not = icmp eq i8 %done.3, 0
  br i1 %tobool11.not, label %update_blocked_load_status.exit, label %if.then.i56

if.then.i56:                                      ; preds = %__update_blocked_fair.exit
  %has_blocked_load.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 3
  %154 = ptrtoint ptr %has_blocked_load.i to i32
  call void @__asan_store4_noabort(i32 %154)
  store i32 0, ptr %has_blocked_load.i, align 4
  br label %update_blocked_load_status.exit

update_blocked_load_status.exit:                  ; preds = %if.then.i56, %__update_blocked_fair.exit
  br i1 %or822, label %if.then, label %if.end.i.i62

if.then:                                          ; preds = %update_blocked_load_status.exit
  tail call fastcc void @cpufreq_update_util(ptr noundef %2, i32 noundef 0)
  br label %if.end.i.i62

if.end.i.i62:                                     ; preds = %if.then, %update_blocked_load_status.exit
  %155 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %155)
  %156 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i61 = icmp eq i32 %156, 0
  br i1 %tobool.not.i.i.i61, label %rq_unpin_lock.exit.i, label %if.then.i.i.i64

if.then.i.i.i64:                                  ; preds = %if.end.i.i62
  %core.i.i.i63 = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 79
  %157 = ptrtoint ptr %core.i.i.i63 to i32
  call void @__asan_load4_noabort(i32 %157)
  %158 = load ptr, ptr %core.i.i.i63, align 8
  br label %rq_unpin_lock.exit.i

rq_unpin_lock.exit.i:                             ; preds = %if.then.i.i.i64, %if.end.i.i62
  %retval.0.i.i.i65 = phi ptr [ %158, %if.then.i.i.i64 ], [ %2, %if.end.i.i62 ]
  %dep_map.i.i66 = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i65, i32 0, i32 4
  %159 = insertvalue [1 x i32] undef, i32 %call1.i.i, 0
  tail call void @lock_unpin_lock(ptr noundef %dep_map.i.i66, [1 x i32] %159) #20
  tail call void @raw_spin_rq_unlock(ptr noundef %2) #20
  br i1 %tobool.not.i.i, label %if.then.i3.i, label %do.body2.i.i

if.then.i3.i:                                     ; preds = %rq_unpin_lock.exit.i
  tail call void @trace_hardirqs_on() #20
  br label %do.body2.i.i

do.body2.i.i:                                     ; preds = %if.then.i3.i, %rq_unpin_lock.exit.i
  %160 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #20, !srcloc !280
  %and.i.i.i.i = and i32 %160, 128
  %tobool10.not.i.i = icmp eq i32 %and.i.i.i.i, 0
  br i1 %tobool10.not.i.i, label %if.then14.i.i, label %rq_unlock_irqrestore.exit, !prof !260

if.then14.i.i:                                    ; preds = %do.body2.i.i
  tail call void @warn_bogus_irq_restore() #20
  br label %rq_unlock_irqrestore.exit

rq_unlock_irqrestore.exit:                        ; preds = %if.then14.i.i, %do.body2.i.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %3) #20, !srcloc !281
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @update_rt_rq_load_avg(i64 noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @update_dl_rq_load_avg(i64 noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @update_thermal_load_avg(i64 noundef, ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @update_irq_load_avg(ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @load_balance(i32 noundef %this_cpu, ptr noundef %this_rq, ptr noundef %sd, i32 noundef %idle, ptr nocapture noundef writeonly %continue_balancing) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %env = alloca %struct.lb_env, align 4
  %0 = ptrtoint ptr %sd to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %sd, align 8
  %2 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i = and i32 %2, -16384
  %3 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %3, i32 0, i32 1
  %4 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %preempt_count.i.i, align 4
  %add.i = add i32 %5, 1
  store volatile i32 %add.i, ptr %preempt_count.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !301
  %6 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %6, -16384
  %7 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %7, i32 0, i32 3
  %8 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %cpu, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %9
  %10 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %arrayidx, align 4
  %add = add i32 %11, ptrtoint (ptr @load_balance_mask to i32)
  %12 = inttoptr i32 %add to ptr
  %13 = ptrtoint ptr %12 to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile ptr, ptr %12, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !302
  %15 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i426 = and i32 %15, -16384
  %16 = inttoptr i32 %and.i.i.i426 to ptr
  %preempt_count.i.i427 = getelementptr inbounds %struct.thread_info, ptr %16, i32 0, i32 1
  %17 = ptrtoint ptr %preempt_count.i.i427 to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load volatile i32, ptr %preempt_count.i.i427, align 4
  %sub.i = add i32 %18, -1
  store volatile i32 %sub.i, ptr %preempt_count.i.i427, align 4
  call void @llvm.lifetime.start.p0(i64 72, ptr nonnull %env) #20
  %19 = ptrtoint ptr %env to i32
  call void @__asan_store4_noabort(i32 %19)
  store ptr %sd, ptr %env, align 4
  %src_rq = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 1
  %20 = ptrtoint ptr %src_rq to i32
  call void @__asan_store4_noabort(i32 %20)
  store ptr null, ptr %src_rq, align 4
  %src_cpu = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 2
  %21 = ptrtoint ptr %src_cpu to i32
  call void @__asan_store4_noabort(i32 %21)
  store i32 0, ptr %src_cpu, align 4
  %dst_cpu = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 3
  %22 = ptrtoint ptr %dst_cpu to i32
  call void @__asan_store4_noabort(i32 %22)
  store i32 %this_cpu, ptr %dst_cpu, align 4
  %dst_rq = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 4
  %23 = ptrtoint ptr %dst_rq to i32
  call void @__asan_store4_noabort(i32 %23)
  store ptr %this_rq, ptr %dst_rq, align 4
  %dst_grpmask = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 5
  %groups = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 2
  %24 = ptrtoint ptr %groups to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %groups, align 8
  %cpumask.i = getelementptr inbounds %struct.sched_group, ptr %25, i32 0, i32 6
  %26 = ptrtoint ptr %dst_grpmask to i32
  call void @__asan_store4_noabort(i32 %26)
  store ptr %cpumask.i, ptr %dst_grpmask, align 4
  %new_dst_cpu = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 6
  %27 = ptrtoint ptr %new_dst_cpu to i32
  call void @__asan_store4_noabort(i32 %27)
  store i32 0, ptr %new_dst_cpu, align 4
  %idle21 = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 7
  %28 = ptrtoint ptr %idle21 to i32
  call void @__asan_store4_noabort(i32 %28)
  store i32 %idle, ptr %idle21, align 4
  %imbalance = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 8
  %29 = ptrtoint ptr %imbalance to i32
  call void @__asan_store4_noabort(i32 %29)
  store i32 0, ptr %imbalance, align 4
  %cpus22 = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 9
  %30 = ptrtoint ptr %cpus22 to i32
  call void @__asan_store4_noabort(i32 %30)
  store ptr %14, ptr %cpus22, align 4
  %flags = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 10
  %31 = ptrtoint ptr %flags to i32
  call void @__asan_store4_noabort(i32 %31)
  store i32 0, ptr %flags, align 4
  %loop = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 11
  %32 = ptrtoint ptr %loop to i32
  call void @__asan_store4_noabort(i32 %32)
  store i32 0, ptr %loop, align 4
  %loop_break = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 12
  %33 = ptrtoint ptr %loop_break to i32
  call void @__asan_store4_noabort(i32 %33)
  store i32 32, ptr %loop_break, align 4
  %loop_max = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 13
  %34 = ptrtoint ptr %loop_max to i32
  call void @__asan_store4_noabort(i32 %34)
  store i32 0, ptr %loop_max, align 4
  %fbq_type = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 14
  %35 = ptrtoint ptr %fbq_type to i32
  call void @__asan_store4_noabort(i32 %35)
  store i32 2, ptr %fbq_type, align 4
  %migration_type = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 15
  %36 = ptrtoint ptr %migration_type to i32
  call void @__asan_store4_noabort(i32 %36)
  store i32 0, ptr %migration_type, align 4
  %tasks = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 16
  %37 = ptrtoint ptr %tasks to i32
  call void @__asan_store4_noabort(i32 %37)
  store ptr %tasks, ptr %tasks, align 4
  %prev = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 16, i32 1
  %38 = ptrtoint ptr %prev to i32
  call void @__asan_store4_noabort(i32 %38)
  store ptr %tasks, ptr %prev, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %39 = load i32, ptr @nr_cpu_ids, align 4
  %span.i = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 41
  %call.i.i = call i32 @__bitmap_and(ptr noundef %14, ptr noundef %span.i, ptr noundef nonnull @__cpu_active_mask, i32 noundef %39) #20
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@load_balance, %if.then)) #20
          to label %do.end34 [label %if.then], !srcloc !261

if.then:                                          ; preds = %entry
  %arrayidx32 = getelementptr %struct.sched_domain, ptr %sd, i32 0, i32 17, i32 %idle
  %40 = ptrtoint ptr %arrayidx32 to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %arrayidx32, align 4
  %inc = add i32 %41, 1
  store i32 %inc, ptr %arrayidx32, align 4
  br label %do.end34

do.end34:                                         ; preds = %if.then, %entry
  %arrayidx115 = getelementptr %struct.sched_domain, ptr %sd, i32 0, i32 20, i32 %idle
  %tobool203.not = icmp eq ptr %1, null
  %groups205 = getelementptr inbounds %struct.sched_domain, ptr %1, i32 0, i32 2
  br label %redo

redo:                                             ; preds = %if.then231, %do.end34
  %42 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load ptr, ptr %env, align 4
  %groups.i = getelementptr inbounds %struct.sched_domain, ptr %43, i32 0, i32 2
  %44 = ptrtoint ptr %groups.i to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load ptr, ptr %groups.i, align 8
  %46 = ptrtoint ptr %dst_cpu to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load i32, ptr %dst_cpu, align 4
  %48 = ptrtoint ptr %cpus22 to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load ptr, ptr %cpus22, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %50 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i = icmp ugt i32 %50, %47
  br i1 %cmp.not.i.i.i.i, label %cpumask_test_cpu.exit.i, label %land.rhs.i.i.i.i

land.rhs.i.i.i.i:                                 ; preds = %redo
  %.b37.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i, label %cpumask_test_cpu.exit.i, label %if.then.i.i.i.i, !prof !259

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpumask_test_cpu.exit.i

cpumask_test_cpu.exit.i:                          ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i.i, %redo
  %div3.i.i.i = lshr i32 %47, 5
  %arrayidx.i.i.i = getelementptr i32, ptr %49, i32 %div3.i.i.i
  %51 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load volatile i32, ptr %arrayidx.i.i.i, align 4
  %and.i.i.i443 = and i32 %47, 31
  %53 = shl nuw i32 1, %and.i.i.i443
  %54 = and i32 %52, %53
  %tobool.not.i = icmp eq i32 %54, 0
  br i1 %tobool.not.i, label %if.then37, label %if.end.i

if.end.i:                                         ; preds = %cpumask_test_cpu.exit.i
  %55 = ptrtoint ptr %idle21 to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load i32, ptr %idle21, align 4
  %cmp.i = icmp eq i32 %56, 2
  br i1 %cmp.i, label %if.end38, label %for.cond.preheader.i

for.cond.preheader.i:                             ; preds = %if.end.i
  %sgc.i.i = getelementptr inbounds %struct.sched_group, ptr %45, i32 0, i32 3
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %for.cond.preheader.i
  %cpu.0.i = phi i32 [ %call5.i, %for.body.i ], [ -1, %for.cond.preheader.i ]
  %57 = ptrtoint ptr %sgc.i.i to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load ptr, ptr %sgc.i.i, align 4
  %cpumask.i.i = getelementptr inbounds %struct.sched_group_capacity, ptr %58, i32 0, i32 7
  %59 = ptrtoint ptr %cpus22 to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load ptr, ptr %cpus22, align 4
  %call5.i = call i32 @cpumask_next_and(i32 noundef %cpu.0.i, ptr noundef %cpumask.i.i, ptr noundef %60) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %61 = load i32, ptr @nr_cpu_ids, align 4
  %cmp6.i = icmp ult i32 %call5.i, %61
  br i1 %cmp6.i, label %for.body.i, label %for.end.i

for.body.i:                                       ; preds = %for.cond.i
  %call7.i = call i32 @idle_cpu(i32 noundef %call5.i) #20
  %tobool8.not.i = icmp eq i32 %call7.i, 0
  br i1 %tobool8.not.i, label %for.cond.i, label %should_we_balance.exit

for.end.i:                                        ; preds = %for.cond.i
  %call13.i = call i32 @group_balance_cpu(ptr noundef %45) #20
  br label %should_we_balance.exit

should_we_balance.exit:                           ; preds = %for.end.i, %for.body.i
  %call13.sink.i = phi i32 [ %call13.i, %for.end.i ], [ %call5.i, %for.body.i ]
  %62 = ptrtoint ptr %dst_cpu to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load i32, ptr %dst_cpu, align 4
  %cmp15.i.not = icmp eq i32 %call13.sink.i, %63
  br i1 %cmp15.i.not, label %if.end38, label %if.then37

if.then37:                                        ; preds = %should_we_balance.exit, %cpumask_test_cpu.exit.i
  %64 = ptrtoint ptr %continue_balancing to i32
  call void @__asan_store4_noabort(i32 %64)
  store i32 0, ptr %continue_balancing, align 4
  br label %out_balanced

if.end38:                                         ; preds = %should_we_balance.exit, %if.end.i
  %call39 = call fastcc ptr @find_busiest_group(ptr noundef nonnull %env)
  %tobool40.not = icmp eq ptr %call39, null
  br i1 %tobool40.not, label %do.body42, label %if.end60

do.body42:                                        ; preds = %if.end38
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@load_balance, %if.then54)) #20
          to label %out_balanced [label %if.then54], !srcloc !261

if.then54:                                        ; preds = %do.body42
  %arrayidx55 = getelementptr %struct.sched_domain, ptr %sd, i32 0, i32 23, i32 %idle
  %65 = ptrtoint ptr %arrayidx55 to i32
  call void @__asan_load4_noabort(i32 %65)
  %66 = load i32, ptr %arrayidx55, align 4
  %inc56 = add i32 %66, 1
  store i32 %inc56, ptr %arrayidx55, align 4
  br label %out_balanced

if.end60:                                         ; preds = %if.end38
  %call61 = call fastcc ptr @find_busiest_queue(ptr noundef nonnull %env, ptr noundef nonnull %call39)
  %tobool62.not = icmp eq ptr %call61, null
  br i1 %tobool62.not, label %do.body64, label %do.body83

do.body64:                                        ; preds = %if.end60
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@load_balance, %if.then76)) #20
          to label %out_balanced [label %if.then76], !srcloc !261

if.then76:                                        ; preds = %do.body64
  %arrayidx77 = getelementptr %struct.sched_domain, ptr %sd, i32 0, i32 24, i32 %idle
  %67 = ptrtoint ptr %arrayidx77 to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load i32, ptr %arrayidx77, align 4
  %inc78 = add i32 %68, 1
  store i32 %inc78, ptr %arrayidx77, align 4
  br label %out_balanced

do.body83:                                        ; preds = %if.end60
  %69 = ptrtoint ptr %dst_rq to i32
  call void @__asan_load4_noabort(i32 %69)
  %70 = load ptr, ptr %dst_rq, align 4
  %cmp = icmp eq ptr %call61, %70
  br i1 %cmp, label %do.body92, label %do.body101, !prof !260

do.body92:                                        ; preds = %do.body83
  call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22kernel/sched/fair.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 9879, 0\0A.popsection", ""() #20, !srcloc !303
  unreachable

do.body101:                                       ; preds = %do.body83
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@load_balance, %if.then113)) #20
          to label %do.end119 [label %if.then113], !srcloc !261

if.then113:                                       ; preds = %do.body101
  %71 = ptrtoint ptr %imbalance to i32
  call void @__asan_load4_noabort(i32 %71)
  %72 = load i32, ptr %imbalance, align 4
  %73 = ptrtoint ptr %arrayidx115 to i32
  call void @__asan_load4_noabort(i32 %73)
  %74 = load i32, ptr %arrayidx115, align 4
  %add116 = add i32 %74, %72
  store i32 %add116, ptr %arrayidx115, align 4
  br label %do.end119

do.end119:                                        ; preds = %if.then113, %do.body101
  %cpu120 = getelementptr inbounds %struct.rq, ptr %call61, i32 0, i32 46
  %75 = ptrtoint ptr %cpu120 to i32
  call void @__asan_load4_noabort(i32 %75)
  %76 = load i32, ptr %cpu120, align 4
  %77 = ptrtoint ptr %src_cpu to i32
  call void @__asan_store4_noabort(i32 %77)
  store i32 %76, ptr %src_cpu, align 4
  %78 = ptrtoint ptr %src_rq to i32
  call void @__asan_store4_noabort(i32 %78)
  store ptr %call61, ptr %src_rq, align 4
  %79 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %79)
  %80 = load i32, ptr %flags, align 4
  %or = or i32 %80, 1
  store i32 %or, ptr %flags, align 4
  %nr_running = getelementptr inbounds %struct.rq, ptr %call61, i32 0, i32 1
  %81 = ptrtoint ptr %nr_running to i32
  call void @__asan_load4_noabort(i32 %81)
  %82 = load i32, ptr %nr_running, align 4
  %cmp124 = icmp ugt i32 %82, 1
  br i1 %cmp124, label %if.then125, label %do.body239

if.then125:                                       ; preds = %do.end119
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @sysctl_sched_nr_migrate to i32))
  %83 = load i32, ptr @sysctl_sched_nr_migrate, align 4
  %84 = call i32 @llvm.umin.i32(i32 %83, i32 %82)
  %85 = ptrtoint ptr %loop_max to i32
  call void @__asan_store4_noabort(i32 %85)
  store i32 %84, ptr %loop_max, align 4
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %call61, i32 0, i32 81
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %call61, i32 0, i32 79
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %call61, i32 0, i32 25
  %balance_callback.i.i = getelementptr inbounds %struct.rq, ptr %call61, i32 0, i32 39
  br label %more_balance

more_balance:                                     ; preds = %more_balance.backedge, %if.then125
  %ld_moved.0 = phi i32 [ 0, %if.then125 ], [ %ld_moved.1, %more_balance.backedge ]
  %86 = call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #20, !srcloc !279
  %and.i.i.i444 = and i32 %86, 128
  %tobool.not.i.i = icmp eq i32 %and.i.i.i444, 0
  br i1 %tobool.not.i.i, label %if.then.i.i445, label %_raw_spin_rq_lock_irqsave.exit.i

if.then.i.i445:                                   ; preds = %more_balance
  call void @trace_hardirqs_off() #20
  br label %_raw_spin_rq_lock_irqsave.exit.i

_raw_spin_rq_lock_irqsave.exit.i:                 ; preds = %if.then.i.i445, %more_balance
  call void @raw_spin_rq_lock_nested(ptr noundef %call61, i32 noundef 0) #20
  %87 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %87)
  %88 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %88, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %_raw_spin_rq_lock_irqsave.exit.i
  %89 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %89)
  %90 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %_raw_spin_rq_lock_irqsave.exit.i
  %retval.0.i.i.i = phi ptr [ %90, %if.then.i.i.i ], [ %call61, %_raw_spin_rq_lock_irqsave.exit.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call1.i.i = call i32 @lock_pin_lock(ptr noundef %dep_map.i.i) #20
  %91 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %91)
  %92 = load i32, ptr %clock_update_flags.i.i, align 4
  %and.i.i446 = and i32 %92, 3
  store i32 %and.i.i446, ptr %clock_update_flags.i.i, align 4
  %93 = ptrtoint ptr %balance_callback.i.i to i32
  call void @__asan_load4_noabort(i32 %93)
  %94 = load ptr, ptr %balance_callback.i.i, align 8
  %tobool.not.i3.i = icmp ne ptr %94, null
  %cmp.i.i = icmp ne ptr %94, @balance_push_callback
  %spec.select.i.i = and i1 %tobool.not.i3.i, %cmp.i.i
  br i1 %spec.select.i.i, label %land.rhs6.i.i, label %rq_lock_irqsave.exit

land.rhs6.i.i:                                    ; preds = %__rq_lockp.exit.i.i
  %.b48.i.i = load i1, ptr @rq_pin_lock.__already_done, align 1
  br i1 %.b48.i.i, label %rq_lock_irqsave.exit, label %if.then.i4.i, !prof !259

if.then.i4.i:                                     ; preds = %land.rhs6.i.i
  store i1 true, ptr @rq_pin_lock.__already_done, align 1
  call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1545, i32 noundef 9, ptr noundef nonnull @.str.35) #20
  br label %rq_lock_irqsave.exit

rq_lock_irqsave.exit:                             ; preds = %if.then.i4.i, %land.rhs6.i.i, %__rq_lockp.exit.i.i
  call void @update_rq_clock(ptr noundef nonnull %call61) #20
  %call130 = call fastcc i32 @detach_tasks(ptr noundef nonnull %env)
  %95 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %95)
  %96 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i451 = icmp eq i32 %96, 0
  br i1 %tobool.not.i.i.i451, label %rq_unlock.exit, label %if.then.i.i.i454

if.then.i.i.i454:                                 ; preds = %rq_lock_irqsave.exit
  %97 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %97)
  %98 = load ptr, ptr %core.i.i.i, align 8
  br label %rq_unlock.exit

rq_unlock.exit:                                   ; preds = %if.then.i.i.i454, %rq_lock_irqsave.exit
  %retval.0.i.i.i455 = phi ptr [ %98, %if.then.i.i.i454 ], [ %call61, %rq_lock_irqsave.exit ]
  %dep_map.i.i456 = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i455, i32 0, i32 4
  %99 = insertvalue [1 x i32] undef, i32 %call1.i.i, 0
  call void @lock_unpin_lock(ptr noundef %dep_map.i.i456, [1 x i32] %99) #20
  call void @raw_spin_rq_unlock(ptr noundef %call61) #20
  %tobool131.not = icmp eq i32 %call130, 0
  br i1 %tobool131.not, label %do.body135, label %if.then132

if.then132:                                       ; preds = %rq_unlock.exit
  %100 = ptrtoint ptr %dst_rq to i32
  call void @__asan_load4_noabort(i32 %100)
  %101 = load ptr, ptr %dst_rq, align 4
  call void @raw_spin_rq_lock_nested(ptr noundef %101, i32 noundef 0) #20
  %core_enabled.i.i.i.i = getelementptr inbounds %struct.rq, ptr %101, i32 0, i32 81
  %102 = ptrtoint ptr %core_enabled.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %102)
  %103 = load i32, ptr %core_enabled.i.i.i.i, align 128
  %tobool.not.i.i.i.i = icmp eq i32 %103, 0
  br i1 %tobool.not.i.i.i.i, label %__rq_lockp.exit.i.i.i, label %if.then.i.i.i.i458

if.then.i.i.i.i458:                               ; preds = %if.then132
  %core.i.i.i.i = getelementptr inbounds %struct.rq, ptr %101, i32 0, i32 79
  %104 = ptrtoint ptr %core.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %104)
  %105 = load ptr, ptr %core.i.i.i.i, align 8
  br label %__rq_lockp.exit.i.i.i

__rq_lockp.exit.i.i.i:                            ; preds = %if.then.i.i.i.i458, %if.then132
  %retval.0.i.i.i.i = phi ptr [ %105, %if.then.i.i.i.i458 ], [ %101, %if.then132 ]
  %dep_map.i.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i.i, i32 0, i32 4
  %call1.i.i.i = call i32 @lock_pin_lock(ptr noundef %dep_map.i.i.i) #20
  %clock_update_flags.i.i.i = getelementptr inbounds %struct.rq, ptr %101, i32 0, i32 25
  %106 = ptrtoint ptr %clock_update_flags.i.i.i to i32
  call void @__asan_load4_noabort(i32 %106)
  %107 = load i32, ptr %clock_update_flags.i.i.i, align 4
  %and.i.i.i459 = and i32 %107, 3
  store i32 %and.i.i.i459, ptr %clock_update_flags.i.i.i, align 4
  %balance_callback.i.i.i = getelementptr inbounds %struct.rq, ptr %101, i32 0, i32 39
  %108 = ptrtoint ptr %balance_callback.i.i.i to i32
  call void @__asan_load4_noabort(i32 %108)
  %109 = load ptr, ptr %balance_callback.i.i.i, align 8
  %tobool.not.i.i.i460 = icmp ne ptr %109, null
  %cmp.i.i.i = icmp ne ptr %109, @balance_push_callback
  %spec.select.i.i.i = and i1 %tobool.not.i.i.i460, %cmp.i.i.i
  br i1 %spec.select.i.i.i, label %land.rhs6.i.i.i, label %rq_lock.exit.i

land.rhs6.i.i.i:                                  ; preds = %__rq_lockp.exit.i.i.i
  %.b48.i.i.i = load i1, ptr @rq_pin_lock.__already_done, align 1
  br i1 %.b48.i.i.i, label %rq_lock.exit.i, label %if.then.i.i.i461, !prof !259

if.then.i.i.i461:                                 ; preds = %land.rhs6.i.i.i
  store i1 true, ptr @rq_pin_lock.__already_done, align 1
  call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1545, i32 noundef 9, ptr noundef nonnull @.str.35) #20
  br label %rq_lock.exit.i

rq_lock.exit.i:                                   ; preds = %if.then.i.i.i461, %land.rhs6.i.i.i, %__rq_lockp.exit.i.i.i
  %110 = ptrtoint ptr %dst_rq to i32
  call void @__asan_load4_noabort(i32 %110)
  %111 = load ptr, ptr %dst_rq, align 4
  call void @update_rq_clock(ptr noundef %111) #20
  %112 = ptrtoint ptr %tasks to i32
  call void @__asan_load4_noabort(i32 %112)
  %113 = load volatile ptr, ptr %tasks, align 4
  %cmp.i.not22.i = icmp eq ptr %113, %tasks
  br i1 %cmp.i.not22.i, label %while.end.i, label %while.body.i

while.body.i:                                     ; preds = %list_del_init.exit.i, %rq_lock.exit.i
  %114 = phi ptr [ %126, %list_del_init.exit.i ], [ %113, %rq_lock.exit.i ]
  %add.ptr.i = getelementptr i8, ptr %114, i32 -148
  %call.i.i.i = call zeroext i1 @__list_del_entry_valid(ptr noundef %114) #20
  br i1 %call.i.i.i, label %if.end.i.i.i, label %list_del_init.exit.i

if.end.i.i.i:                                     ; preds = %while.body.i
  %prev.i.i.i = getelementptr inbounds %struct.list_head, ptr %114, i32 0, i32 1
  %115 = ptrtoint ptr %prev.i.i.i to i32
  call void @__asan_load4_noabort(i32 %115)
  %116 = load ptr, ptr %prev.i.i.i, align 4
  %117 = ptrtoint ptr %114 to i32
  call void @__asan_load4_noabort(i32 %117)
  %118 = load ptr, ptr %114, align 4
  %prev1.i.i.i.i = getelementptr inbounds %struct.list_head, ptr %118, i32 0, i32 1
  %119 = ptrtoint ptr %prev1.i.i.i.i to i32
  call void @__asan_store4_noabort(i32 %119)
  store ptr %116, ptr %prev1.i.i.i.i, align 4
  %120 = ptrtoint ptr %116 to i32
  call void @__asan_store4_noabort(i32 %120)
  store volatile ptr %118, ptr %116, align 4
  br label %list_del_init.exit.i

list_del_init.exit.i:                             ; preds = %if.end.i.i.i, %while.body.i
  %121 = ptrtoint ptr %114 to i32
  call void @__asan_store4_noabort(i32 %121)
  store volatile ptr %114, ptr %114, align 4
  %prev.i3.i.i = getelementptr inbounds %struct.list_head, ptr %114, i32 0, i32 1
  %122 = ptrtoint ptr %prev.i3.i.i to i32
  call void @__asan_store4_noabort(i32 %122)
  store ptr %114, ptr %prev.i3.i.i, align 4
  %123 = ptrtoint ptr %dst_rq to i32
  call void @__asan_load4_noabort(i32 %123)
  %124 = load ptr, ptr %dst_rq, align 4
  call fastcc void @attach_task(ptr noundef %124, ptr noundef %add.ptr.i) #20
  %125 = ptrtoint ptr %tasks to i32
  call void @__asan_load4_noabort(i32 %125)
  %126 = load volatile ptr, ptr %tasks, align 4
  %cmp.i.not.i = icmp eq ptr %126, %tasks
  br i1 %cmp.i.not.i, label %while.end.i, label %while.body.i

while.end.i:                                      ; preds = %list_del_init.exit.i, %rq_lock.exit.i
  %127 = ptrtoint ptr %dst_rq to i32
  call void @__asan_load4_noabort(i32 %127)
  %128 = load ptr, ptr %dst_rq, align 4
  %core_enabled.i.i.i14.i = getelementptr inbounds %struct.rq, ptr %128, i32 0, i32 81
  %129 = ptrtoint ptr %core_enabled.i.i.i14.i to i32
  call void @__asan_load4_noabort(i32 %129)
  %130 = load i32, ptr %core_enabled.i.i.i14.i, align 128
  %tobool.not.i.i.i15.i = icmp eq i32 %130, 0
  br i1 %tobool.not.i.i.i15.i, label %attach_tasks.exit, label %if.then.i.i.i18.i

if.then.i.i.i18.i:                                ; preds = %while.end.i
  %core.i.i.i17.i = getelementptr inbounds %struct.rq, ptr %128, i32 0, i32 79
  %131 = ptrtoint ptr %core.i.i.i17.i to i32
  call void @__asan_load4_noabort(i32 %131)
  %132 = load ptr, ptr %core.i.i.i17.i, align 8
  br label %attach_tasks.exit

attach_tasks.exit:                                ; preds = %if.then.i.i.i18.i, %while.end.i
  %retval.0.i.i.i19.i = phi ptr [ %132, %if.then.i.i.i18.i ], [ %128, %while.end.i ]
  %dep_map.i.i20.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i19.i, i32 0, i32 4
  %133 = insertvalue [1 x i32] undef, i32 %call1.i.i.i, 0
  call void @lock_unpin_lock(ptr noundef %dep_map.i.i20.i, [1 x i32] %133) #20
  call void @raw_spin_rq_unlock(ptr noundef %128) #20
  %add133 = add i32 %call130, %ld_moved.0
  br label %do.body135

do.body135:                                       ; preds = %attach_tasks.exit, %rq_unlock.exit
  %ld_moved.1 = phi i32 [ %add133, %attach_tasks.exit ], [ %ld_moved.0, %rq_unlock.exit ]
  br i1 %tobool.not.i.i, label %if.then142, label %do.body144

if.then142:                                       ; preds = %do.body135
  call void @trace_hardirqs_on() #20
  br label %do.body144

do.body144:                                       ; preds = %if.then142, %do.body135
  %134 = call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #20, !srcloc !280
  %and.i.i463 = and i32 %134, 128
  %tobool152.not = icmp eq i32 %and.i.i463, 0
  br i1 %tobool152.not, label %if.then161, label %do.end164, !prof !260

if.then161:                                       ; preds = %do.body144
  call void @warn_bogus_irq_restore() #20
  br label %do.end164

do.end164:                                        ; preds = %if.then161, %do.body144
  call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %86) #20, !srcloc !281
  %135 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %135)
  %136 = load i32, ptr %flags, align 4
  %and = and i32 %136, 2
  %tobool171.not = icmp eq i32 %and, 0
  br i1 %tobool171.not, label %if.end175, label %if.then172

if.then172:                                       ; preds = %do.end164
  %and174 = and i32 %136, -3
  %137 = ptrtoint ptr %flags to i32
  call void @__asan_store4_noabort(i32 %137)
  store i32 %and174, ptr %flags, align 4
  br label %more_balance.backedge

more_balance.backedge:                            ; preds = %__cpumask_clear_cpu.exit, %if.then172
  br label %more_balance

if.end175:                                        ; preds = %do.end164
  %and177 = and i32 %136, 4
  %tobool178.not = icmp eq i32 %and177, 0
  br i1 %tobool178.not, label %if.end202, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end175
  %138 = ptrtoint ptr %imbalance to i32
  call void @__asan_load4_noabort(i32 %138)
  %139 = load i32, ptr %imbalance, align 4
  %cmp180 = icmp sgt i32 %139, 0
  br i1 %cmp180, label %if.then182, label %if.end202

if.then182:                                       ; preds = %land.lhs.true
  %140 = ptrtoint ptr %dst_cpu to i32
  call void @__asan_load4_noabort(i32 %140)
  %141 = load i32, ptr %dst_cpu, align 4
  %142 = ptrtoint ptr %cpus22 to i32
  call void @__asan_load4_noabort(i32 %142)
  %143 = load ptr, ptr %cpus22, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %144 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i = icmp ugt i32 %144, %141
  br i1 %cmp.not.i.i.i, label %__cpumask_clear_cpu.exit, label %land.rhs.i.i.i

land.rhs.i.i.i:                                   ; preds = %if.then182
  %.b37.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i, label %__cpumask_clear_cpu.exit, label %if.then.i.i.i464, !prof !259

if.then.i.i.i464:                                 ; preds = %land.rhs.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %__cpumask_clear_cpu.exit

__cpumask_clear_cpu.exit:                         ; preds = %if.then.i.i.i464, %land.rhs.i.i.i, %if.then182
  %rem.i.i = and i32 %141, 31
  %shl.i.i = shl nuw i32 1, %rem.i.i
  %div2.i.i = lshr i32 %141, 5
  %add.ptr.i.i = getelementptr i32, ptr %143, i32 %div2.i.i
  %neg.i.i = xor i32 %shl.i.i, -1
  %145 = ptrtoint ptr %add.ptr.i.i to i32
  call void @__asan_load4_noabort(i32 %145)
  %146 = load i32, ptr %add.ptr.i.i, align 4
  %and.i.i465 = and i32 %146, %neg.i.i
  store i32 %and.i.i465, ptr %add.ptr.i.i, align 4
  %147 = ptrtoint ptr %new_dst_cpu to i32
  call void @__asan_load4_noabort(i32 %147)
  %148 = load i32, ptr %new_dst_cpu, align 4
  %arrayidx193 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %148
  %149 = ptrtoint ptr %arrayidx193 to i32
  call void @__asan_load4_noabort(i32 %149)
  %150 = load i32, ptr %arrayidx193, align 4
  %add194 = add i32 %150, ptrtoint (ptr @runqueues to i32)
  %151 = inttoptr i32 %add194 to ptr
  %152 = ptrtoint ptr %dst_rq to i32
  call void @__asan_store4_noabort(i32 %152)
  store ptr %151, ptr %dst_rq, align 4
  %153 = ptrtoint ptr %dst_cpu to i32
  call void @__asan_store4_noabort(i32 %153)
  store i32 %148, ptr %dst_cpu, align 4
  %154 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %154)
  %155 = load i32, ptr %flags, align 4
  %and199 = and i32 %155, -5
  store i32 %and199, ptr %flags, align 4
  %156 = ptrtoint ptr %loop to i32
  call void @__asan_store4_noabort(i32 %156)
  store i32 0, ptr %loop, align 4
  %157 = ptrtoint ptr %loop_break to i32
  call void @__asan_store4_noabort(i32 %157)
  store i32 32, ptr %loop_break, align 4
  br label %more_balance.backedge

if.end202:                                        ; preds = %land.lhs.true, %if.end175
  br i1 %tobool203.not, label %if.end216, label %if.then204

if.then204:                                       ; preds = %if.end202
  %158 = ptrtoint ptr %groups205 to i32
  call void @__asan_load4_noabort(i32 %158)
  %159 = load ptr, ptr %groups205, align 8
  %sgc = getelementptr inbounds %struct.sched_group, ptr %159, i32 0, i32 3
  %160 = ptrtoint ptr %sgc to i32
  call void @__asan_load4_noabort(i32 %160)
  %161 = load ptr, ptr %sgc, align 4
  %imbalance206 = getelementptr inbounds %struct.sched_group_capacity, ptr %161, i32 0, i32 5
  %and208 = and i32 %136, 8
  %tobool209.not = icmp eq i32 %and208, 0
  br i1 %tobool209.not, label %if.end216, label %land.lhs.true210

land.lhs.true210:                                 ; preds = %if.then204
  %162 = ptrtoint ptr %imbalance to i32
  call void @__asan_load4_noabort(i32 %162)
  %163 = load i32, ptr %imbalance, align 4
  %cmp212 = icmp sgt i32 %163, 0
  br i1 %cmp212, label %if.then214, label %if.end216

if.then214:                                       ; preds = %land.lhs.true210
  %164 = ptrtoint ptr %imbalance206 to i32
  call void @__asan_store4_noabort(i32 %164)
  store i32 1, ptr %imbalance206, align 4
  br label %if.end216

if.end216:                                        ; preds = %if.then214, %land.lhs.true210, %if.then204, %if.end202
  %165 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %165)
  %166 = load i32, ptr %flags, align 4
  %and218 = and i32 %166, 1
  %tobool219.not = icmp eq i32 %and218, 0
  br i1 %tobool219.not, label %if.end236, label %if.then226, !prof !259

if.then226:                                       ; preds = %if.end216
  %167 = ptrtoint ptr %cpu120 to i32
  call void @__asan_load4_noabort(i32 %167)
  %168 = load i32, ptr %cpu120, align 4
  call fastcc void @__cpumask_clear_cpu(i32 noundef %168, ptr noundef %14)
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %169 = load i32, ptr @nr_cpu_ids, align 4
  %170 = ptrtoint ptr %dst_grpmask to i32
  call void @__asan_load4_noabort(i32 %170)
  %171 = load ptr, ptr %dst_grpmask, align 4
  %call.i.i474 = call i32 @__bitmap_subset(ptr noundef %14, ptr noundef %171, i32 noundef %169) #20
  %tobool230.not = icmp eq i32 %call.i.i474, 0
  br i1 %tobool230.not, label %if.then231, label %do.body316

if.then231:                                       ; preds = %if.then226
  %172 = ptrtoint ptr %loop to i32
  call void @__asan_store4_noabort(i32 %172)
  store i32 0, ptr %loop, align 4
  %173 = ptrtoint ptr %loop_break to i32
  call void @__asan_store4_noabort(i32 %173)
  store i32 32, ptr %loop_break, align 4
  br label %redo

if.end236:                                        ; preds = %if.end216
  %tobool237.not = icmp eq i32 %ld_moved.1, 0
  br i1 %tobool237.not, label %do.body239, label %if.else

do.body239:                                       ; preds = %if.end236, %do.end119
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@load_balance, %if.then251)) #20
          to label %do.end256 [label %if.then251], !srcloc !261

if.then251:                                       ; preds = %do.body239
  %arrayidx252 = getelementptr %struct.sched_domain, ptr %sd, i32 0, i32 18, i32 %idle
  %174 = ptrtoint ptr %arrayidx252 to i32
  call void @__asan_load4_noabort(i32 %174)
  %175 = load i32, ptr %arrayidx252, align 4
  %inc253 = add i32 %175, 1
  store i32 %inc253, ptr %arrayidx252, align 4
  br label %do.end256

do.end256:                                        ; preds = %if.then251, %do.body239
  %cmp257.not = icmp eq i32 %idle, 2
  br i1 %cmp257.not, label %if.end261, label %if.then259

if.then259:                                       ; preds = %do.end256
  %nr_balance_failed = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 13
  %176 = ptrtoint ptr %nr_balance_failed to i32
  call void @__asan_load4_noabort(i32 %176)
  %177 = load i32, ptr %nr_balance_failed, align 4
  %inc260 = add i32 %177, 1
  store i32 %inc260, ptr %nr_balance_failed, align 4
  br label %if.end261

if.end261:                                        ; preds = %if.then259, %do.end256
  %call262 = call fastcc i32 @need_active_balance(ptr noundef nonnull %env)
  %tobool263.not = icmp eq i32 %call262, 0
  br i1 %tobool263.not, label %if.then300, label %if.then264

if.then264:                                       ; preds = %if.end261
  %178 = call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #20, !srcloc !279
  %and.i.i475 = and i32 %178, 128
  %tobool.not.i476 = icmp eq i32 %and.i.i475, 0
  br i1 %tobool.not.i476, label %if.then.i, label %_raw_spin_rq_lock_irqsave.exit

if.then.i:                                        ; preds = %if.then264
  call void @trace_hardirqs_off() #20
  br label %_raw_spin_rq_lock_irqsave.exit

_raw_spin_rq_lock_irqsave.exit:                   ; preds = %if.then.i, %if.then264
  call void @raw_spin_rq_lock_nested(ptr noundef %call61, i32 noundef 0) #20
  %curr = getelementptr inbounds %struct.rq, ptr %call61, i32 0, i32 20
  %179 = ptrtoint ptr %curr to i32
  call void @__asan_load4_noabort(i32 %179)
  %180 = load ptr, ptr %curr, align 8
  %cpus_ptr = getelementptr inbounds %struct.task_struct, ptr %180, i32 0, i32 33
  %181 = ptrtoint ptr %cpus_ptr to i32
  call void @__asan_load4_noabort(i32 %181)
  %182 = load ptr, ptr %cpus_ptr, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %183 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i477 = icmp ugt i32 %183, %this_cpu
  br i1 %cmp.not.i.i.i477, label %cpumask_test_cpu.exit, label %land.rhs.i.i.i479

land.rhs.i.i.i479:                                ; preds = %_raw_spin_rq_lock_irqsave.exit
  %.b37.i.i.i478 = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i478, label %cpumask_test_cpu.exit, label %if.then.i.i.i480, !prof !259

if.then.i.i.i480:                                 ; preds = %land.rhs.i.i.i479
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpumask_test_cpu.exit

cpumask_test_cpu.exit:                            ; preds = %if.then.i.i.i480, %land.rhs.i.i.i479, %_raw_spin_rq_lock_irqsave.exit
  %div3.i.i = lshr i32 %this_cpu, 5
  %arrayidx.i.i = getelementptr i32, ptr %182, i32 %div3.i.i
  %184 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %184)
  %185 = load volatile i32, ptr %arrayidx.i.i, align 4
  %and.i.i481 = and i32 %this_cpu, 31
  %186 = shl nuw i32 1, %and.i.i481
  %187 = and i32 %185, %186
  %tobool271.not = icmp eq i32 %187, 0
  br i1 %tobool271.not, label %if.then272, label %if.end273

if.then272:                                       ; preds = %cpumask_test_cpu.exit
  call void @raw_spin_rq_unlock(ptr noundef %call61) #20
  br i1 %tobool.not.i476, label %if.then.i485, label %do.body2.i

if.then.i485:                                     ; preds = %if.then272
  call void @trace_hardirqs_on() #20
  br label %do.body2.i

do.body2.i:                                       ; preds = %if.then.i485, %if.then272
  %188 = call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #20, !srcloc !280
  %and.i.i.i486 = and i32 %188, 128
  %tobool10.not.i = icmp eq i32 %and.i.i.i486, 0
  br i1 %tobool10.not.i, label %if.then14.i, label %cleanup, !prof !260

if.then14.i:                                      ; preds = %do.body2.i
  call void @warn_bogus_irq_restore() #20
  br label %cleanup

if.end273:                                        ; preds = %cpumask_test_cpu.exit
  %189 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %189)
  %190 = load i32, ptr %flags, align 4
  %and275 = and i32 %190, -2
  store i32 %and275, ptr %flags, align 4
  %active_balance276 = getelementptr inbounds %struct.rq, ptr %call61, i32 0, i32 43
  %191 = ptrtoint ptr %active_balance276 to i32
  call void @__asan_load4_noabort(i32 %191)
  %192 = load i32, ptr %active_balance276, align 4
  %tobool277.not = icmp eq i32 %192, 0
  br i1 %tobool277.not, label %if.then278, label %if.end280

if.then278:                                       ; preds = %if.end273
  %193 = ptrtoint ptr %active_balance276 to i32
  call void @__asan_store4_noabort(i32 %193)
  store i32 1, ptr %active_balance276, align 4
  %push_cpu = getelementptr inbounds %struct.rq, ptr %call61, i32 0, i32 44
  %194 = ptrtoint ptr %push_cpu to i32
  call void @__asan_store4_noabort(i32 %194)
  store i32 %this_cpu, ptr %push_cpu, align 8
  br label %if.end280

if.end280:                                        ; preds = %if.then278, %if.end273
  call void @raw_spin_rq_unlock(ptr noundef %call61) #20
  br i1 %tobool.not.i476, label %if.then.i489, label %do.body2.i492

if.then.i489:                                     ; preds = %if.end280
  call void @trace_hardirqs_on() #20
  br label %do.body2.i492

do.body2.i492:                                    ; preds = %if.then.i489, %if.end280
  %195 = call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #20, !srcloc !280
  %and.i.i.i490 = and i32 %195, 128
  %tobool10.not.i491 = icmp eq i32 %and.i.i.i490, 0
  br i1 %tobool10.not.i491, label %if.then14.i493, label %raw_spin_rq_unlock_irqrestore.exit494, !prof !260

if.then14.i493:                                   ; preds = %do.body2.i492
  call void @warn_bogus_irq_restore() #20
  br label %raw_spin_rq_unlock_irqrestore.exit494

raw_spin_rq_unlock_irqrestore.exit494:            ; preds = %if.then14.i493, %do.body2.i492
  call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %178) #20, !srcloc !281
  br i1 %tobool277.not, label %if.then282, label %if.then300

if.then282:                                       ; preds = %raw_spin_rq_unlock_irqrestore.exit494
  %196 = ptrtoint ptr %cpu120 to i32
  call void @__asan_load4_noabort(i32 %196)
  %197 = load i32, ptr %cpu120, align 4
  %active_balance_work = getelementptr inbounds %struct.rq, ptr %call61, i32 0, i32 45
  %call284 = call zeroext i1 @stop_one_cpu_nowait(i32 noundef %197, ptr noundef nonnull @active_load_balance_cpu_stop, ptr noundef nonnull %call61, ptr noundef %active_balance_work) #20
  %call298 = call fastcc i32 @need_active_balance(ptr noundef nonnull %env)
  %tobool299.not = icmp eq i32 %call298, 0
  br i1 %tobool299.not, label %cleanup354, label %if.then300

cleanup:                                          ; preds = %if.then14.i, %do.body2.i
  call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %178) #20, !srcloc !281
  br label %out_one_pinned

if.else:                                          ; preds = %if.end236
  %nr_balance_failed287 = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 13
  %198 = ptrtoint ptr %nr_balance_failed287 to i32
  call void @__asan_store4_noabort(i32 %198)
  store i32 0, ptr %nr_balance_failed287, align 4
  br label %if.then300

if.then300:                                       ; preds = %if.else, %if.then282, %raw_spin_rq_unlock_irqrestore.exit494, %if.end261
  %ld_moved.2508516 = phi i32 [ 0, %if.then282 ], [ 0, %if.end261 ], [ %ld_moved.1, %if.else ], [ 0, %raw_spin_rq_unlock_irqrestore.exit494 ]
  %min_interval = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 3
  %199 = ptrtoint ptr %min_interval to i32
  call void @__asan_load4_noabort(i32 %199)
  %200 = load i32, ptr %min_interval, align 4
  %balance_interval = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 12
  %201 = ptrtoint ptr %balance_interval to i32
  call void @__asan_store4_noabort(i32 %201)
  store i32 %200, ptr %balance_interval, align 8
  br label %cleanup354

out_balanced:                                     ; preds = %if.then76, %do.body64, %if.then54, %do.body42, %if.then37
  br i1 %tobool203.not, label %do.body316, label %land.lhs.true303

land.lhs.true303:                                 ; preds = %out_balanced
  %202 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %202)
  %203 = load i32, ptr %flags, align 4
  %and305 = and i32 %203, 1
  %tobool306.not = icmp eq i32 %and305, 0
  br i1 %tobool306.not, label %if.then307, label %do.body316

if.then307:                                       ; preds = %land.lhs.true303
  %204 = ptrtoint ptr %groups205 to i32
  call void @__asan_load4_noabort(i32 %204)
  %205 = load ptr, ptr %groups205, align 8
  %sgc310 = getelementptr inbounds %struct.sched_group, ptr %205, i32 0, i32 3
  %206 = ptrtoint ptr %sgc310 to i32
  call void @__asan_load4_noabort(i32 %206)
  %207 = load ptr, ptr %sgc310, align 4
  %imbalance311 = getelementptr inbounds %struct.sched_group_capacity, ptr %207, i32 0, i32 5
  %208 = ptrtoint ptr %imbalance311 to i32
  call void @__asan_load4_noabort(i32 %208)
  %209 = load i32, ptr %imbalance311, align 4
  %tobool312.not = icmp eq i32 %209, 0
  br i1 %tobool312.not, label %do.body316, label %if.then313

if.then313:                                       ; preds = %if.then307
  %210 = ptrtoint ptr %imbalance311 to i32
  call void @__asan_store4_noabort(i32 %210)
  store i32 0, ptr %imbalance311, align 4
  br label %do.body316

do.body316:                                       ; preds = %if.then313, %if.then307, %land.lhs.true303, %out_balanced, %if.then226
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@load_balance, %if.then328)) #20
          to label %do.end333 [label %if.then328], !srcloc !261

if.then328:                                       ; preds = %do.body316
  %arrayidx329 = getelementptr %struct.sched_domain, ptr %sd, i32 0, i32 19, i32 %idle
  %211 = ptrtoint ptr %arrayidx329 to i32
  call void @__asan_load4_noabort(i32 %211)
  %212 = load i32, ptr %arrayidx329, align 4
  %inc330 = add i32 %212, 1
  store i32 %inc330, ptr %arrayidx329, align 4
  br label %do.end333

do.end333:                                        ; preds = %if.then328, %do.body316
  %nr_balance_failed334 = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 13
  %213 = ptrtoint ptr %nr_balance_failed334 to i32
  call void @__asan_store4_noabort(i32 %213)
  store i32 0, ptr %nr_balance_failed334, align 4
  br label %out_one_pinned

out_one_pinned:                                   ; preds = %do.end333, %cleanup
  %214 = ptrtoint ptr %idle21 to i32
  call void @__asan_load4_noabort(i32 %214)
  %215 = load i32, ptr %idle21, align 4
  %cmp336 = icmp eq i32 %215, 2
  br i1 %cmp336, label %cleanup354, label %if.end339

if.end339:                                        ; preds = %out_one_pinned
  %216 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %216)
  %217 = load i32, ptr %flags, align 4
  %and341 = and i32 %217, 1
  %tobool342.not = icmp eq i32 %and341, 0
  br i1 %tobool342.not, label %lor.lhs.false347, label %land.lhs.true343

land.lhs.true343:                                 ; preds = %if.end339
  %balance_interval344 = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 12
  %218 = ptrtoint ptr %balance_interval344 to i32
  call void @__asan_load4_noabort(i32 %218)
  %219 = load i32, ptr %balance_interval344, align 8
  %cmp345 = icmp ult i32 %219, 512
  br i1 %cmp345, label %if.then351, label %lor.lhs.false347

lor.lhs.false347:                                 ; preds = %land.lhs.true343, %if.end339
  %balance_interval348 = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 12
  %220 = ptrtoint ptr %balance_interval348 to i32
  call void @__asan_load4_noabort(i32 %220)
  %221 = load i32, ptr %balance_interval348, align 8
  %max_interval = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 4
  %222 = ptrtoint ptr %max_interval to i32
  call void @__asan_load4_noabort(i32 %222)
  %223 = load i32, ptr %max_interval, align 8
  %cmp349 = icmp ult i32 %221, %223
  br i1 %cmp349, label %if.then351, label %cleanup354

if.then351:                                       ; preds = %lor.lhs.false347, %land.lhs.true343
  %balance_interval352 = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 12
  %224 = ptrtoint ptr %balance_interval352 to i32
  call void @__asan_load4_noabort(i32 %224)
  %225 = load i32, ptr %balance_interval352, align 8
  %mul = shl i32 %225, 1
  store i32 %mul, ptr %balance_interval352, align 8
  br label %cleanup354

cleanup354:                                       ; preds = %if.then351, %lor.lhs.false347, %out_one_pinned, %if.then300, %if.then282
  %retval.0 = phi i32 [ 0, %out_one_pinned ], [ 0, %if.then351 ], [ 0, %lor.lhs.false347 ], [ %ld_moved.2508516, %if.then300 ], [ 0, %if.then282 ]
  call void @llvm.lifetime.end.p0(i64 72, ptr nonnull %env) #20
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @_raw_spin_trylock(ptr noundef) local_unnamed_addr #4 section ".spinlock.text"

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc ptr @find_busiest_group(ptr noundef %env) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tmp_sgs.i = alloca %struct.sg_lb_stats, align 4
  %sg_status.i = alloca i32, align 4
  %sds = alloca %struct.sd_lb_stats, align 4
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %sds) #20
  %0 = call ptr @memset(ptr %sds, i32 0, i32 52)
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %sds, i32 52
  %1 = ptrtoint ptr %.compoundliteral.sroa.2.0..sroa_idx.i to i32
  call void @__asan_store4_noabort(i32 %1)
  store i32 -1, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.3.0..sroa_idx.i = getelementptr inbounds i8, ptr %sds, i32 56
  %2 = call ptr @memset(ptr %.compoundliteral.sroa.3.0..sroa_idx.i, i32 0, i32 64)
  %3 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %env, align 4
  %child1.i = getelementptr inbounds %struct.sched_domain, ptr %4, i32 0, i32 1
  %5 = ptrtoint ptr %child1.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %child1.i, align 4
  %groups.i = getelementptr inbounds %struct.sched_domain, ptr %4, i32 0, i32 2
  %7 = ptrtoint ptr %groups.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %groups.i, align 8
  %local_stat.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 7
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %tmp_sgs.i) #20
  %9 = call ptr @memset(ptr %tmp_sgs.i, i32 255, i32 48)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %sg_status.i) #20
  %10 = ptrtoint ptr %sg_status.i to i32
  call void @__asan_store4_noabort(i32 %10)
  store i32 0, ptr %sg_status.i, align 4
  %dst_cpu.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 3
  %local4.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 1
  %idle.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 7
  %busiest_stat.i.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 6
  %sum_h_nr_running.i.i = getelementptr inbounds %struct.sg_lb_stats, ptr %tmp_sgs.i, i32 0, i32 6
  %group_type.i.i = getelementptr inbounds %struct.sg_lb_stats, ptr %tmp_sgs.i, i32 0, i32 9
  %group_type3.i.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 7, i32 9
  %group_type8.i.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 6, i32 9
  %idle_cpus.i.i = getelementptr inbounds %struct.sg_lb_stats, ptr %tmp_sgs.i, i32 0, i32 7
  %sum_nr_running.i.i = getelementptr inbounds %struct.sg_lb_stats, ptr %tmp_sgs.i, i32 0, i32 5
  %sum_nr_running48.i.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 6, i32 5
  %group_misfit_task_load.i.i = getelementptr inbounds %struct.sg_lb_stats, ptr %tmp_sgs.i, i32 0, i32 11
  %group_misfit_task_load30.i.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 6, i32 11
  %total_load.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 2
  %total_capacity.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 3
  br label %do.body.i

do.body.i:                                        ; preds = %next_group.i, %entry
  %sg.0.i = phi ptr [ %8, %entry ], [ %103, %next_group.i ]
  %11 = ptrtoint ptr %dst_cpu.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %dst_cpu.i, align 4
  %cpumask.i.i = getelementptr inbounds %struct.sched_group, ptr %sg.0.i, i32 0, i32 6
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %13 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i = icmp ugt i32 %13, %12
  br i1 %cmp.not.i.i.i.i, label %cpumask_test_cpu.exit.i, label %land.rhs.i.i.i.i

land.rhs.i.i.i.i:                                 ; preds = %do.body.i
  %.b37.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i, label %cpumask_test_cpu.exit.i, label %if.then.i.i.i.i, !prof !259

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpumask_test_cpu.exit.i

cpumask_test_cpu.exit.i:                          ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i.i, %do.body.i
  %div3.i.i.i = lshr i32 %12, 5
  %arrayidx.i.i.i = getelementptr i32, ptr %cpumask.i.i, i32 %div3.i.i.i
  %14 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %arrayidx.i.i.i, align 4
  %and.i.i.i = and i32 %12, 31
  %16 = shl nuw i32 1, %and.i.i.i
  %17 = and i32 %15, %16
  %tobool.not.i = icmp eq i32 %17, 0
  br i1 %tobool.not.i, label %if.end12.i, label %if.then.i

if.then.i:                                        ; preds = %cpumask_test_cpu.exit.i
  %18 = ptrtoint ptr %local4.i to i32
  call void @__asan_store4_noabort(i32 %18)
  store ptr %sg.0.i, ptr %local4.i, align 4
  %19 = ptrtoint ptr %idle.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %idle.i, align 4
  %cmp.not.i = icmp eq i32 %20, 2
  br i1 %cmp.not.i, label %lor.lhs.false.i, label %if.then6.i

lor.lhs.false.i:                                  ; preds = %if.then.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %21 = load volatile i32, ptr @jiffies, align 128
  %sgc.i = getelementptr inbounds %struct.sched_group, ptr %sg.0.i, i32 0, i32 3
  %22 = ptrtoint ptr %sgc.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %sgc.i, align 4
  %next_update.i = getelementptr inbounds %struct.sched_group_capacity, ptr %23, i32 0, i32 4
  %24 = ptrtoint ptr %next_update.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %next_update.i, align 4
  %sub.i = sub i32 %21, %25
  %cmp5.i = icmp sgt i32 %sub.i, -1
  br i1 %cmp5.i, label %if.then6.i, label %if.end9.thread.i

if.then6.i:                                       ; preds = %lor.lhs.false.i, %if.then.i
  %26 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load ptr, ptr %env, align 4
  %28 = ptrtoint ptr %dst_cpu.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %dst_cpu.i, align 4
  call void @update_group_capacity(ptr noundef %27, i32 noundef %29) #20
  br label %if.end9.thread.i

if.end9.thread.i:                                 ; preds = %if.then6.i, %lor.lhs.false.i
  call fastcc void @update_sg_lb_stats(ptr noundef %env, ptr noundef nonnull %sds, ptr noundef %sg.0.i, ptr noundef %local_stat.i, ptr noundef nonnull %sg_status.i) #20
  br label %next_group.i

if.end12.i:                                       ; preds = %cpumask_test_cpu.exit.i
  call fastcc void @update_sg_lb_stats(ptr noundef %env, ptr noundef nonnull %sds, ptr noundef %sg.0.i, ptr noundef nonnull %tmp_sgs.i, ptr noundef nonnull %sg_status.i) #20
  %30 = ptrtoint ptr %sum_h_nr_running.i.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load i32, ptr %sum_h_nr_running.i.i, align 4
  %tobool.not.i.i = icmp eq i32 %31, 0
  br i1 %tobool.not.i.i, label %next_group.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.end12.i
  %32 = ptrtoint ptr %group_type.i.i to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %group_type.i.i, align 4
  %cmp.i.i = icmp eq i32 %33, 2
  br i1 %cmp.i.i, label %land.lhs.true.i.i, label %if.end6.i.i

land.lhs.true.i.i:                                ; preds = %if.end.i.i
  %34 = ptrtoint ptr %dst_cpu.i to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load i32, ptr %dst_cpu.i, align 4
  %arrayidx.i.i113.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %35
  %36 = ptrtoint ptr %arrayidx.i.i113.i to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load i32, ptr %arrayidx.i.i113.i, align 4
  %add.i.i.i = add i32 %37, ptrtoint (ptr @runqueues to i32)
  %38 = inttoptr i32 %add.i.i.i to ptr
  %cpu_capacity.i.i.i = getelementptr inbounds %struct.rq, ptr %38, i32 0, i32 37
  %39 = ptrtoint ptr %cpu_capacity.i.i.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load i32, ptr %cpu_capacity.i.i.i, align 16
  %mul.i.i = shl i32 %40, 10
  %sgc.i.i = getelementptr inbounds %struct.sched_group, ptr %sg.0.i, i32 0, i32 3
  %41 = ptrtoint ptr %sgc.i.i to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load ptr, ptr %sgc.i.i, align 4
  %max_capacity.i.i = getelementptr inbounds %struct.sched_group_capacity, ptr %42, i32 0, i32 3
  %43 = ptrtoint ptr %max_capacity.i.i to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load i32, ptr %max_capacity.i.i, align 4
  %mul1.i.i = mul i32 %44, 1078
  %cmp2.i.i = icmp ugt i32 %mul.i.i, %mul1.i.i
  br i1 %cmp2.i.i, label %lor.lhs.false.i.i, label %next_group.i

lor.lhs.false.i.i:                                ; preds = %land.lhs.true.i.i
  %45 = ptrtoint ptr %group_type3.i.i to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load i32, ptr %group_type3.i.i, align 4
  %cmp4.not.i.i = icmp eq i32 %46, 0
  br i1 %cmp4.not.i.i, label %if.end6.i.i, label %next_group.i

if.end6.i.i:                                      ; preds = %lor.lhs.false.i.i, %if.end.i.i
  %47 = ptrtoint ptr %group_type8.i.i to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load i32, ptr %group_type8.i.i, align 4
  %cmp9.i.i = icmp ugt i32 %33, %48
  br i1 %cmp9.i.i, label %if.then14.i, label %if.end11.i.i

if.end11.i.i:                                     ; preds = %if.end6.i.i
  %cmp14.i.i = icmp ult i32 %33, %48
  br i1 %cmp14.i.i, label %next_group.i, label %if.end16.i.i

if.end16.i.i:                                     ; preds = %if.end11.i.i
  switch i32 %33, label %sw.epilog.i.i [
    i32 5, label %sw.bb.i.i
    i32 4, label %next_group.i
    i32 3, label %sw.bb23.i.i
    i32 2, label %sw.bb29.i.i
    i32 1, label %sw.bb34.i.i
    i32 0, label %sw.bb40.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.end16.i.i
  %49 = ptrtoint ptr %tmp_sgs.i to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load i32, ptr %tmp_sgs.i, align 4
  %51 = ptrtoint ptr %busiest_stat.i.i to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load i32, ptr %busiest_stat.i.i, align 4
  %cmp19.not.i.i = icmp ugt i32 %50, %52
  br i1 %cmp19.not.i.i, label %sw.epilog.i.i, label %next_group.i

sw.bb23.i.i:                                      ; preds = %if.end16.i.i
  %asym_prefer_cpu.i.i = getelementptr inbounds %struct.sched_group, ptr %sg.0.i, i32 0, i32 4
  %53 = ptrtoint ptr %asym_prefer_cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load i32, ptr %asym_prefer_cpu.i.i, align 4
  %55 = ptrtoint ptr %sds to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load ptr, ptr %sds, align 4
  %asym_prefer_cpu25.i.i = getelementptr inbounds %struct.sched_group, ptr %56, i32 0, i32 4
  %57 = ptrtoint ptr %asym_prefer_cpu25.i.i to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load i32, ptr %asym_prefer_cpu25.i.i, align 4
  %call.i.i.i = call i32 @arch_asym_cpu_priority(i32 noundef %54) #20
  %call1.i.i.i = call i32 @arch_asym_cpu_priority(i32 noundef %58) #20
  %cmp.i.i.i = icmp sgt i32 %call.i.i.i, %call1.i.i.i
  br i1 %cmp.i.i.i, label %next_group.i, label %sw.epilog.i.i

sw.bb29.i.i:                                      ; preds = %if.end16.i.i
  %59 = ptrtoint ptr %group_misfit_task_load.i.i to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load i32, ptr %group_misfit_task_load.i.i, align 4
  %61 = ptrtoint ptr %group_misfit_task_load30.i.i to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load i32, ptr %group_misfit_task_load30.i.i, align 4
  %cmp31.i.i = icmp ult i32 %60, %62
  br i1 %cmp31.i.i, label %next_group.i, label %sw.epilog.i.i

sw.bb34.i.i:                                      ; preds = %if.end16.i.i
  %63 = ptrtoint ptr %tmp_sgs.i to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load i32, ptr %tmp_sgs.i, align 4
  %65 = ptrtoint ptr %busiest_stat.i.i to i32
  call void @__asan_load4_noabort(i32 %65)
  %66 = load i32, ptr %busiest_stat.i.i, align 4
  %cmp37.not.i.i = icmp ugt i32 %64, %66
  br i1 %cmp37.not.i.i, label %sw.epilog.i.i, label %next_group.i

sw.bb40.i.i:                                      ; preds = %if.end16.i.i
  %67 = ptrtoint ptr %idle_cpus.i.i to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load i32, ptr %idle_cpus.i.i, align 4
  %69 = ptrtoint ptr %.compoundliteral.sroa.2.0..sroa_idx.i to i32
  call void @__asan_load4_noabort(i32 %69)
  %70 = load i32, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 4
  %cmp42.i.i = icmp ugt i32 %68, %70
  br i1 %cmp42.i.i, label %next_group.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %sw.bb40.i.i
  %cmp46.i.i = icmp eq i32 %68, %70
  br i1 %cmp46.i.i, label %land.lhs.true47.i.i, label %sw.epilog.i.i

land.lhs.true47.i.i:                              ; preds = %if.else.i.i
  %71 = ptrtoint ptr %sum_nr_running.i.i to i32
  call void @__asan_load4_noabort(i32 %71)
  %72 = load i32, ptr %sum_nr_running.i.i, align 4
  %73 = ptrtoint ptr %sum_nr_running48.i.i to i32
  call void @__asan_load4_noabort(i32 %73)
  %74 = load i32, ptr %sum_nr_running48.i.i, align 4
  %cmp49.not.i.i = icmp ugt i32 %72, %74
  br i1 %cmp49.not.i.i, label %sw.epilog.i.i, label %next_group.i

sw.epilog.i.i:                                    ; preds = %land.lhs.true47.i.i, %if.else.i.i, %sw.bb34.i.i, %sw.bb29.i.i, %sw.bb23.i.i, %sw.bb.i.i, %if.end16.i.i
  %75 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %75)
  %76 = load ptr, ptr %env, align 4
  %flags.i.i = getelementptr inbounds %struct.sched_domain, ptr %76, i32 0, i32 9
  %77 = ptrtoint ptr %flags.i.i to i32
  call void @__asan_load4_noabort(i32 %77)
  %78 = load i32, ptr %flags.i.i, align 4
  %and.i.i = and i32 %78, 32
  %tobool53.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool53.not.i.i, label %if.then14.i, label %land.lhs.true54.i.i

land.lhs.true54.i.i:                              ; preds = %sw.epilog.i.i
  %79 = ptrtoint ptr %group_type.i.i to i32
  call void @__asan_load4_noabort(i32 %79)
  %80 = load i32, ptr %group_type.i.i, align 4
  %cmp56.i.i = icmp ult i32 %80, 2
  br i1 %cmp56.i.i, label %land.lhs.true57.i.i, label %if.then14.i

land.lhs.true57.i.i:                              ; preds = %land.lhs.true54.i.i
  %sgc58.i.i = getelementptr inbounds %struct.sched_group, ptr %sg.0.i, i32 0, i32 3
  %81 = ptrtoint ptr %sgc58.i.i to i32
  call void @__asan_load4_noabort(i32 %81)
  %82 = load ptr, ptr %sgc58.i.i, align 4
  %min_capacity.i.i = getelementptr inbounds %struct.sched_group_capacity, ptr %82, i32 0, i32 2
  %83 = ptrtoint ptr %min_capacity.i.i to i32
  call void @__asan_load4_noabort(i32 %83)
  %84 = load i32, ptr %min_capacity.i.i, align 4
  %mul59.i.i = shl i32 %84, 10
  %85 = ptrtoint ptr %dst_cpu.i to i32
  call void @__asan_load4_noabort(i32 %85)
  %86 = load i32, ptr %dst_cpu.i, align 4
  %arrayidx.i93.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %86
  %87 = ptrtoint ptr %arrayidx.i93.i.i to i32
  call void @__asan_load4_noabort(i32 %87)
  %88 = load i32, ptr %arrayidx.i93.i.i, align 4
  %add.i94.i.i = add i32 %88, ptrtoint (ptr @runqueues to i32)
  %89 = inttoptr i32 %add.i94.i.i to ptr
  %cpu_capacity.i95.i.i = getelementptr inbounds %struct.rq, ptr %89, i32 0, i32 37
  %90 = ptrtoint ptr %cpu_capacity.i95.i.i to i32
  call void @__asan_load4_noabort(i32 %90)
  %91 = load i32, ptr %cpu_capacity.i95.i.i, align 16
  %mul62.i.i = mul i32 %91, 1078
  %cmp63.i.i = icmp ugt i32 %mul59.i.i, %mul62.i.i
  br i1 %cmp63.i.i, label %next_group.i, label %if.then14.i

if.then14.i:                                      ; preds = %land.lhs.true57.i.i, %land.lhs.true54.i.i, %sw.epilog.i.i, %if.end6.i.i
  %92 = ptrtoint ptr %sds to i32
  call void @__asan_store4_noabort(i32 %92)
  store ptr %sg.0.i, ptr %sds, align 4
  %93 = call ptr @memcpy(ptr %busiest_stat.i.i, ptr %tmp_sgs.i, i32 48)
  br label %next_group.i

next_group.i:                                     ; preds = %if.then14.i, %land.lhs.true57.i.i, %land.lhs.true47.i.i, %sw.bb40.i.i, %sw.bb34.i.i, %sw.bb29.i.i, %sw.bb23.i.i, %sw.bb.i.i, %if.end16.i.i, %if.end11.i.i, %lor.lhs.false.i.i, %land.lhs.true.i.i, %if.end12.i, %if.end9.thread.i
  %sgs.0115.i = phi ptr [ %local_stat.i, %if.end9.thread.i ], [ %tmp_sgs.i, %if.then14.i ], [ %tmp_sgs.i, %if.end12.i ], [ %tmp_sgs.i, %lor.lhs.false.i.i ], [ %tmp_sgs.i, %land.lhs.true.i.i ], [ %tmp_sgs.i, %if.end11.i.i ], [ %tmp_sgs.i, %sw.bb.i.i ], [ %tmp_sgs.i, %if.end16.i.i ], [ %tmp_sgs.i, %sw.bb23.i.i ], [ %tmp_sgs.i, %sw.bb29.i.i ], [ %tmp_sgs.i, %sw.bb34.i.i ], [ %tmp_sgs.i, %sw.bb40.i.i ], [ %tmp_sgs.i, %land.lhs.true47.i.i ], [ %tmp_sgs.i, %land.lhs.true57.i.i ]
  %group_load.i = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs.0115.i, i32 0, i32 1
  %94 = ptrtoint ptr %group_load.i to i32
  call void @__asan_load4_noabort(i32 %94)
  %95 = load i32, ptr %group_load.i, align 4
  %96 = ptrtoint ptr %total_load.i to i32
  call void @__asan_load4_noabort(i32 %96)
  %97 = load i32, ptr %total_load.i, align 4
  %add.i = add i32 %97, %95
  store i32 %add.i, ptr %total_load.i, align 4
  %group_capacity.i = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs.0115.i, i32 0, i32 2
  %98 = ptrtoint ptr %group_capacity.i to i32
  call void @__asan_load4_noabort(i32 %98)
  %99 = load i32, ptr %group_capacity.i, align 4
  %100 = ptrtoint ptr %total_capacity.i to i32
  call void @__asan_load4_noabort(i32 %100)
  %101 = load i32, ptr %total_capacity.i, align 4
  %add16.i = add i32 %101, %99
  store i32 %add16.i, ptr %total_capacity.i, align 4
  %102 = ptrtoint ptr %sg.0.i to i32
  call void @__asan_load4_noabort(i32 %102)
  %103 = load ptr, ptr %sg.0.i, align 4
  %104 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %104)
  %105 = load ptr, ptr %env, align 4
  %groups18.i = getelementptr inbounds %struct.sched_domain, ptr %105, i32 0, i32 2
  %106 = ptrtoint ptr %groups18.i to i32
  call void @__asan_load4_noabort(i32 %106)
  %107 = load ptr, ptr %groups18.i, align 8
  %cmp19.not.i = icmp eq ptr %103, %107
  br i1 %cmp19.not.i, label %do.end.i, label %do.body.i

do.end.i:                                         ; preds = %next_group.i
  %tobool20.not.i = icmp eq ptr %6, null
  br i1 %tobool20.not.i, label %land.end.i, label %land.rhs.i

land.rhs.i:                                       ; preds = %do.end.i
  %flags.i = getelementptr inbounds %struct.sched_domain, ptr %6, i32 0, i32 9
  %108 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %108)
  %109 = load i32, ptr %flags.i, align 4
  %and.i = lshr i32 %109, 11
  %and.lobit.i = and i32 %and.i, 1
  br label %land.end.i

land.end.i:                                       ; preds = %land.rhs.i, %do.end.i
  %110 = phi i32 [ 0, %do.end.i ], [ %and.lobit.i, %land.rhs.i ]
  %prefer_sibling.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 5
  %111 = ptrtoint ptr %prefer_sibling.i to i32
  call void @__asan_store4_noabort(i32 %111)
  store i32 %110, ptr %prefer_sibling.i, align 4
  %flags23.i = getelementptr inbounds %struct.sched_domain, ptr %105, i32 0, i32 9
  %112 = ptrtoint ptr %flags23.i to i32
  call void @__asan_load4_noabort(i32 %112)
  %113 = load i32, ptr %flags23.i, align 4
  %and24.i = and i32 %113, 8192
  %tobool25.not.i = icmp eq i32 %and24.i, 0
  br i1 %tobool25.not.i, label %if.end29.i, label %if.then26.i

if.then26.i:                                      ; preds = %land.end.i
  %fbq_type.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 14
  %114 = ptrtoint ptr %fbq_type.i to i32
  call void @__asan_store4_noabort(i32 %114)
  store i32 2, ptr %fbq_type.i, align 4
  br label %if.end29.i

if.end29.i:                                       ; preds = %if.then26.i, %land.end.i
  %115 = ptrtoint ptr %105 to i32
  call void @__asan_load4_noabort(i32 %115)
  %116 = load ptr, ptr %105, align 8
  %tobool31.not.i = icmp eq ptr %116, null
  br i1 %tobool31.not.i, label %if.then32.i, label %if.else.i

if.then32.i:                                      ; preds = %if.end29.i
  %dst_rq.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 4
  %117 = ptrtoint ptr %dst_rq.i to i32
  call void @__asan_load4_noabort(i32 %117)
  %118 = load ptr, ptr %dst_rq.i, align 4
  %rd33.i = getelementptr inbounds %struct.rq, ptr %118, i32 0, i32 35
  %119 = ptrtoint ptr %rd33.i to i32
  call void @__asan_load4_noabort(i32 %119)
  %120 = load ptr, ptr %rd33.i, align 8
  %121 = ptrtoint ptr %sg_status.i to i32
  call void @__asan_load4_noabort(i32 %121)
  %122 = load i32, ptr %sg_status.i, align 4
  %and39.i = and i32 %122, 1
  %overload.i = getelementptr inbounds %struct.root_domain, ptr %120, i32 0, i32 5
  %123 = ptrtoint ptr %overload.i to i32
  call void @__asan_store4_noabort(i32 %123)
  store volatile i32 %and39.i, ptr %overload.i, align 8
  %and49.i = and i32 %122, 2
  %overutilized.i = getelementptr inbounds %struct.root_domain, ptr %120, i32 0, i32 6
  %124 = ptrtoint ptr %overutilized.i to i32
  call void @__asan_store4_noabort(i32 %124)
  store volatile i32 %and49.i, ptr %overutilized.i, align 4
  %tobool55.i = icmp ne i32 %and49.i, 0
  call fastcc void @trace_sched_overutilized_tp(ptr noundef %120, i1 noundef zeroext %tobool55.i) #20
  br label %update_sd_lb_stats.exit

if.else.i:                                        ; preds = %if.end29.i
  %125 = ptrtoint ptr %sg_status.i to i32
  call void @__asan_load4_noabort(i32 %125)
  %126 = load i32, ptr %sg_status.i, align 4
  %and56.i = and i32 %126, 2
  %tobool57.not.i = icmp eq i32 %and56.i, 0
  br i1 %tobool57.not.i, label %update_sd_lb_stats.exit, label %if.then58.i

if.then58.i:                                      ; preds = %if.else.i
  %dst_rq60.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 4
  %127 = ptrtoint ptr %dst_rq60.i to i32
  call void @__asan_load4_noabort(i32 %127)
  %128 = load ptr, ptr %dst_rq60.i, align 4
  %rd61.i = getelementptr inbounds %struct.rq, ptr %128, i32 0, i32 35
  %129 = ptrtoint ptr %rd61.i to i32
  call void @__asan_load4_noabort(i32 %129)
  %130 = load ptr, ptr %rd61.i, align 8
  %overutilized67.i = getelementptr inbounds %struct.root_domain, ptr %130, i32 0, i32 6
  %131 = ptrtoint ptr %overutilized67.i to i32
  call void @__asan_store4_noabort(i32 %131)
  store volatile i32 2, ptr %overutilized67.i, align 4
  call fastcc void @trace_sched_overutilized_tp(ptr noundef %130, i1 noundef zeroext true) #20
  br label %update_sd_lb_stats.exit

update_sd_lb_stats.exit:                          ; preds = %if.then58.i, %if.else.i, %if.then32.i
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %sg_status.i) #20
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %tmp_sgs.i) #20
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_energy_present, ptr blockaddress(@find_busiest_group, %if.then)) #20
          to label %if.end21 [label %if.then], !srcloc !261

if.then:                                          ; preds = %update_sd_lb_stats.exit
  %dst_rq = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 4
  %132 = ptrtoint ptr %dst_rq to i32
  call void @__asan_load4_noabort(i32 %132)
  %133 = load ptr, ptr %dst_rq, align 4
  %rd1 = getelementptr inbounds %struct.rq, ptr %133, i32 0, i32 35
  %134 = ptrtoint ptr %rd1 to i32
  call void @__asan_load4_noabort(i32 %134)
  %135 = load ptr, ptr %rd1, align 8
  %pd = getelementptr inbounds %struct.root_domain, ptr %135, i32 0, i32 21
  %136 = ptrtoint ptr %pd to i32
  call void @__asan_load4_noabort(i32 %136)
  %137 = load volatile ptr, ptr %pd, align 8
  %call3 = call i32 @rcu_read_lock_held() #20
  %tobool.not = icmp eq i32 %call3, 0
  br i1 %tobool.not, label %land.lhs.true, label %do.end10

land.lhs.true:                                    ; preds = %if.then
  %call4 = call i32 @debug_lockdep_rcu_enabled() #20
  %tobool5.not = icmp eq i32 %call4, 0
  br i1 %tobool5.not, label %do.end10, label %land.lhs.true6

land.lhs.true6:                                   ; preds = %land.lhs.true
  %.b120 = load i1, ptr @find_busiest_group.__warned, align 1
  br i1 %.b120, label %do.end10, label %if.then8

if.then8:                                         ; preds = %land.lhs.true6
  store i1 true, ptr @find_busiest_group.__warned, align 1
  call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 9484, ptr noundef nonnull @.str.16) #20
  br label %do.end10

do.end10:                                         ; preds = %if.then8, %land.lhs.true6, %land.lhs.true, %if.then
  %tobool12.not = icmp eq ptr %137, null
  br i1 %tobool12.not, label %if.end21, label %do.end16

do.end16:                                         ; preds = %do.end10
  %overutilized = getelementptr inbounds %struct.root_domain, ptr %135, i32 0, i32 6
  %138 = ptrtoint ptr %overutilized to i32
  call void @__asan_load4_noabort(i32 %138)
  %139 = load volatile i32, ptr %overutilized, align 4
  %tobool18.not = icmp eq i32 %139, 0
  br i1 %tobool18.not, label %out_balanced, label %if.end21

if.end21:                                         ; preds = %do.end16, %do.end10, %update_sd_lb_stats.exit
  %140 = ptrtoint ptr %sds to i32
  call void @__asan_load4_noabort(i32 %140)
  %141 = load ptr, ptr %sds, align 4
  %tobool23.not = icmp eq ptr %141, null
  br i1 %tobool23.not, label %out_balanced, label %if.end25

if.end25:                                         ; preds = %if.end21
  %142 = ptrtoint ptr %group_type8.i.i to i32
  call void @__asan_load4_noabort(i32 %142)
  %143 = load i32, ptr %group_type8.i.i, align 4
  %.off = add i32 %143, -2
  %switch122 = icmp ult i32 %.off, 3
  br i1 %switch122, label %force_balance, label %if.end35

if.end35:                                         ; preds = %if.end25
  %144 = ptrtoint ptr %group_type3.i.i to i32
  call void @__asan_load4_noabort(i32 %144)
  %145 = load i32, ptr %group_type3.i.i, align 4
  %cmp38 = icmp ugt i32 %145, %143
  br i1 %cmp38, label %out_balanced, label %if.end40

if.end40:                                         ; preds = %if.end35
  %cmp42 = icmp eq i32 %145, 5
  br i1 %cmp42, label %if.then43, label %if.end61

if.then43:                                        ; preds = %if.end40
  %146 = ptrtoint ptr %local_stat.i to i32
  call void @__asan_load4_noabort(i32 %146)
  %147 = load i32, ptr %local_stat.i, align 4
  %148 = ptrtoint ptr %busiest_stat.i.i to i32
  call void @__asan_load4_noabort(i32 %148)
  %149 = load i32, ptr %busiest_stat.i.i, align 4
  %cmp45.not = icmp ult i32 %147, %149
  br i1 %cmp45.not, label %if.end47, label %out_balanced

if.end47:                                         ; preds = %if.then43
  %150 = ptrtoint ptr %total_load.i to i32
  call void @__asan_load4_noabort(i32 %150)
  %151 = load i32, ptr %total_load.i, align 4
  %mul = shl i32 %151, 10
  %152 = ptrtoint ptr %total_capacity.i to i32
  call void @__asan_load4_noabort(i32 %152)
  %153 = load i32, ptr %total_capacity.i, align 4
  %div = udiv i32 %mul, %153
  %avg_load48 = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 4
  %154 = ptrtoint ptr %avg_load48 to i32
  call void @__asan_store4_noabort(i32 %154)
  store i32 %div, ptr %avg_load48, align 4
  %cmp51.not = icmp ult i32 %147, %div
  br i1 %cmp51.not, label %if.end53, label %out_balanced

if.end53:                                         ; preds = %if.end47
  %mul55 = mul i32 %149, 100
  %155 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %155)
  %156 = load ptr, ptr %env, align 4
  %imbalance_pct = getelementptr inbounds %struct.sched_domain, ptr %156, i32 0, i32 6
  %157 = ptrtoint ptr %imbalance_pct to i32
  call void @__asan_load4_noabort(i32 %157)
  %158 = load i32, ptr %imbalance_pct, align 8
  %mul57 = mul i32 %158, %147
  %cmp58.not = icmp ugt i32 %mul55, %mul57
  br i1 %cmp58.not, label %if.end70, label %out_balanced

if.end61:                                         ; preds = %if.end40
  %159 = ptrtoint ptr %prefer_sibling.i to i32
  call void @__asan_load4_noabort(i32 %159)
  %160 = load i32, ptr %prefer_sibling.i, align 4
  %tobool62.not = icmp ne i32 %160, 0
  %cmp65 = icmp eq i32 %145, 0
  %or.cond = select i1 %tobool62.not, i1 %cmp65, i1 false
  br i1 %or.cond, label %land.lhs.true66, label %if.end70

land.lhs.true66:                                  ; preds = %if.end61
  %161 = ptrtoint ptr %sum_nr_running48.i.i to i32
  call void @__asan_load4_noabort(i32 %161)
  %162 = load i32, ptr %sum_nr_running48.i.i, align 4
  %sum_nr_running67 = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 7, i32 5
  %163 = ptrtoint ptr %sum_nr_running67 to i32
  call void @__asan_load4_noabort(i32 %163)
  %164 = load i32, ptr %sum_nr_running67, align 4
  %add = add i32 %164, 1
  %cmp68 = icmp ugt i32 %162, %add
  br i1 %cmp68, label %force_balance, label %if.end70

if.end70:                                         ; preds = %land.lhs.true66, %if.end61, %if.end53
  %cmp72.not = icmp eq i32 %143, 5
  br i1 %cmp72.not, label %if.end12.i125.thread, label %if.then73

if.then73:                                        ; preds = %if.end70
  %165 = ptrtoint ptr %idle.i to i32
  call void @__asan_load4_noabort(i32 %165)
  %166 = load i32, ptr %idle.i, align 4
  %cmp74 = icmp eq i32 %166, 1
  br i1 %cmp74, label %out_balanced, label %if.end76

if.end76:                                         ; preds = %if.then73
  %167 = ptrtoint ptr %.compoundliteral.sroa.3.0..sroa_idx.i to i32
  call void @__asan_load4_noabort(i32 %167)
  %168 = load i32, ptr %.compoundliteral.sroa.3.0..sroa_idx.i, align 4
  %cmp77 = icmp ugt i32 %168, 1
  br i1 %cmp77, label %land.lhs.true78, label %if.end83

land.lhs.true78:                                  ; preds = %if.end76
  %idle_cpus = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 7, i32 7
  %169 = ptrtoint ptr %idle_cpus to i32
  call void @__asan_load4_noabort(i32 %169)
  %170 = load i32, ptr %idle_cpus, align 4
  %171 = ptrtoint ptr %.compoundliteral.sroa.2.0..sroa_idx.i to i32
  call void @__asan_load4_noabort(i32 %171)
  %172 = load i32, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 4
  %add80 = add i32 %172, 1
  %cmp81.not = icmp ugt i32 %170, %add80
  br i1 %cmp81.not, label %if.end83, label %out_balanced

if.end83:                                         ; preds = %land.lhs.true78, %if.end76
  %sum_h_nr_running = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 6, i32 6
  %173 = ptrtoint ptr %sum_h_nr_running to i32
  call void @__asan_load4_noabort(i32 %173)
  %174 = load i32, ptr %sum_h_nr_running, align 4
  %cmp84 = icmp eq i32 %174, 1
  br i1 %cmp84, label %out_balanced, label %force_balance

force_balance:                                    ; preds = %if.end83, %land.lhs.true66, %if.end25
  switch i32 %143, label %if.end12.i125 [
    i32 2, label %if.then.i124
    i32 3, label %if.then3.i
    i32 4, label %if.then9.i
  ]

if.then.i124:                                     ; preds = %force_balance
  %migration_type.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 15
  %175 = ptrtoint ptr %migration_type.i to i32
  call void @__asan_store4_noabort(i32 %175)
  store i32 3, ptr %migration_type.i, align 4
  %imbalance.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 8
  %176 = ptrtoint ptr %imbalance.i to i32
  call void @__asan_store4_noabort(i32 %176)
  store i32 1, ptr %imbalance.i, align 4
  br label %calculate_imbalance.exit

if.then3.i:                                       ; preds = %force_balance
  %migration_type4.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 15
  %177 = ptrtoint ptr %migration_type4.i to i32
  call void @__asan_store4_noabort(i32 %177)
  store i32 2, ptr %migration_type4.i, align 4
  %sum_h_nr_running.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 6, i32 6
  %178 = ptrtoint ptr %sum_h_nr_running.i to i32
  call void @__asan_load4_noabort(i32 %178)
  %179 = load i32, ptr %sum_h_nr_running.i, align 4
  %imbalance5.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 8
  %180 = ptrtoint ptr %imbalance5.i to i32
  call void @__asan_store4_noabort(i32 %180)
  store i32 %179, ptr %imbalance5.i, align 4
  br label %calculate_imbalance.exit

if.then9.i:                                       ; preds = %force_balance
  %migration_type10.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 15
  %181 = ptrtoint ptr %migration_type10.i to i32
  call void @__asan_store4_noabort(i32 %181)
  store i32 2, ptr %migration_type10.i, align 4
  %imbalance11.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 8
  %182 = ptrtoint ptr %imbalance11.i to i32
  call void @__asan_store4_noabort(i32 %182)
  store i32 1, ptr %imbalance11.i, align 4
  br label %calculate_imbalance.exit

if.end12.i125:                                    ; preds = %force_balance
  %183 = ptrtoint ptr %group_type3.i.i to i32
  call void @__asan_load4_noabort(i32 %183)
  %184 = load i32, ptr %group_type3.i.i, align 4
  %cmp14.i = icmp eq i32 %184, 0
  br i1 %cmp14.i, label %if.then15.i, label %if.end67.i

if.end12.i125.thread:                             ; preds = %if.end70
  %185 = ptrtoint ptr %group_type3.i.i to i32
  call void @__asan_load4_noabort(i32 %185)
  %186 = load i32, ptr %group_type3.i.i, align 4
  %cmp14.i145 = icmp eq i32 %186, 0
  br i1 %cmp14.i145, label %land.lhs.true.i, label %if.end67.i

if.then15.i:                                      ; preds = %if.end12.i125
  %cmp17.i = icmp ugt i32 %143, 1
  br i1 %cmp17.i, label %land.lhs.true.i, label %if.end31.i

land.lhs.true.i:                                  ; preds = %if.then15.i, %if.end12.i125.thread
  %187 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %187)
  %188 = load ptr, ptr %env, align 4
  %flags.i126 = getelementptr inbounds %struct.sched_domain, ptr %188, i32 0, i32 9
  %189 = ptrtoint ptr %flags.i126 to i32
  call void @__asan_load4_noabort(i32 %189)
  %190 = load i32, ptr %flags.i126, align 4
  %and.i127 = and i32 %190, 256
  %tobool.not.i128 = icmp eq i32 %and.i127, 0
  br i1 %tobool.not.i128, label %if.then18.i, label %if.end31.i

if.then18.i:                                      ; preds = %land.lhs.true.i
  %migration_type19.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 15
  %191 = ptrtoint ptr %migration_type19.i to i32
  call void @__asan_store4_noabort(i32 %191)
  store i32 1, ptr %migration_type19.i, align 4
  %group_capacity.i129 = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 7, i32 2
  %192 = ptrtoint ptr %group_capacity.i129 to i32
  call void @__asan_load4_noabort(i32 %192)
  %193 = load i32, ptr %group_capacity.i129, align 4
  %group_util.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 7, i32 3
  %194 = ptrtoint ptr %group_util.i to i32
  call void @__asan_load4_noabort(i32 %194)
  %195 = load i32, ptr %group_util.i, align 4
  %196 = call i32 @llvm.usub.sat.i32(i32 %193, i32 %195) #20
  %imbalance22.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 8
  %197 = ptrtoint ptr %imbalance22.i to i32
  call void @__asan_store4_noabort(i32 %197)
  store i32 %196, ptr %imbalance22.i, align 4
  %198 = ptrtoint ptr %idle.i to i32
  call void @__asan_load4_noabort(i32 %198)
  %199 = load i32, ptr %idle.i, align 4
  %cmp23.not.i = icmp ne i32 %199, 1
  %cmp26.i = icmp uge i32 %195, %193
  %or.cond.i = select i1 %cmp23.not.i, i1 %cmp26.i, i1 false
  br i1 %or.cond.i, label %if.then27.i, label %calculate_imbalance.exit

if.then27.i:                                      ; preds = %if.then18.i
  %200 = ptrtoint ptr %migration_type19.i to i32
  call void @__asan_store4_noabort(i32 %200)
  store i32 2, ptr %migration_type19.i, align 4
  %201 = ptrtoint ptr %imbalance22.i to i32
  call void @__asan_store4_noabort(i32 %201)
  store i32 1, ptr %imbalance22.i, align 4
  br label %calculate_imbalance.exit

if.end31.i:                                       ; preds = %land.lhs.true.i, %if.then15.i
  %202 = ptrtoint ptr %.compoundliteral.sroa.3.0..sroa_idx.i to i32
  call void @__asan_load4_noabort(i32 %202)
  %203 = load i32, ptr %.compoundliteral.sroa.3.0..sroa_idx.i, align 4
  %cmp32.i = icmp eq i32 %203, 1
  br i1 %cmp32.i, label %if.then34.i, label %lor.lhs.false.i132

lor.lhs.false.i132:                               ; preds = %if.end31.i
  %204 = ptrtoint ptr %prefer_sibling.i to i32
  call void @__asan_load4_noabort(i32 %204)
  %205 = load i32, ptr %prefer_sibling.i, align 4
  %tobool33.not.i = icmp eq i32 %205, 0
  br i1 %tobool33.not.i, label %if.else.i133, label %if.then34.i

if.then34.i:                                      ; preds = %lor.lhs.false.i132, %if.end31.i
  %206 = ptrtoint ptr %sum_nr_running48.i.i to i32
  call void @__asan_load4_noabort(i32 %206)
  %207 = load i32, ptr %sum_nr_running48.i.i, align 4
  %migration_type35.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 15
  %208 = ptrtoint ptr %migration_type35.i to i32
  call void @__asan_store4_noabort(i32 %208)
  store i32 2, ptr %migration_type35.i, align 4
  %sum_nr_running36.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 7, i32 5
  %209 = ptrtoint ptr %sum_nr_running36.i to i32
  call void @__asan_load4_noabort(i32 %209)
  %210 = load i32, ptr %sum_nr_running36.i, align 4
  %211 = call i32 @llvm.usub.sat.i32(i32 %207, i32 %210) #20
  br label %if.end56.i

if.else.i133:                                     ; preds = %lor.lhs.false.i132
  %migration_type45.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 15
  %212 = ptrtoint ptr %migration_type45.i to i32
  call void @__asan_store4_noabort(i32 %212)
  store i32 2, ptr %migration_type45.i, align 4
  %idle_cpus.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 7, i32 7
  %213 = ptrtoint ptr %idle_cpus.i to i32
  call void @__asan_load4_noabort(i32 %213)
  %214 = load i32, ptr %idle_cpus.i, align 4
  %215 = ptrtoint ptr %.compoundliteral.sroa.2.0..sroa_idx.i to i32
  call void @__asan_load4_noabort(i32 %215)
  %216 = load i32, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 4
  %sub47.i = sub i32 %214, %216
  br label %if.end56.i

if.end56.i:                                       ; preds = %if.else.i133, %if.then34.i
  %sub47.sink.i = phi i32 [ %sub47.i, %if.else.i133 ], [ %211, %if.then34.i ]
  %shr48.i = lshr i32 %sub47.sink.i, 1
  %imbalance55.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 8
  %217 = ptrtoint ptr %imbalance55.i to i32
  call void @__asan_store4_noabort(i32 %217)
  store i32 %shr48.i, ptr %imbalance55.i, align 4
  %218 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %218)
  %219 = load ptr, ptr %env, align 4
  %flags58.i = getelementptr inbounds %struct.sched_domain, ptr %219, i32 0, i32 9
  %220 = ptrtoint ptr %flags58.i to i32
  call void @__asan_load4_noabort(i32 %220)
  %221 = load i32, ptr %flags58.i, align 4
  %and59.i = and i32 %221, 8192
  %tobool60.not.i = icmp eq i32 %and59.i, 0
  br i1 %tobool60.not.i, label %calculate_imbalance.exit, label %if.then61.i

if.then61.i:                                      ; preds = %if.end56.i
  %222 = ptrtoint ptr %sum_nr_running48.i.i to i32
  call void @__asan_load4_noabort(i32 %222)
  %223 = load i32, ptr %sum_nr_running48.i.i, align 4
  %shr.i.i.i = ashr i32 %203, 2
  %cmp.i.i.i134 = icmp sgt i32 %shr.i.i.i, %223
  %cmp.i.i135 = icmp ult i32 %sub47.sink.i, 6
  %224 = and i1 %cmp.i.i135, %cmp.i.i.i134
  %retval.0.i.i136 = select i1 %224, i32 0, i32 %shr48.i
  %225 = ptrtoint ptr %imbalance55.i to i32
  call void @__asan_store4_noabort(i32 %225)
  store i32 %retval.0.i.i136, ptr %imbalance55.i, align 4
  br label %calculate_imbalance.exit

if.end67.i:                                       ; preds = %if.end12.i125.thread, %if.end12.i125
  %226 = phi i32 [ %186, %if.end12.i125.thread ], [ %184, %if.end12.i125 ]
  %cmp69.i = icmp ult i32 %226, 5
  br i1 %cmp69.i, label %if.then70.i, label %if.end81.i

if.then70.i:                                      ; preds = %if.end67.i
  %group_load.i137 = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 7, i32 1
  %227 = ptrtoint ptr %group_load.i137 to i32
  call void @__asan_load4_noabort(i32 %227)
  %228 = load i32, ptr %group_load.i137, align 4
  %mul.i = shl i32 %228, 10
  %group_capacity71.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 7, i32 2
  %229 = ptrtoint ptr %group_capacity71.i to i32
  call void @__asan_load4_noabort(i32 %229)
  %230 = load i32, ptr %group_capacity71.i, align 4
  %div.i = udiv i32 %mul.i, %230
  %231 = ptrtoint ptr %local_stat.i to i32
  call void @__asan_store4_noabort(i32 %231)
  store i32 %div.i, ptr %local_stat.i, align 4
  %232 = ptrtoint ptr %total_load.i to i32
  call void @__asan_load4_noabort(i32 %232)
  %233 = load i32, ptr %total_load.i, align 4
  %mul72.i = shl i32 %233, 10
  %234 = ptrtoint ptr %total_capacity.i to i32
  call void @__asan_load4_noabort(i32 %234)
  %235 = load i32, ptr %total_capacity.i, align 4
  %div73.i = udiv i32 %mul72.i, %235
  %avg_load74.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 4
  %236 = ptrtoint ptr %avg_load74.i to i32
  call void @__asan_store4_noabort(i32 %236)
  store i32 %div73.i, ptr %avg_load74.i, align 4
  %237 = ptrtoint ptr %busiest_stat.i.i to i32
  call void @__asan_load4_noabort(i32 %237)
  %238 = load i32, ptr %busiest_stat.i.i, align 4
  %cmp77.not.i = icmp ult i32 %div.i, %238
  br i1 %cmp77.not.i, label %if.end81.i, label %if.then78.i

if.then78.i:                                      ; preds = %if.then70.i
  %imbalance79.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 8
  %239 = ptrtoint ptr %imbalance79.i to i32
  call void @__asan_store4_noabort(i32 %239)
  store i32 0, ptr %imbalance79.i, align 4
  br label %calculate_imbalance.exit

if.end81.i:                                       ; preds = %if.then70.i, %if.end67.i
  %migration_type82.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 15
  %240 = ptrtoint ptr %migration_type82.i to i32
  call void @__asan_store4_noabort(i32 %240)
  store i32 0, ptr %migration_type82.i, align 4
  %241 = ptrtoint ptr %busiest_stat.i.i to i32
  call void @__asan_load4_noabort(i32 %241)
  %242 = load i32, ptr %busiest_stat.i.i, align 4
  %avg_load84.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 4
  %243 = ptrtoint ptr %avg_load84.i to i32
  call void @__asan_load4_noabort(i32 %243)
  %244 = load i32, ptr %avg_load84.i, align 4
  %sub85.i = sub i32 %242, %244
  %group_capacity86.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 6, i32 2
  %245 = ptrtoint ptr %group_capacity86.i to i32
  call void @__asan_load4_noabort(i32 %245)
  %246 = load i32, ptr %group_capacity86.i, align 4
  %mul87.i = mul i32 %sub85.i, %246
  %247 = ptrtoint ptr %local_stat.i to i32
  call void @__asan_load4_noabort(i32 %247)
  %248 = load i32, ptr %local_stat.i, align 4
  %sub90.i = sub i32 %244, %248
  %group_capacity91.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 7, i32 2
  %249 = ptrtoint ptr %group_capacity91.i to i32
  call void @__asan_load4_noabort(i32 %249)
  %250 = load i32, ptr %group_capacity91.i, align 4
  %mul92.i = mul i32 %sub90.i, %250
  %251 = call i32 @llvm.umin.i32(i32 %mul87.i, i32 %mul92.i) #20
  %div99171.i = lshr i32 %251, 10
  %imbalance100.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 8
  %252 = ptrtoint ptr %imbalance100.i to i32
  call void @__asan_store4_noabort(i32 %252)
  store i32 %div99171.i, ptr %imbalance100.i, align 4
  br label %calculate_imbalance.exit

calculate_imbalance.exit:                         ; preds = %if.end81.i, %if.then78.i, %if.then61.i, %if.end56.i, %if.then27.i, %if.then18.i, %if.then9.i, %if.then3.i, %if.then.i124
  %imbalance = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 8
  %253 = ptrtoint ptr %imbalance to i32
  call void @__asan_load4_noabort(i32 %253)
  %254 = load i32, ptr %imbalance, align 4
  %tobool88.not = icmp eq i32 %254, 0
  %spec.select = select i1 %tobool88.not, ptr null, ptr %141
  br label %cleanup91

out_balanced:                                     ; preds = %if.end83, %land.lhs.true78, %if.then73, %if.end53, %if.end47, %if.then43, %if.end35, %if.end21, %do.end16
  %imbalance90 = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 8
  %255 = ptrtoint ptr %imbalance90 to i32
  call void @__asan_store4_noabort(i32 %255)
  store i32 0, ptr %imbalance90, align 4
  br label %cleanup91

cleanup91:                                        ; preds = %out_balanced, %calculate_imbalance.exit
  %retval.0 = phi ptr [ null, %out_balanced ], [ %spec.select, %calculate_imbalance.exit ]
  call void @llvm.lifetime.end.p0(i64 120, ptr nonnull %sds) #20
  ret ptr %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc ptr @find_busiest_queue(ptr nocapture noundef readonly %env, ptr noundef %group) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %cpumask.i = getelementptr inbounds %struct.sched_group, ptr %group, i32 0, i32 6
  %cpus = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 9
  %0 = ptrtoint ptr %cpus to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %cpus, align 4
  %call1118 = tail call i32 @cpumask_next_and(i32 noundef -1, ptr noundef %cpumask.i, ptr noundef %1) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %2 = load i32, ptr @nr_cpu_ids, align 4
  %cmp119 = icmp ult i32 %call1118, %2
  br i1 %cmp119, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %entry
  %dst_cpu = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 3
  %migration_type = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 15
  %imbalance = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 8
  br label %for.body

for.body:                                         ; preds = %cleanup, %for.body.lr.ph
  %call1130 = phi i32 [ %call1118, %for.body.lr.ph ], [ %call1, %cleanup ]
  %busiest.0128 = phi ptr [ null, %for.body.lr.ph ], [ %busiest.2, %cleanup ]
  %busiest_util.0126 = phi i32 [ 0, %for.body.lr.ph ], [ %busiest_util.2, %cleanup ]
  %busiest_load.0124 = phi i32 [ 0, %for.body.lr.ph ], [ %busiest_load.2, %cleanup ]
  %busiest_capacity.0122 = phi i32 [ 1, %for.body.lr.ph ], [ %busiest_capacity.2, %cleanup ]
  %busiest_nr.0120 = phi i32 [ 0, %for.body.lr.ph ], [ %busiest_nr.2, %cleanup ]
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call1130
  %3 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %arrayidx, align 4
  %add = add i32 %4, ptrtoint (ptr @runqueues to i32)
  %5 = inttoptr i32 %add to ptr
  %h_nr_running = getelementptr inbounds %struct.rq, ptr %5, i32 0, i32 14, i32 2
  %6 = ptrtoint ptr %h_nr_running to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %h_nr_running, align 4
  %tobool.not = icmp eq i32 %7, 0
  br i1 %tobool.not, label %cleanup, label %if.end6

if.end6:                                          ; preds = %for.body
  %cpu_capacity.i = getelementptr inbounds %struct.rq, ptr %5, i32 0, i32 37
  %8 = ptrtoint ptr %cpu_capacity.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %cpu_capacity.i, align 16
  %10 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %env, align 4
  %flags = getelementptr inbounds %struct.sched_domain, ptr %11, i32 0, i32 9
  %12 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %flags, align 4
  %and = and i32 %13, 32
  %tobool8.not = icmp eq i32 %and, 0
  br i1 %tobool8.not, label %if.end15, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end6
  %14 = ptrtoint ptr %dst_cpu to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %dst_cpu, align 4
  %arrayidx.i111 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %15
  %16 = ptrtoint ptr %arrayidx.i111 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %arrayidx.i111, align 4
  %add.i112 = add i32 %17, ptrtoint (ptr @runqueues to i32)
  %18 = inttoptr i32 %add.i112 to ptr
  %cpu_capacity.i113 = getelementptr inbounds %struct.rq, ptr %18, i32 0, i32 37
  %19 = ptrtoint ptr %cpu_capacity.i113 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %cpu_capacity.i113, align 16
  %mul = shl i32 %20, 10
  %mul10 = mul i32 %9, 1078
  %cmp11 = icmp ule i32 %mul, %mul10
  %cmp13 = icmp eq i32 %7, 1
  %or.cond = select i1 %cmp11, i1 %cmp13, i1 false
  br i1 %or.cond, label %cleanup, label %if.end15

if.end15:                                         ; preds = %land.lhs.true, %if.end6
  %and18 = and i32 %13, 1024
  %tobool19.not = icmp eq i32 %and18, 0
  br i1 %tobool19.not, label %if.end26, label %land.lhs.true20

land.lhs.true20:                                  ; preds = %if.end15
  %21 = ptrtoint ptr %dst_cpu to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load i32, ptr %dst_cpu, align 4
  %call.i = tail call i32 @arch_asym_cpu_priority(i32 noundef %call1130) #20
  %call1.i = tail call i32 @arch_asym_cpu_priority(i32 noundef %22) #20
  %cmp.i = icmp sgt i32 %call.i, %call1.i
  %cmp24 = icmp eq i32 %7, 1
  %or.cond105 = select i1 %cmp.i, i1 %cmp24, i1 false
  br i1 %or.cond105, label %cleanup, label %if.end26

if.end26:                                         ; preds = %land.lhs.true20, %if.end15
  %23 = ptrtoint ptr %migration_type to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %migration_type, align 4
  switch i32 %24, label %cleanup [
    i32 0, label %sw.bb
    i32 1, label %sw.bb42
    i32 2, label %sw.bb50
    i32 3, label %sw.bb54
  ]

sw.bb:                                            ; preds = %if.end26
  %load_avg.i.i = getelementptr inbounds %struct.rq, ptr %5, i32 0, i32 14, i32 17, i32 5
  %25 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %load_avg.i.i, align 32
  %cmp28 = icmp eq i32 %7, 1
  br i1 %cmp28, label %land.lhs.true29, label %if.end36

land.lhs.true29:                                  ; preds = %sw.bb
  %27 = ptrtoint ptr %imbalance to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load i32, ptr %imbalance, align 4
  %cmp30 = icmp ugt i32 %26, %28
  br i1 %cmp30, label %land.lhs.true31, label %if.end36

land.lhs.true31:                                  ; preds = %land.lhs.true29
  %29 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %env, align 4
  %31 = ptrtoint ptr %cpu_capacity.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %cpu_capacity.i, align 16
  %imbalance_pct.i = getelementptr inbounds %struct.sched_domain, ptr %30, i32 0, i32 6
  %33 = ptrtoint ptr %imbalance_pct.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %imbalance_pct.i, align 8
  %mul.i = mul i32 %34, %32
  %cpu_capacity_orig.i = getelementptr inbounds %struct.rq, ptr %5, i32 0, i32 38
  %35 = ptrtoint ptr %cpu_capacity_orig.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %cpu_capacity_orig.i, align 4
  %mul1.i = mul i32 %36, 100
  %cmp.i115.not = icmp ult i32 %mul.i, %mul1.i
  br i1 %cmp.i115.not, label %if.end36, label %cleanup

if.end36:                                         ; preds = %land.lhs.true31, %land.lhs.true29, %sw.bb
  %mul37 = mul i32 %26, %busiest_capacity.0122
  %mul38 = mul i32 %9, %busiest_load.0124
  %cmp39 = icmp ugt i32 %mul37, %mul38
  br i1 %cmp39, label %if.then40, label %cleanup

if.then40:                                        ; preds = %if.end36
  br label %cleanup

sw.bb42:                                          ; preds = %if.end26
  %37 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %arrayidx, align 4
  %add.i117 = add i32 %38, ptrtoint (ptr @runqueues to i32)
  %39 = inttoptr i32 %add.i117 to ptr
  %util_avg.i = getelementptr inbounds %struct.rq, ptr %39, i32 0, i32 14, i32 17, i32 7
  %40 = ptrtoint ptr %util_avg.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load volatile i32, ptr %util_avg.i, align 8
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 20), i32 1), ptr blockaddress(@find_busiest_queue, %cpu_util_cfs.exit)) #20
          to label %if.then.i [label %cpu_util_cfs.exit], !srcloc !261

if.then.i:                                        ; preds = %sw.bb42
  %util_est.i = getelementptr inbounds %struct.rq, ptr %39, i32 0, i32 14, i32 17, i32 9
  %42 = ptrtoint ptr %util_est.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load volatile i32, ptr %util_est.i, align 16
  %44 = tail call i32 @llvm.umax.i32(i32 %41, i32 %43) #20
  br label %cpu_util_cfs.exit

cpu_util_cfs.exit:                                ; preds = %if.then.i, %sw.bb42
  %util.0.i = phi i32 [ %44, %if.then.i ], [ %41, %sw.bb42 ]
  %cmp44 = icmp ult i32 %7, 2
  br i1 %cmp44, label %cleanup, label %if.end46

if.end46:                                         ; preds = %cpu_util_cfs.exit
  %45 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load i32, ptr %arrayidx, align 4
  %add.i.i = add i32 %46, ptrtoint (ptr @runqueues to i32)
  %47 = inttoptr i32 %add.i.i to ptr
  %cpu_capacity_orig.i.i = getelementptr inbounds %struct.rq, ptr %47, i32 0, i32 38
  %48 = ptrtoint ptr %cpu_capacity_orig.i.i to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load i32, ptr %cpu_capacity_orig.i.i, align 4
  %50 = tail call i32 @llvm.umin.i32(i32 %util.0.i, i32 %49) #20
  %cmp47 = icmp ult i32 %busiest_util.0126, %50
  %51 = tail call i32 @llvm.umax.i32(i32 %busiest_util.0126, i32 %50)
  %spec.select106 = select i1 %cmp47, ptr %5, ptr %busiest.0128
  br label %cleanup

sw.bb50:                                          ; preds = %if.end26
  %cmp51 = icmp ult i32 %busiest_nr.0120, %7
  %52 = tail call i32 @llvm.umax.i32(i32 %busiest_nr.0120, i32 %7)
  %spec.select108 = select i1 %cmp51, ptr %5, ptr %busiest.0128
  br label %cleanup

sw.bb54:                                          ; preds = %if.end26
  %misfit_task_load = getelementptr inbounds %struct.rq, ptr %5, i32 0, i32 42
  %53 = ptrtoint ptr %misfit_task_load to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load i32, ptr %misfit_task_load, align 64
  %cmp55 = icmp ugt i32 %54, %busiest_load.0124
  %55 = tail call i32 @llvm.umax.i32(i32 %54, i32 %busiest_load.0124)
  %spec.select110 = select i1 %cmp55, ptr %5, ptr %busiest.0128
  br label %cleanup

cleanup:                                          ; preds = %sw.bb54, %sw.bb50, %if.end46, %cpu_util_cfs.exit, %if.then40, %if.end36, %land.lhs.true31, %if.end26, %land.lhs.true20, %land.lhs.true, %for.body
  %busiest_nr.2 = phi i32 [ %busiest_nr.0120, %for.body ], [ %busiest_nr.0120, %land.lhs.true ], [ %busiest_nr.0120, %land.lhs.true20 ], [ %busiest_nr.0120, %cpu_util_cfs.exit ], [ %busiest_nr.0120, %if.end26 ], [ %busiest_nr.0120, %if.then40 ], [ %busiest_nr.0120, %if.end36 ], [ %busiest_nr.0120, %land.lhs.true31 ], [ %busiest_nr.0120, %if.end46 ], [ %52, %sw.bb50 ], [ %busiest_nr.0120, %sw.bb54 ]
  %busiest_capacity.2 = phi i32 [ %busiest_capacity.0122, %for.body ], [ %busiest_capacity.0122, %land.lhs.true ], [ %busiest_capacity.0122, %land.lhs.true20 ], [ %busiest_capacity.0122, %cpu_util_cfs.exit ], [ %busiest_capacity.0122, %if.end26 ], [ %9, %if.then40 ], [ %busiest_capacity.0122, %if.end36 ], [ %busiest_capacity.0122, %land.lhs.true31 ], [ %busiest_capacity.0122, %if.end46 ], [ %busiest_capacity.0122, %sw.bb50 ], [ %busiest_capacity.0122, %sw.bb54 ]
  %busiest_load.2 = phi i32 [ %busiest_load.0124, %for.body ], [ %busiest_load.0124, %land.lhs.true ], [ %busiest_load.0124, %land.lhs.true20 ], [ %busiest_load.0124, %cpu_util_cfs.exit ], [ %busiest_load.0124, %if.end26 ], [ %26, %if.then40 ], [ %busiest_load.0124, %if.end36 ], [ %busiest_load.0124, %land.lhs.true31 ], [ %busiest_load.0124, %if.end46 ], [ %busiest_load.0124, %sw.bb50 ], [ %55, %sw.bb54 ]
  %busiest_util.2 = phi i32 [ %busiest_util.0126, %for.body ], [ %busiest_util.0126, %land.lhs.true ], [ %busiest_util.0126, %land.lhs.true20 ], [ %busiest_util.0126, %cpu_util_cfs.exit ], [ %busiest_util.0126, %if.end26 ], [ %busiest_util.0126, %if.then40 ], [ %busiest_util.0126, %if.end36 ], [ %busiest_util.0126, %land.lhs.true31 ], [ %51, %if.end46 ], [ %busiest_util.0126, %sw.bb50 ], [ %busiest_util.0126, %sw.bb54 ]
  %busiest.2 = phi ptr [ %busiest.0128, %for.body ], [ %busiest.0128, %land.lhs.true ], [ %busiest.0128, %land.lhs.true20 ], [ %busiest.0128, %cpu_util_cfs.exit ], [ %busiest.0128, %if.end26 ], [ %5, %if.then40 ], [ %busiest.0128, %if.end36 ], [ %busiest.0128, %land.lhs.true31 ], [ %spec.select106, %if.end46 ], [ %spec.select108, %sw.bb50 ], [ %spec.select110, %sw.bb54 ]
  %56 = ptrtoint ptr %cpus to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load ptr, ptr %cpus, align 4
  %call1 = tail call i32 @cpumask_next_and(i32 noundef %call1130, ptr noundef %cpumask.i, ptr noundef %57) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %58 = load i32, ptr @nr_cpu_ids, align 4
  %cmp = icmp ult i32 %call1, %58
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %cleanup, %entry
  %busiest.0.lcssa = phi ptr [ null, %entry ], [ %busiest.2, %cleanup ]
  ret ptr %busiest.0.lcssa
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @detach_tasks(ptr noundef %env) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %ue.sroa.0.i.i.i.i = alloca i32, align 8
  %ue.sroa.5.i.i.i.i = alloca i32, align 4
  %ue.sroa.0.i.i = alloca i32, align 8
  %ue.sroa.5.i.i = alloca i32, align 4
  %src_rq = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 1
  %0 = ptrtoint ptr %src_rq to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %src_rq, align 4
  %cfs_tasks = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 48
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %2 = load i32, ptr @debug_locks, align 4
  %tobool.not.i = icmp eq i32 %2, 0
  br i1 %tobool.not.i, label %lockdep_assert_rq_held.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %entry
  %core_enabled.i.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 81
  %3 = ptrtoint ptr %core_enabled.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %core_enabled.i.i, align 128
  %tobool.not.i.i = icmp eq i32 %4, 0
  br i1 %tobool.not.i.i, label %__rq_lockp.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.rhs.i
  %core.i.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 79
  %5 = ptrtoint ptr %core.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %core.i.i, align 8
  br label %__rq_lockp.exit.i

__rq_lockp.exit.i:                                ; preds = %if.then.i.i, %land.rhs.i
  %retval.0.i.i = phi ptr [ %6, %if.then.i.i ], [ %1, %land.rhs.i ]
  %dep_map.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i, i32 0, i32 4
  %call.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i, i32 noundef -1) #20
  %cmp.not.i = icmp eq i32 %call.i.i, 0
  br i1 %cmp.not.i, label %do.end.i, label %lockdep_assert_rq_held.exit, !prof !260

do.end.i:                                         ; preds = %__rq_lockp.exit.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit

lockdep_assert_rq_held.exit:                      ; preds = %do.end.i, %__rq_lockp.exit.i, %entry
  %7 = ptrtoint ptr %src_rq to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %src_rq, align 4
  %nr_running = getelementptr inbounds %struct.rq, ptr %8, i32 0, i32 1
  %9 = ptrtoint ptr %nr_running to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %nr_running, align 4
  %cmp = icmp ult i32 %10, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lockdep_assert_rq_held.exit
  %flags = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 10
  %11 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %flags, align 4
  %and = and i32 %12, -2
  store i32 %and, ptr %flags, align 4
  br label %cleanup

if.end:                                           ; preds = %lockdep_assert_rq_held.exit
  %imbalance = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 8
  %13 = ptrtoint ptr %imbalance to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %imbalance, align 4
  %cmp3 = icmp slt i32 %14, 1
  br i1 %cmp3, label %cleanup, label %while.cond.preheader

while.cond.preheader:                             ; preds = %if.end
  %15 = ptrtoint ptr %cfs_tasks to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile ptr, ptr %cfs_tasks, align 4
  %cmp.i.not157 = icmp eq ptr %16, %cfs_tasks
  br i1 %cmp.i.not157, label %do.body, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %while.cond.preheader
  %idle = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 7
  %prev = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 48, i32 1
  %loop = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 11
  %loop_max = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 13
  %loop_break = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 12
  %migration_type = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 15
  %src_cpu = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 2
  %dst_cpu.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 3
  %tasks66 = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 16
  br label %while.body

while.body:                                       ; preds = %while.cond.backedge, %while.body.lr.ph
  %detached.0158 = phi i32 [ 0, %while.body.lr.ph ], [ %detached.0.be, %while.cond.backedge ]
  %17 = ptrtoint ptr %idle to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %idle, align 4
  %cmp6.not = icmp eq i32 %18, 1
  br i1 %cmp6.not, label %if.end11, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.body
  %19 = ptrtoint ptr %src_rq to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %src_rq, align 4
  %nr_running8 = getelementptr inbounds %struct.rq, ptr %20, i32 0, i32 1
  %21 = ptrtoint ptr %nr_running8 to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load i32, ptr %nr_running8, align 4
  %cmp9 = icmp ult i32 %22, 2
  br i1 %cmp9, label %do.body, label %if.end11

if.end11:                                         ; preds = %land.lhs.true, %while.body
  %23 = ptrtoint ptr %prev to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %prev, align 4
  %add.ptr = getelementptr i8, ptr %24, i32 -148
  %25 = ptrtoint ptr %loop to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %loop, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %loop, align 4
  %27 = ptrtoint ptr %loop_max to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load i32, ptr %loop_max, align 4
  %cmp13 = icmp ugt i32 %inc, %28
  br i1 %cmp13, label %do.body, label %if.end15

if.end15:                                         ; preds = %if.end11
  %29 = ptrtoint ptr %loop_break to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %loop_break, align 4
  %cmp17 = icmp ugt i32 %inc, %30
  br i1 %cmp17, label %if.then18, label %if.end21

if.then18:                                        ; preds = %if.end15
  %add = add i32 %30, 32
  %31 = ptrtoint ptr %loop_break to i32
  call void @__asan_store4_noabort(i32 %31)
  store i32 %add, ptr %loop_break, align 4
  %flags20 = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 10
  %32 = ptrtoint ptr %flags20 to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %flags20, align 4
  %or = or i32 %33, 2
  store i32 %or, ptr %flags20, align 4
  br label %do.body

if.end21:                                         ; preds = %if.end15
  %call22 = tail call fastcc i32 @can_migrate_task(ptr noundef %add.ptr, ptr noundef %env)
  %tobool23.not = icmp eq i32 %call22, 0
  br i1 %tobool23.not, label %next, label %if.end25

if.end25:                                         ; preds = %if.end21
  %34 = ptrtoint ptr %migration_type to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load i32, ptr %migration_type, align 4
  switch i32 %35, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb49
    i32 2, label %sw.bb57
    i32 3, label %sw.bb59
  ]

sw.bb:                                            ; preds = %if.end25
  %cfs_rq.i.i = getelementptr i8, ptr %24, i32 60
  %36 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load ptr, ptr %cfs_rq.i.i, align 16
  %rq.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %37, i32 0, i32 27
  %38 = ptrtoint ptr %rq.i.i.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load ptr, ptr %rq.i.i.i, align 4
  %tg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %37, i32 0, i32 30
  %40 = ptrtoint ptr %tg.i.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load ptr, ptr %tg.i.i, align 4
  %se1.i.i = getelementptr inbounds %struct.task_group, ptr %41, i32 0, i32 1
  %42 = ptrtoint ptr %se1.i.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load ptr, ptr %se1.i.i, align 8
  %cpu.i.i.i = getelementptr inbounds %struct.rq, ptr %39, i32 0, i32 46
  %44 = ptrtoint ptr %cpu.i.i.i to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load i32, ptr %cpu.i.i.i, align 4
  %arrayidx.i.i = getelementptr ptr, ptr %43, i32 %45
  %46 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load ptr, ptr %arrayidx.i.i, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %48 = load volatile i32, ptr @jiffies, align 128
  %last_h_load_update.i.i = getelementptr inbounds %struct.cfs_rq, ptr %37, i32 0, i32 25
  %49 = ptrtoint ptr %last_h_load_update.i.i to i32
  call void @__asan_load8_noabort(i32 %49)
  %50 = load i64, ptr %last_h_load_update.i.i, align 16
  %conv.i.i = zext i32 %48 to i64
  %cmp.i.i = icmp eq i64 %50, %conv.i.i
  br i1 %cmp.i.i, label %task_h_load.exit, label %do.body5.i.i

do.body5.i.i:                                     ; preds = %sw.bb
  %h_load_next.i.i = getelementptr inbounds %struct.cfs_rq, ptr %37, i32 0, i32 26
  %51 = ptrtoint ptr %h_load_next.i.i to i32
  call void @__asan_store4_noabort(i32 %51)
  store volatile ptr null, ptr %h_load_next.i.i, align 8
  %tobool.not82.i.i = icmp eq ptr %47, null
  br i1 %tobool.not82.i.i, label %if.then28.i.i, label %for.body.i.i

for.body.i.i:                                     ; preds = %for.inc.i.i, %do.body5.i.i
  %se.083.i.i = phi ptr [ %58, %for.inc.i.i ], [ %47, %do.body5.i.i ]
  %cfs_rq.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.083.i.i, i32 0, i32 11
  %52 = ptrtoint ptr %cfs_rq.i.i.i to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load ptr, ptr %cfs_rq.i.i.i, align 16
  %h_load_next16.i.i = getelementptr inbounds %struct.cfs_rq, ptr %53, i32 0, i32 26
  %54 = ptrtoint ptr %h_load_next16.i.i to i32
  call void @__asan_store4_noabort(i32 %54)
  store volatile ptr %se.083.i.i, ptr %h_load_next16.i.i, align 8
  %last_h_load_update21.i.i = getelementptr inbounds %struct.cfs_rq, ptr %53, i32 0, i32 25
  %55 = ptrtoint ptr %last_h_load_update21.i.i to i32
  call void @__asan_load8_noabort(i32 %55)
  %56 = load i64, ptr %last_h_load_update21.i.i, align 16
  %cmp23.i.i = icmp eq i64 %56, %conv.i.i
  br i1 %cmp23.i.i, label %if.end32.i.i, label %for.inc.i.i

for.inc.i.i:                                      ; preds = %for.body.i.i
  %parent.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.083.i.i, i32 0, i32 10
  %57 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i138 = icmp eq ptr %58, null
  br i1 %tobool.not.i.i138, label %if.then28.i.i, label %for.body.i.i

if.then28.i.i:                                    ; preds = %for.inc.i.i, %do.body5.i.i
  %cfs_rq.addr.0.lcssa.i.i = phi ptr [ %37, %do.body5.i.i ], [ %53, %for.inc.i.i ]
  %load_avg.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.0.lcssa.i.i, i32 0, i32 17, i32 5
  %59 = ptrtoint ptr %load_avg.i.i.i to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load i32, ptr %load_avg.i.i.i, align 32
  %h_load.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.0.lcssa.i.i, i32 0, i32 24
  %61 = ptrtoint ptr %h_load.i.i to i32
  call void @__asan_store4_noabort(i32 %61)
  store i32 %60, ptr %h_load.i.i, align 4
  %last_h_load_update31.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.0.lcssa.i.i, i32 0, i32 25
  %62 = ptrtoint ptr %last_h_load_update31.i.i to i32
  call void @__asan_store8_noabort(i32 %62)
  store i64 %conv.i.i, ptr %last_h_load_update31.i.i, align 16
  br label %if.end32.i.i

if.end32.i.i:                                     ; preds = %if.then28.i.i, %for.body.i.i
  %cfs_rq.addr.176.i.i = phi ptr [ %cfs_rq.addr.0.lcssa.i.i, %if.then28.i.i ], [ %53, %for.body.i.i ]
  %h_load_next3684.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.176.i.i, i32 0, i32 26
  %63 = ptrtoint ptr %h_load_next3684.i.i to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load volatile ptr, ptr %h_load_next3684.i.i, align 8
  %cmp37.not85.i.i = icmp eq ptr %64, null
  br i1 %cmp37.not85.i.i, label %task_h_load.exit, label %div_u64.exit.i.i

div_u64.exit.i.i:                                 ; preds = %div_u64.exit.i.i, %if.end32.i.i
  %65 = phi ptr [ %77, %div_u64.exit.i.i ], [ %64, %if.end32.i.i ]
  %cfs_rq.addr.286.i.i = phi ptr [ %73, %div_u64.exit.i.i ], [ %cfs_rq.addr.176.i.i, %if.end32.i.i ]
  %load_avg.i.i = getelementptr inbounds %struct.sched_entity, ptr %65, i32 0, i32 15, i32 5
  %66 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load i32, ptr %load_avg.i.i, align 32
  %h_load39.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.286.i.i, i32 0, i32 24
  %68 = ptrtoint ptr %h_load39.i.i to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load i32, ptr %h_load39.i.i, align 4
  %mul.i.i = mul i32 %67, %69
  %load_avg.i74.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.286.i.i, i32 0, i32 17, i32 5
  %70 = ptrtoint ptr %load_avg.i74.i.i to i32
  call void @__asan_load4_noabort(i32 %70)
  %71 = load i32, ptr %load_avg.i74.i.i, align 32
  %add.i.i = add i32 %71, 1
  %div172.i.i.i.i = udiv i32 %mul.i.i, %add.i.i
  %my_q.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %65, i32 0, i32 12
  %72 = ptrtoint ptr %my_q.i.i.i to i32
  call void @__asan_load4_noabort(i32 %72)
  %73 = load ptr, ptr %my_q.i.i.i, align 4
  %h_load45.i.i = getelementptr inbounds %struct.cfs_rq, ptr %73, i32 0, i32 24
  %74 = ptrtoint ptr %h_load45.i.i to i32
  call void @__asan_store4_noabort(i32 %74)
  store i32 %div172.i.i.i.i, ptr %h_load45.i.i, align 4
  %last_h_load_update47.i.i = getelementptr inbounds %struct.cfs_rq, ptr %73, i32 0, i32 25
  %75 = ptrtoint ptr %last_h_load_update47.i.i to i32
  call void @__asan_store8_noabort(i32 %75)
  store i64 %conv.i.i, ptr %last_h_load_update47.i.i, align 16
  %h_load_next36.i.i = getelementptr inbounds %struct.cfs_rq, ptr %73, i32 0, i32 26
  %76 = ptrtoint ptr %h_load_next36.i.i to i32
  call void @__asan_load4_noabort(i32 %76)
  %77 = load volatile ptr, ptr %h_load_next36.i.i, align 8
  %cmp37.not.i.i = icmp eq ptr %77, null
  br i1 %cmp37.not.i.i, label %task_h_load.exit, label %div_u64.exit.i.i

task_h_load.exit:                                 ; preds = %div_u64.exit.i.i, %if.end32.i.i, %sw.bb
  %h_load.i = getelementptr inbounds %struct.cfs_rq, ptr %37, i32 0, i32 24
  %78 = ptrtoint ptr %h_load.i to i32
  call void @__asan_load4_noabort(i32 %78)
  %79 = load i32, ptr %h_load.i, align 4
  %load_avg.i = getelementptr i8, ptr %24, i32 140
  %80 = ptrtoint ptr %load_avg.i to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load i32, ptr %load_avg.i, align 32
  %mul.i = mul i32 %79, %81
  %load_avg.i7.i = getelementptr inbounds %struct.cfs_rq, ptr %37, i32 0, i32 17, i32 5
  %82 = ptrtoint ptr %load_avg.i7.i to i32
  call void @__asan_load4_noabort(i32 %82)
  %83 = load i32, ptr %load_avg.i7.i, align 32
  %add.i = add i32 %83, 1
  %div172.i.i.i = udiv i32 %mul.i, %add.i
  %84 = tail call i32 @llvm.umax.i32(i32 %div172.i.i.i, i32 1)
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 15), ptr blockaddress(@detach_tasks, %l_yes.i.i.i)) #20
          to label %static_branch_LB_MIN.exit [label %l_yes.i.i.i], !srcloc !261

l_yes.i.i.i:                                      ; preds = %task_h_load.exit
  br label %static_branch_LB_MIN.exit

static_branch_LB_MIN.exit:                        ; preds = %l_yes.i.i.i, %task_h_load.exit
  %retval.0.i.i.i = phi i1 [ true, %l_yes.i.i.i ], [ false, %task_h_load.exit ]
  %cmp31 = icmp ult i32 %84, 16
  %or.cond = select i1 %retval.0.i.i.i, i1 %cmp31, i1 false
  br i1 %or.cond, label %land.lhs.true32, label %if.end35

land.lhs.true32:                                  ; preds = %static_branch_LB_MIN.exit
  %85 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %85)
  %86 = load ptr, ptr %env, align 4
  %nr_balance_failed = getelementptr inbounds %struct.sched_domain, ptr %86, i32 0, i32 13
  %87 = ptrtoint ptr %nr_balance_failed to i32
  call void @__asan_load4_noabort(i32 %87)
  %88 = load i32, ptr %nr_balance_failed, align 4
  %tobool33.not = icmp eq i32 %88, 0
  br i1 %tobool33.not, label %next, label %if.end35

if.end35:                                         ; preds = %land.lhs.true32, %static_branch_LB_MIN.exit
  %89 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %89)
  %90 = load ptr, ptr %env, align 4
  %nr_balance_failed37 = getelementptr inbounds %struct.sched_domain, ptr %90, i32 0, i32 13
  %91 = ptrtoint ptr %nr_balance_failed37 to i32
  call void @__asan_load4_noabort(i32 %91)
  %92 = load i32, ptr %nr_balance_failed37, align 4
  %93 = tail call i32 @llvm.umin.i32(i32 %92, i32 31)
  %shr = lshr i32 %84, %93
  %94 = ptrtoint ptr %imbalance to i32
  call void @__asan_load4_noabort(i32 %94)
  %95 = load i32, ptr %imbalance, align 4
  %cmp45 = icmp ugt i32 %shr, %95
  br i1 %cmp45, label %next, label %if.end47

if.end47:                                         ; preds = %if.end35
  %sub = sub i32 %95, %84
  br label %sw.epilog.sink.split

sw.bb49:                                          ; preds = %if.end25
  %util_avg.i.i = getelementptr i8, ptr %24, i32 148
  %96 = ptrtoint ptr %util_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %96)
  %97 = load volatile i32, ptr %util_avg.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.0.i.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.5.i.i)
  %util_est.i.i = getelementptr i8, ptr %24, i32 156
  %98 = ptrtoint ptr %util_est.i.i to i32
  call void @__asan_load4_noabort(i32 %98)
  %ue.sroa.0.0.copyload.i.i = load volatile i32, ptr %util_est.i.i, align 16
  %99 = ptrtoint ptr %ue.sroa.0.i.i to i32
  call void @__asan_store4_noabort(i32 %99)
  store volatile i32 %ue.sroa.0.0.copyload.i.i, ptr %ue.sroa.0.i.i, align 8
  %ue.sroa.5.0.util_est.sroa_idx.i.i = getelementptr i8, ptr %24, i32 160
  %100 = ptrtoint ptr %ue.sroa.5.0.util_est.sroa_idx.i.i to i32
  call void @__asan_load4_noabort(i32 %100)
  %ue.sroa.5.0.copyload.i.i = load volatile i32, ptr %ue.sroa.5.0.util_est.sroa_idx.i.i, align 4
  %101 = ptrtoint ptr %ue.sroa.5.i.i to i32
  call void @__asan_store4_noabort(i32 %101)
  store volatile i32 %ue.sroa.5.0.copyload.i.i, ptr %ue.sroa.5.i.i, align 4
  %and.i.i = and i32 %ue.sroa.0.0.copyload.i.i, 2147483647
  %102 = tail call i32 @llvm.umax.i32(i32 %ue.sroa.5.0.copyload.i.i, i32 %and.i.i) #20
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.0.i.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.5.i.i)
  %103 = tail call i32 @llvm.umax.i32(i32 %97, i32 %102) #20
  %104 = ptrtoint ptr %imbalance to i32
  call void @__asan_load4_noabort(i32 %104)
  %105 = load i32, ptr %imbalance, align 4
  %cmp52 = icmp ult i32 %105, %103
  br i1 %cmp52, label %next, label %if.end54

if.end54:                                         ; preds = %sw.bb49
  %sub56 = sub i32 %105, %103
  br label %sw.epilog.sink.split

sw.bb57:                                          ; preds = %if.end25
  %106 = ptrtoint ptr %imbalance to i32
  call void @__asan_load4_noabort(i32 %106)
  %107 = load i32, ptr %imbalance, align 4
  %dec = add i32 %107, -1
  br label %sw.epilog.sink.split

sw.bb59:                                          ; preds = %if.end25
  %108 = ptrtoint ptr %src_cpu to i32
  call void @__asan_load4_noabort(i32 %108)
  %109 = load i32, ptr %src_cpu, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %109
  %110 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %110)
  %111 = load i32, ptr %arrayidx.i, align 4
  %add.i140 = add i32 %111, ptrtoint (ptr @runqueues to i32)
  %112 = inttoptr i32 %add.i140 to ptr
  %cpu_capacity.i = getelementptr inbounds %struct.rq, ptr %112, i32 0, i32 37
  %113 = ptrtoint ptr %cpu_capacity.i to i32
  call void @__asan_load4_noabort(i32 %113)
  %114 = load i32, ptr %cpu_capacity.i, align 16
  %util_avg.i.i.i.i = getelementptr i8, ptr %24, i32 148
  %115 = ptrtoint ptr %util_avg.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %115)
  %116 = load volatile i32, ptr %util_avg.i.i.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.0.i.i.i.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.5.i.i.i.i)
  %util_est.i.i.i.i = getelementptr i8, ptr %24, i32 156
  %117 = ptrtoint ptr %util_est.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %117)
  %ue.sroa.0.0.copyload.i.i.i.i = load volatile i32, ptr %util_est.i.i.i.i, align 16
  %118 = ptrtoint ptr %ue.sroa.0.i.i.i.i to i32
  call void @__asan_store4_noabort(i32 %118)
  store volatile i32 %ue.sroa.0.0.copyload.i.i.i.i, ptr %ue.sroa.0.i.i.i.i, align 8
  %ue.sroa.5.0.util_est.sroa_idx.i.i.i.i = getelementptr i8, ptr %24, i32 160
  %119 = ptrtoint ptr %ue.sroa.5.0.util_est.sroa_idx.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %119)
  %ue.sroa.5.0.copyload.i.i.i.i = load volatile i32, ptr %ue.sroa.5.0.util_est.sroa_idx.i.i.i.i, align 4
  %120 = ptrtoint ptr %ue.sroa.5.i.i.i.i to i32
  call void @__asan_store4_noabort(i32 %120)
  store volatile i32 %ue.sroa.5.0.copyload.i.i.i.i, ptr %ue.sroa.5.i.i.i.i, align 4
  %and.i.i.i.i141 = and i32 %ue.sroa.0.0.copyload.i.i.i.i, 2147483647
  %121 = tail call i32 @llvm.umax.i32(i32 %ue.sroa.5.0.copyload.i.i.i.i, i32 %and.i.i.i.i141) #20
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.0.i.i.i.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.5.i.i.i.i)
  %122 = tail call i32 @llvm.umax.i32(i32 %116, i32 %121) #20
  %call1.i.i = tail call i32 @uclamp_eff_value(ptr noundef %add.ptr, i32 noundef 0) #20
  %123 = tail call i32 @llvm.umax.i32(i32 %122, i32 %call1.i.i) #20
  %call2.i.i = tail call i32 @uclamp_eff_value(ptr noundef %add.ptr, i32 noundef 1) #20
  %124 = tail call i32 @llvm.umin.i32(i32 %123, i32 %call2.i.i) #20
  %mul.i142 = mul i32 %124, 1280
  %mul1.i = shl i32 %114, 10
  %cmp.i143.not = icmp ult i32 %mul.i142, %mul1.i
  br i1 %cmp.i143.not, label %next, label %sw.epilog.sink.split

sw.epilog.sink.split:                             ; preds = %sw.bb59, %sw.bb57, %if.end54, %if.end47
  %.sink = phi i32 [ %dec, %sw.bb57 ], [ %sub56, %if.end54 ], [ %sub, %if.end47 ], [ 0, %sw.bb59 ]
  %125 = ptrtoint ptr %imbalance to i32
  call void @__asan_store4_noabort(i32 %125)
  store i32 %.sink, ptr %imbalance, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.epilog.sink.split, %if.end25
  %126 = ptrtoint ptr %src_rq to i32
  call void @__asan_load4_noabort(i32 %126)
  %127 = load ptr, ptr %src_rq, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %128 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i145 = icmp eq i32 %128, 0
  br i1 %tobool.not.i.i145, label %detach_task.exit, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %sw.epilog
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %127, i32 0, i32 81
  %129 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %129)
  %130 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i146 = icmp eq i32 %130, 0
  br i1 %tobool.not.i.i.i146, label %__rq_lockp.exit.i.i, label %if.then.i.i.i147

if.then.i.i.i147:                                 ; preds = %land.rhs.i.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %127, i32 0, i32 79
  %131 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %131)
  %132 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i147, %land.rhs.i.i
  %retval.0.i.i.i148 = phi ptr [ %132, %if.then.i.i.i147 ], [ %127, %land.rhs.i.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i148, i32 0, i32 4
  %call.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i, i32 noundef -1) #20
  %cmp.not.i.i = icmp eq i32 %call.i.i.i, 0
  br i1 %cmp.not.i.i, label %do.end.i.i, label %detach_task.exit, !prof !260

do.end.i.i:                                       ; preds = %__rq_lockp.exit.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %detach_task.exit

detach_task.exit:                                 ; preds = %do.end.i.i, %__rq_lockp.exit.i.i, %sw.epilog
  %133 = ptrtoint ptr %src_rq to i32
  call void @__asan_load4_noabort(i32 %133)
  %134 = load ptr, ptr %src_rq, align 4
  tail call void @deactivate_task(ptr noundef %134, ptr noundef %add.ptr, i32 noundef 8) #20
  %135 = ptrtoint ptr %dst_cpu.i to i32
  call void @__asan_load4_noabort(i32 %135)
  %136 = load i32, ptr %dst_cpu.i, align 4
  tail call void @set_task_cpu(ptr noundef %add.ptr, i32 noundef %136) #20
  %137 = ptrtoint ptr %tasks66 to i32
  call void @__asan_load4_noabort(i32 %137)
  %138 = load ptr, ptr %tasks66, align 4
  %call.i.i149 = tail call zeroext i1 @__list_add_valid(ptr noundef %24, ptr noundef %tasks66, ptr noundef %138) #20
  br i1 %call.i.i149, label %if.end.i.i, label %list_add.exit

if.end.i.i:                                       ; preds = %detach_task.exit
  %prev1.i.i = getelementptr inbounds %struct.list_head, ptr %138, i32 0, i32 1
  %139 = ptrtoint ptr %prev1.i.i to i32
  call void @__asan_store4_noabort(i32 %139)
  store ptr %24, ptr %prev1.i.i, align 4
  %140 = ptrtoint ptr %24 to i32
  call void @__asan_store4_noabort(i32 %140)
  store ptr %138, ptr %24, align 4
  %prev3.i.i = getelementptr inbounds %struct.list_head, ptr %24, i32 0, i32 1
  %141 = ptrtoint ptr %prev3.i.i to i32
  call void @__asan_store4_noabort(i32 %141)
  store ptr %tasks66, ptr %prev3.i.i, align 4
  %142 = ptrtoint ptr %tasks66 to i32
  call void @__asan_store4_noabort(i32 %142)
  store volatile ptr %24, ptr %tasks66, align 4
  br label %list_add.exit

list_add.exit:                                    ; preds = %if.end.i.i, %detach_task.exit
  %inc67 = add i32 %detached.0158, 1
  %143 = ptrtoint ptr %imbalance to i32
  call void @__asan_load4_noabort(i32 %143)
  %144 = load i32, ptr %imbalance, align 4
  %cmp69 = icmp slt i32 %144, 1
  br i1 %cmp69, label %do.body, label %while.cond.backedge

next:                                             ; preds = %sw.bb59, %sw.bb49, %if.end35, %land.lhs.true32, %if.end21
  %call.i.i150 = tail call zeroext i1 @__list_del_entry_valid(ptr noundef %24) #20
  br i1 %call.i.i150, label %if.end.i.i151, label %__list_del_entry.exit.i

if.end.i.i151:                                    ; preds = %next
  %prev.i.i = getelementptr inbounds %struct.list_head, ptr %24, i32 0, i32 1
  %145 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_load4_noabort(i32 %145)
  %146 = load ptr, ptr %prev.i.i, align 4
  %147 = ptrtoint ptr %24 to i32
  call void @__asan_load4_noabort(i32 %147)
  %148 = load ptr, ptr %24, align 4
  %prev1.i.i.i = getelementptr inbounds %struct.list_head, ptr %148, i32 0, i32 1
  %149 = ptrtoint ptr %prev1.i.i.i to i32
  call void @__asan_store4_noabort(i32 %149)
  store ptr %146, ptr %prev1.i.i.i, align 4
  %150 = ptrtoint ptr %146 to i32
  call void @__asan_store4_noabort(i32 %150)
  store volatile ptr %148, ptr %146, align 4
  br label %__list_del_entry.exit.i

__list_del_entry.exit.i:                          ; preds = %if.end.i.i151, %next
  %151 = ptrtoint ptr %cfs_tasks to i32
  call void @__asan_load4_noabort(i32 %151)
  %152 = load ptr, ptr %cfs_tasks, align 4
  %call.i.i.i152 = tail call zeroext i1 @__list_add_valid(ptr noundef %24, ptr noundef %cfs_tasks, ptr noundef %152) #20
  br i1 %call.i.i.i152, label %if.end.i.i.i, label %while.cond.backedge

if.end.i.i.i:                                     ; preds = %__list_del_entry.exit.i
  %prev1.i.i2.i = getelementptr inbounds %struct.list_head, ptr %152, i32 0, i32 1
  %153 = ptrtoint ptr %prev1.i.i2.i to i32
  call void @__asan_store4_noabort(i32 %153)
  store ptr %24, ptr %prev1.i.i2.i, align 4
  %154 = ptrtoint ptr %24 to i32
  call void @__asan_store4_noabort(i32 %154)
  store ptr %152, ptr %24, align 4
  %prev3.i.i.i = getelementptr inbounds %struct.list_head, ptr %24, i32 0, i32 1
  %155 = ptrtoint ptr %prev3.i.i.i to i32
  call void @__asan_store4_noabort(i32 %155)
  store ptr %cfs_tasks, ptr %prev3.i.i.i, align 4
  %156 = ptrtoint ptr %cfs_tasks to i32
  call void @__asan_store4_noabort(i32 %156)
  store volatile ptr %24, ptr %cfs_tasks, align 4
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %if.end.i.i.i, %__list_del_entry.exit.i, %list_add.exit
  %detached.0.be = phi i32 [ %inc67, %list_add.exit ], [ %detached.0158, %__list_del_entry.exit.i ], [ %detached.0158, %if.end.i.i.i ]
  %157 = ptrtoint ptr %cfs_tasks to i32
  call void @__asan_load4_noabort(i32 %157)
  %158 = load volatile ptr, ptr %cfs_tasks, align 4
  %cmp.i.not = icmp eq ptr %158, %cfs_tasks
  br i1 %cmp.i.not, label %do.body, label %while.body

do.body:                                          ; preds = %while.cond.backedge, %list_add.exit, %if.then18, %if.end11, %land.lhs.true, %while.cond.preheader
  %detached.1 = phi i32 [ %detached.0158, %if.then18 ], [ 0, %while.cond.preheader ], [ %inc67, %list_add.exit ], [ %detached.0158, %if.end11 ], [ %detached.0158, %land.lhs.true ], [ %detached.0.be, %while.cond.backedge ]
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@detach_tasks, %if.then80)) #20
          to label %cleanup [label %if.then80], !srcloc !261

if.then80:                                        ; preds = %do.body
  %159 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %159)
  %160 = load ptr, ptr %env, align 4
  %idle82 = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 7
  %161 = ptrtoint ptr %idle82 to i32
  call void @__asan_load4_noabort(i32 %161)
  %162 = load i32, ptr %idle82, align 4
  %arrayidx = getelementptr %struct.sched_domain, ptr %160, i32 0, i32 21, i32 %162
  %163 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %163)
  %164 = load i32, ptr %arrayidx, align 4
  %add83 = add i32 %164, %detached.1
  store i32 %add83, ptr %arrayidx, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.then80, %do.body, %if.end, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ 0, %if.end ], [ %detached.1, %if.then80 ], [ %detached.1, %do.body ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @trace_hardirqs_on() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @warn_bogus_irq_restore() local_unnamed_addr #4

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @__cpumask_clear_cpu(i32 noundef %cpu, ptr nocapture noundef %dstp) unnamed_addr #7 align 64 {
entry:
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %0 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i = icmp ugt i32 %0, %cpu
  br i1 %cmp.not.i.i, label %cpumask_check.exit, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %entry
  %.b37.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i, label %cpumask_check.exit, label %if.then.i.i, !prof !259

if.then.i.i:                                      ; preds = %land.rhs.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpumask_check.exit

cpumask_check.exit:                               ; preds = %if.then.i.i, %land.rhs.i.i, %entry
  %rem.i = and i32 %cpu, 31
  %shl.i = shl nuw i32 1, %rem.i
  %div2.i = lshr i32 %cpu, 5
  %add.ptr.i = getelementptr i32, ptr %dstp, i32 %div2.i
  %neg.i = xor i32 %shl.i, -1
  %1 = ptrtoint ptr %add.ptr.i to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %add.ptr.i, align 4
  %and.i = and i32 %2, %neg.i
  store i32 %and.i, ptr %add.ptr.i, align 4
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @need_active_balance(ptr nocapture noundef readonly %env) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %env, align 4
  %idle.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 7
  %2 = ptrtoint ptr %idle.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %idle.i, align 4
  %cmp.not.i = icmp eq i32 %3, 1
  br i1 %cmp.not.i, label %if.end, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %flags.i = getelementptr inbounds %struct.sched_domain, ptr %1, i32 0, i32 9
  %4 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %flags.i, align 4
  %and.i = and i32 %5, 1024
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end, label %asym_active_balance.exit

asym_active_balance.exit:                         ; preds = %land.lhs.true.i
  %dst_cpu.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 3
  %6 = ptrtoint ptr %dst_cpu.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %dst_cpu.i, align 4
  %src_cpu.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 2
  %8 = ptrtoint ptr %src_cpu.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %src_cpu.i, align 4
  %call.i.i = tail call i32 @arch_asym_cpu_priority(i32 noundef %7) #20
  %call1.i.i = tail call i32 @arch_asym_cpu_priority(i32 noundef %9) #20
  %cmp.i.i = icmp sgt i32 %call.i.i, %call1.i.i
  br i1 %cmp.i.i, label %cleanup, label %if.end

if.end:                                           ; preds = %asym_active_balance.exit, %land.lhs.true.i, %entry
  %migration_type.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 15
  %10 = ptrtoint ptr %migration_type.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %migration_type.i, align 4
  %cmp.i = icmp eq i32 %11, 2
  br i1 %cmp.i, label %land.lhs.true.i29, label %if.end4

land.lhs.true.i29:                                ; preds = %if.end
  %12 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %env, align 4
  %nr_balance_failed.i = getelementptr inbounds %struct.sched_domain, ptr %13, i32 0, i32 13
  %14 = ptrtoint ptr %nr_balance_failed.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %nr_balance_failed.i, align 4
  %cache_nice_tries.i = getelementptr inbounds %struct.sched_domain, ptr %13, i32 0, i32 7
  %16 = ptrtoint ptr %cache_nice_tries.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %cache_nice_tries.i, align 4
  %add.i = add i32 %17, 2
  %cmp2.i = icmp ugt i32 %15, %add.i
  br i1 %cmp2.i, label %cleanup, label %if.end4

if.end4:                                          ; preds = %land.lhs.true.i29, %if.end
  %18 = ptrtoint ptr %idle.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %idle.i, align 4
  %cmp.not = icmp eq i32 %19, 1
  br i1 %cmp.not, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end4
  %src_rq = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 1
  %20 = ptrtoint ptr %src_rq to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %src_rq, align 4
  %h_nr_running = getelementptr inbounds %struct.rq, ptr %21, i32 0, i32 14, i32 2
  %22 = ptrtoint ptr %h_nr_running to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load i32, ptr %h_nr_running, align 4
  %cmp5 = icmp eq i32 %23, 1
  br i1 %cmp5, label %if.then6, label %if.end16

if.then6:                                         ; preds = %land.lhs.true
  %cpu_capacity.i = getelementptr inbounds %struct.rq, ptr %21, i32 0, i32 37
  %24 = ptrtoint ptr %cpu_capacity.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %cpu_capacity.i, align 16
  %imbalance_pct.i = getelementptr inbounds %struct.sched_domain, ptr %1, i32 0, i32 6
  %26 = ptrtoint ptr %imbalance_pct.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %imbalance_pct.i, align 8
  %mul.i = mul i32 %27, %25
  %cpu_capacity_orig.i = getelementptr inbounds %struct.rq, ptr %21, i32 0, i32 38
  %28 = ptrtoint ptr %cpu_capacity_orig.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %cpu_capacity_orig.i, align 4
  %mul1.i = mul i32 %29, 100
  %cmp.i30.not = icmp ult i32 %mul.i, %mul1.i
  br i1 %cmp.i30.not, label %land.lhs.true9, label %if.end16

land.lhs.true9:                                   ; preds = %if.then6
  %src_cpu = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 2
  %30 = ptrtoint ptr %src_cpu to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load i32, ptr %src_cpu, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %31
  %32 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %arrayidx.i, align 4
  %add.i31 = add i32 %33, ptrtoint (ptr @runqueues to i32)
  %34 = inttoptr i32 %add.i31 to ptr
  %cpu_capacity.i32 = getelementptr inbounds %struct.rq, ptr %34, i32 0, i32 37
  %35 = ptrtoint ptr %cpu_capacity.i32 to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %cpu_capacity.i32, align 16
  %mul = mul i32 %36, %27
  %dst_cpu = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 3
  %37 = ptrtoint ptr %dst_cpu to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %dst_cpu, align 4
  %arrayidx.i33 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %38
  %39 = ptrtoint ptr %arrayidx.i33 to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load i32, ptr %arrayidx.i33, align 4
  %add.i34 = add i32 %40, ptrtoint (ptr @runqueues to i32)
  %41 = inttoptr i32 %add.i34 to ptr
  %cpu_capacity.i35 = getelementptr inbounds %struct.rq, ptr %41, i32 0, i32 37
  %42 = ptrtoint ptr %cpu_capacity.i35 to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load i32, ptr %cpu_capacity.i35, align 16
  %mul12 = mul i32 %43, 100
  %cmp13 = icmp ult i32 %mul, %mul12
  br i1 %cmp13, label %cleanup, label %if.end16

if.end16:                                         ; preds = %land.lhs.true9, %if.then6, %land.lhs.true, %if.end4
  %cmp17 = icmp eq i32 %11, 3
  %. = zext i1 %cmp17 to i32
  br label %cleanup

cleanup:                                          ; preds = %if.end16, %land.lhs.true9, %land.lhs.true.i29, %asym_active_balance.exit
  %retval.0 = phi i32 [ 1, %asym_active_balance.exit ], [ 1, %land.lhs.true9 ], [ %., %if.end16 ], [ 1, %land.lhs.true.i29 ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @stop_one_cpu_nowait(i32 noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @active_load_balance_cpu_stop(ptr noundef %data) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %env = alloca %struct.lb_env, align 4
  %cpu.i = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 46
  %0 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %cpu.i, align 4
  %push_cpu = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 44
  %2 = ptrtoint ptr %push_cpu to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %push_cpu, align 8
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %3
  %4 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %arrayidx, align 4
  %add = add i32 %5, ptrtoint (ptr @runqueues to i32)
  %6 = inttoptr i32 %add to ptr
  %7 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #20, !srcloc !280
  %and.i.i.i.i = and i32 %7, 128
  %tobool.not.i.i = icmp eq i32 %and.i.i.i.i, 0
  tail call void asm sideeffect "\09cpsid i\09\09\09@ arch_local_irq_disable", "~{memory},~{cc}"() #20, !srcloc !285
  br i1 %tobool.not.i.i, label %if.then.i.i, label %raw_spin_rq_lock_irq.exit.i

if.then.i.i:                                      ; preds = %entry
  tail call void @trace_hardirqs_off() #20
  br label %raw_spin_rq_lock_irq.exit.i

raw_spin_rq_lock_irq.exit.i:                      ; preds = %if.then.i.i, %entry
  tail call void @raw_spin_rq_lock_nested(ptr noundef %data, i32 noundef 0) #20
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 81
  %8 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %9, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %raw_spin_rq_lock_irq.exit.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 79
  %10 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %raw_spin_rq_lock_irq.exit.i
  %retval.0.i.i.i = phi ptr [ %11, %if.then.i.i.i ], [ %data, %raw_spin_rq_lock_irq.exit.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call1.i.i = tail call i32 @lock_pin_lock(ptr noundef %dep_map.i.i) #20
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 25
  %12 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %clock_update_flags.i.i, align 4
  %and.i.i = and i32 %13, 3
  store i32 %and.i.i, ptr %clock_update_flags.i.i, align 4
  %balance_callback.i.i = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 39
  %14 = ptrtoint ptr %balance_callback.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %balance_callback.i.i, align 8
  %tobool.not.i2.i = icmp ne ptr %15, null
  %cmp.i.i = icmp ne ptr %15, @balance_push_callback
  %spec.select.i.i = and i1 %tobool.not.i2.i, %cmp.i.i
  br i1 %spec.select.i.i, label %land.rhs6.i.i, label %rq_lock_irq.exit

land.rhs6.i.i:                                    ; preds = %__rq_lockp.exit.i.i
  %.b48.i.i = load i1, ptr @rq_pin_lock.__already_done, align 1
  br i1 %.b48.i.i, label %rq_lock_irq.exit, label %if.then.i3.i, !prof !259

if.then.i3.i:                                     ; preds = %land.rhs6.i.i
  store i1 true, ptr @rq_pin_lock.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1545, i32 noundef 9, ptr noundef nonnull @.str.35) #20
  br label %rq_lock_irq.exit

rq_lock_irq.exit:                                 ; preds = %if.then.i3.i, %land.rhs6.i.i, %__rq_lockp.exit.i.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %16 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i = icmp ugt i32 %16, %1
  br i1 %cmp.not.i.i.i.i, label %cpu_active.exit, label %land.rhs.i.i.i.i

land.rhs.i.i.i.i:                                 ; preds = %rq_lock_irq.exit
  %.b37.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i, label %cpu_active.exit, label %if.then.i.i.i.i, !prof !259

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_active.exit

cpu_active.exit:                                  ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i.i, %rq_lock_irq.exit
  %div3.i.i.i = lshr i32 %1, 5
  %arrayidx.i.i.i = getelementptr i32, ptr @__cpu_active_mask, i32 %div3.i.i.i
  %17 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load volatile i32, ptr %arrayidx.i.i.i, align 4
  %and.i.i.i = and i32 %1, 31
  %19 = shl nuw i32 1, %and.i.i.i
  %20 = and i32 %18, %19
  %tobool.i.not = icmp eq i32 %20, 0
  br i1 %tobool.i.not, label %out_unlock, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cpu_active.exit
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %21 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i170 = icmp ugt i32 %21, %3
  br i1 %cmp.not.i.i.i.i170, label %cpu_active.exit178, label %land.rhs.i.i.i.i172

land.rhs.i.i.i.i172:                              ; preds = %lor.lhs.false
  %.b37.i.i.i.i171 = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i171, label %cpu_active.exit178, label %if.then.i.i.i.i173, !prof !259

if.then.i.i.i.i173:                               ; preds = %land.rhs.i.i.i.i172
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_active.exit178

cpu_active.exit178:                               ; preds = %if.then.i.i.i.i173, %land.rhs.i.i.i.i172, %lor.lhs.false
  %div3.i.i.i174 = lshr i32 %3, 5
  %arrayidx.i.i.i175 = getelementptr i32, ptr @__cpu_active_mask, i32 %div3.i.i.i174
  %22 = ptrtoint ptr %arrayidx.i.i.i175 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %arrayidx.i.i.i175, align 4
  %and.i.i.i176 = and i32 %3, 31
  %24 = shl nuw i32 1, %and.i.i.i176
  %25 = and i32 %23, %24
  %tobool.i177.not = icmp eq i32 %25, 0
  br i1 %tobool.i177.not, label %out_unlock, label %if.end

if.end:                                           ; preds = %cpu_active.exit178
  %26 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %26, -16384
  %27 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %27, i32 0, i32 3
  %28 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %cpu, align 4
  %cmp.not = icmp eq i32 %1, %29
  br i1 %cmp.not, label %lor.rhs, label %out_unlock, !prof !259

lor.rhs:                                          ; preds = %if.end
  %active_balance = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 43
  %30 = ptrtoint ptr %active_balance to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load i32, ptr %active_balance, align 4
  %tobool.not = icmp eq i32 %31, 0
  br i1 %tobool.not, label %out_unlock, label %if.end9, !prof !260

if.end9:                                          ; preds = %lor.rhs
  %nr_running = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 1
  %32 = ptrtoint ptr %nr_running to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %nr_running, align 4
  %cmp10 = icmp ult i32 %33, 2
  br i1 %cmp10, label %out_unlock, label %do.body13

do.body13:                                        ; preds = %if.end9
  %cmp14 = icmp eq ptr %6, %data
  br i1 %cmp14, label %do.body22, label %do.end30, !prof !260

do.body22:                                        ; preds = %do.body13
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22kernel/sched/fair.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 10175, 0\0A.popsection", ""() #20, !srcloc !304
  unreachable

do.end30:                                         ; preds = %do.body13
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %27, i32 0, i32 1
  %34 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %35, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !268
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #20
  %call.i = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %do.end30
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 696, ptr noundef nonnull @.str.28) #20
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %do.end30
  %36 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load i32, ptr %arrayidx, align 4
  %add43 = add i32 %37, ptrtoint (ptr @runqueues to i32)
  %38 = inttoptr i32 %add43 to ptr
  %sd44 = getelementptr inbounds %struct.rq, ptr %38, i32 0, i32 36
  %39 = ptrtoint ptr %sd44 to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load volatile ptr, ptr %sd44, align 4
  %call.i179 = tail call i32 @lock_is_held_type(ptr noundef getelementptr inbounds (%struct.mutex, ptr @sched_domains_mutex, i32 0, i32 5), i32 noundef -1) #20
  %tobool47.not = icmp eq i32 %call.i179, 0
  br i1 %tobool47.not, label %lor.lhs.false48, label %do.end58

lor.lhs.false48:                                  ; preds = %rcu_read_lock.exit
  %call49 = tail call i32 @rcu_read_lock_held() #20
  %tobool50.not = icmp eq i32 %call49, 0
  br i1 %tobool50.not, label %land.lhs.true, label %do.end58

land.lhs.true:                                    ; preds = %lor.lhs.false48
  %call51 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool52.not = icmp eq i32 %call51, 0
  br i1 %tobool52.not, label %do.end58, label %land.lhs.true53

land.lhs.true53:                                  ; preds = %land.lhs.true
  %.b163 = load i1, ptr @active_load_balance_cpu_stop.__warned, align 1
  br i1 %.b163, label %do.end58, label %if.then55

if.then55:                                        ; preds = %land.lhs.true53
  store i1 true, ptr @active_load_balance_cpu_stop.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 10179, ptr noundef nonnull @.str.16) #20
  br label %do.end58

do.end58:                                         ; preds = %if.then55, %land.lhs.true53, %land.lhs.true, %lor.lhs.false48, %rcu_read_lock.exit
  %tobool60.not211 = icmp eq ptr %40, null
  br i1 %tobool60.not211, label %if.end128, label %for.body

for.body:                                         ; preds = %for.inc, %do.end58
  %sd.0212 = phi ptr [ %46, %for.inc ], [ %40, %do.end58 ]
  %span.i = getelementptr inbounds %struct.sched_domain, ptr %sd.0212, i32 0, i32 41
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %41 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i = icmp ugt i32 %41, %1
  br i1 %cmp.not.i.i.i, label %cpumask_test_cpu.exit, label %land.rhs.i.i.i

land.rhs.i.i.i:                                   ; preds = %for.body
  %.b37.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i, label %cpumask_test_cpu.exit, label %if.then.i.i.i180, !prof !259

if.then.i.i.i180:                                 ; preds = %land.rhs.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpumask_test_cpu.exit

cpumask_test_cpu.exit:                            ; preds = %if.then.i.i.i180, %land.rhs.i.i.i, %for.body
  %arrayidx.i.i = getelementptr i32, ptr %span.i, i32 %div3.i.i.i
  %42 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load volatile i32, ptr %arrayidx.i.i, align 4
  %44 = and i32 %43, %19
  %tobool63.not = icmp eq i32 %44, 0
  br i1 %tobool63.not, label %for.inc, label %if.then73.critedge

for.inc:                                          ; preds = %cpumask_test_cpu.exit
  %45 = ptrtoint ptr %sd.0212 to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load ptr, ptr %sd.0212, align 8
  %tobool60.not = icmp eq ptr %46, null
  br i1 %tobool60.not, label %if.end128, label %for.body

if.then73.critedge:                               ; preds = %cpumask_test_cpu.exit
  call void @llvm.lifetime.start.p0(i64 72, ptr nonnull %env) #20
  %47 = ptrtoint ptr %env to i32
  call void @__asan_store4_noabort(i32 %47)
  store ptr %sd.0212, ptr %env, align 4
  %src_rq = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 1
  %48 = ptrtoint ptr %src_rq to i32
  call void @__asan_store4_noabort(i32 %48)
  store ptr %data, ptr %src_rq, align 4
  %src_cpu = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 2
  %49 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load i32, ptr %cpu.i, align 4
  %51 = ptrtoint ptr %src_cpu to i32
  call void @__asan_store4_noabort(i32 %51)
  store i32 %50, ptr %src_cpu, align 4
  %dst_cpu = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 3
  %52 = ptrtoint ptr %dst_cpu to i32
  call void @__asan_store4_noabort(i32 %52)
  store i32 %3, ptr %dst_cpu, align 4
  %dst_rq = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 4
  %53 = ptrtoint ptr %dst_rq to i32
  call void @__asan_store4_noabort(i32 %53)
  store ptr %6, ptr %dst_rq, align 4
  %dst_grpmask = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 5
  %flags = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 10
  %54 = call ptr @memset(ptr %dst_grpmask, i32 0, i32 20)
  %55 = ptrtoint ptr %flags to i32
  call void @__asan_store4_noabort(i32 %55)
  store i32 16, ptr %flags, align 4
  %loop = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 11
  %56 = call ptr @memset(ptr %loop, i32 0, i32 28)
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@active_load_balance_cpu_stop, %if.then86)) #20
          to label %do.end89 [label %if.then86], !srcloc !261

if.then86:                                        ; preds = %if.then73.critedge
  %alb_count = getelementptr inbounds %struct.sched_domain, ptr %sd.0212, i32 0, i32 25
  %57 = ptrtoint ptr %alb_count to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load i32, ptr %alb_count, align 8
  %inc = add i32 %58, 1
  store i32 %inc, ptr %alb_count, align 8
  br label %do.end89

do.end89:                                         ; preds = %if.then86, %if.then73.critedge
  tail call void @update_rq_clock(ptr noundef %data) #20
  %call90 = call fastcc ptr @detach_one_task(ptr noundef nonnull %env)
  %tobool91.not = icmp eq ptr %call90, null
  br i1 %tobool91.not, label %do.body110, label %do.body93

do.body93:                                        ; preds = %do.end89
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@active_load_balance_cpu_stop, %if.then105)) #20
          to label %do.end109 [label %if.then105], !srcloc !261

if.then105:                                       ; preds = %do.body93
  %alb_pushed = getelementptr inbounds %struct.sched_domain, ptr %sd.0212, i32 0, i32 27
  %59 = ptrtoint ptr %alb_pushed to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load i32, ptr %alb_pushed, align 8
  %inc106 = add i32 %60, 1
  store i32 %inc106, ptr %alb_pushed, align 8
  br label %do.end109

do.end109:                                        ; preds = %if.then105, %do.body93
  %nr_balance_failed = getelementptr inbounds %struct.sched_domain, ptr %sd.0212, i32 0, i32 13
  %61 = ptrtoint ptr %nr_balance_failed to i32
  call void @__asan_store4_noabort(i32 %61)
  store i32 0, ptr %nr_balance_failed, align 4
  br label %if.end127

do.body110:                                       ; preds = %do.end89
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@active_load_balance_cpu_stop, %if.then122)) #20
          to label %if.end127 [label %if.then122], !srcloc !261

if.then122:                                       ; preds = %do.body110
  %alb_failed = getelementptr inbounds %struct.sched_domain, ptr %sd.0212, i32 0, i32 26
  %62 = ptrtoint ptr %alb_failed to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load i32, ptr %alb_failed, align 4
  %inc123 = add i32 %63, 1
  store i32 %inc123, ptr %alb_failed, align 4
  br label %if.end127

if.end127:                                        ; preds = %if.then122, %do.body110, %do.end109
  call void @llvm.lifetime.end.p0(i64 72, ptr nonnull %env) #20
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %for.inc, %do.end58
  %p.0 = phi ptr [ %call90, %if.end127 ], [ null, %do.end58 ], [ null, %for.inc ]
  %call.i182 = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i182, label %rcu_read_unlock.exit, label %land.lhs.true.i185

land.lhs.true.i185:                               ; preds = %if.end128
  %call1.i183 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i184 = icmp eq i32 %call1.i183, 0
  br i1 %tobool.not.i184, label %rcu_read_unlock.exit, label %land.lhs.true2.i187

land.lhs.true2.i187:                              ; preds = %land.lhs.true.i185
  %.b4.i186 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i186, label %rcu_read_unlock.exit, label %if.then.i188

if.then.i188:                                     ; preds = %land.lhs.true2.i187
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i188, %land.lhs.true2.i187, %land.lhs.true.i185, %if.end128
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %64 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i189 = and i32 %64, -16384
  %65 = inttoptr i32 %and.i.i.i.i.i189 to ptr
  %preempt_count.i.i.i.i190 = getelementptr inbounds %struct.thread_info, ptr %65, i32 0, i32 1
  %66 = ptrtoint ptr %preempt_count.i.i.i.i190 to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load volatile i32, ptr %preempt_count.i.i.i.i190, align 4
  %sub.i.i.i = add i32 %67, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i190, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  br label %out_unlock

out_unlock:                                       ; preds = %rcu_read_unlock.exit, %if.end9, %lor.rhs, %if.end, %cpu_active.exit178, %cpu_active.exit
  %p.1 = phi ptr [ null, %lor.rhs ], [ null, %if.end9 ], [ %p.0, %rcu_read_unlock.exit ], [ null, %cpu_active.exit178 ], [ null, %cpu_active.exit ], [ null, %if.end ]
  %active_balance129 = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 43
  %68 = ptrtoint ptr %active_balance129 to i32
  call void @__asan_store4_noabort(i32 %68)
  store i32 0, ptr %active_balance129, align 4
  %69 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %69)
  %70 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i195 = icmp eq i32 %70, 0
  br i1 %tobool.not.i.i.i195, label %rq_unlock.exit, label %if.then.i.i.i197

if.then.i.i.i197:                                 ; preds = %out_unlock
  %core.i.i.i196 = getelementptr inbounds %struct.rq, ptr %data, i32 0, i32 79
  %71 = ptrtoint ptr %core.i.i.i196 to i32
  call void @__asan_load4_noabort(i32 %71)
  %72 = load ptr, ptr %core.i.i.i196, align 8
  br label %rq_unlock.exit

rq_unlock.exit:                                   ; preds = %if.then.i.i.i197, %out_unlock
  %retval.0.i.i.i198 = phi ptr [ %72, %if.then.i.i.i197 ], [ %data, %out_unlock ]
  %dep_map.i.i199 = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i198, i32 0, i32 4
  %73 = insertvalue [1 x i32] undef, i32 %call1.i.i, 0
  tail call void @lock_unpin_lock(ptr noundef %dep_map.i.i199, [1 x i32] %73) #20
  tail call void @raw_spin_rq_unlock(ptr noundef %data) #20
  %tobool130.not = icmp eq ptr %p.1, null
  br i1 %tobool130.not, label %do.body133, label %if.then131

if.then131:                                       ; preds = %rq_unlock.exit
  tail call void @raw_spin_rq_lock_nested(ptr noundef %6, i32 noundef 0) #20
  %core_enabled.i.i.i.i = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 81
  %74 = ptrtoint ptr %core_enabled.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %74)
  %75 = load i32, ptr %core_enabled.i.i.i.i, align 128
  %tobool.not.i.i.i.i = icmp eq i32 %75, 0
  br i1 %tobool.not.i.i.i.i, label %__rq_lockp.exit.i.i.i, label %if.then.i.i.i.i201

if.then.i.i.i.i201:                               ; preds = %if.then131
  %core.i.i.i.i = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 79
  %76 = ptrtoint ptr %core.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %76)
  %77 = load ptr, ptr %core.i.i.i.i, align 8
  br label %__rq_lockp.exit.i.i.i

__rq_lockp.exit.i.i.i:                            ; preds = %if.then.i.i.i.i201, %if.then131
  %retval.0.i.i.i.i = phi ptr [ %77, %if.then.i.i.i.i201 ], [ %6, %if.then131 ]
  %dep_map.i.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i.i, i32 0, i32 4
  %call1.i.i.i = tail call i32 @lock_pin_lock(ptr noundef %dep_map.i.i.i) #20
  %clock_update_flags.i.i.i = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 25
  %78 = ptrtoint ptr %clock_update_flags.i.i.i to i32
  call void @__asan_load4_noabort(i32 %78)
  %79 = load i32, ptr %clock_update_flags.i.i.i, align 4
  %and.i.i.i202 = and i32 %79, 3
  store i32 %and.i.i.i202, ptr %clock_update_flags.i.i.i, align 4
  %balance_callback.i.i.i = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 39
  %80 = ptrtoint ptr %balance_callback.i.i.i to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load ptr, ptr %balance_callback.i.i.i, align 8
  %tobool.not.i.i.i203 = icmp ne ptr %81, null
  %cmp.i.i.i = icmp ne ptr %81, @balance_push_callback
  %spec.select.i.i.i = and i1 %tobool.not.i.i.i203, %cmp.i.i.i
  br i1 %spec.select.i.i.i, label %land.rhs6.i.i.i, label %rq_lock.exit.i

land.rhs6.i.i.i:                                  ; preds = %__rq_lockp.exit.i.i.i
  %.b48.i.i.i = load i1, ptr @rq_pin_lock.__already_done, align 1
  br i1 %.b48.i.i.i, label %rq_lock.exit.i, label %if.then.i.i.i204, !prof !259

if.then.i.i.i204:                                 ; preds = %land.rhs6.i.i.i
  store i1 true, ptr @rq_pin_lock.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1545, i32 noundef 9, ptr noundef nonnull @.str.35) #20
  br label %rq_lock.exit.i

rq_lock.exit.i:                                   ; preds = %if.then.i.i.i204, %land.rhs6.i.i.i, %__rq_lockp.exit.i.i.i
  tail call void @update_rq_clock(ptr noundef %6) #20
  tail call fastcc void @attach_task(ptr noundef %6, ptr noundef nonnull %p.1) #20
  %82 = ptrtoint ptr %core_enabled.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %82)
  %83 = load i32, ptr %core_enabled.i.i.i.i, align 128
  %tobool.not.i.i.i8.i = icmp eq i32 %83, 0
  br i1 %tobool.not.i.i.i8.i, label %attach_one_task.exit, label %if.then.i.i.i10.i

if.then.i.i.i10.i:                                ; preds = %rq_lock.exit.i
  %core.i.i.i9.i = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 79
  %84 = ptrtoint ptr %core.i.i.i9.i to i32
  call void @__asan_load4_noabort(i32 %84)
  %85 = load ptr, ptr %core.i.i.i9.i, align 8
  br label %attach_one_task.exit

attach_one_task.exit:                             ; preds = %if.then.i.i.i10.i, %rq_lock.exit.i
  %retval.0.i.i.i11.i = phi ptr [ %85, %if.then.i.i.i10.i ], [ %6, %rq_lock.exit.i ]
  %dep_map.i.i12.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i11.i, i32 0, i32 4
  %86 = insertvalue [1 x i32] undef, i32 %call1.i.i.i, 0
  tail call void @lock_unpin_lock(ptr noundef %dep_map.i.i12.i, [1 x i32] %86) #20
  tail call void @raw_spin_rq_unlock(ptr noundef %6) #20
  br label %do.body133

do.body133:                                       ; preds = %attach_one_task.exit, %rq_unlock.exit
  tail call void @trace_hardirqs_on() #20
  tail call void asm sideeffect "\09cpsie i\09\09\09@ arch_local_irq_enable", "~{memory},~{cc}"() #20, !srcloc !286
  ret i32 0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__bitmap_and(ptr noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree nounwind null_pointer_is_valid readonly willreturn
declare dso_local i32 @cpumask_next_and(i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #8

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @group_balance_cpu(ptr noundef) local_unnamed_addr #4

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @update_sg_lb_stats(ptr nocapture noundef readonly %env, ptr nocapture noundef readonly %sds, ptr noundef %group, ptr noundef %sgs, ptr nocapture noundef %sg_status) unnamed_addr #7 align 64 {
entry:
  %0 = call ptr @memset(ptr %sgs, i32 0, i32 48)
  %local = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 1
  %1 = ptrtoint ptr %local to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %local, align 4
  %cmp = icmp eq ptr %2, %group
  %cpumask.i = getelementptr inbounds %struct.sched_group, ptr %group, i32 0, i32 6
  %cpus = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 9
  %3 = ptrtoint ptr %cpus to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %cpus, align 4
  %call1123 = tail call i32 @cpumask_next_and(i32 noundef -1, ptr noundef %cpumask.i, ptr noundef %4) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %5 = load i32, ptr @nr_cpu_ids, align 4
  %cmp2124 = icmp ult i32 %call1123, %5
  br i1 %cmp2124, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %entry
  %group_load = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 1
  %group_util = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 3
  %group_runnable = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 4
  %sum_h_nr_running = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 6
  %sum_nr_running = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 5
  %idle_cpus = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 7
  %group_misfit_task_load = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 11
  br label %for.body

for.body:                                         ; preds = %cleanup, %for.body.lr.ph
  %call1125 = phi i32 [ %call1123, %for.body.lr.ph ], [ %call1, %cleanup ]
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call1125
  %6 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %arrayidx, align 4
  %add = add i32 %7, ptrtoint (ptr @runqueues to i32)
  %8 = inttoptr i32 %add to ptr
  %load_avg.i.i = getelementptr inbounds %struct.rq, ptr %8, i32 0, i32 14, i32 17, i32 5
  %9 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %load_avg.i.i, align 32
  %11 = ptrtoint ptr %group_load to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %group_load, align 4
  %add6 = add i32 %12, %10
  store i32 %add6, ptr %group_load, align 4
  %13 = load i32, ptr %arrayidx, align 4
  %add.i = add i32 %13, ptrtoint (ptr @runqueues to i32)
  %14 = inttoptr i32 %add.i to ptr
  %util_avg.i = getelementptr inbounds %struct.rq, ptr %14, i32 0, i32 14, i32 17, i32 7
  %15 = ptrtoint ptr %util_avg.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %util_avg.i, align 8
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 20), i32 1), ptr blockaddress(@update_sg_lb_stats, %cpu_util_cfs.exit)) #20
          to label %if.then.i [label %cpu_util_cfs.exit], !srcloc !261

if.then.i:                                        ; preds = %for.body
  %util_est.i = getelementptr inbounds %struct.rq, ptr %14, i32 0, i32 14, i32 17, i32 9
  %17 = ptrtoint ptr %util_est.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load volatile i32, ptr %util_est.i, align 16
  %19 = tail call i32 @llvm.umax.i32(i32 %16, i32 %18) #20
  br label %cpu_util_cfs.exit

cpu_util_cfs.exit:                                ; preds = %if.then.i, %for.body
  %util.0.i = phi i32 [ %19, %if.then.i ], [ %16, %for.body ]
  %20 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %arrayidx, align 4
  %add.i.i = add i32 %21, ptrtoint (ptr @runqueues to i32)
  %22 = inttoptr i32 %add.i.i to ptr
  %cpu_capacity_orig.i.i = getelementptr inbounds %struct.rq, ptr %22, i32 0, i32 38
  %23 = ptrtoint ptr %cpu_capacity_orig.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %cpu_capacity_orig.i.i, align 4
  %25 = tail call i32 @llvm.umin.i32(i32 %util.0.i, i32 %24) #20
  %26 = ptrtoint ptr %group_util to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %group_util, align 4
  %add8 = add i32 %27, %25
  store i32 %add8, ptr %group_util, align 4
  %runnable_avg.i.i = getelementptr inbounds %struct.rq, ptr %8, i32 0, i32 14, i32 17, i32 6
  %28 = ptrtoint ptr %runnable_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %runnable_avg.i.i, align 4
  %30 = ptrtoint ptr %group_runnable to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load i32, ptr %group_runnable, align 4
  %add10 = add i32 %31, %29
  store i32 %add10, ptr %group_runnable, align 4
  %h_nr_running = getelementptr inbounds %struct.rq, ptr %8, i32 0, i32 14, i32 2
  %32 = ptrtoint ptr %h_nr_running to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %h_nr_running, align 4
  %34 = ptrtoint ptr %sum_h_nr_running to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load i32, ptr %sum_h_nr_running, align 4
  %add11 = add i32 %35, %33
  store i32 %add11, ptr %sum_h_nr_running, align 4
  %nr_running12 = getelementptr inbounds %struct.rq, ptr %8, i32 0, i32 1
  %36 = ptrtoint ptr %nr_running12 to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load i32, ptr %nr_running12, align 4
  %38 = ptrtoint ptr %sum_nr_running to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load i32, ptr %sum_nr_running, align 4
  %add13 = add i32 %39, %37
  store i32 %add13, ptr %sum_nr_running, align 4
  %cmp14 = icmp sgt i32 %37, 1
  br i1 %cmp14, label %if.then, label %if.end

if.then:                                          ; preds = %cpu_util_cfs.exit
  %40 = ptrtoint ptr %sg_status to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %sg_status, align 4
  %or = or i32 %41, 1
  store i32 %or, ptr %sg_status, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %cpu_util_cfs.exit
  %42 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load i32, ptr %arrayidx, align 4
  %add.i.i108 = add i32 %43, ptrtoint (ptr @runqueues to i32)
  %44 = inttoptr i32 %add.i.i108 to ptr
  %util_avg.i.i = getelementptr inbounds %struct.rq, ptr %44, i32 0, i32 14, i32 17, i32 7
  %45 = ptrtoint ptr %util_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load volatile i32, ptr %util_avg.i.i, align 8
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 20), i32 1), ptr blockaddress(@update_sg_lb_stats, %cpu_overutilized.exit)) #20
          to label %if.then.i.i [label %cpu_overutilized.exit], !srcloc !261

if.then.i.i:                                      ; preds = %if.end
  %util_est.i.i = getelementptr inbounds %struct.rq, ptr %44, i32 0, i32 14, i32 17, i32 9
  %47 = ptrtoint ptr %util_est.i.i to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load volatile i32, ptr %util_est.i.i, align 16
  %49 = tail call i32 @llvm.umax.i32(i32 %46, i32 %48) #20
  br label %cpu_overutilized.exit

cpu_overutilized.exit:                            ; preds = %if.then.i.i, %if.end
  %util.0.i.i = phi i32 [ %49, %if.then.i.i ], [ %46, %if.end ]
  %50 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load i32, ptr %arrayidx, align 4
  %add.i.i.i = add i32 %51, ptrtoint (ptr @runqueues to i32)
  %52 = inttoptr i32 %add.i.i.i to ptr
  %cpu_capacity_orig.i.i.i = getelementptr inbounds %struct.rq, ptr %52, i32 0, i32 38
  %53 = ptrtoint ptr %cpu_capacity_orig.i.i.i to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load i32, ptr %cpu_capacity_orig.i.i.i, align 4
  %55 = tail call i32 @llvm.umin.i32(i32 %util.0.i.i, i32 %54) #20
  %mul.i = mul i32 %55, 1280
  %cpu_capacity.i.i = getelementptr inbounds %struct.rq, ptr %52, i32 0, i32 37
  %56 = ptrtoint ptr %cpu_capacity.i.i to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load i32, ptr %cpu_capacity.i.i, align 16
  %mul2.i = shl i32 %57, 10
  %cmp.i.not = icmp ult i32 %mul.i, %mul2.i
  br i1 %cmp.i.not, label %if.end19, label %if.then17

if.then17:                                        ; preds = %cpu_overutilized.exit
  %58 = ptrtoint ptr %sg_status to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load i32, ptr %sg_status, align 4
  %or18 = or i32 %59, 2
  store i32 %or18, ptr %sg_status, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %cpu_overutilized.exit
  %tobool.not = icmp eq i32 %37, 0
  br i1 %tobool.not, label %land.lhs.true, label %if.end23

land.lhs.true:                                    ; preds = %if.end19
  %call20 = tail call i32 @idle_cpu(i32 noundef %call1125) #20
  %tobool21.not = icmp eq i32 %call20, 0
  br i1 %tobool21.not, label %if.end23, label %if.then22

if.then22:                                        ; preds = %land.lhs.true
  %60 = ptrtoint ptr %idle_cpus to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load i32, ptr %idle_cpus, align 4
  %inc = add i32 %61, 1
  store i32 %inc, ptr %idle_cpus, align 4
  br label %cleanup

if.end23:                                         ; preds = %land.lhs.true, %if.end19
  br i1 %cmp, label %cleanup, label %if.end26

if.end26:                                         ; preds = %if.end23
  %62 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load ptr, ptr %env, align 4
  %flags = getelementptr inbounds %struct.sched_domain, ptr %63, i32 0, i32 9
  %64 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %64)
  %65 = load i32, ptr %flags, align 4
  %and = and i32 %65, 32
  %tobool27.not = icmp eq i32 %and, 0
  br i1 %tobool27.not, label %cleanup, label %land.lhs.true28

land.lhs.true28:                                  ; preds = %if.end26
  %66 = ptrtoint ptr %group_misfit_task_load to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load i32, ptr %group_misfit_task_load, align 4
  %misfit_task_load = getelementptr inbounds %struct.rq, ptr %8, i32 0, i32 42
  %68 = ptrtoint ptr %misfit_task_load to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load i32, ptr %misfit_task_load, align 64
  %cmp29 = icmp ult i32 %67, %69
  br i1 %cmp29, label %if.then31, label %cleanup

if.then31:                                        ; preds = %land.lhs.true28
  %70 = ptrtoint ptr %group_misfit_task_load to i32
  call void @__asan_store4_noabort(i32 %70)
  store i32 %69, ptr %group_misfit_task_load, align 4
  %71 = ptrtoint ptr %sg_status to i32
  call void @__asan_load4_noabort(i32 %71)
  %72 = load i32, ptr %sg_status, align 4
  %or34 = or i32 %72, 1
  store i32 %or34, ptr %sg_status, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.then31, %land.lhs.true28, %if.end26, %if.end23, %if.then22
  %73 = ptrtoint ptr %cpus to i32
  call void @__asan_load4_noabort(i32 %73)
  %74 = load ptr, ptr %cpus, align 4
  %call1 = tail call i32 @cpumask_next_and(i32 noundef %call1125, ptr noundef %cpumask.i, ptr noundef %74) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %75 = load i32, ptr @nr_cpu_ids, align 4
  %cmp2 = icmp ult i32 %call1, %75
  br i1 %cmp2, label %for.body, label %for.end

for.end:                                          ; preds = %cleanup, %entry
  %sgc = getelementptr inbounds %struct.sched_group, ptr %group, i32 0, i32 3
  %76 = ptrtoint ptr %sgc to i32
  call void @__asan_load4_noabort(i32 %76)
  %77 = load ptr, ptr %sgc, align 4
  %capacity = getelementptr inbounds %struct.sched_group_capacity, ptr %77, i32 0, i32 1
  %78 = ptrtoint ptr %capacity to i32
  call void @__asan_load4_noabort(i32 %78)
  %79 = load i32, ptr %capacity, align 4
  %group_capacity = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 2
  %80 = ptrtoint ptr %group_capacity to i32
  call void @__asan_store4_noabort(i32 %80)
  store i32 %79, ptr %group_capacity, align 4
  %group_weight = getelementptr inbounds %struct.sched_group, ptr %group, i32 0, i32 2
  %81 = ptrtoint ptr %group_weight to i32
  call void @__asan_load4_noabort(i32 %81)
  %82 = load i32, ptr %group_weight, align 4
  %group_weight36 = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 8
  %83 = ptrtoint ptr %group_weight36 to i32
  call void @__asan_store4_noabort(i32 %83)
  store i32 %82, ptr %group_weight36, align 4
  br i1 %cmp, label %if.end53, label %land.lhs.true38

land.lhs.true38:                                  ; preds = %for.end
  %84 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %84)
  %85 = load ptr, ptr %env, align 4
  %flags40 = getelementptr inbounds %struct.sched_domain, ptr %85, i32 0, i32 9
  %86 = ptrtoint ptr %flags40 to i32
  call void @__asan_load4_noabort(i32 %86)
  %87 = load i32, ptr %flags40, align 4
  %and41 = and i32 %87, 1024
  %tobool42.not = icmp eq i32 %and41, 0
  br i1 %tobool42.not, label %if.end53, label %land.lhs.true43

land.lhs.true43:                                  ; preds = %land.lhs.true38
  %idle = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 7
  %88 = ptrtoint ptr %idle to i32
  call void @__asan_load4_noabort(i32 %88)
  %89 = load i32, ptr %idle, align 4
  %cmp44.not = icmp eq i32 %89, 1
  br i1 %cmp44.not, label %if.end53, label %land.lhs.true46

land.lhs.true46:                                  ; preds = %land.lhs.true43
  %sum_h_nr_running47 = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 6
  %90 = ptrtoint ptr %sum_h_nr_running47 to i32
  call void @__asan_load4_noabort(i32 %90)
  %91 = load i32, ptr %sum_h_nr_running47, align 4
  %tobool48.not = icmp eq i32 %91, 0
  br i1 %tobool48.not, label %if.end53, label %land.lhs.true49

land.lhs.true49:                                  ; preds = %land.lhs.true46
  %92 = ptrtoint ptr %local to i32
  call void @__asan_load4_noabort(i32 %92)
  %93 = load ptr, ptr %local, align 4
  %flags.i = getelementptr inbounds %struct.sched_group, ptr %93, i32 0, i32 5
  %94 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %94)
  %95 = load i32, ptr %flags.i, align 4
  %and.i = and i32 %95, 128
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %lor.lhs.false.i, label %if.end7.i.i

lor.lhs.false.i:                                  ; preds = %land.lhs.true49
  %flags1.i = getelementptr inbounds %struct.sched_group, ptr %group, i32 0, i32 5
  %96 = ptrtoint ptr %flags1.i to i32
  call void @__asan_load4_noabort(i32 %96)
  %97 = load i32, ptr %flags1.i, align 4
  %and2.i = and i32 %97, 128
  %tobool3.not.i = icmp eq i32 %and2.i, 0
  %dst_cpu4.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 3
  %98 = ptrtoint ptr %dst_cpu4.i to i32
  call void @__asan_load4_noabort(i32 %98)
  %99 = load i32, ptr %dst_cpu4.i, align 4
  br i1 %tobool3.not.i, label %sched_asym.exit, label %if.then.i.i109

if.then.i.i109:                                   ; preds = %lor.lhs.false.i
  %idle_cpus.i13.i = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 7
  %100 = ptrtoint ptr %idle_cpus.i13.i to i32
  call void @__asan_load4_noabort(i32 %100)
  %101 = load i32, ptr %idle_cpus.i13.i, align 4
  %sub.i14.i = sub i32 %82, %101
  %cmp.i.i = icmp sgt i32 %sub.i14.i, 1
  br i1 %cmp.i.i, label %if.then52, label %sched_asym.exit

if.end7.i.i:                                      ; preds = %land.lhs.true49
  %dst_cpu.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 3
  %102 = ptrtoint ptr %dst_cpu.i to i32
  call void @__asan_load4_noabort(i32 %102)
  %103 = load i32, ptr %dst_cpu.i, align 4
  %flags1.i.i = getelementptr inbounds %struct.sched_group, ptr %group, i32 0, i32 5
  %104 = ptrtoint ptr %flags1.i.i to i32
  call void @__asan_load4_noabort(i32 %104)
  %105 = load i32, ptr %flags1.i.i, align 4
  %and2.i.i = and i32 %105, 128
  %tobool3.not.i.i = icmp eq i32 %and2.i.i, 0
  br i1 %tobool3.not.i.i, label %if.end21.i.i, label %if.then9.i.i

if.then9.i.i:                                     ; preds = %if.end7.i.i
  %idle_cpus.i.i = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 7
  %106 = ptrtoint ptr %idle_cpus.i.i to i32
  call void @__asan_load4_noabort(i32 %106)
  %107 = load i32, ptr %idle_cpus.i.i, align 4
  %group_weight11.i.i = getelementptr inbounds %struct.sched_group, ptr %93, i32 0, i32 2
  %108 = ptrtoint ptr %group_weight11.i.i to i32
  call void @__asan_load4_noabort(i32 %108)
  %109 = load i32, ptr %group_weight11.i.i, align 4
  %idle_cpus12.i.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 7, i32 7
  %110 = ptrtoint ptr %idle_cpus12.i.i to i32
  call void @__asan_load4_noabort(i32 %110)
  %111 = load i32, ptr %idle_cpus12.i.i, align 4
  %112 = add i32 %107, %109
  %sub13.neg.i.i = sub i32 %82, %112
  %sub14.i.i = add i32 %sub13.neg.i.i, %111
  %cmp15.i.i = icmp eq i32 %sub14.i.i, 1
  br i1 %cmp15.i.i, label %sched_asym.exit, label %if.end53

if.end21.i.i:                                     ; preds = %if.end7.i.i
  %sum_nr_running.i.i = getelementptr inbounds %struct.sd_lb_stats, ptr %sds, i32 0, i32 7, i32 5
  %113 = ptrtoint ptr %sum_nr_running.i.i to i32
  call void @__asan_load4_noabort(i32 %113)
  %114 = load i32, ptr %sum_nr_running.i.i, align 4
  %tobool23.not.i.i = icmp eq i32 %114, 0
  br i1 %tobool23.not.i.i, label %sched_asym.exit, label %if.end53

sched_asym.exit:                                  ; preds = %if.end21.i.i, %if.then9.i.i, %if.then.i.i109, %lor.lhs.false.i
  %.sink18.i = phi i32 [ %103, %if.end21.i.i ], [ %103, %if.then9.i.i ], [ %99, %if.then.i.i109 ], [ %99, %lor.lhs.false.i ]
  %asym_prefer_cpu17.i.i = getelementptr inbounds %struct.sched_group, ptr %group, i32 0, i32 4
  %115 = ptrtoint ptr %asym_prefer_cpu17.i.i to i32
  call void @__asan_load4_noabort(i32 %115)
  %116 = load i32, ptr %asym_prefer_cpu17.i.i, align 4
  %call.i41.i.i = tail call i32 @arch_asym_cpu_priority(i32 noundef %.sink18.i) #20
  %call1.i42.i.i = tail call i32 @arch_asym_cpu_priority(i32 noundef %116) #20
  %cmp.i43.i.i = icmp sgt i32 %call.i41.i.i, %call1.i42.i.i
  br i1 %cmp.i43.i.i, label %if.then52, label %if.end53

if.then52:                                        ; preds = %sched_asym.exit, %if.then.i.i109
  %group_asym_packing = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 10
  %117 = ptrtoint ptr %group_asym_packing to i32
  call void @__asan_store4_noabort(i32 %117)
  store i32 1, ptr %group_asym_packing, align 4
  br label %if.end53

if.end53:                                         ; preds = %if.then52, %sched_asym.exit, %if.end21.i.i, %if.then9.i.i, %land.lhs.true46, %land.lhs.true43, %land.lhs.true38, %for.end
  %118 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %118)
  %119 = load ptr, ptr %env, align 4
  %imbalance_pct = getelementptr inbounds %struct.sched_domain, ptr %119, i32 0, i32 6
  %120 = ptrtoint ptr %imbalance_pct to i32
  call void @__asan_load4_noabort(i32 %120)
  %121 = load i32, ptr %imbalance_pct, align 8
  %sum_nr_running.i.i110 = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 5
  %122 = ptrtoint ptr %sum_nr_running.i.i110 to i32
  call void @__asan_load4_noabort(i32 %122)
  %123 = load i32, ptr %sum_nr_running.i.i110, align 4
  %124 = ptrtoint ptr %group_weight36 to i32
  call void @__asan_load4_noabort(i32 %124)
  %125 = load i32, ptr %group_weight36, align 4
  %cmp.not.i.i = icmp ugt i32 %123, %125
  br i1 %cmp.not.i.i, label %if.end.i.i, label %if.end.i

if.end.i.i:                                       ; preds = %if.end53
  %126 = ptrtoint ptr %group_capacity to i32
  call void @__asan_load4_noabort(i32 %126)
  %127 = load i32, ptr %group_capacity, align 4
  %mul.i.i = mul i32 %127, 100
  %group_util.i.i = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 3
  %128 = ptrtoint ptr %group_util.i.i to i32
  call void @__asan_load4_noabort(i32 %128)
  %129 = load i32, ptr %group_util.i.i, align 4
  %mul1.i.i = mul i32 %129, %121
  %cmp2.i.i = icmp ult i32 %mul.i.i, %mul1.i.i
  br i1 %cmp2.i.i, label %if.then59, label %group_is_overloaded.exit.i

group_is_overloaded.exit.i:                       ; preds = %if.end.i.i
  %mul6.i.i = mul i32 %127, %121
  %group_runnable.i.i = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 4
  %130 = ptrtoint ptr %group_runnable.i.i to i32
  call void @__asan_load4_noabort(i32 %130)
  %131 = load i32, ptr %group_runnable.i.i, align 4
  %mul7.i.i = mul i32 %131, 100
  %cmp8.i.i = icmp ult i32 %mul6.i.i, %mul7.i.i
  br i1 %cmp8.i.i, label %if.then59, label %if.end.i

if.end.i:                                         ; preds = %group_is_overloaded.exit.i, %if.end53
  %132 = ptrtoint ptr %sgc to i32
  call void @__asan_load4_noabort(i32 %132)
  %133 = load ptr, ptr %sgc, align 4
  %imbalance.i.i = getelementptr inbounds %struct.sched_group_capacity, ptr %133, i32 0, i32 5
  %134 = ptrtoint ptr %imbalance.i.i to i32
  call void @__asan_load4_noabort(i32 %134)
  %135 = load i32, ptr %imbalance.i.i, align 4
  %tobool.not.i112 = icmp eq i32 %135, 0
  br i1 %tobool.not.i112, label %if.end3.i, label %group_classify.exit.thread

if.end3.i:                                        ; preds = %if.end.i
  %group_asym_packing.i = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 10
  %136 = ptrtoint ptr %group_asym_packing.i to i32
  call void @__asan_load4_noabort(i32 %136)
  %137 = load i32, ptr %group_asym_packing.i, align 4
  %tobool4.not.i = icmp eq i32 %137, 0
  br i1 %tobool4.not.i, label %if.end6.i, label %group_classify.exit.thread

if.end6.i:                                        ; preds = %if.end3.i
  %group_misfit_task_load.i = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 11
  %138 = ptrtoint ptr %group_misfit_task_load.i to i32
  call void @__asan_load4_noabort(i32 %138)
  %139 = load i32, ptr %group_misfit_task_load.i, align 4
  %tobool7.not.i = icmp eq i32 %139, 0
  br i1 %tobool7.not.i, label %if.end9.i, label %group_classify.exit.thread

if.end9.i:                                        ; preds = %if.end6.i
  %cmp.i.i113 = icmp ult i32 %123, %125
  br i1 %cmp.i.i113, label %group_has_capacity.exit.thread.i, label %if.end.i24.i

if.end.i24.i:                                     ; preds = %if.end9.i
  %140 = ptrtoint ptr %group_capacity to i32
  call void @__asan_load4_noabort(i32 %140)
  %141 = load i32, ptr %group_capacity, align 4
  %mul.i20.i = mul i32 %141, %121
  %group_runnable.i21.i = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 4
  %142 = ptrtoint ptr %group_runnable.i21.i to i32
  call void @__asan_load4_noabort(i32 %142)
  %143 = load i32, ptr %group_runnable.i21.i, align 4
  %mul1.i22.i = mul i32 %143, 100
  %cmp2.i23.i = icmp ult i32 %mul.i20.i, %mul1.i22.i
  br i1 %cmp2.i23.i, label %group_classify.exit.thread, label %group_has_capacity.exit.i

group_has_capacity.exit.i:                        ; preds = %if.end.i24.i
  %mul6.i25.i = mul i32 %141, 100
  %group_util.i26.i = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 3
  %144 = ptrtoint ptr %group_util.i26.i to i32
  call void @__asan_load4_noabort(i32 %144)
  %145 = load i32, ptr %group_util.i26.i, align 4
  %mul7.i27.i = mul i32 %145, %121
  %cmp8.i28.i = icmp ugt i32 %mul6.i25.i, %mul7.i27.i
  br i1 %cmp8.i28.i, label %group_has_capacity.exit.thread.i, label %group_classify.exit.thread

group_has_capacity.exit.thread.i:                 ; preds = %group_has_capacity.exit.i, %if.end9.i
  br label %group_classify.exit.thread

group_classify.exit.thread:                       ; preds = %group_has_capacity.exit.thread.i, %group_has_capacity.exit.i, %if.end.i24.i, %if.end6.i, %if.end3.i, %if.end.i
  %retval.0.i114.ph = phi i32 [ 1, %if.end.i24.i ], [ 1, %group_has_capacity.exit.i ], [ 0, %group_has_capacity.exit.thread.i ], [ 2, %if.end6.i ], [ 3, %if.end3.i ], [ 4, %if.end.i ]
  %group_type119 = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 9
  %146 = ptrtoint ptr %group_type119 to i32
  call void @__asan_store4_noabort(i32 %146)
  store i32 %retval.0.i114.ph, ptr %group_type119, align 4
  br label %if.end62

if.then59:                                        ; preds = %group_is_overloaded.exit.i, %if.end.i.i
  %group_type = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 9
  %147 = ptrtoint ptr %group_type to i32
  call void @__asan_store4_noabort(i32 %147)
  store i32 5, ptr %group_type, align 4
  %group_load60 = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 1
  %148 = ptrtoint ptr %group_load60 to i32
  call void @__asan_load4_noabort(i32 %148)
  %149 = load i32, ptr %group_load60, align 4
  %mul = shl i32 %149, 10
  %150 = ptrtoint ptr %group_capacity to i32
  call void @__asan_load4_noabort(i32 %150)
  %151 = load i32, ptr %group_capacity, align 4
  %div = udiv i32 %mul, %151
  %152 = ptrtoint ptr %sgs to i32
  call void @__asan_store4_noabort(i32 %152)
  store i32 %div, ptr %sgs, align 4
  br label %if.end62

if.end62:                                         ; preds = %if.then59, %group_classify.exit.thread
  ret void
}

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @trace_sched_overutilized_tp(ptr noundef %rd, i1 noundef zeroext %overutilized) unnamed_addr #7 align 64 {
entry:
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_overutilized_tp, i32 0, i32 1), ptr blockaddress(@trace_sched_overutilized_tp, %do.body)) #20
          to label %if.end49 [label %do.body], !srcloc !261

do.body:                                          ; preds = %entry
  %0 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 3
  %2 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %4 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i = icmp ugt i32 %4, %3
  br i1 %cmp.not.i.i.i.i, label %cpu_online.exit, label %land.rhs.i.i.i.i

land.rhs.i.i.i.i:                                 ; preds = %do.body
  %.b37.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i, label %cpu_online.exit, label %if.then.i.i.i.i, !prof !259

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_online.exit

cpu_online.exit:                                  ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i.i, %do.body
  %div3.i.i.i = lshr i32 %3, 5
  %arrayidx.i.i.i = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i
  %5 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %arrayidx.i.i.i, align 4
  %and.i.i.i76 = and i32 %3, 31
  %7 = shl nuw i32 1, %and.i.i.i76
  %8 = and i32 %6, %7
  %tobool.i.not = icmp eq i32 %8, 0
  br i1 %tobool.i.not, label %if.end70, label %cleanup.thread

cleanup.thread:                                   ; preds = %cpu_online.exit
  %9 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i = and i32 %9, -16384
  %10 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %10, i32 0, i32 1
  %11 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %preempt_count.i.i, align 4
  %add.i = add i32 %12, 1
  store volatile i32 %add.i, ptr %preempt_count.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !305
  %call43 = tail call i32 @__traceiter_sched_overutilized_tp(ptr noundef null, ptr noundef %rd, i1 noundef zeroext %overutilized) #20
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !306
  %13 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i74 = and i32 %13, -16384
  %14 = inttoptr i32 %and.i.i.i74 to ptr
  %preempt_count.i.i75 = getelementptr inbounds %struct.thread_info, ptr %14, i32 0, i32 1
  %15 = ptrtoint ptr %preempt_count.i.i75 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %preempt_count.i.i75, align 4
  %sub.i = add i32 %16, -1
  store volatile i32 %sub.i, ptr %preempt_count.i.i75, align 4
  br label %if.end49

if.end49:                                         ; preds = %cleanup.thread, %entry
  %17 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i77 = and i32 %17, -16384
  %18 = inttoptr i32 %and.i77 to ptr
  %cpu51 = getelementptr inbounds %struct.thread_info, ptr %18, i32 0, i32 3
  %19 = ptrtoint ptr %cpu51 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %cpu51, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %21 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i78 = icmp ugt i32 %21, %20
  br i1 %cmp.not.i.i.i.i78, label %cpu_online.exit86, label %land.rhs.i.i.i.i80

land.rhs.i.i.i.i80:                               ; preds = %if.end49
  %.b37.i.i.i.i79 = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i79, label %cpu_online.exit86, label %if.then.i.i.i.i81, !prof !259

if.then.i.i.i.i81:                                ; preds = %land.rhs.i.i.i.i80
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_online.exit86

cpu_online.exit86:                                ; preds = %if.then.i.i.i.i81, %land.rhs.i.i.i.i80, %if.end49
  %div3.i.i.i82 = lshr i32 %20, 5
  %arrayidx.i.i.i83 = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i82
  %22 = ptrtoint ptr %arrayidx.i.i.i83 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %arrayidx.i.i.i83, align 4
  %and.i.i.i84 = and i32 %20, 31
  %24 = shl nuw i32 1, %and.i.i.i84
  %25 = and i32 %23, %24
  %tobool.i85.not = icmp eq i32 %25, 0
  br i1 %tobool.i85.not, label %if.end70, label %if.then53

if.then53:                                        ; preds = %cpu_online.exit86
  %26 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i = and i32 %26, -16384
  %27 = inttoptr i32 %and.i.i.i.i to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %27, i32 0, i32 1
  %28 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %add.i.i = add i32 %29, 1
  store volatile i32 %add.i.i, ptr %preempt_count.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !293
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_overutilized_tp, i32 0, i32 7) to i32))
  %30 = load volatile ptr, ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_overutilized_tp, i32 0, i32 7), align 4
  %call59 = tail call i32 @rcu_read_lock_sched_held() #20
  %tobool60.not = icmp eq i32 %call59, 0
  br i1 %tobool60.not, label %land.lhs.true, label %do.end68

land.lhs.true:                                    ; preds = %if.then53
  %call61 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool62.not = icmp eq i32 %call61, 0
  br i1 %tobool62.not, label %do.end68, label %land.lhs.true63

land.lhs.true63:                                  ; preds = %land.lhs.true
  %.b73 = load i1, ptr @trace_sched_overutilized_tp.__warned, align 1
  br i1 %.b73, label %do.end68, label %if.then65

if.then65:                                        ; preds = %land.lhs.true63
  store i1 true, ptr @trace_sched_overutilized_tp.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.15, i32 noundef 721, ptr noundef nonnull @.str.16) #20
  br label %do.end68

do.end68:                                         ; preds = %if.then65, %land.lhs.true63, %land.lhs.true, %if.then53
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !294
  %31 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i87 = and i32 %31, -16384
  %32 = inttoptr i32 %and.i.i.i.i87 to ptr
  %preempt_count.i.i.i88 = getelementptr inbounds %struct.thread_info, ptr %32, i32 0, i32 1
  %33 = ptrtoint ptr %preempt_count.i.i.i88 to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load volatile i32, ptr %preempt_count.i.i.i88, align 4
  %sub.i.i = add i32 %34, -1
  store volatile i32 %sub.i.i, ptr %preempt_count.i.i.i88, align 4
  br label %if.end70

if.end70:                                         ; preds = %do.end68, %cpu_online.exit86, %cpu_online.exit
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__traceiter_sched_overutilized_tp(ptr noundef, ptr noundef, i1 noundef zeroext) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @can_migrate_task(ptr noundef %p, ptr nocapture noundef %env) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %src_rq = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 1
  %0 = ptrtoint ptr %src_rq to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %src_rq, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %2 = load i32, ptr @debug_locks, align 4
  %tobool.not.i = icmp eq i32 %2, 0
  br i1 %tobool.not.i, label %lockdep_assert_rq_held.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %entry
  %core_enabled.i.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 81
  %3 = ptrtoint ptr %core_enabled.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %core_enabled.i.i, align 128
  %tobool.not.i.i = icmp eq i32 %4, 0
  br i1 %tobool.not.i.i, label %__rq_lockp.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.rhs.i
  %core.i.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 79
  %5 = ptrtoint ptr %core.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %core.i.i, align 8
  br label %__rq_lockp.exit.i

__rq_lockp.exit.i:                                ; preds = %if.then.i.i, %land.rhs.i
  %retval.0.i.i = phi ptr [ %6, %if.then.i.i ], [ %1, %land.rhs.i ]
  %dep_map.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i, i32 0, i32 4
  %call.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i, i32 noundef -1) #20
  %cmp.not.i = icmp eq i32 %call.i.i, 0
  br i1 %cmp.not.i, label %do.end.i, label %lockdep_assert_rq_held.exit, !prof !260

do.end.i:                                         ; preds = %__rq_lockp.exit.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit

lockdep_assert_rq_held.exit:                      ; preds = %do.end.i, %__rq_lockp.exit.i, %entry
  %sched_task_group.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 25
  %7 = ptrtoint ptr %sched_task_group.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %sched_task_group.i, align 8
  %src_cpu = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 2
  %9 = ptrtoint ptr %src_cpu to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %src_cpu, align 4
  %dst_cpu = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 3
  %11 = ptrtoint ptr %dst_cpu to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %dst_cpu, align 4
  %cfs_rq.i = getelementptr inbounds %struct.task_group, ptr %8, i32 0, i32 2
  %13 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %cfs_rq.i, align 4
  %arrayidx.i = getelementptr ptr, ptr %14, i32 %10
  %15 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %arrayidx.i, align 4
  %arrayidx2.i = getelementptr ptr, ptr %14, i32 %12
  %17 = ptrtoint ptr %arrayidx2.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %arrayidx2.i, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@can_migrate_task, %land.rhs.i.i)) #20
          to label %lor.rhs.i [label %land.rhs.i.i], !srcloc !261

land.rhs.i.i:                                     ; preds = %lockdep_assert_rq_held.exit
  %throttle_count.i.i = getelementptr inbounds %struct.cfs_rq, ptr %16, i32 0, i32 38
  %19 = ptrtoint ptr %throttle_count.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %throttle_count.i.i, align 4
  %tobool.i.not.i = icmp eq i32 %20, 0
  br i1 %tobool.i.not.i, label %lor.rhs.i, label %cleanup128

lor.rhs.i:                                        ; preds = %land.rhs.i.i, %lockdep_assert_rq_held.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@can_migrate_task, %land.rhs.i9.i)) #20
          to label %if.end [label %land.rhs.i9.i], !srcloc !261

land.rhs.i9.i:                                    ; preds = %lor.rhs.i
  %throttle_count.i6.i = getelementptr inbounds %struct.cfs_rq, ptr %18, i32 0, i32 38
  %21 = ptrtoint ptr %throttle_count.i6.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load i32, ptr %throttle_count.i6.i, align 4
  %tobool.i7.i.not = icmp eq i32 %22, 0
  br i1 %tobool.i7.i.not, label %if.end, label %cleanup128

if.end:                                           ; preds = %land.rhs.i9.i, %lor.rhs.i
  %call2 = tail call zeroext i1 @kthread_is_per_cpu(ptr noundef %p) #20
  br i1 %call2, label %cleanup128, label %if.end4

if.end4:                                          ; preds = %if.end
  %23 = ptrtoint ptr %dst_cpu to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %dst_cpu, align 4
  %cpus_ptr = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 33
  %25 = ptrtoint ptr %cpus_ptr to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load ptr, ptr %cpus_ptr, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %27 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i = icmp ugt i32 %27, %24
  br i1 %cmp.not.i.i.i, label %cpumask_test_cpu.exit, label %land.rhs.i.i.i

land.rhs.i.i.i:                                   ; preds = %if.end4
  %.b37.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i, label %cpumask_test_cpu.exit, label %if.then.i.i.i, !prof !259

if.then.i.i.i:                                    ; preds = %land.rhs.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpumask_test_cpu.exit

cpumask_test_cpu.exit:                            ; preds = %if.then.i.i.i, %land.rhs.i.i.i, %if.end4
  %div3.i.i = lshr i32 %24, 5
  %arrayidx.i.i = getelementptr i32, ptr %26, i32 %div3.i.i
  %28 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %arrayidx.i.i, align 4
  %and.i.i = and i32 %24, 31
  %30 = shl nuw i32 1, %and.i.i
  %31 = and i32 %29, %30
  %tobool7.not = icmp eq i32 %31, 0
  br i1 %tobool7.not, label %if.then8, label %if.end28

if.then8:                                         ; preds = %cpumask_test_cpu.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@can_migrate_task, %if.then13)) #20
          to label %do.end [label %if.then13], !srcloc !261

if.then13:                                        ; preds = %if.then8
  %nr_failed_migrations_affine = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 29, i32 15
  %32 = ptrtoint ptr %nr_failed_migrations_affine to i32
  call void @__asan_load8_noabort(i32 %32)
  %33 = load i64, ptr %nr_failed_migrations_affine, align 8
  %inc = add i64 %33, 1
  store i64 %inc, ptr %nr_failed_migrations_affine, align 8
  br label %do.end

do.end:                                           ; preds = %if.then13, %if.then8
  %flags = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 10
  %34 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load i32, ptr %flags, align 4
  %or = or i32 %35, 8
  store i32 %or, ptr %flags, align 4
  %idle = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 7
  %36 = ptrtoint ptr %idle to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load i32, ptr %idle, align 4
  %cmp = icmp ne i32 %37, 2
  %and = and i32 %35, 20
  %tobool16.not = icmp eq i32 %and, 0
  %or.cond = select i1 %cmp, i1 %tobool16.not, i1 false
  br i1 %or.cond, label %for.cond.preheader, label %cleanup128

for.cond.preheader:                               ; preds = %do.end
  %dst_grpmask = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 5
  %38 = ptrtoint ptr %dst_grpmask to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load ptr, ptr %dst_grpmask, align 4
  %cpus = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 9
  %40 = ptrtoint ptr %cpus to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load ptr, ptr %cpus, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %42 = load i32, ptr @nr_cpu_ids, align 4
  br label %for.cond

for.cond:                                         ; preds = %cpumask_test_cpu.exit184, %for.cond.preheader
  %cpu.0 = phi i32 [ %call19, %cpumask_test_cpu.exit184 ], [ -1, %for.cond.preheader ]
  %call19 = tail call i32 @cpumask_next_and(i32 noundef %cpu.0, ptr noundef %39, ptr noundef %41) #24
  %cmp20 = icmp ult i32 %call19, %42
  br i1 %cmp20, label %cpumask_test_cpu.exit184, label %cleanup128

cpumask_test_cpu.exit184:                         ; preds = %for.cond
  %43 = ptrtoint ptr %cpus_ptr to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load ptr, ptr %cpus_ptr, align 4
  %div3.i.i179 = lshr i32 %call19, 5
  %arrayidx.i.i180 = getelementptr i32, ptr %44, i32 %div3.i.i179
  %45 = ptrtoint ptr %arrayidx.i.i180 to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load volatile i32, ptr %arrayidx.i.i180, align 4
  %and.i.i181 = and i32 %call19, 31
  %47 = shl nuw i32 1, %and.i.i181
  %48 = and i32 %46, %47
  %tobool23.not = icmp eq i32 %48, 0
  br i1 %tobool23.not, label %for.cond, label %if.then24

if.then24:                                        ; preds = %cpumask_test_cpu.exit184
  %49 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load i32, ptr %flags, align 4
  %or26 = or i32 %50, 4
  store i32 %or26, ptr %flags, align 4
  %new_dst_cpu = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 6
  %51 = ptrtoint ptr %new_dst_cpu to i32
  call void @__asan_store4_noabort(i32 %51)
  store i32 %call19, ptr %new_dst_cpu, align 4
  br label %cleanup128

if.end28:                                         ; preds = %cpumask_test_cpu.exit
  %flags29 = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 10
  %52 = ptrtoint ptr %flags29 to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load i32, ptr %flags29, align 4
  %and30 = and i32 %53, -2
  store i32 %and30, ptr %flags29, align 4
  %on_cpu.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 5
  %54 = ptrtoint ptr %on_cpu.i to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load i32, ptr %on_cpu.i, align 4
  %tobool33.not = icmp eq i32 %55, 0
  br i1 %tobool33.not, label %if.end53, label %do.body35

do.body35:                                        ; preds = %if.end28
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@can_migrate_task, %if.then47)) #20
          to label %cleanup128 [label %if.then47], !srcloc !261

if.then47:                                        ; preds = %do.body35
  %nr_failed_migrations_running = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 29, i32 16
  %56 = ptrtoint ptr %nr_failed_migrations_running to i32
  call void @__asan_load8_noabort(i32 %56)
  %57 = load i64, ptr %nr_failed_migrations_running, align 128
  %inc49 = add i64 %57, 1
  store i64 %inc49, ptr %nr_failed_migrations_running, align 128
  br label %cleanup128

if.end53:                                         ; preds = %if.end28
  %and55 = and i32 %53, 16
  %tobool56.not = icmp eq i32 %and55, 0
  br i1 %tobool56.not, label %if.end58, label %cleanup128

if.end58:                                         ; preds = %if.end53
  %call62 = tail call fastcc i32 @task_hot(ptr noundef %p, ptr noundef %env)
  %cmp64 = icmp slt i32 %call62, 1
  br i1 %cmp64, label %cleanup128, label %lor.lhs.false65

lor.lhs.false65:                                  ; preds = %if.end58
  %58 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load ptr, ptr %env, align 4
  %nr_balance_failed = getelementptr inbounds %struct.sched_domain, ptr %59, i32 0, i32 13
  %60 = ptrtoint ptr %nr_balance_failed to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load i32, ptr %nr_balance_failed, align 4
  %cache_nice_tries = getelementptr inbounds %struct.sched_domain, ptr %59, i32 0, i32 7
  %62 = ptrtoint ptr %cache_nice_tries to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load i32, ptr %cache_nice_tries, align 4
  %cmp67 = icmp ugt i32 %61, %63
  br i1 %cmp67, label %if.then68, label %do.body110

if.then68:                                        ; preds = %lor.lhs.false65
  %cmp69 = icmp eq i32 %call62, 1
  br i1 %cmp69, label %do.body71, label %cleanup128

do.body71:                                        ; preds = %if.then68
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@can_migrate_task, %if.then83)) #20
          to label %do.body90 [label %if.then83], !srcloc !261

if.then83:                                        ; preds = %do.body71
  %64 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %64)
  %65 = load ptr, ptr %env, align 4
  %idle85 = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 7
  %66 = ptrtoint ptr %idle85 to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load i32, ptr %idle85, align 4
  %arrayidx = getelementptr %struct.sched_domain, ptr %65, i32 0, i32 22, i32 %67
  %68 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load i32, ptr %arrayidx, align 4
  %inc86 = add i32 %69, 1
  store i32 %inc86, ptr %arrayidx, align 4
  br label %do.body90

do.body90:                                        ; preds = %if.then83, %do.body71
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@can_migrate_task, %if.then102)) #20
          to label %cleanup128 [label %if.then102], !srcloc !261

if.then102:                                       ; preds = %do.body90
  %nr_forced_migrations = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 29, i32 18
  %70 = ptrtoint ptr %nr_forced_migrations to i32
  call void @__asan_load8_noabort(i32 %70)
  %71 = load i64, ptr %nr_forced_migrations, align 16
  %inc104 = add i64 %71, 1
  store i64 %inc104, ptr %nr_forced_migrations, align 16
  br label %cleanup128

do.body110:                                       ; preds = %lor.lhs.false65
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@can_migrate_task, %if.then122)) #20
          to label %cleanup128 [label %if.then122], !srcloc !261

if.then122:                                       ; preds = %do.body110
  %nr_failed_migrations_hot = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 29, i32 17
  %72 = ptrtoint ptr %nr_failed_migrations_hot to i32
  call void @__asan_load8_noabort(i32 %72)
  %73 = load i64, ptr %nr_failed_migrations_hot, align 8
  %inc124 = add i64 %73, 1
  store i64 %inc124, ptr %nr_failed_migrations_hot, align 8
  br label %cleanup128

cleanup128:                                       ; preds = %if.then122, %do.body110, %if.then102, %do.body90, %if.then68, %if.end58, %if.end53, %if.then47, %do.body35, %if.then24, %for.cond, %do.end, %if.end, %land.rhs.i9.i, %land.rhs.i.i
  %retval.1 = phi i32 [ 0, %land.rhs.i9.i ], [ 0, %if.end ], [ 0, %if.then24 ], [ 0, %do.end ], [ 0, %if.then47 ], [ 1, %if.end53 ], [ 1, %if.then102 ], [ 1, %if.then68 ], [ 0, %if.then122 ], [ 0, %do.body35 ], [ 1, %do.body90 ], [ 0, %do.body110 ], [ 0, %land.rhs.i.i ], [ 1, %if.end58 ], [ 0, %for.cond ]
  ret i32 %retval.1
}

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @kthread_is_per_cpu(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @task_hot(ptr noundef readonly %p, ptr nocapture noundef readonly %env) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %src_rq = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 1
  %0 = ptrtoint ptr %src_rq to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %src_rq, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %2 = load i32, ptr @debug_locks, align 4
  %tobool.not.i = icmp eq i32 %2, 0
  br i1 %tobool.not.i, label %lockdep_assert_rq_held.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %entry
  %core_enabled.i.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 81
  %3 = ptrtoint ptr %core_enabled.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %core_enabled.i.i, align 128
  %tobool.not.i.i = icmp eq i32 %4, 0
  br i1 %tobool.not.i.i, label %__rq_lockp.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.rhs.i
  %core.i.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 79
  %5 = ptrtoint ptr %core.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %core.i.i, align 8
  br label %__rq_lockp.exit.i

__rq_lockp.exit.i:                                ; preds = %if.then.i.i, %land.rhs.i
  %retval.0.i.i = phi ptr [ %6, %if.then.i.i ], [ %1, %land.rhs.i ]
  %dep_map.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i, i32 0, i32 4
  %call.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i, i32 noundef -1) #20
  %cmp.not.i = icmp eq i32 %call.i.i, 0
  br i1 %cmp.not.i, label %do.end.i, label %lockdep_assert_rq_held.exit, !prof !260

do.end.i:                                         ; preds = %__rq_lockp.exit.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit

lockdep_assert_rq_held.exit:                      ; preds = %do.end.i, %__rq_lockp.exit.i, %entry
  %sched_class = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 21
  %7 = ptrtoint ptr %sched_class to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %sched_class, align 32
  %cmp.not = icmp eq ptr %8, @fair_sched_class
  br i1 %cmp.not, label %if.end, label %cleanup

if.end:                                           ; preds = %lockdep_assert_rq_held.exit
  %policy.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 31
  %9 = ptrtoint ptr %policy.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %policy.i, align 4
  %cmp.i.i.not = icmp eq i32 %10, 5
  br i1 %cmp.i.i.not, label %cleanup, label %if.end4, !prof !260

if.end4:                                          ; preds = %if.end
  %11 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %env, align 4
  %flags = getelementptr inbounds %struct.sched_domain, ptr %12, i32 0, i32 9
  %13 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %flags, align 4
  %and = and i32 %14, 128
  %tobool5.not = icmp eq i32 %and, 0
  br i1 %tobool5.not, label %if.end7, label %cleanup

if.end7:                                          ; preds = %if.end4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 4), i32 1), ptr blockaddress(@task_hot, %if.end19)) #20
          to label %land.lhs.true [label %if.end19], !srcloc !261

land.lhs.true:                                    ; preds = %if.end7
  %dst_rq = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 4
  %15 = ptrtoint ptr %dst_rq to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %dst_rq, align 4
  %nr_running = getelementptr inbounds %struct.rq, ptr %16, i32 0, i32 1
  %17 = ptrtoint ptr %nr_running to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %nr_running, align 4
  %tobool9.not = icmp eq i32 %18, 0
  br i1 %tobool9.not, label %if.end19, label %land.lhs.true10

land.lhs.true10:                                  ; preds = %land.lhs.true
  %se = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %cfs_rq.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %19 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %cfs_rq.i, align 16
  %next = getelementptr inbounds %struct.cfs_rq, ptr %20, i32 0, i32 12
  %21 = ptrtoint ptr %next to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %next, align 4
  %cmp13 = icmp eq ptr %se, %22
  br i1 %cmp13, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true10
  %last = getelementptr inbounds %struct.cfs_rq, ptr %20, i32 0, i32 13
  %23 = ptrtoint ptr %last to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %last, align 16
  %cmp17 = icmp eq ptr %se, %24
  br i1 %cmp17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %lor.lhs.false, %land.lhs.true, %if.end7
  %25 = load i32, ptr @sysctl_sched_migration_cost, align 4
  %cmp20 = icmp eq i32 %25, -1
  br i1 %cmp20, label %cleanup, label %do.body

do.body:                                          ; preds = %if.end19
  %dst_cpu = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 3
  %26 = ptrtoint ptr %dst_cpu to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %dst_cpu, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %27
  %28 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %arrayidx, align 4
  %add = add i32 %29, ptrtoint (ptr @runqueues to i32)
  %30 = inttoptr i32 %add to ptr
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__sched_core_enabled, ptr blockaddress(@task_hot, %land.rhs.i.i)) #20
          to label %if.end26 [label %land.rhs.i.i], !srcloc !261

land.rhs.i.i:                                     ; preds = %do.body
  %core_enabled.i.i47 = getelementptr inbounds %struct.rq, ptr %30, i32 0, i32 81
  %31 = ptrtoint ptr %core_enabled.i.i47 to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %core_enabled.i.i47, align 128
  %tobool3.i.not.i = icmp eq i32 %32, 0
  br i1 %tobool3.i.not.i, label %if.end26, label %for.cond.preheader.i

for.cond.preheader.i:                             ; preds = %land.rhs.i.i
  %cpu.i.i = getelementptr inbounds %struct.rq, ptr %30, i32 0, i32 46
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %for.cond.preheader.i
  %cpu.0.i = phi i32 [ %call3.i, %for.body.i ], [ -1, %for.cond.preheader.i ]
  %33 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %cpu.i.i, align 4
  %thread_sibling.i.i = getelementptr [4 x %struct.cpu_topology], ptr @cpu_topology, i32 0, i32 %34, i32 5
  %call3.i = tail call i32 @cpumask_next(i32 noundef %cpu.0.i, ptr noundef %thread_sibling.i.i) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %35 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.i = icmp ult i32 %call3.i, %35
  br i1 %cmp.i, label %for.body.i, label %if.end26

for.body.i:                                       ; preds = %for.cond.i
  %call4.i = tail call i32 @available_idle_cpu(i32 noundef %call3.i) #20
  %tobool.not.i48 = icmp eq i32 %call4.i, 0
  br i1 %tobool.not.i48, label %lor.rhs.critedge.i, label %for.cond.i

lor.rhs.critedge.i:                               ; preds = %for.body.i
  %core.i = getelementptr inbounds %struct.rq, ptr %30, i32 0, i32 79
  %36 = ptrtoint ptr %core.i to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load ptr, ptr %core.i, align 8
  %core_cookie.i = getelementptr inbounds %struct.rq, ptr %37, i32 0, i32 86
  %38 = ptrtoint ptr %core_cookie.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load i32, ptr %core_cookie.i, align 4
  %core_cookie8.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 23
  %40 = ptrtoint ptr %core_cookie8.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %core_cookie8.i, align 16
  %cmp9.i = icmp eq i32 %39, %41
  br i1 %cmp9.i, label %if.end26, label %cleanup

if.end26:                                         ; preds = %lor.rhs.critedge.i, %for.cond.i, %land.rhs.i.i, %do.body
  %42 = load i32, ptr @sysctl_sched_migration_cost, align 4
  %cmp27 = icmp eq i32 %42, 0
  br i1 %cmp27, label %cleanup, label %if.end29

if.end29:                                         ; preds = %if.end26
  %43 = ptrtoint ptr %src_rq to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load ptr, ptr %src_rq, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %45 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i49 = icmp eq i32 %45, 0
  br i1 %tobool.not.i.i49, label %lockdep_assert_rq_held.exit.i, label %land.rhs.i.i50

land.rhs.i.i50:                                   ; preds = %if.end29
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %44, i32 0, i32 81
  %46 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %47, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.rhs.i.i50
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %44, i32 0, i32 79
  %48 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %land.rhs.i.i50
  %retval.0.i.i.i51 = phi ptr [ %49, %if.then.i.i.i ], [ %44, %land.rhs.i.i50 ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i51, i32 0, i32 4
  %call.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i, i32 noundef -1) #20
  %cmp.not.i.i = icmp eq i32 %call.i.i.i, 0
  br i1 %cmp.not.i.i, label %do.end.i.i, label %lockdep_assert_rq_held.exit.i, !prof !260

do.end.i.i:                                       ; preds = %__rq_lockp.exit.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit.i

lockdep_assert_rq_held.exit.i:                    ; preds = %do.end.i.i, %__rq_lockp.exit.i.i, %if.end29
  %clock_update_flags.i.i = getelementptr inbounds %struct.rq, ptr %44, i32 0, i32 25
  %50 = ptrtoint ptr %clock_update_flags.i.i to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load i32, ptr %clock_update_flags.i.i, align 4
  %cmp.i.i52 = icmp ult i32 %51, 2
  br i1 %cmp.i.i52, label %land.rhs.i3.i, label %rq_clock_task.exit

land.rhs.i3.i:                                    ; preds = %lockdep_assert_rq_held.exit.i
  %.b37.i.i = load i1, ptr @assert_clock_updated.__already_done, align 1
  br i1 %.b37.i.i, label %rq_clock_task.exit, label %if.then.i.i53, !prof !259

if.then.i.i53:                                    ; preds = %land.rhs.i3.i
  store i1 true, ptr @assert_clock_updated.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1459, i32 noundef 9, ptr noundef nonnull @.str.10) #20
  br label %rq_clock_task.exit

rq_clock_task.exit:                               ; preds = %if.then.i.i53, %land.rhs.i3.i, %lockdep_assert_rq_held.exit.i
  %clock_task.i = getelementptr inbounds %struct.rq, ptr %44, i32 0, i32 28
  %52 = ptrtoint ptr %clock_task.i to i32
  call void @__asan_load8_noabort(i32 %52)
  %53 = load i64, ptr %clock_task.i, align 128
  %exec_start = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 4
  %54 = ptrtoint ptr %exec_start to i32
  call void @__asan_load8_noabort(i32 %54)
  %55 = load i64, ptr %exec_start, align 32
  %sub = sub i64 %53, %55
  %56 = load i32, ptr @sysctl_sched_migration_cost, align 4
  %conv = zext i32 %56 to i64
  %cmp33 = icmp slt i64 %sub, %conv
  %conv34 = zext i1 %cmp33 to i32
  br label %cleanup

cleanup:                                          ; preds = %rq_clock_task.exit, %if.end26, %lor.rhs.critedge.i, %if.end19, %lor.lhs.false, %land.lhs.true10, %if.end4, %if.end, %lockdep_assert_rq_held.exit
  %retval.0 = phi i32 [ %conv34, %rq_clock_task.exit ], [ 0, %lockdep_assert_rq_held.exit ], [ 0, %if.end ], [ 0, %if.end4 ], [ 1, %lor.lhs.false ], [ 1, %land.lhs.true10 ], [ 1, %if.end19 ], [ 0, %if.end26 ], [ 1, %lor.rhs.critedge.i ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @deactivate_task(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @set_task_cpu(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @raw_spin_rq_unlock(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @lock_unpin_lock(ptr noundef, [1 x i32]) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @attach_task(ptr noundef %rq, ptr noundef %p) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %0 = load i32, ptr @debug_locks, align 4
  %tobool.not.i = icmp eq i32 %0, 0
  br i1 %tobool.not.i, label %lockdep_assert_rq_held.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %entry
  %core_enabled.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 81
  %1 = ptrtoint ptr %core_enabled.i.i to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %core_enabled.i.i, align 128
  %tobool.not.i.i = icmp eq i32 %2, 0
  br i1 %tobool.not.i.i, label %__rq_lockp.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.rhs.i
  %core.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 79
  %3 = ptrtoint ptr %core.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %core.i.i, align 8
  br label %__rq_lockp.exit.i

__rq_lockp.exit.i:                                ; preds = %if.then.i.i, %land.rhs.i
  %retval.0.i.i = phi ptr [ %4, %if.then.i.i ], [ %rq, %land.rhs.i ]
  %dep_map.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i, i32 0, i32 4
  %call.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i, i32 noundef -1) #20
  %cmp.not.i = icmp eq i32 %call.i.i, 0
  br i1 %cmp.not.i, label %do.end.i, label %lockdep_assert_rq_held.exit, !prof !260

do.end.i:                                         ; preds = %__rq_lockp.exit.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit

lockdep_assert_rq_held.exit:                      ; preds = %do.end.i, %__rq_lockp.exit.i, %entry
  %stack.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 1
  %5 = ptrtoint ptr %stack.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %stack.i, align 4
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %6, i32 0, i32 3
  %7 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load volatile i32, ptr %cpu.i, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %8
  %9 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %arrayidx, align 4
  %add = add i32 %10, ptrtoint (ptr @runqueues to i32)
  %11 = inttoptr i32 %add to ptr
  %cmp.not = icmp eq ptr %11, %rq
  br i1 %cmp.not, label %do.end8, label %do.body4, !prof !259

do.body4:                                         ; preds = %lockdep_assert_rq_held.exit
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22kernel/sched/fair.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 8014, 0\0A.popsection", ""() #20, !srcloc !307
  unreachable

do.end8:                                          ; preds = %lockdep_assert_rq_held.exit
  tail call void @activate_task(ptr noundef %rq, ptr noundef %p, i32 noundef 8) #20
  tail call void @check_preempt_curr(ptr noundef %rq, ptr noundef %p, i32 noundef 0) #20
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @raw_spin_rq_lock_nested(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @lock_pin_lock(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @activate_task(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @check_preempt_curr(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__bitmap_subset(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc ptr @detach_one_task(ptr nocapture noundef %env) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %src_rq = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 1
  %0 = ptrtoint ptr %src_rq to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %src_rq, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %2 = load i32, ptr @debug_locks, align 4
  %tobool.not.i = icmp eq i32 %2, 0
  br i1 %tobool.not.i, label %lockdep_assert_rq_held.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %entry
  %core_enabled.i.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 81
  %3 = ptrtoint ptr %core_enabled.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %core_enabled.i.i, align 128
  %tobool.not.i.i = icmp eq i32 %4, 0
  br i1 %tobool.not.i.i, label %__rq_lockp.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.rhs.i
  %core.i.i = getelementptr inbounds %struct.rq, ptr %1, i32 0, i32 79
  %5 = ptrtoint ptr %core.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %core.i.i, align 8
  br label %__rq_lockp.exit.i

__rq_lockp.exit.i:                                ; preds = %if.then.i.i, %land.rhs.i
  %retval.0.i.i = phi ptr [ %6, %if.then.i.i ], [ %1, %land.rhs.i ]
  %dep_map.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i, i32 0, i32 4
  %call.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i, i32 noundef -1) #20
  %cmp.not.i = icmp eq i32 %call.i.i, 0
  br i1 %cmp.not.i, label %do.end.i, label %lockdep_assert_rq_held.exit, !prof !260

do.end.i:                                         ; preds = %__rq_lockp.exit.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit

lockdep_assert_rq_held.exit:                      ; preds = %do.end.i, %__rq_lockp.exit.i, %entry
  %7 = ptrtoint ptr %src_rq to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %src_rq, align 4
  %prev = getelementptr inbounds %struct.rq, ptr %8, i32 0, i32 48, i32 1
  %9 = ptrtoint ptr %prev to i32
  call void @__asan_load4_noabort(i32 %9)
  %.pn31 = load ptr, ptr %prev, align 4
  %cfs_tasks333 = getelementptr inbounds %struct.rq, ptr %8, i32 0, i32 48
  %cmp.not34 = icmp eq ptr %.pn31, %cfs_tasks333
  br i1 %cmp.not34, label %cleanup, label %for.body

for.cond:                                         ; preds = %for.body
  %prev15 = getelementptr inbounds %struct.list_head, ptr %.pn35, i32 0, i32 1
  %10 = ptrtoint ptr %prev15 to i32
  call void @__asan_load4_noabort(i32 %10)
  %.pn = load ptr, ptr %prev15, align 4
  %11 = ptrtoint ptr %src_rq to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %src_rq, align 4
  %cfs_tasks3 = getelementptr inbounds %struct.rq, ptr %12, i32 0, i32 48
  %cmp.not = icmp eq ptr %.pn, %cfs_tasks3
  br i1 %cmp.not, label %cleanup, label %for.body

for.body:                                         ; preds = %for.cond, %lockdep_assert_rq_held.exit
  %.pn35 = phi ptr [ %.pn, %for.cond ], [ %.pn31, %lockdep_assert_rq_held.exit ]
  %p.036 = getelementptr i8, ptr %.pn35, i32 -148
  %call = tail call fastcc i32 @can_migrate_task(ptr noundef %p.036, ptr noundef %env)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %for.cond, label %if.end

if.end:                                           ; preds = %for.body
  %13 = ptrtoint ptr %src_rq to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %src_rq, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %15 = load i32, ptr @debug_locks, align 4
  %tobool.not.i.i28 = icmp eq i32 %15, 0
  br i1 %tobool.not.i.i28, label %detach_task.exit, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %if.end
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %14, i32 0, i32 81
  %16 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool.not.i.i.i = icmp eq i32 %17, 0
  br i1 %tobool.not.i.i.i, label %__rq_lockp.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.rhs.i.i
  %core.i.i.i = getelementptr inbounds %struct.rq, ptr %14, i32 0, i32 79
  %18 = ptrtoint ptr %core.i.i.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load ptr, ptr %core.i.i.i, align 8
  br label %__rq_lockp.exit.i.i

__rq_lockp.exit.i.i:                              ; preds = %if.then.i.i.i, %land.rhs.i.i
  %retval.0.i.i.i = phi ptr [ %19, %if.then.i.i.i ], [ %14, %land.rhs.i.i ]
  %dep_map.i.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i.i, i32 0, i32 4
  %call.i.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i.i, i32 noundef -1) #20
  %cmp.not.i.i = icmp eq i32 %call.i.i.i, 0
  br i1 %cmp.not.i.i, label %do.end.i.i, label %detach_task.exit, !prof !260

do.end.i.i:                                       ; preds = %__rq_lockp.exit.i.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %detach_task.exit

detach_task.exit:                                 ; preds = %do.end.i.i, %__rq_lockp.exit.i.i, %if.end
  %20 = ptrtoint ptr %src_rq to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %src_rq, align 4
  tail call void @deactivate_task(ptr noundef %21, ptr noundef %p.036, i32 noundef 8) #20
  %dst_cpu.i = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 3
  %22 = ptrtoint ptr %dst_cpu.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load i32, ptr %dst_cpu.i, align 4
  tail call void @set_task_cpu(ptr noundef %p.036, i32 noundef %23) #20
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@detach_one_task, %if.then10)) #20
          to label %cleanup [label %if.then10], !srcloc !261

if.then10:                                        ; preds = %detach_task.exit
  %24 = ptrtoint ptr %env to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %env, align 4
  %idle = getelementptr inbounds %struct.lb_env, ptr %env, i32 0, i32 7
  %26 = ptrtoint ptr %idle to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %idle, align 4
  %arrayidx = getelementptr %struct.sched_domain, ptr %25, i32 0, i32 21, i32 %27
  %28 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %arrayidx, align 4
  %inc = add i32 %29, 1
  store i32 %inc, ptr %arrayidx, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.then10, %detach_task.exit, %for.cond, %lockdep_assert_rq_held.exit
  %retval.0 = phi ptr [ %p.036, %if.then10 ], [ %p.036, %detach_task.exit ], [ null, %lockdep_assert_rq_held.exit ], [ null, %for.cond ]
  ret ptr %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @sched_clock_cpu(i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @lock_repin_lock(ptr noundef, [1 x i32]) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @smp_call_function_single_async(i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @housekeeping_cpumask(i32 noundef) local_unnamed_addr #4

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare { i32, i1 } @llvm.umul.with.overflow.i32(i32, i32) #15

; Function Attrs: null_pointer_is_valid allocsize(0)
declare dso_local noalias ptr @__kmalloc(i32 noundef, i32 noundef) local_unnamed_addr #18

; Function Attrs: null_pointer_is_valid allocsize(2)
declare dso_local noalias ptr @kmem_cache_alloc_trace(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #19

; Function Attrs: null_pointer_is_valid
declare dso_local void @trace_hardirqs_off() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @hrtimer_cancel(ptr noundef) local_unnamed_addr #4

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @trace_sched_util_est_cfs_tp(ptr noundef %cfs_rq) unnamed_addr #7 align 64 {
entry:
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_util_est_cfs_tp, i32 0, i32 1), ptr blockaddress(@trace_sched_util_est_cfs_tp, %do.body)) #20
          to label %if.end48 [label %do.body], !srcloc !261

do.body:                                          ; preds = %entry
  %0 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 3
  %2 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %4 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i = icmp ugt i32 %4, %3
  br i1 %cmp.not.i.i.i.i, label %cpu_online.exit, label %land.rhs.i.i.i.i

land.rhs.i.i.i.i:                                 ; preds = %do.body
  %.b37.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i, label %cpu_online.exit, label %if.then.i.i.i.i, !prof !259

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_online.exit

cpu_online.exit:                                  ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i.i, %do.body
  %div3.i.i.i = lshr i32 %3, 5
  %arrayidx.i.i.i = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i
  %5 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %arrayidx.i.i.i, align 4
  %and.i.i.i75 = and i32 %3, 31
  %7 = shl nuw i32 1, %and.i.i.i75
  %8 = and i32 %6, %7
  %tobool.i.not = icmp eq i32 %8, 0
  br i1 %tobool.i.not, label %if.end69, label %cleanup.thread

cleanup.thread:                                   ; preds = %cpu_online.exit
  %9 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i = and i32 %9, -16384
  %10 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %10, i32 0, i32 1
  %11 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %preempt_count.i.i, align 4
  %add.i = add i32 %12, 1
  store volatile i32 %add.i, ptr %preempt_count.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !308
  %call42 = tail call i32 @__traceiter_sched_util_est_cfs_tp(ptr noundef null, ptr noundef %cfs_rq) #20
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !309
  %13 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i73 = and i32 %13, -16384
  %14 = inttoptr i32 %and.i.i.i73 to ptr
  %preempt_count.i.i74 = getelementptr inbounds %struct.thread_info, ptr %14, i32 0, i32 1
  %15 = ptrtoint ptr %preempt_count.i.i74 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %preempt_count.i.i74, align 4
  %sub.i = add i32 %16, -1
  store volatile i32 %sub.i, ptr %preempt_count.i.i74, align 4
  br label %if.end48

if.end48:                                         ; preds = %cleanup.thread, %entry
  %17 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i76 = and i32 %17, -16384
  %18 = inttoptr i32 %and.i76 to ptr
  %cpu50 = getelementptr inbounds %struct.thread_info, ptr %18, i32 0, i32 3
  %19 = ptrtoint ptr %cpu50 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %cpu50, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %21 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i77 = icmp ugt i32 %21, %20
  br i1 %cmp.not.i.i.i.i77, label %cpu_online.exit85, label %land.rhs.i.i.i.i79

land.rhs.i.i.i.i79:                               ; preds = %if.end48
  %.b37.i.i.i.i78 = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i78, label %cpu_online.exit85, label %if.then.i.i.i.i80, !prof !259

if.then.i.i.i.i80:                                ; preds = %land.rhs.i.i.i.i79
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_online.exit85

cpu_online.exit85:                                ; preds = %if.then.i.i.i.i80, %land.rhs.i.i.i.i79, %if.end48
  %div3.i.i.i81 = lshr i32 %20, 5
  %arrayidx.i.i.i82 = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i81
  %22 = ptrtoint ptr %arrayidx.i.i.i82 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %arrayidx.i.i.i82, align 4
  %and.i.i.i83 = and i32 %20, 31
  %24 = shl nuw i32 1, %and.i.i.i83
  %25 = and i32 %23, %24
  %tobool.i84.not = icmp eq i32 %25, 0
  br i1 %tobool.i84.not, label %if.end69, label %if.then52

if.then52:                                        ; preds = %cpu_online.exit85
  %26 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i = and i32 %26, -16384
  %27 = inttoptr i32 %and.i.i.i.i to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %27, i32 0, i32 1
  %28 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %add.i.i = add i32 %29, 1
  store volatile i32 %add.i.i, ptr %preempt_count.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !293
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_util_est_cfs_tp, i32 0, i32 7) to i32))
  %30 = load volatile ptr, ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_util_est_cfs_tp, i32 0, i32 7), align 4
  %call58 = tail call i32 @rcu_read_lock_sched_held() #20
  %tobool59.not = icmp eq i32 %call58, 0
  br i1 %tobool59.not, label %land.lhs.true, label %do.end67

land.lhs.true:                                    ; preds = %if.then52
  %call60 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool61.not = icmp eq i32 %call60, 0
  br i1 %tobool61.not, label %do.end67, label %land.lhs.true62

land.lhs.true62:                                  ; preds = %land.lhs.true
  %.b72 = load i1, ptr @trace_sched_util_est_cfs_tp.__warned, align 1
  br i1 %.b72, label %do.end67, label %if.then64

if.then64:                                        ; preds = %land.lhs.true62
  store i1 true, ptr @trace_sched_util_est_cfs_tp.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.15, i32 noundef 725, ptr noundef nonnull @.str.16) #20
  br label %do.end67

do.end67:                                         ; preds = %if.then64, %land.lhs.true62, %land.lhs.true, %if.then52
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !294
  %31 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i86 = and i32 %31, -16384
  %32 = inttoptr i32 %and.i.i.i.i86 to ptr
  %preempt_count.i.i.i87 = getelementptr inbounds %struct.thread_info, ptr %32, i32 0, i32 1
  %33 = ptrtoint ptr %preempt_count.i.i.i87 to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load volatile i32, ptr %preempt_count.i.i.i87, align 4
  %sub.i.i = add i32 %34, -1
  store volatile i32 %sub.i.i, ptr %preempt_count.i.i.i87, align 4
  br label %if.end69

if.end69:                                         ; preds = %do.end67, %cpu_online.exit85, %cpu_online.exit
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__traceiter_sched_util_est_cfs_tp(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @set_next_buddy(ptr noundef %se) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tobool.not54 = icmp eq ptr %se, null
  br i1 %tobool.not54, label %for.end, label %for.body

for.body:                                         ; preds = %if.end43, %entry
  %se.addr.055 = phi ptr [ %12, %if.end43 ], [ %se, %entry ]
  %on_rq = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055, i32 0, i32 3
  %0 = ptrtoint ptr %on_rq to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %on_rq, align 4
  %tobool1.not = icmp eq i32 %1, 0
  br i1 %tobool1.not, label %land.rhs, label %if.end40.critedge

land.rhs:                                         ; preds = %for.body
  %.b52 = load i1, ptr @set_next_buddy.__already_done, align 1
  br i1 %.b52, label %for.end, label %if.then, !prof !259

if.then:                                          ; preds = %land.rhs
  store i1 true, ptr @set_next_buddy.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 7065, i32 noundef 9, ptr noundef nonnull @.str.42) #20
  br label %for.end

if.end40.critedge:                                ; preds = %for.body
  %my_q.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055, i32 0, i32 12
  %2 = ptrtoint ptr %my_q.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %my_q.i, align 4
  %tobool.not.i = icmp eq ptr %3, null
  br i1 %tobool.not.i, label %se_is_idle.exit, label %if.end.i

if.end.i:                                         ; preds = %if.end40.critedge
  %idle.i.i = getelementptr inbounds %struct.cfs_rq, ptr %3, i32 0, i32 31
  %4 = ptrtoint ptr %idle.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %idle.i.i, align 16
  %cmp.i.i = icmp sgt i32 %5, 0
  br i1 %cmp.i.i, label %for.end, label %if.end43

se_is_idle.exit:                                  ; preds = %if.end40.critedge
  %policy.i.i = getelementptr i8, ptr %se.addr.055, i32 900
  %6 = ptrtoint ptr %policy.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %policy.i.i, align 4
  %cmp.i.i.i = icmp eq i32 %7, 5
  br i1 %cmp.i.i.i, label %for.end, label %if.end43

if.end43:                                         ; preds = %se_is_idle.exit, %if.end.i
  %cfs_rq.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055, i32 0, i32 11
  %8 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %cfs_rq.i, align 16
  %next = getelementptr inbounds %struct.cfs_rq, ptr %9, i32 0, i32 12
  %10 = ptrtoint ptr %next to i32
  call void @__asan_store4_noabort(i32 %10)
  store ptr %se.addr.055, ptr %next, align 4
  %parent = getelementptr inbounds %struct.sched_entity, ptr %se.addr.055, i32 0, i32 10
  %11 = ptrtoint ptr %parent to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %parent, align 4
  %tobool.not = icmp eq ptr %12, null
  br i1 %tobool.not, label %for.end, label %for.body

for.end:                                          ; preds = %if.end43, %se_is_idle.exit, %if.end.i, %if.then, %land.rhs, %entry
  ret void
}

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @trace_sched_util_est_se_tp(ptr noundef %se) unnamed_addr #7 align 64 {
entry:
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_util_est_se_tp, i32 0, i32 1), ptr blockaddress(@trace_sched_util_est_se_tp, %do.body)) #20
          to label %if.end48 [label %do.body], !srcloc !261

do.body:                                          ; preds = %entry
  %0 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 3
  %2 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %4 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i = icmp ugt i32 %4, %3
  br i1 %cmp.not.i.i.i.i, label %cpu_online.exit, label %land.rhs.i.i.i.i

land.rhs.i.i.i.i:                                 ; preds = %do.body
  %.b37.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i, label %cpu_online.exit, label %if.then.i.i.i.i, !prof !259

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_online.exit

cpu_online.exit:                                  ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i.i, %do.body
  %div3.i.i.i = lshr i32 %3, 5
  %arrayidx.i.i.i = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i
  %5 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %arrayidx.i.i.i, align 4
  %and.i.i.i75 = and i32 %3, 31
  %7 = shl nuw i32 1, %and.i.i.i75
  %8 = and i32 %6, %7
  %tobool.i.not = icmp eq i32 %8, 0
  br i1 %tobool.i.not, label %if.end69, label %cleanup.thread

cleanup.thread:                                   ; preds = %cpu_online.exit
  %9 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i = and i32 %9, -16384
  %10 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %10, i32 0, i32 1
  %11 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %preempt_count.i.i, align 4
  %add.i = add i32 %12, 1
  store volatile i32 %add.i, ptr %preempt_count.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !310
  %call42 = tail call i32 @__traceiter_sched_util_est_se_tp(ptr noundef null, ptr noundef %se) #20
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !311
  %13 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i73 = and i32 %13, -16384
  %14 = inttoptr i32 %and.i.i.i73 to ptr
  %preempt_count.i.i74 = getelementptr inbounds %struct.thread_info, ptr %14, i32 0, i32 1
  %15 = ptrtoint ptr %preempt_count.i.i74 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %preempt_count.i.i74, align 4
  %sub.i = add i32 %16, -1
  store volatile i32 %sub.i, ptr %preempt_count.i.i74, align 4
  br label %if.end48

if.end48:                                         ; preds = %cleanup.thread, %entry
  %17 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i76 = and i32 %17, -16384
  %18 = inttoptr i32 %and.i76 to ptr
  %cpu50 = getelementptr inbounds %struct.thread_info, ptr %18, i32 0, i32 3
  %19 = ptrtoint ptr %cpu50 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %cpu50, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %21 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i77 = icmp ugt i32 %21, %20
  br i1 %cmp.not.i.i.i.i77, label %cpu_online.exit85, label %land.rhs.i.i.i.i79

land.rhs.i.i.i.i79:                               ; preds = %if.end48
  %.b37.i.i.i.i78 = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i78, label %cpu_online.exit85, label %if.then.i.i.i.i80, !prof !259

if.then.i.i.i.i80:                                ; preds = %land.rhs.i.i.i.i79
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpu_online.exit85

cpu_online.exit85:                                ; preds = %if.then.i.i.i.i80, %land.rhs.i.i.i.i79, %if.end48
  %div3.i.i.i81 = lshr i32 %20, 5
  %arrayidx.i.i.i82 = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i81
  %22 = ptrtoint ptr %arrayidx.i.i.i82 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %arrayidx.i.i.i82, align 4
  %and.i.i.i83 = and i32 %20, 31
  %24 = shl nuw i32 1, %and.i.i.i83
  %25 = and i32 %23, %24
  %tobool.i84.not = icmp eq i32 %25, 0
  br i1 %tobool.i84.not, label %if.end69, label %if.then52

if.then52:                                        ; preds = %cpu_online.exit85
  %26 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i = and i32 %26, -16384
  %27 = inttoptr i32 %and.i.i.i.i to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %27, i32 0, i32 1
  %28 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %add.i.i = add i32 %29, 1
  store volatile i32 %add.i.i, ptr %preempt_count.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !293
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_util_est_se_tp, i32 0, i32 7) to i32))
  %30 = load volatile ptr, ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_sched_util_est_se_tp, i32 0, i32 7), align 4
  %call58 = tail call i32 @rcu_read_lock_sched_held() #20
  %tobool59.not = icmp eq i32 %call58, 0
  br i1 %tobool59.not, label %land.lhs.true, label %do.end67

land.lhs.true:                                    ; preds = %if.then52
  %call60 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool61.not = icmp eq i32 %call60, 0
  br i1 %tobool61.not, label %do.end67, label %land.lhs.true62

land.lhs.true62:                                  ; preds = %land.lhs.true
  %.b72 = load i1, ptr @trace_sched_util_est_se_tp.__warned, align 1
  br i1 %.b72, label %do.end67, label %if.then64

if.then64:                                        ; preds = %land.lhs.true62
  store i1 true, ptr @trace_sched_util_est_se_tp.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.15, i32 noundef 729, ptr noundef nonnull @.str.16) #20
  br label %do.end67

do.end67:                                         ; preds = %if.then64, %land.lhs.true62, %land.lhs.true, %if.then52
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !294
  %31 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i86 = and i32 %31, -16384
  %32 = inttoptr i32 %and.i.i.i.i86 to ptr
  %preempt_count.i.i.i87 = getelementptr inbounds %struct.thread_info, ptr %32, i32 0, i32 1
  %33 = ptrtoint ptr %preempt_count.i.i.i87 to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load volatile i32, ptr %preempt_count.i.i.i87, align 4
  %sub.i.i = add i32 %34, -1
  store volatile i32 %sub.i.i, ptr %preempt_count.i.i.i87, align 4
  br label %if.end69

if.end69:                                         ; preds = %do.end67, %cpu_online.exit85, %cpu_online.exit
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__traceiter_sched_util_est_se_tp(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @find_energy_efficient_cpu(ptr noundef %p, i32 noundef %prev_cpu) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %ue.sroa.0.i.i239 = alloca i32, align 8
  %ue.sroa.5.i.i240 = alloca i32, align 4
  %ue.sroa.0.i.i = alloca i32, align 8
  %ue.sroa.5.i.i = alloca i32, align 4
  %0 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i226 = and i32 %0, -16384
  %1 = inttoptr i32 %and.i226 to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 3
  %2 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %3
  %4 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %arrayidx, align 4
  %add = add i32 %5, ptrtoint (ptr @runqueues to i32)
  %6 = inttoptr i32 %add to ptr
  %rd2 = getelementptr inbounds %struct.rq, ptr %6, i32 0, i32 35
  %7 = ptrtoint ptr %rd2 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %rd2, align 8
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %9 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %10, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !268
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #20
  %call.i = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 696, ptr noundef nonnull @.str.28) #20
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %entry
  %pd8 = getelementptr inbounds %struct.root_domain, ptr %8, i32 0, i32 21
  %11 = ptrtoint ptr %pd8 to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile ptr, ptr %pd8, align 8
  %call10 = tail call i32 @rcu_read_lock_held() #20
  %tobool.not = icmp eq i32 %call10, 0
  br i1 %tobool.not, label %land.lhs.true, label %do.end16

land.lhs.true:                                    ; preds = %rcu_read_lock.exit
  %call11 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %do.end16, label %land.lhs.true13

land.lhs.true13:                                  ; preds = %land.lhs.true
  %.b222 = load i1, ptr @find_energy_efficient_cpu.__warned, align 1
  br i1 %.b222, label %do.end16, label %if.then

if.then:                                          ; preds = %land.lhs.true13
  store i1 true, ptr @find_energy_efficient_cpu.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 6742, ptr noundef nonnull @.str.16) #20
  br label %do.end16

do.end16:                                         ; preds = %if.then, %land.lhs.true13, %land.lhs.true, %rcu_read_lock.exit
  %tobool18.not = icmp eq ptr %12, null
  br i1 %tobool18.not, label %unlock, label %do.end21

do.end21:                                         ; preds = %do.end16
  %overutilized = getelementptr inbounds %struct.root_domain, ptr %8, i32 0, i32 6
  %13 = ptrtoint ptr %overutilized to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %overutilized, align 4
  %tobool23.not = icmp eq i32 %14, 0
  br i1 %tobool23.not, label %if.end25, label %unlock

if.end25:                                         ; preds = %do.end21
  %15 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %cpu, align 4
  %arrayidx39 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %16
  %17 = ptrtoint ptr %arrayidx39 to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %arrayidx39, align 4
  %add40 = add i32 %18, ptrtoint (ptr @sd_asym_cpucapacity to i32)
  %19 = inttoptr i32 %add40 to ptr
  %20 = ptrtoint ptr %19 to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load volatile ptr, ptr %19, align 4
  %call42 = tail call i32 @rcu_read_lock_held() #20
  %tobool43.not = icmp eq i32 %call42, 0
  br i1 %tobool43.not, label %land.lhs.true44, label %do.end52

land.lhs.true44:                                  ; preds = %if.end25
  %call45 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool46.not = icmp eq i32 %call45, 0
  br i1 %tobool46.not, label %do.end52, label %land.lhs.true47

land.lhs.true47:                                  ; preds = %land.lhs.true44
  %.b218221 = load i1, ptr @find_energy_efficient_cpu.__warned.43, align 1
  br i1 %.b218221, label %do.end52, label %if.then49

if.then49:                                        ; preds = %land.lhs.true47
  store i1 true, ptr @find_energy_efficient_cpu.__warned.43, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 6750, ptr noundef nonnull @.str.16) #20
  br label %do.end52

do.end52:                                         ; preds = %if.then49, %land.lhs.true47, %land.lhs.true44, %if.end25
  %tobool54.not284 = icmp eq ptr %21, null
  br i1 %tobool54.not284, label %unlock, label %land.rhs.lr.ph

land.rhs.lr.ph:                                   ; preds = %do.end52
  %div3.i.i = lshr i32 %prev_cpu, 5
  %and.i.i = and i32 %prev_cpu, 31
  %22 = shl nuw i32 1, %and.i.i
  br label %land.rhs

land.rhs:                                         ; preds = %while.body, %land.rhs.lr.ph
  %sd.0285 = phi ptr [ %21, %land.rhs.lr.ph ], [ %28, %while.body ]
  %span.i = getelementptr inbounds %struct.sched_domain, ptr %sd.0285, i32 0, i32 41
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %23 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i = icmp ugt i32 %23, %prev_cpu
  br i1 %cmp.not.i.i.i, label %cpumask_test_cpu.exit, label %land.rhs.i.i.i

land.rhs.i.i.i:                                   ; preds = %land.rhs
  %.b37.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i, label %cpumask_test_cpu.exit, label %if.then.i.i.i, !prof !259

if.then.i.i.i:                                    ; preds = %land.rhs.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpumask_test_cpu.exit

cpumask_test_cpu.exit:                            ; preds = %if.then.i.i.i, %land.rhs.i.i.i, %land.rhs
  %arrayidx.i.i = getelementptr i32, ptr %span.i, i32 %div3.i.i
  %24 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load volatile i32, ptr %arrayidx.i.i, align 4
  %26 = and i32 %25, %22
  %tobool57.not = icmp eq i32 %26, 0
  br i1 %tobool57.not, label %while.body, label %if.end60.critedge

while.body:                                       ; preds = %cpumask_test_cpu.exit
  %27 = ptrtoint ptr %sd.0285 to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %sd.0285, align 8
  %tobool54.not = icmp eq ptr %28, null
  br i1 %tobool54.not, label %unlock, label %land.rhs

if.end60.critedge:                                ; preds = %cpumask_test_cpu.exit
  %cfs_rq.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %29 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %cfs_rq.i.i, align 16
  %load_last_update_time_copy.i.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 18
  %avg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 17
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.end60.critedge
  %31 = ptrtoint ptr %load_last_update_time_copy.i.i to i32
  call void @__asan_load8_noabort(i32 %31)
  %32 = load i64, ptr %load_last_update_time_copy.i.i, align 128
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !287
  %33 = ptrtoint ptr %avg.i.i to i32
  call void @__asan_load8_noabort(i32 %33)
  %34 = load i64, ptr %avg.i.i, align 128
  %cmp.not.i.i = icmp eq i64 %34, %32
  br i1 %cmp.not.i.i, label %sync_entity_load_avg.exit, label %do.body.i.i

sync_entity_load_avg.exit:                        ; preds = %do.body.i.i
  %se = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %call2.i = tail call i32 @__update_load_avg_blocked_se(i64 noundef %32, ptr noundef %se) #20
  %util_avg.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 7
  %35 = ptrtoint ptr %util_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load volatile i32, ptr %util_avg.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.0.i.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.5.i.i)
  %util_est.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9
  %37 = ptrtoint ptr %util_est.i.i to i32
  call void @__asan_load4_noabort(i32 %37)
  %ue.sroa.0.0.copyload.i.i = load volatile i32, ptr %util_est.i.i, align 16
  %38 = ptrtoint ptr %ue.sroa.0.i.i to i32
  call void @__asan_store4_noabort(i32 %38)
  store volatile i32 %ue.sroa.0.0.copyload.i.i, ptr %ue.sroa.0.i.i, align 8
  %ue.sroa.5.0.util_est.sroa_idx.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9, i32 1
  %39 = ptrtoint ptr %ue.sroa.5.0.util_est.sroa_idx.i.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %ue.sroa.5.0.copyload.i.i = load volatile i32, ptr %ue.sroa.5.0.util_est.sroa_idx.i.i, align 4
  %40 = ptrtoint ptr %ue.sroa.5.i.i to i32
  call void @__asan_store4_noabort(i32 %40)
  store volatile i32 %ue.sroa.5.0.copyload.i.i, ptr %ue.sroa.5.i.i, align 4
  %and.i.i227 = and i32 %ue.sroa.0.0.copyload.i.i, 2147483647
  %41 = tail call i32 @llvm.umax.i32(i32 %ue.sroa.5.0.copyload.i.i, i32 %and.i.i227) #20
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.0.i.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.5.i.i)
  %42 = tail call i32 @llvm.umax.i32(i32 %36, i32 %41) #20
  %tobool62.not = icmp eq i32 %42, 0
  br i1 %tobool62.not, label %unlock, label %for.cond66.preheader.lr.ph

for.cond66.preheader.lr.ph:                       ; preds = %sync_entity_load_avg.exit
  %cpus_ptr = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 33
  %stack.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 1
  %tobool4.not.i = icmp eq ptr %p, null
  br label %for.cond66.preheader

for.cond66.preheader:                             ; preds = %for.inc, %for.cond66.preheader.lr.ph
  %prev_delta.0313 = phi i32 [ -1, %for.cond66.preheader.lr.ph ], [ %prev_delta.2.ph, %for.inc ]
  %best_delta.0312 = phi i32 [ -1, %for.cond66.preheader.lr.ph ], [ %best_delta.3.ph, %for.inc ]
  %best_energy_cpu.0311 = phi i32 [ %prev_cpu, %for.cond66.preheader.lr.ph ], [ %best_energy_cpu.2.ph, %for.inc ]
  %base_energy.0310 = phi i32 [ 0, %for.cond66.preheader.lr.ph ], [ %base_energy.1.ph, %for.inc ]
  %pd.0305 = phi ptr [ %12, %for.cond66.preheader.lr.ph ], [ %101, %for.inc ]
  %43 = ptrtoint ptr %pd.0305 to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load ptr, ptr %pd.0305, align 4
  %cpus288295 = getelementptr inbounds %struct.em_perf_domain, ptr %44, i32 0, i32 3
  %call68289296 = tail call i32 @cpumask_next_and(i32 noundef -1, ptr noundef %cpus288295, ptr noundef %span.i) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %45 = load i32, ptr @nr_cpu_ids, align 4
  %cmp290297 = icmp ult i32 %call68289296, %45
  br i1 %cmp290297, label %cpumask_test_cpu.exit238.lr.ph, label %for.end

cpumask_test_cpu.exit238.lr.ph:                   ; preds = %if.end94, %for.cond66.preheader
  %call68289301 = phi i32 [ %call68289, %if.end94 ], [ %call68289296, %for.cond66.preheader ]
  %max_spare_cap_cpu.0.ph300 = phi i32 [ %max_spare_cap_cpu.1, %if.end94 ], [ -1, %for.cond66.preheader ]
  %compute_prev_delta.0.off0.ph299 = phi i1 [ %compute_prev_delta.1.off0, %if.end94 ], [ false, %for.cond66.preheader ]
  %max_spare_cap.0.ph298 = phi i32 [ %max_spare_cap.1, %if.end94 ], [ 0, %for.cond66.preheader ]
  br label %cpumask_test_cpu.exit238

cpumask_test_cpu.exit238:                         ; preds = %for.cond66.backedge, %cpumask_test_cpu.exit238.lr.ph
  %call68291 = phi i32 [ %call68289301, %cpumask_test_cpu.exit238.lr.ph ], [ %call68, %for.cond66.backedge ]
  %46 = ptrtoint ptr %cpus_ptr to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load ptr, ptr %cpus_ptr, align 4
  %div3.i.i233 = lshr i32 %call68291, 5
  %arrayidx.i.i234 = getelementptr i32, ptr %47, i32 %div3.i.i233
  %48 = ptrtoint ptr %arrayidx.i.i234 to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load volatile i32, ptr %arrayidx.i.i234, align 4
  %and.i.i235 = and i32 %call68291, 31
  %50 = shl nuw i32 1, %and.i.i235
  %51 = and i32 %49, %50
  %tobool71.not = icmp eq i32 %51, 0
  br i1 %tobool71.not, label %for.cond66.backedge, label %if.end73

for.cond66.backedge:                              ; preds = %uclamp_rq_util_with.exit, %cpumask_test_cpu.exit238
  %52 = ptrtoint ptr %pd.0305 to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load ptr, ptr %pd.0305, align 4
  %cpus = getelementptr inbounds %struct.em_perf_domain, ptr %53, i32 0, i32 3
  %call68 = tail call i32 @cpumask_next_and(i32 noundef %call68291, ptr noundef %cpus, ptr noundef %span.i) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %54 = load i32, ptr @nr_cpu_ids, align 4
  %cmp = icmp ult i32 %call68, %54
  br i1 %cmp, label %cpumask_test_cpu.exit238, label %for.end

if.end73:                                         ; preds = %cpumask_test_cpu.exit238
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call68291
  %55 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %56, ptrtoint (ptr @runqueues to i32)
  %57 = inttoptr i32 %add.i to ptr
  %util_avg.i = getelementptr inbounds %struct.rq, ptr %57, i32 0, i32 14, i32 17, i32 7
  %58 = ptrtoint ptr %util_avg.i to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load volatile i32, ptr %util_avg.i, align 8
  %60 = ptrtoint ptr %stack.i.i to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load ptr, ptr %stack.i.i, align 4
  %cpu.i.i = getelementptr inbounds %struct.thread_info, ptr %61, i32 0, i32 3
  %62 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load volatile i32, ptr %cpu.i.i, align 4
  %64 = load volatile i32, ptr %cpu.i.i, align 4
  %cmp14.not.i.not = icmp eq i32 %64, %call68291
  br i1 %cmp14.not.i.not, label %if.end20.i, label %if.then17.i

if.then17.i:                                      ; preds = %if.end73
  %65 = ptrtoint ptr %util_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %65)
  %66 = load volatile i32, ptr %util_avg.i.i, align 8
  %add19.i = add i32 %66, %59
  br label %if.end20.i

if.end20.i:                                       ; preds = %if.then17.i, %if.end73
  %util.0.i = phi i32 [ %add19.i, %if.then17.i ], [ %59, %if.end73 ]
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 20), i32 1), ptr blockaddress(@find_energy_efficient_cpu, %cpu_util_next.exit)) #20
          to label %do.end25.i [label %cpu_util_next.exit], !srcloc !261

do.end25.i:                                       ; preds = %if.end20.i
  %util_est28.i = getelementptr inbounds %struct.rq, ptr %57, i32 0, i32 14, i32 17, i32 9
  %67 = ptrtoint ptr %util_est28.i to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load volatile i32, ptr %util_est28.i, align 16
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.0.i.i239)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.5.i.i240)
  %69 = ptrtoint ptr %util_est.i.i to i32
  call void @__asan_load4_noabort(i32 %69)
  %ue.sroa.0.0.copyload.i.i242 = load volatile i32, ptr %util_est.i.i, align 16
  %70 = ptrtoint ptr %ue.sroa.0.i.i239 to i32
  call void @__asan_store4_noabort(i32 %70)
  store volatile i32 %ue.sroa.0.0.copyload.i.i242, ptr %ue.sroa.0.i.i239, align 8
  %71 = ptrtoint ptr %ue.sroa.5.0.util_est.sroa_idx.i.i to i32
  call void @__asan_load4_noabort(i32 %71)
  %ue.sroa.5.0.copyload.i.i244 = load volatile i32, ptr %ue.sroa.5.0.util_est.sroa_idx.i.i, align 4
  %72 = ptrtoint ptr %ue.sroa.5.i.i240 to i32
  call void @__asan_store4_noabort(i32 %72)
  store volatile i32 %ue.sroa.5.0.copyload.i.i244, ptr %ue.sroa.5.i.i240, align 4
  %and.i.i245 = and i32 %ue.sroa.0.0.copyload.i.i242, 2147483647
  %73 = tail call i32 @llvm.umax.i32(i32 %ue.sroa.5.0.copyload.i.i244, i32 %and.i.i245) #20
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.0.i.i239)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.5.i.i240)
  %add32.i = add i32 %73, %68
  %74 = tail call i32 @llvm.umax.i32(i32 %util.0.i, i32 %add32.i) #20
  br label %cpu_util_next.exit

cpu_util_next.exit:                               ; preds = %do.end25.i, %if.end20.i
  %util.1.i = phi i32 [ %74, %do.end25.i ], [ %util.0.i, %if.end20.i ]
  %75 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %75)
  %76 = load i32, ptr %arrayidx.i, align 4
  %add.i.i = add i32 %76, ptrtoint (ptr @runqueues to i32)
  %77 = inttoptr i32 %add.i.i to ptr
  %cpu_capacity_orig.i.i = getelementptr inbounds %struct.rq, ptr %77, i32 0, i32 38
  %78 = ptrtoint ptr %cpu_capacity_orig.i.i to i32
  call void @__asan_load4_noabort(i32 %78)
  %79 = load i32, ptr %cpu_capacity_orig.i.i, align 4
  %80 = tail call i32 @llvm.umin.i32(i32 %util.1.i, i32 %79) #20
  %cpu_capacity.i = getelementptr inbounds %struct.rq, ptr %77, i32 0, i32 37
  %81 = ptrtoint ptr %cpu_capacity.i to i32
  call void @__asan_load4_noabort(i32 %81)
  %82 = load i32, ptr %cpu_capacity.i, align 16
  callbr void asm sideeffect "1:\0A\09b ${1:l}\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @sched_uclamp_used, i32 1), ptr blockaddress(@find_energy_efficient_cpu, %uclamp_rq_util_with.exit)) #20
          to label %if.end.i [label %uclamp_rq_util_with.exit], !srcloc !312

if.end.i:                                         ; preds = %cpu_util_next.exit
  br i1 %tobool4.not.i, label %if.end11.i, label %if.then5.i

if.then5.i:                                       ; preds = %if.end.i
  %call6.i = tail call i32 @uclamp_eff_value(ptr noundef nonnull %p, i32 noundef 0) #20
  %call7.i = tail call i32 @uclamp_eff_value(ptr noundef nonnull %p, i32 noundef 1) #20
  %uclamp_flags.i = getelementptr inbounds %struct.rq, ptr %77, i32 0, i32 12
  %83 = ptrtoint ptr %uclamp_flags.i to i32
  call void @__asan_load4_noabort(i32 %83)
  %84 = load i32, ptr %uclamp_flags.i, align 16
  %and.i = and i32 %84, 1
  %tobool8.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool8.not.i, label %if.end11.i, label %out.i

if.end11.i:                                       ; preds = %if.then5.i, %if.end.i
  %max_util.0.i = phi i32 [ %call7.i, %if.then5.i ], [ 0, %if.end.i ]
  %min_util.0.i = phi i32 [ %call6.i, %if.then5.i ], [ 0, %if.end.i ]
  %uclamp.i = getelementptr inbounds %struct.rq, ptr %77, i32 0, i32 11
  %85 = ptrtoint ptr %uclamp.i to i32
  call void @__asan_load4_noabort(i32 %85)
  %86 = load volatile i32, ptr %uclamp.i, align 128
  %87 = tail call i32 @llvm.umax.i32(i32 %min_util.0.i, i32 %86) #20
  %arrayidx19.i = getelementptr %struct.rq, ptr %77, i32 0, i32 11, i32 1
  %88 = ptrtoint ptr %arrayidx19.i to i32
  call void @__asan_load4_noabort(i32 %88)
  %89 = load volatile i32, ptr %arrayidx19.i, align 8
  %90 = tail call i32 @llvm.umax.i32(i32 %max_util.0.i, i32 %89) #20
  br label %out.i

out.i:                                            ; preds = %if.end11.i, %if.then5.i
  %max_util.1.i = phi i32 [ %call7.i, %if.then5.i ], [ %90, %if.end11.i ]
  %min_util.1.i = phi i32 [ %call6.i, %if.then5.i ], [ %87, %if.end11.i ]
  %cmp27.not.i = icmp ult i32 %min_util.1.i, %max_util.1.i
  br i1 %cmp27.not.i, label %if.end35.i, label %uclamp_rq_util_with.exit, !prof !259

if.end35.i:                                       ; preds = %out.i
  %91 = tail call i32 @llvm.umax.i32(i32 %min_util.1.i, i32 %80) #20
  %92 = tail call i32 @llvm.umin.i32(i32 %91, i32 %max_util.1.i) #20
  br label %uclamp_rq_util_with.exit

uclamp_rq_util_with.exit:                         ; preds = %if.end35.i, %out.i, %cpu_util_next.exit
  %retval.0.i = phi i32 [ %92, %if.end35.i ], [ %min_util.1.i, %out.i ], [ %80, %cpu_util_next.exit ]
  %mul = mul i32 %retval.0.i, 1280
  %mul91 = shl i32 %82, 10
  %cmp92 = icmp ult i32 %mul, %mul91
  br i1 %cmp92, label %if.end94, label %for.cond66.backedge

if.end94:                                         ; preds = %uclamp_rq_util_with.exit
  %93 = tail call i32 @llvm.usub.sat.i32(i32 %82, i32 %80)
  %cmp95 = icmp eq i32 %call68291, %prev_cpu
  %cmp97 = icmp ugt i32 %93, %max_spare_cap.0.ph298
  %94 = tail call i32 @llvm.umax.i32(i32 %93, i32 %max_spare_cap.0.ph298)
  %spec.select223 = select i1 %cmp97, i32 %call68291, i32 %max_spare_cap_cpu.0.ph300
  %max_spare_cap.1 = select i1 %cmp95, i32 %max_spare_cap.0.ph298, i32 %94
  %compute_prev_delta.1.off0 = select i1 %cmp95, i1 true, i1 %compute_prev_delta.0.off0.ph299
  %max_spare_cap_cpu.1 = select i1 %cmp95, i32 %max_spare_cap_cpu.0.ph300, i32 %spec.select223
  %95 = ptrtoint ptr %pd.0305 to i32
  call void @__asan_load4_noabort(i32 %95)
  %96 = load ptr, ptr %pd.0305, align 4
  %cpus288 = getelementptr inbounds %struct.em_perf_domain, ptr %96, i32 0, i32 3
  %call68289 = tail call i32 @cpumask_next_and(i32 noundef %call68291, ptr noundef %cpus288, ptr noundef %span.i) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %97 = load i32, ptr @nr_cpu_ids, align 4
  %cmp290 = icmp ult i32 %call68289, %97
  br i1 %cmp290, label %cpumask_test_cpu.exit238.lr.ph, label %for.end

for.end:                                          ; preds = %if.end94, %for.cond66.backedge, %for.cond66.preheader
  %compute_prev_delta.0.off0.ph.lcssa = phi i1 [ false, %for.cond66.preheader ], [ %compute_prev_delta.0.off0.ph299, %for.cond66.backedge ], [ %compute_prev_delta.1.off0, %if.end94 ]
  %max_spare_cap_cpu.0.ph.lcssa = phi i32 [ -1, %for.cond66.preheader ], [ %max_spare_cap_cpu.0.ph300, %for.cond66.backedge ], [ %max_spare_cap_cpu.1, %if.end94 ]
  %cmp101 = icmp sgt i32 %max_spare_cap_cpu.0.ph.lcssa, -1
  %brmerge = select i1 %cmp101, i1 true, i1 %compute_prev_delta.0.off0.ph.lcssa
  br i1 %brmerge, label %if.end105, label %for.inc

if.end105:                                        ; preds = %for.end
  %call106 = tail call fastcc i32 @compute_energy(ptr noundef %p, i32 noundef -1, ptr noundef nonnull %pd.0305)
  %add107 = add i32 %call106, %base_energy.0310
  br i1 %compute_prev_delta.0.off0.ph.lcssa, label %if.then109, label %if.end121

if.then109:                                       ; preds = %if.end105
  %call110 = tail call fastcc i32 @compute_energy(ptr noundef %p, i32 noundef %prev_cpu, ptr noundef nonnull %pd.0305)
  %cmp111 = icmp ult i32 %call110, %call106
  br i1 %cmp111, label %unlock, label %if.end113

if.end113:                                        ; preds = %if.then109
  %sub114 = sub i32 %call110, %call106
  %98 = tail call i32 @llvm.umin.i32(i32 %best_delta.0312, i32 %sub114)
  br label %if.end121

if.end121:                                        ; preds = %if.end113, %if.end105
  %best_delta.1 = phi i32 [ %98, %if.end113 ], [ %best_delta.0312, %if.end105 ]
  %prev_delta.1 = phi i32 [ %sub114, %if.end113 ], [ %prev_delta.0313, %if.end105 ]
  br i1 %cmp101, label %if.then123, label %for.inc

if.then123:                                       ; preds = %if.end121
  %call124 = tail call fastcc i32 @compute_energy(ptr noundef %p, i32 noundef %max_spare_cap_cpu.0.ph.lcssa, ptr noundef nonnull %pd.0305)
  %cmp125 = icmp ult i32 %call124, %call106
  br i1 %cmp125, label %unlock, label %if.end127

if.end127:                                        ; preds = %if.then123
  %sub128 = sub i32 %call124, %call106
  %cmp129 = icmp ult i32 %sub128, %best_delta.1
  %spec.select224 = select i1 %cmp129, i32 %max_spare_cap_cpu.0.ph.lcssa, i32 %best_energy_cpu.0311
  %99 = tail call i32 @llvm.umin.i32(i32 %sub128, i32 %best_delta.1)
  br label %for.inc

for.inc:                                          ; preds = %if.end127, %if.end121, %for.end
  %base_energy.1.ph = phi i32 [ %add107, %if.end121 ], [ %add107, %if.end127 ], [ %base_energy.0310, %for.end ]
  %best_energy_cpu.2.ph = phi i32 [ %best_energy_cpu.0311, %if.end121 ], [ %spec.select224, %if.end127 ], [ %best_energy_cpu.0311, %for.end ]
  %best_delta.3.ph = phi i32 [ %best_delta.1, %if.end121 ], [ %99, %if.end127 ], [ %best_delta.0312, %for.end ]
  %prev_delta.2.ph = phi i32 [ %prev_delta.1, %if.end121 ], [ %prev_delta.1, %if.end127 ], [ %prev_delta.0313, %for.end ]
  %next = getelementptr inbounds %struct.perf_domain, ptr %pd.0305, i32 0, i32 1
  %100 = ptrtoint ptr %next to i32
  call void @__asan_load4_noabort(i32 %100)
  %101 = load ptr, ptr %next, align 4
  %tobool65.not = icmp eq ptr %101, null
  br i1 %tobool65.not, label %for.end138, label %for.cond66.preheader

for.end138:                                       ; preds = %for.inc
  %call.i248 = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i248, label %rcu_read_unlock.exit, label %land.lhs.true.i251

land.lhs.true.i251:                               ; preds = %for.end138
  %call1.i249 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i250 = icmp eq i32 %call1.i249, 0
  br i1 %tobool.not.i250, label %rcu_read_unlock.exit, label %land.lhs.true2.i253

land.lhs.true2.i253:                              ; preds = %land.lhs.true.i251
  %.b4.i252 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i252, label %rcu_read_unlock.exit, label %if.then.i254

if.then.i254:                                     ; preds = %land.lhs.true2.i253
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i254, %land.lhs.true2.i253, %land.lhs.true.i251, %for.end138
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %102 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i255 = and i32 %102, -16384
  %103 = inttoptr i32 %and.i.i.i.i.i255 to ptr
  %preempt_count.i.i.i.i256 = getelementptr inbounds %struct.thread_info, ptr %103, i32 0, i32 1
  %104 = ptrtoint ptr %preempt_count.i.i.i.i256 to i32
  call void @__asan_load4_noabort(i32 %104)
  %105 = load volatile i32, ptr %preempt_count.i.i.i.i256, align 4
  %sub.i.i.i = add i32 %105, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i256, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  %cmp139 = icmp eq i32 %prev_delta.2.ph, -1
  br i1 %cmp139, label %if.then144, label %lor.lhs.false140

lor.lhs.false140:                                 ; preds = %rcu_read_unlock.exit
  %sub141 = sub i32 %prev_delta.2.ph, %best_delta.3.ph
  %add142 = add i32 %prev_delta.2.ph, %base_energy.1.ph
  %shr = lshr i32 %add142, 4
  %cmp143 = icmp ugt i32 %sub141, %shr
  br i1 %cmp143, label %if.then144, label %cleanup146

if.then144:                                       ; preds = %lor.lhs.false140, %rcu_read_unlock.exit
  br label %cleanup146

unlock:                                           ; preds = %if.then123, %if.then109, %sync_entity_load_avg.exit, %while.body, %do.end52, %do.end21, %do.end16
  %target.1 = phi i32 [ -1, %do.end21 ], [ %prev_cpu, %sync_entity_load_avg.exit ], [ -1, %do.end16 ], [ -1, %do.end52 ], [ %prev_cpu, %if.then123 ], [ %prev_cpu, %if.then109 ], [ -1, %while.body ]
  %call.i257 = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i257, label %rcu_read_unlock.exit267, label %land.lhs.true.i260

land.lhs.true.i260:                               ; preds = %unlock
  %call1.i258 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i259 = icmp eq i32 %call1.i258, 0
  br i1 %tobool.not.i259, label %rcu_read_unlock.exit267, label %land.lhs.true2.i262

land.lhs.true2.i262:                              ; preds = %land.lhs.true.i260
  %.b4.i261 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i261, label %rcu_read_unlock.exit267, label %if.then.i263

if.then.i263:                                     ; preds = %land.lhs.true2.i262
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %rcu_read_unlock.exit267

rcu_read_unlock.exit267:                          ; preds = %if.then.i263, %land.lhs.true2.i262, %land.lhs.true.i260, %unlock
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %106 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i264 = and i32 %106, -16384
  %107 = inttoptr i32 %and.i.i.i.i.i264 to ptr
  %preempt_count.i.i.i.i265 = getelementptr inbounds %struct.thread_info, ptr %107, i32 0, i32 1
  %108 = ptrtoint ptr %preempt_count.i.i.i.i265 to i32
  call void @__asan_load4_noabort(i32 %108)
  %109 = load volatile i32, ptr %preempt_count.i.i.i.i265, align 4
  %sub.i.i.i266 = add i32 %109, -1
  store volatile i32 %sub.i.i.i266, ptr %preempt_count.i.i.i.i265, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  br label %cleanup146

cleanup146:                                       ; preds = %rcu_read_unlock.exit267, %if.then144, %lor.lhs.false140
  %retval.0 = phi i32 [ %target.1, %rcu_read_unlock.exit267 ], [ %best_energy_cpu.2.ph, %if.then144 ], [ %prev_cpu, %lor.lhs.false140 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @wake_affine(ptr nocapture noundef %sd, ptr nocapture noundef %p, i32 noundef %this_cpu, i32 noundef %prev_cpu, i32 noundef %sync) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %0 = load i32, ptr @nr_cpu_ids, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 17), i32 1), ptr blockaddress(@wake_affine, %if.end)) #20
          to label %if.then [label %if.end], !srcloc !261

if.then:                                          ; preds = %entry
  %call.i = tail call i32 @available_idle_cpu(i32 noundef %this_cpu) #20
  %tobool.not.i = icmp eq i32 %call.i, 0
  br i1 %tobool.not.i, label %if.end.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.then
  %call1.i = tail call zeroext i1 @cpus_share_cache(i32 noundef %this_cpu, i32 noundef %prev_cpu) #20
  br i1 %call1.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %land.lhs.true.i
  %call2.i = tail call i32 @available_idle_cpu(i32 noundef %prev_cpu) #20
  %tobool3.not.i = icmp eq i32 %call2.i, 0
  %this_cpu.prev_cpu.i = select i1 %tobool3.not.i, i32 %this_cpu, i32 %prev_cpu
  br label %if.end

if.end.i:                                         ; preds = %land.lhs.true.i, %if.then
  %tobool4.not.i = icmp eq i32 %sync, 0
  br i1 %tobool4.not.i, label %if.end8.i, label %do.body.i

do.body.i:                                        ; preds = %if.end.i
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %this_cpu
  %1 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %2, ptrtoint (ptr @runqueues to i32)
  %3 = inttoptr i32 %add.i to ptr
  %nr_running.i = getelementptr inbounds %struct.rq, ptr %3, i32 0, i32 1
  %4 = ptrtoint ptr %nr_running.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %nr_running.i, align 4
  %cmp.i = icmp eq i32 %5, 1
  br i1 %cmp.i, label %if.end, label %if.end8.i

if.end8.i:                                        ; preds = %do.body.i, %if.end.i
  %call9.i = tail call i32 @available_idle_cpu(i32 noundef %prev_cpu) #20
  %tobool10.not.i = icmp eq i32 %call9.i, 0
  br i1 %tobool10.not.i, label %if.end12.i, label %if.end

if.end12.i:                                       ; preds = %if.end8.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %6 = load i32, ptr @nr_cpu_ids, align 4
  br label %if.end

if.end:                                           ; preds = %if.end12.i, %if.end8.i, %do.body.i, %if.then.i, %entry
  %target.0 = phi i32 [ %this_cpu.prev_cpu.i, %if.then.i ], [ %6, %if.end12.i ], [ %this_cpu, %do.body.i ], [ %prev_cpu, %if.end8.i ], [ %0, %entry ]
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 18), i32 1), ptr blockaddress(@wake_affine, %do.body)) #20
          to label %land.lhs.true [label %do.body], !srcloc !261

land.lhs.true:                                    ; preds = %if.end
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %7 = load i32, ptr @nr_cpu_ids, align 4
  %cmp = icmp eq i32 %target.0, %7
  br i1 %cmp, label %if.then3, label %do.body

if.then3:                                         ; preds = %land.lhs.true
  %call4 = tail call fastcc i32 @wake_affine_weight(ptr noundef %sd, ptr noundef %p, i32 noundef %this_cpu, i32 noundef %prev_cpu, i32 noundef %sync)
  br label %do.body

do.body:                                          ; preds = %if.then3, %land.lhs.true, %if.end
  %target.1 = phi i32 [ %call4, %if.then3 ], [ %target.0, %land.lhs.true ], [ %target.0, %if.end ]
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@wake_affine, %if.then9)) #20
          to label %do.end [label %if.then9], !srcloc !261

if.then9:                                         ; preds = %do.body
  %nr_wakeups_affine_attempts = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 29, i32 25
  %8 = ptrtoint ptr %nr_wakeups_affine_attempts to i32
  call void @__asan_load8_noabort(i32 %8)
  %9 = load i64, ptr %nr_wakeups_affine_attempts, align 8
  %inc = add i64 %9, 1
  store i64 %inc, ptr %nr_wakeups_affine_attempts, align 8
  br label %do.end

do.end:                                           ; preds = %if.then9, %do.body
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %10 = load i32, ptr @nr_cpu_ids, align 4
  %cmp11 = icmp eq i32 %target.1, %10
  br i1 %cmp11, label %cleanup, label %do.body14

do.body14:                                        ; preds = %do.end
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@wake_affine, %if.then26)) #20
          to label %do.body31 [label %if.then26], !srcloc !261

if.then26:                                        ; preds = %do.body14
  %ttwu_move_affine = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 35
  %11 = ptrtoint ptr %ttwu_move_affine to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %ttwu_move_affine, align 8
  %inc27 = add i32 %12, 1
  store i32 %inc27, ptr %ttwu_move_affine, align 8
  br label %do.body31

do.body31:                                        ; preds = %if.then26, %do.body14
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_schedstats, ptr blockaddress(@wake_affine, %if.then43)) #20
          to label %cleanup [label %if.then43], !srcloc !261

if.then43:                                        ; preds = %do.body31
  %nr_wakeups_affine = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 29, i32 24
  %13 = ptrtoint ptr %nr_wakeups_affine to i32
  call void @__asan_load8_noabort(i32 %13)
  %14 = load i64, ptr %nr_wakeups_affine, align 64
  %inc45 = add i64 %14, 1
  store i64 %inc45, ptr %nr_wakeups_affine, align 64
  br label %cleanup

cleanup:                                          ; preds = %if.then43, %do.body31, %do.end
  %retval.0 = phi i32 [ %prev_cpu, %do.end ], [ %target.1, %if.then43 ], [ %target.1, %do.body31 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @find_idlest_cpu(ptr noundef %sd, ptr noundef %p, i32 noundef %cpu, i32 noundef %prev_cpu, i32 noundef %sd_flag) unnamed_addr #7 align 64 {
entry:
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %0 = load i32, ptr @nr_cpu_ids, align 4
  %cpus_ptr = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 33
  %1 = ptrtoint ptr %cpus_ptr to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %cpus_ptr, align 4
  %span.i = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 41
  %call.i.i = tail call i32 @__bitmap_intersects(ptr noundef %span.i, ptr noundef %2, i32 noundef %0) #20
  %tobool.i.not = icmp eq i32 %call.i.i, 0
  br i1 %tobool.i.not, label %cleanup51, label %if.end

if.end:                                           ; preds = %entry
  %and = and i32 %sd_flag, 4
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %cfs_rq.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %3 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %cfs_rq.i.i, align 16
  %load_last_update_time_copy.i.i = getelementptr inbounds %struct.cfs_rq, ptr %4, i32 0, i32 18
  %avg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %4, i32 0, i32 17
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then2
  %5 = ptrtoint ptr %load_last_update_time_copy.i.i to i32
  call void @__asan_load8_noabort(i32 %5)
  %6 = load i64, ptr %load_last_update_time_copy.i.i, align 128
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !287
  %7 = ptrtoint ptr %avg.i.i to i32
  call void @__asan_load8_noabort(i32 %7)
  %8 = load i64, ptr %avg.i.i, align 128
  %cmp.not.i.i = icmp eq i64 %8, %6
  br i1 %cmp.not.i.i, label %sync_entity_load_avg.exit, label %do.body.i.i

sync_entity_load_avg.exit:                        ; preds = %do.body.i.i
  %se = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %call2.i = tail call i32 @__update_load_avg_blocked_se(i64 noundef %6, ptr noundef %se) #20
  br label %if.end3

if.end3:                                          ; preds = %sync_entity_load_avg.exit, %if.end
  %tobool4.not80 = icmp eq ptr %sd, null
  br i1 %tobool4.not80, label %cleanup51, label %while.body

while.body:                                       ; preds = %cleanup, %if.end3
  %sd.addr.083 = phi ptr [ %sd.addr.3, %cleanup ], [ %sd, %if.end3 ]
  %cpu.addr.082 = phi i32 [ %cpu.addr.1, %cleanup ], [ %cpu, %if.end3 ]
  %new_cpu.081 = phi i32 [ %new_cpu.1, %cleanup ], [ %cpu, %if.end3 ]
  %flags = getelementptr inbounds %struct.sched_domain, ptr %sd.addr.083, i32 0, i32 9
  %9 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %flags, align 4
  %and5 = and i32 %10, %sd_flag
  %tobool6.not = icmp eq i32 %and5, 0
  br i1 %tobool6.not, label %cleanup.sink.split, label %if.end8

if.end8:                                          ; preds = %while.body
  %call9 = tail call fastcc ptr @find_idlest_group(ptr noundef nonnull %sd.addr.083, ptr noundef %p, i32 noundef %cpu.addr.082)
  %tobool10.not = icmp eq ptr %call9, null
  br i1 %tobool10.not, label %cleanup.sink.split, label %if.end13

if.end13:                                         ; preds = %if.end8
  %call14 = tail call fastcc i32 @find_idlest_group_cpu(ptr noundef nonnull %call9, ptr noundef %p, i32 noundef %cpu.addr.082)
  %cmp = icmp eq i32 %call14, %cpu.addr.082
  br i1 %cmp, label %cleanup.sink.split, label %if.end17

if.end17:                                         ; preds = %if.end13
  %span_weight = getelementptr inbounds %struct.sched_domain, ptr %sd.addr.083, i32 0, i32 40
  %11 = ptrtoint ptr %span_weight to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %span_weight, align 8
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call14
  %13 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %arrayidx, align 4
  %add = add i32 %14, ptrtoint (ptr @runqueues to i32)
  %15 = inttoptr i32 %add to ptr
  %sd24 = getelementptr inbounds %struct.rq, ptr %15, i32 0, i32 36
  %16 = ptrtoint ptr %sd24 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load volatile ptr, ptr %sd24, align 4
  %call.i = tail call i32 @lock_is_held_type(ptr noundef getelementptr inbounds (%struct.mutex, ptr @sched_domains_mutex, i32 0, i32 5), i32 noundef -1) #20
  %tobool27.not = icmp eq i32 %call.i, 0
  br i1 %tobool27.not, label %lor.lhs.false, label %do.end37

lor.lhs.false:                                    ; preds = %if.end17
  %call28 = tail call i32 @rcu_read_lock_held() #20
  %tobool29.not = icmp eq i32 %call28, 0
  br i1 %tobool29.not, label %land.lhs.true, label %do.end37

land.lhs.true:                                    ; preds = %lor.lhs.false
  %call30 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool31.not = icmp eq i32 %call30, 0
  br i1 %tobool31.not, label %do.end37, label %land.lhs.true32

land.lhs.true32:                                  ; preds = %land.lhs.true
  %.b75 = load i1, ptr @find_idlest_cpu.__warned, align 1
  br i1 %.b75, label %do.end37, label %if.then34

if.then34:                                        ; preds = %land.lhs.true32
  store i1 true, ptr @find_idlest_cpu.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 6115, ptr noundef nonnull @.str.16) #20
  br label %do.end37

do.end37:                                         ; preds = %if.then34, %land.lhs.true32, %land.lhs.true, %lor.lhs.false, %if.end17
  %tobool39.not76 = icmp eq ptr %17, null
  br i1 %tobool39.not76, label %cleanup51, label %for.body

for.body:                                         ; preds = %if.end43, %do.end37
  %sd.addr.178 = phi ptr [ %spec.select, %if.end43 ], [ null, %do.end37 ]
  %tmp.077 = phi ptr [ %23, %if.end43 ], [ %17, %do.end37 ]
  %span_weight40 = getelementptr inbounds %struct.sched_domain, ptr %tmp.077, i32 0, i32 40
  %18 = ptrtoint ptr %span_weight40 to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %span_weight40, align 8
  %cmp41.not = icmp ugt i32 %12, %19
  br i1 %cmp41.not, label %if.end43, label %cleanup

if.end43:                                         ; preds = %for.body
  %flags44 = getelementptr inbounds %struct.sched_domain, ptr %tmp.077, i32 0, i32 9
  %20 = ptrtoint ptr %flags44 to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %flags44, align 4
  %and45 = and i32 %21, %sd_flag
  %tobool46.not = icmp eq i32 %and45, 0
  %spec.select = select i1 %tobool46.not, ptr %sd.addr.178, ptr %tmp.077
  %22 = ptrtoint ptr %tmp.077 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %tmp.077, align 8
  %tobool39.not = icmp eq ptr %23, null
  br i1 %tobool39.not, label %cleanup, label %for.body

cleanup.sink.split:                               ; preds = %if.end13, %if.end8, %while.body
  %new_cpu.1.ph = phi i32 [ %new_cpu.081, %while.body ], [ %new_cpu.081, %if.end8 ], [ %cpu.addr.082, %if.end13 ]
  %child16 = getelementptr inbounds %struct.sched_domain, ptr %sd.addr.083, i32 0, i32 1
  %24 = ptrtoint ptr %child16 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %child16, align 4
  br label %cleanup

cleanup:                                          ; preds = %cleanup.sink.split, %if.end43, %for.body
  %new_cpu.1 = phi i32 [ %new_cpu.1.ph, %cleanup.sink.split ], [ %call14, %if.end43 ], [ %call14, %for.body ]
  %cpu.addr.1 = phi i32 [ %cpu.addr.082, %cleanup.sink.split ], [ %call14, %if.end43 ], [ %call14, %for.body ]
  %sd.addr.3 = phi ptr [ %25, %cleanup.sink.split ], [ %sd.addr.178, %for.body ], [ %spec.select, %if.end43 ]
  %tobool4.not = icmp eq ptr %sd.addr.3, null
  br i1 %tobool4.not, label %cleanup51, label %while.body

cleanup51:                                        ; preds = %cleanup, %do.end37, %if.end3, %entry
  %retval.0 = phi i32 [ %prev_cpu, %entry ], [ %cpu, %if.end3 ], [ %call14, %do.end37 ], [ %new_cpu.1, %cleanup ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @select_idle_sibling(ptr noundef %p, i32 noundef %prev, i32 noundef %target) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %ue.sroa.0.i.i.i.i = alloca i32, align 8
  %ue.sroa.5.i.i.i.i = alloca i32, align 4
  %ue.sroa.0.i.i.i = alloca i32, align 8
  %ue.sroa.5.i.i.i = alloca i32, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_asym_cpucapacity, ptr blockaddress(@select_idle_sibling, %if.then)) #20
          to label %do.body [label %if.then], !srcloc !261

if.then:                                          ; preds = %entry
  %cfs_rq.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %0 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %cfs_rq.i.i, align 16
  %load_last_update_time_copy.i.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 18
  %avg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 17
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %if.then
  %2 = ptrtoint ptr %load_last_update_time_copy.i.i to i32
  call void @__asan_load8_noabort(i32 %2)
  %3 = load i64, ptr %load_last_update_time_copy.i.i, align 128
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !287
  %4 = ptrtoint ptr %avg.i.i to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %avg.i.i, align 128
  %cmp.not.i.i = icmp eq i64 %5, %3
  br i1 %cmp.not.i.i, label %sync_entity_load_avg.exit, label %do.body.i.i

sync_entity_load_avg.exit:                        ; preds = %do.body.i.i
  %se = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  %call2.i = tail call i32 @__update_load_avg_blocked_se(i64 noundef %3, ptr noundef %se) #20
  %util_avg.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 7
  %6 = ptrtoint ptr %util_avg.i.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %util_avg.i.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.0.i.i.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.5.i.i.i)
  %util_est.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9
  %8 = ptrtoint ptr %util_est.i.i.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %ue.sroa.0.0.copyload.i.i.i = load volatile i32, ptr %util_est.i.i.i, align 16
  %9 = ptrtoint ptr %ue.sroa.0.i.i.i to i32
  call void @__asan_store4_noabort(i32 %9)
  store volatile i32 %ue.sroa.0.0.copyload.i.i.i, ptr %ue.sroa.0.i.i.i, align 8
  %ue.sroa.5.0.util_est.sroa_idx.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9, i32 1
  %10 = ptrtoint ptr %ue.sroa.5.0.util_est.sroa_idx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %ue.sroa.5.0.copyload.i.i.i = load volatile i32, ptr %ue.sroa.5.0.util_est.sroa_idx.i.i.i, align 4
  %11 = ptrtoint ptr %ue.sroa.5.i.i.i to i32
  call void @__asan_store4_noabort(i32 %11)
  store volatile i32 %ue.sroa.5.0.copyload.i.i.i, ptr %ue.sroa.5.i.i.i, align 4
  %and.i.i.i364 = and i32 %ue.sroa.0.0.copyload.i.i.i, 2147483647
  %12 = tail call i32 @llvm.umax.i32(i32 %ue.sroa.5.0.copyload.i.i.i, i32 %and.i.i.i364) #20
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.0.i.i.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.5.i.i.i)
  %13 = tail call i32 @llvm.umax.i32(i32 %7, i32 %12) #20
  %call1.i = tail call i32 @uclamp_eff_value(ptr noundef %p, i32 noundef 0) #20
  %14 = tail call i32 @llvm.umax.i32(i32 %13, i32 %call1.i) #20
  %call2.i365 = tail call i32 @uclamp_eff_value(ptr noundef %p, i32 noundef 1) #20
  %15 = tail call i32 @llvm.umin.i32(i32 %14, i32 %call2.i365) #20
  %phi.bo = mul i32 %15, 1280
  br label %do.body

do.body:                                          ; preds = %sync_entity_load_avg.exit, %entry
  %task_util.0 = phi i32 [ %phi.bo, %sync_entity_load_avg.exit ], [ -1280, %entry ]
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %16 = load i32, ptr @debug_locks, align 4
  %tobool4.not = icmp eq i32 %16, 0
  br i1 %tobool4.not, label %if.end102, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %17 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i = and i32 %17, -16384
  %18 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %18, i32 0, i32 1
  %19 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load volatile i32, ptr %preempt_count.i.i, align 4
  %add.i = add i32 %20, 1
  store volatile i32 %add.i, ptr %preempt_count.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !313
  %21 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %21, -16384
  %22 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %22, i32 0, i32 3
  %23 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %cpu, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %24
  %25 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %arrayidx, align 4
  %add = add i32 %26, ptrtoint (ptr @lockdep_recursion to i32)
  %27 = inttoptr i32 %add to ptr
  %28 = ptrtoint ptr %27 to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %27, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !314
  %30 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i349 = and i32 %30, -16384
  %31 = inttoptr i32 %and.i.i.i349 to ptr
  %preempt_count.i.i350 = getelementptr inbounds %struct.thread_info, ptr %31, i32 0, i32 1
  %32 = ptrtoint ptr %preempt_count.i.i350 to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load volatile i32, ptr %preempt_count.i.i350, align 4
  %sub.i = add i32 %33, -1
  store volatile i32 %sub.i, ptr %preempt_count.i.i350, align 4
  %tobool26.not = icmp eq i32 %29, 0
  br i1 %tobool26.not, label %land.rhs, label %if.end102

land.rhs:                                         ; preds = %land.lhs.true
  %34 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i351 = and i32 %34, -16384
  %35 = inttoptr i32 %and.i.i.i351 to ptr
  %preempt_count.i.i352 = getelementptr inbounds %struct.thread_info, ptr %35, i32 0, i32 1
  %36 = ptrtoint ptr %preempt_count.i.i352 to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load volatile i32, ptr %preempt_count.i.i352, align 4
  %add.i353 = add i32 %37, 1
  store volatile i32 %add.i353, ptr %preempt_count.i.i352, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !315
  %38 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load i32, ptr %cpu, align 4
  %arrayidx50 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %39
  %40 = ptrtoint ptr %arrayidx50 to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %arrayidx50, align 4
  %add51 = add i32 %41, ptrtoint (ptr @hardirqs_enabled to i32)
  %42 = inttoptr i32 %add51 to ptr
  %43 = ptrtoint ptr %42 to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load volatile i32, ptr %42, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !316
  %45 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i354 = and i32 %45, -16384
  %46 = inttoptr i32 %and.i.i.i354 to ptr
  %preempt_count.i.i355 = getelementptr inbounds %struct.thread_info, ptr %46, i32 0, i32 1
  %47 = ptrtoint ptr %preempt_count.i.i355 to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load volatile i32, ptr %preempt_count.i.i355, align 4
  %sub.i356 = add i32 %48, -1
  store volatile i32 %sub.i356, ptr %preempt_count.i.i355, align 4
  %tobool58.not = icmp eq i32 %44, 0
  br i1 %tobool58.not, label %if.end102, label %land.rhs65

land.rhs65:                                       ; preds = %land.rhs
  %.b345 = load i1, ptr @select_idle_sibling.__already_done, align 1
  br i1 %.b345, label %if.end102, label %if.then76, !prof !259

if.then76:                                        ; preds = %land.rhs65
  store i1 true, ptr @select_idle_sibling.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 6410, i32 noundef 9, ptr noundef null) #20
  br label %if.end102

if.end102:                                        ; preds = %if.then76, %land.rhs65, %land.rhs, %land.lhs.true, %do.body
  %call112 = tail call i32 @available_idle_cpu(i32 noundef %target) #20
  %tobool113.not = icmp eq i32 %call112, 0
  br i1 %tobool113.not, label %lor.lhs.false, label %land.lhs.true116

lor.lhs.false:                                    ; preds = %if.end102
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %target
  %49 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load i32, ptr %arrayidx.i, align 4
  %add.i366 = add i32 %50, ptrtoint (ptr @runqueues to i32)
  %51 = inttoptr i32 %add.i366 to ptr
  %nr_running.i.i = getelementptr inbounds %struct.rq, ptr %51, i32 0, i32 1
  %52 = ptrtoint ptr %nr_running.i.i to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load i32, ptr %nr_running.i.i, align 4
  %idle_h_nr_running.i.i = getelementptr inbounds %struct.rq, ptr %51, i32 0, i32 14, i32 4
  %54 = ptrtoint ptr %idle_h_nr_running.i.i to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load i32, ptr %idle_h_nr_running.i.i, align 4
  %cmp.i.i = icmp ne i32 %53, %55
  %tobool.i.i = icmp eq i32 %53, 0
  %tobool115.not = or i1 %tobool.i.i, %cmp.i.i
  br i1 %tobool115.not, label %if.end119, label %land.lhs.true116

land.lhs.true116:                                 ; preds = %lor.lhs.false, %if.end102
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_asym_cpucapacity, ptr blockaddress(@select_idle_sibling, %if.then.i)) #20
          to label %cleanup [label %if.then.i], !srcloc !261

if.then.i:                                        ; preds = %land.lhs.true116
  %arrayidx.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %target
  %56 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load i32, ptr %arrayidx.i.i, align 4
  %add.i.i = add i32 %57, ptrtoint (ptr @runqueues to i32)
  %58 = inttoptr i32 %add.i.i to ptr
  %cpu_capacity.i.i = getelementptr inbounds %struct.rq, ptr %58, i32 0, i32 37
  %59 = ptrtoint ptr %cpu_capacity.i.i to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load i32, ptr %cpu_capacity.i.i, align 16
  %mul4.i = shl i32 %60, 10
  %cmp.i = icmp ult i32 %task_util.0, %mul4.i
  br i1 %cmp.i, label %cleanup, label %if.end119

if.end119:                                        ; preds = %if.then.i, %lor.lhs.false
  %cmp.not = icmp eq i32 %prev, %target
  br i1 %cmp.not, label %if.end131, label %land.lhs.true120

land.lhs.true120:                                 ; preds = %if.end119
  %call121 = tail call zeroext i1 @cpus_share_cache(i32 noundef %prev, i32 noundef %target) #20
  br i1 %call121, label %land.lhs.true122, label %if.end131

land.lhs.true122:                                 ; preds = %land.lhs.true120
  %call123 = tail call i32 @available_idle_cpu(i32 noundef %prev) #20
  %tobool124.not = icmp eq i32 %call123, 0
  br i1 %tobool124.not, label %lor.lhs.false125, label %land.lhs.true128

lor.lhs.false125:                                 ; preds = %land.lhs.true122
  %arrayidx.i368 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %prev
  %61 = ptrtoint ptr %arrayidx.i368 to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load i32, ptr %arrayidx.i368, align 4
  %add.i369 = add i32 %62, ptrtoint (ptr @runqueues to i32)
  %63 = inttoptr i32 %add.i369 to ptr
  %nr_running.i.i370 = getelementptr inbounds %struct.rq, ptr %63, i32 0, i32 1
  %64 = ptrtoint ptr %nr_running.i.i370 to i32
  call void @__asan_load4_noabort(i32 %64)
  %65 = load i32, ptr %nr_running.i.i370, align 4
  %idle_h_nr_running.i.i371 = getelementptr inbounds %struct.rq, ptr %63, i32 0, i32 14, i32 4
  %66 = ptrtoint ptr %idle_h_nr_running.i.i371 to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load i32, ptr %idle_h_nr_running.i.i371, align 4
  %cmp.i.i372 = icmp ne i32 %65, %67
  %tobool.i.i373 = icmp eq i32 %65, 0
  %tobool127.not = or i1 %tobool.i.i373, %cmp.i.i372
  br i1 %tobool127.not, label %if.end131, label %land.lhs.true128

land.lhs.true128:                                 ; preds = %lor.lhs.false125, %land.lhs.true122
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_asym_cpucapacity, ptr blockaddress(@select_idle_sibling, %if.then.i381)) #20
          to label %cleanup [label %if.then.i381], !srcloc !261

if.then.i381:                                     ; preds = %land.lhs.true128
  %arrayidx.i.i376 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %prev
  %68 = ptrtoint ptr %arrayidx.i.i376 to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load i32, ptr %arrayidx.i.i376, align 4
  %add.i.i377 = add i32 %69, ptrtoint (ptr @runqueues to i32)
  %70 = inttoptr i32 %add.i.i377 to ptr
  %cpu_capacity.i.i378 = getelementptr inbounds %struct.rq, ptr %70, i32 0, i32 37
  %71 = ptrtoint ptr %cpu_capacity.i.i378 to i32
  call void @__asan_load4_noabort(i32 %71)
  %72 = load i32, ptr %cpu_capacity.i.i378, align 16
  %mul4.i379 = shl i32 %72, 10
  %cmp.i380 = icmp ult i32 %task_util.0, %mul4.i379
  br i1 %cmp.i380, label %cleanup, label %if.end131

if.end131:                                        ; preds = %if.then.i381, %lor.lhs.false125, %land.lhs.true120, %if.end119
  %73 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i384 = and i32 %73, -16384
  %74 = inttoptr i32 %and.i384 to ptr
  %task = getelementptr inbounds %struct.thread_info, ptr %74, i32 0, i32 2
  %75 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %75)
  %76 = load ptr, ptr %task, align 8
  %flags.i = getelementptr inbounds %struct.task_struct, ptr %76, i32 0, i32 3
  %77 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %77)
  %78 = load i32, ptr %flags.i, align 4
  %and.i385 = and i32 %78, 2097152
  %tobool.not.i = icmp eq i32 %and.i385, 0
  br i1 %tobool.not.i, label %if.end163, label %is_per_cpu_kthread.exit

is_per_cpu_kthread.exit:                          ; preds = %if.end131
  %nr_cpus_allowed.i = getelementptr inbounds %struct.task_struct, ptr %76, i32 0, i32 32
  %79 = ptrtoint ptr %nr_cpus_allowed.i to i32
  call void @__asan_load4_noabort(i32 %79)
  %80 = load i32, ptr %nr_cpus_allowed.i, align 8
  %cmp.not.i = icmp eq i32 %80, 1
  br i1 %cmp.not.i, label %land.lhs.true134, label %if.end163

land.lhs.true134:                                 ; preds = %is_per_cpu_kthread.exit
  %preempt_count.i = getelementptr inbounds %struct.thread_info, ptr %74, i32 0, i32 1
  %81 = ptrtoint ptr %preempt_count.i to i32
  call void @__asan_load4_noabort(i32 %81)
  %82 = load volatile i32, ptr %preempt_count.i, align 4
  %and = and i32 %82, 15728640
  %83 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i357 = and i32 %83, -16384
  %84 = inttoptr i32 %and.i.i357 to ptr
  %preempt_count.i358 = getelementptr inbounds %struct.thread_info, ptr %84, i32 0, i32 1
  %85 = ptrtoint ptr %preempt_count.i358 to i32
  call void @__asan_load4_noabort(i32 %85)
  %86 = load volatile i32, ptr %preempt_count.i358, align 4
  %and137 = and i32 %86, 983040
  %or = or i32 %and137, %and
  %87 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i359 = and i32 %87, -16384
  %88 = inttoptr i32 %and.i.i359 to ptr
  %preempt_count.i360 = getelementptr inbounds %struct.thread_info, ptr %88, i32 0, i32 1
  %89 = ptrtoint ptr %preempt_count.i360 to i32
  call void @__asan_load4_noabort(i32 %89)
  %90 = load volatile i32, ptr %preempt_count.i360, align 4
  %and140 = and i32 %90, 256
  %or141 = or i32 %or, %and140
  %tobool142.not = icmp eq i32 %or141, 0
  br i1 %tobool142.not, label %land.lhs.true143, label %if.end163

land.lhs.true143:                                 ; preds = %land.lhs.true134
  %cpu145 = getelementptr inbounds %struct.thread_info, ptr %74, i32 0, i32 3
  %91 = ptrtoint ptr %cpu145 to i32
  call void @__asan_load4_noabort(i32 %91)
  %92 = load i32, ptr %cpu145, align 4
  %cmp146 = icmp eq i32 %92, %prev
  br i1 %cmp146, label %do.body148, label %if.end163

do.body148:                                       ; preds = %land.lhs.true143
  %arrayidx157 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %prev
  %93 = ptrtoint ptr %arrayidx157 to i32
  call void @__asan_load4_noabort(i32 %93)
  %94 = load i32, ptr %arrayidx157, align 4
  %add158 = add i32 %94, ptrtoint (ptr @runqueues to i32)
  %95 = inttoptr i32 %add158 to ptr
  %nr_running = getelementptr inbounds %struct.rq, ptr %95, i32 0, i32 1
  %96 = ptrtoint ptr %nr_running to i32
  call void @__asan_load4_noabort(i32 %96)
  %97 = load i32, ptr %nr_running, align 4
  %cmp159 = icmp ult i32 %97, 2
  br i1 %cmp159, label %land.lhs.true160, label %if.end163

land.lhs.true160:                                 ; preds = %do.body148
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_asym_cpucapacity, ptr blockaddress(@select_idle_sibling, %if.then.i393)) #20
          to label %cleanup [label %if.then.i393], !srcloc !261

if.then.i393:                                     ; preds = %land.lhs.true160
  %98 = ptrtoint ptr %arrayidx157 to i32
  call void @__asan_load4_noabort(i32 %98)
  %99 = load i32, ptr %arrayidx157, align 4
  %add.i.i389 = add i32 %99, ptrtoint (ptr @runqueues to i32)
  %100 = inttoptr i32 %add.i.i389 to ptr
  %cpu_capacity.i.i390 = getelementptr inbounds %struct.rq, ptr %100, i32 0, i32 37
  %101 = ptrtoint ptr %cpu_capacity.i.i390 to i32
  call void @__asan_load4_noabort(i32 %101)
  %102 = load i32, ptr %cpu_capacity.i.i390, align 16
  %mul4.i391 = shl i32 %102, 10
  %cmp.i392 = icmp ult i32 %task_util.0, %mul4.i391
  br i1 %cmp.i392, label %cleanup, label %if.end163

if.end163:                                        ; preds = %if.then.i393, %do.body148, %land.lhs.true143, %land.lhs.true134, %is_per_cpu_kthread.exit, %if.end131
  %recent_used_cpu164 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 10
  %103 = ptrtoint ptr %recent_used_cpu164 to i32
  call void @__asan_load4_noabort(i32 %103)
  %104 = load i32, ptr %recent_used_cpu164, align 4
  store i32 %prev, ptr %recent_used_cpu164, align 4
  %cmp166.not = icmp eq i32 %104, %prev
  %cmp168.not = icmp eq i32 %104, %target
  %or.cond = or i1 %cmp166.not, %cmp168.not
  br i1 %or.cond, label %if.end184, label %land.lhs.true169

land.lhs.true169:                                 ; preds = %if.end163
  %call170 = tail call zeroext i1 @cpus_share_cache(i32 noundef %104, i32 noundef %target) #20
  br i1 %call170, label %land.lhs.true171, label %if.end184

land.lhs.true171:                                 ; preds = %land.lhs.true169
  %call172 = tail call i32 @available_idle_cpu(i32 noundef %104) #20
  %tobool173.not = icmp eq i32 %call172, 0
  br i1 %tobool173.not, label %lor.lhs.false174, label %land.lhs.true177

lor.lhs.false174:                                 ; preds = %land.lhs.true171
  %arrayidx.i396 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %104
  %105 = ptrtoint ptr %arrayidx.i396 to i32
  call void @__asan_load4_noabort(i32 %105)
  %106 = load i32, ptr %arrayidx.i396, align 4
  %add.i397 = add i32 %106, ptrtoint (ptr @runqueues to i32)
  %107 = inttoptr i32 %add.i397 to ptr
  %nr_running.i.i398 = getelementptr inbounds %struct.rq, ptr %107, i32 0, i32 1
  %108 = ptrtoint ptr %nr_running.i.i398 to i32
  call void @__asan_load4_noabort(i32 %108)
  %109 = load i32, ptr %nr_running.i.i398, align 4
  %idle_h_nr_running.i.i399 = getelementptr inbounds %struct.rq, ptr %107, i32 0, i32 14, i32 4
  %110 = ptrtoint ptr %idle_h_nr_running.i.i399 to i32
  call void @__asan_load4_noabort(i32 %110)
  %111 = load i32, ptr %idle_h_nr_running.i.i399, align 4
  %cmp.i.i400 = icmp ne i32 %109, %111
  %tobool.i.i401 = icmp eq i32 %109, 0
  %tobool176.not = or i1 %tobool.i.i401, %cmp.i.i400
  br i1 %tobool176.not, label %if.end184, label %land.lhs.true177

land.lhs.true177:                                 ; preds = %lor.lhs.false174, %land.lhs.true171
  %112 = ptrtoint ptr %recent_used_cpu164 to i32
  call void @__asan_load4_noabort(i32 %112)
  %113 = load i32, ptr %recent_used_cpu164, align 4
  %cpus_ptr = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 33
  %114 = ptrtoint ptr %cpus_ptr to i32
  call void @__asan_load4_noabort(i32 %114)
  %115 = load ptr, ptr %cpus_ptr, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %116 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i = icmp ugt i32 %116, %113
  br i1 %cmp.not.i.i.i, label %cpumask_test_cpu.exit, label %land.rhs.i.i.i

land.rhs.i.i.i:                                   ; preds = %land.lhs.true177
  %.b37.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i, label %cpumask_test_cpu.exit, label %if.then.i.i.i, !prof !259

if.then.i.i.i:                                    ; preds = %land.rhs.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpumask_test_cpu.exit

cpumask_test_cpu.exit:                            ; preds = %if.then.i.i.i, %land.rhs.i.i.i, %land.lhs.true177
  %div3.i.i = lshr i32 %113, 5
  %arrayidx.i.i403 = getelementptr i32, ptr %115, i32 %div3.i.i
  %117 = ptrtoint ptr %arrayidx.i.i403 to i32
  call void @__asan_load4_noabort(i32 %117)
  %118 = load volatile i32, ptr %arrayidx.i.i403, align 4
  %and.i.i404 = and i32 %113, 31
  %119 = shl nuw i32 1, %and.i.i404
  %120 = and i32 %118, %119
  %tobool180.not = icmp eq i32 %120, 0
  br i1 %tobool180.not, label %if.end184, label %land.lhs.true181

land.lhs.true181:                                 ; preds = %cpumask_test_cpu.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_asym_cpucapacity, ptr blockaddress(@select_idle_sibling, %if.then.i411)) #20
          to label %cleanup [label %if.then.i411], !srcloc !261

if.then.i411:                                     ; preds = %land.lhs.true181
  %arrayidx.i.i406 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %104
  %121 = ptrtoint ptr %arrayidx.i.i406 to i32
  call void @__asan_load4_noabort(i32 %121)
  %122 = load i32, ptr %arrayidx.i.i406, align 4
  %add.i.i407 = add i32 %122, ptrtoint (ptr @runqueues to i32)
  %123 = inttoptr i32 %add.i.i407 to ptr
  %cpu_capacity.i.i408 = getelementptr inbounds %struct.rq, ptr %123, i32 0, i32 37
  %124 = ptrtoint ptr %cpu_capacity.i.i408 to i32
  call void @__asan_load4_noabort(i32 %124)
  %125 = load i32, ptr %cpu_capacity.i.i408, align 16
  %mul4.i409 = shl i32 %125, 10
  %cmp.i410 = icmp ult i32 %task_util.0, %mul4.i409
  br i1 %cmp.i410, label %cleanup, label %if.end184

if.end184:                                        ; preds = %if.then.i411, %cpumask_test_cpu.exit, %lor.lhs.false174, %land.lhs.true169, %if.end163
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @sched_asym_cpucapacity, ptr blockaddress(@select_idle_sibling, %if.then196)) #20
          to label %if.end228 [label %if.then196], !srcloc !261

if.then196:                                       ; preds = %if.end184
  %arrayidx208 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %target
  %126 = ptrtoint ptr %arrayidx208 to i32
  call void @__asan_load4_noabort(i32 %126)
  %127 = load i32, ptr %arrayidx208, align 4
  %add209 = add i32 %127, ptrtoint (ptr @sd_asym_cpucapacity to i32)
  %128 = inttoptr i32 %add209 to ptr
  %129 = ptrtoint ptr %128 to i32
  call void @__asan_load4_noabort(i32 %129)
  %130 = load volatile ptr, ptr %128, align 4
  %call211 = tail call i32 @rcu_read_lock_held() #20
  %tobool212.not = icmp eq i32 %call211, 0
  br i1 %tobool212.not, label %land.lhs.true213, label %do.end221

land.lhs.true213:                                 ; preds = %if.then196
  %call214 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool215.not = icmp eq i32 %call214, 0
  br i1 %tobool215.not, label %do.end221, label %land.lhs.true216

land.lhs.true216:                                 ; preds = %land.lhs.true213
  %.b341344 = load i1, ptr @select_idle_sibling.__warned, align 1
  br i1 %.b341344, label %do.end221, label %if.then218

if.then218:                                       ; preds = %land.lhs.true216
  store i1 true, ptr @select_idle_sibling.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 6457, ptr noundef nonnull @.str.16) #20
  br label %do.end221

do.end221:                                        ; preds = %if.then218, %land.lhs.true216, %land.lhs.true213, %if.then196
  %tobool223.not = icmp eq ptr %130, null
  br i1 %tobool223.not, label %if.end228, label %if.then224

if.then224:                                       ; preds = %do.end221
  %131 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i = and i32 %131, -16384
  %132 = inttoptr i32 %and.i.i.i.i to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %132, i32 0, i32 1
  %133 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %133)
  %134 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %add.i.i414 = add i32 %134, 1
  store volatile i32 %add.i.i414, ptr %preempt_count.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !317
  %135 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i415 = and i32 %135, -16384
  %136 = inttoptr i32 %and.i.i415 to ptr
  %cpu13.i = getelementptr inbounds %struct.thread_info, ptr %136, i32 0, i32 3
  %137 = ptrtoint ptr %cpu13.i to i32
  call void @__asan_load4_noabort(i32 %137)
  %138 = load i32, ptr %cpu13.i, align 4
  %arrayidx.i416 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %138
  %139 = ptrtoint ptr %arrayidx.i416 to i32
  call void @__asan_load4_noabort(i32 %139)
  %140 = load i32, ptr %arrayidx.i416, align 4
  %add.i417 = add i32 %140, ptrtoint (ptr @select_idle_mask to i32)
  %141 = inttoptr i32 %add.i417 to ptr
  %142 = ptrtoint ptr %141 to i32
  call void @__asan_load4_noabort(i32 %142)
  %143 = load volatile ptr, ptr %141, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !318
  %144 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i55.i = and i32 %144, -16384
  %145 = inttoptr i32 %and.i.i.i55.i to ptr
  %preempt_count.i.i56.i = getelementptr inbounds %struct.thread_info, ptr %145, i32 0, i32 1
  %146 = ptrtoint ptr %preempt_count.i.i56.i to i32
  call void @__asan_load4_noabort(i32 %146)
  %147 = load volatile i32, ptr %preempt_count.i.i56.i, align 4
  %sub.i.i = add i32 %147, -1
  store volatile i32 %sub.i.i, ptr %preempt_count.i.i56.i, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %148 = load i32, ptr @nr_cpu_ids, align 4
  %cpus_ptr.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 33
  %149 = ptrtoint ptr %cpus_ptr.i to i32
  call void @__asan_load4_noabort(i32 %149)
  %150 = load ptr, ptr %cpus_ptr.i, align 4
  %span.i.i = getelementptr inbounds %struct.sched_domain, ptr %130, i32 0, i32 41
  %call.i.i.i = tail call i32 @__bitmap_and(ptr noundef %143, ptr noundef %span.i.i, ptr noundef %150, i32 noundef %148) #20
  %util_avg.i.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 7
  %151 = ptrtoint ptr %util_avg.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %151)
  %152 = load volatile i32, ptr %util_avg.i.i.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.0.i.i.i.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.5.i.i.i.i)
  %util_est.i.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9
  %153 = ptrtoint ptr %util_est.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %153)
  %ue.sroa.0.0.copyload.i.i.i.i = load volatile i32, ptr %util_est.i.i.i.i, align 16
  %154 = ptrtoint ptr %ue.sroa.0.i.i.i.i to i32
  call void @__asan_store4_noabort(i32 %154)
  store volatile i32 %ue.sroa.0.0.copyload.i.i.i.i, ptr %ue.sroa.0.i.i.i.i, align 8
  %ue.sroa.5.0.util_est.sroa_idx.i.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9, i32 1
  %155 = ptrtoint ptr %ue.sroa.5.0.util_est.sroa_idx.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %155)
  %ue.sroa.5.0.copyload.i.i.i.i = load volatile i32, ptr %ue.sroa.5.0.util_est.sroa_idx.i.i.i.i, align 4
  %156 = ptrtoint ptr %ue.sroa.5.i.i.i.i to i32
  call void @__asan_store4_noabort(i32 %156)
  store volatile i32 %ue.sroa.5.0.copyload.i.i.i.i, ptr %ue.sroa.5.i.i.i.i, align 4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.0.i.i.i.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.5.i.i.i.i)
  %call1.i.i = tail call i32 @uclamp_eff_value(ptr noundef %p, i32 noundef 0) #20
  %call2.i.i = tail call i32 @uclamp_eff_value(ptr noundef %p, i32 noundef 1) #20
  %sub.i420 = add i32 %target, -1
  %call23.i = tail call i32 @cpumask_next_wrap(i32 noundef %sub.i420, ptr noundef %143, i32 noundef %target, i1 noundef zeroext false) #20
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %157 = load i32, ptr @nr_cpu_ids, align 4
  %cmp68.i = icmp ult i32 %call23.i, %157
  br i1 %cmp68.i, label %for.body.lr.ph.i, label %cleanup.sink.split

for.body.lr.ph.i:                                 ; preds = %if.then224
  %and.i.i.i57.i = and i32 %ue.sroa.0.0.copyload.i.i.i.i, 2147483647
  %158 = tail call i32 @llvm.umax.i32(i32 %ue.sroa.5.0.copyload.i.i.i.i, i32 %and.i.i.i57.i) #20
  %159 = tail call i32 @llvm.umax.i32(i32 %152, i32 %158) #20
  %160 = tail call i32 @llvm.umax.i32(i32 %159, i32 %call1.i.i) #20
  %161 = tail call i32 @llvm.umin.i32(i32 %160, i32 %call2.i.i) #20
  %mul.i421 = mul i32 %161, 1280
  br label %for.body.i

for.body.i:                                       ; preds = %for.inc.i, %for.body.lr.ph.i
  %best_cap.073.i = phi i32 [ 0, %for.body.lr.ph.i ], [ %best_cap.2.ph.i, %for.inc.i ]
  %cpu.071.i = phi i32 [ %call23.i, %for.body.lr.ph.i ], [ %call35.i, %for.inc.i ]
  %best_cpu.069.i = phi i32 [ -1, %for.body.lr.ph.i ], [ %best_cpu.2.ph.i, %for.inc.i ]
  %arrayidx.i.i422 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %cpu.071.i
  %162 = ptrtoint ptr %arrayidx.i.i422 to i32
  call void @__asan_load4_noabort(i32 %162)
  %163 = load i32, ptr %arrayidx.i.i422, align 4
  %add.i58.i = add i32 %163, ptrtoint (ptr @runqueues to i32)
  %164 = inttoptr i32 %add.i58.i to ptr
  %cpu_capacity.i.i423 = getelementptr inbounds %struct.rq, ptr %164, i32 0, i32 37
  %165 = ptrtoint ptr %cpu_capacity.i.i423 to i32
  call void @__asan_load4_noabort(i32 %165)
  %166 = load i32, ptr %cpu_capacity.i.i423, align 16
  %call25.i = tail call i32 @available_idle_cpu(i32 noundef %cpu.071.i) #20
  %tobool.not.i424 = icmp eq i32 %call25.i, 0
  br i1 %tobool.not.i424, label %land.lhs.true.i, label %if.end.i425

land.lhs.true.i:                                  ; preds = %for.body.i
  %167 = ptrtoint ptr %arrayidx.i.i422 to i32
  call void @__asan_load4_noabort(i32 %167)
  %168 = load i32, ptr %arrayidx.i.i422, align 4
  %add.i60.i = add i32 %168, ptrtoint (ptr @runqueues to i32)
  %169 = inttoptr i32 %add.i60.i to ptr
  %nr_running.i.i.i = getelementptr inbounds %struct.rq, ptr %169, i32 0, i32 1
  %170 = ptrtoint ptr %nr_running.i.i.i to i32
  call void @__asan_load4_noabort(i32 %170)
  %171 = load i32, ptr %nr_running.i.i.i, align 4
  %idle_h_nr_running.i.i.i = getelementptr inbounds %struct.rq, ptr %169, i32 0, i32 14, i32 4
  %172 = ptrtoint ptr %idle_h_nr_running.i.i.i to i32
  call void @__asan_load4_noabort(i32 %172)
  %173 = load i32, ptr %idle_h_nr_running.i.i.i, align 4
  %cmp.i.i.i = icmp ne i32 %171, %173
  %tobool.i.i.i = icmp eq i32 %171, 0
  %tobool27.not.i = or i1 %tobool.i.i.i, %cmp.i.i.i
  br i1 %tobool27.not.i, label %for.inc.i, label %if.end.i425

if.end.i425:                                      ; preds = %land.lhs.true.i, %for.body.i
  %mul28.i = shl i32 %166, 10
  %cmp29.i = icmp ult i32 %mul.i421, %mul28.i
  br i1 %cmp29.i, label %cleanup.sink.split, label %if.end31.i

if.end31.i:                                       ; preds = %if.end.i425
  %cmp32.i = icmp ugt i32 %166, %best_cap.073.i
  %spec.select.i = select i1 %cmp32.i, i32 %cpu.071.i, i32 %best_cpu.069.i
  %174 = tail call i32 @llvm.umax.i32(i32 %166, i32 %best_cap.073.i) #20
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.end31.i, %land.lhs.true.i
  %best_cpu.2.ph.i = phi i32 [ %best_cpu.069.i, %land.lhs.true.i ], [ %spec.select.i, %if.end31.i ]
  %best_cap.2.ph.i = phi i32 [ %best_cap.073.i, %land.lhs.true.i ], [ %174, %if.end31.i ]
  %call35.i = tail call i32 @cpumask_next_wrap(i32 noundef %cpu.071.i, ptr noundef %143, i32 noundef %target, i1 noundef zeroext true) #20
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %175 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.i426 = icmp ult i32 %call35.i, %175
  br i1 %cmp.i426, label %for.body.i, label %cleanup.sink.split

if.end228:                                        ; preds = %do.end221, %if.end184
  %arrayidx240 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %target
  %176 = ptrtoint ptr %arrayidx240 to i32
  call void @__asan_load4_noabort(i32 %176)
  %177 = load i32, ptr %arrayidx240, align 4
  %add241 = add i32 %177, ptrtoint (ptr @sd_llc to i32)
  %178 = inttoptr i32 %add241 to ptr
  %179 = ptrtoint ptr %178 to i32
  call void @__asan_load4_noabort(i32 %179)
  %180 = load volatile ptr, ptr %178, align 4
  %call243 = tail call i32 @rcu_read_lock_held() #20
  %tobool244.not = icmp eq i32 %call243, 0
  br i1 %tobool244.not, label %land.lhs.true245, label %do.end253

land.lhs.true245:                                 ; preds = %if.end228
  %call246 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool247.not = icmp eq i32 %call246, 0
  br i1 %tobool247.not, label %do.end253, label %land.lhs.true248

land.lhs.true248:                                 ; preds = %land.lhs.true245
  %.b342343 = load i1, ptr @select_idle_sibling.__warned.46, align 1
  br i1 %.b342343, label %do.end253, label %if.then250

if.then250:                                       ; preds = %land.lhs.true248
  store i1 true, ptr @select_idle_sibling.__warned.46, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 6472, ptr noundef nonnull @.str.16) #20
  br label %do.end253

do.end253:                                        ; preds = %if.then250, %land.lhs.true248, %land.lhs.true245, %if.end228
  %tobool255.not = icmp eq ptr %180, null
  br i1 %tobool255.not, label %cleanup, label %if.end257

if.end257:                                        ; preds = %do.end253
  callbr void asm sideeffect "1:\0A\09b ${1:l}\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @sched_smt_present, i32 1), ptr blockaddress(@select_idle_sibling, %if.end271)) #20
          to label %if.then259 [label %if.end271], !srcloc !312

if.then259:                                       ; preds = %if.end257
  %181 = ptrtoint ptr %arrayidx240 to i32
  call void @__asan_load4_noabort(i32 %181)
  %182 = load i32, ptr %arrayidx240, align 4
  %add.i428 = add i32 %182, ptrtoint (ptr @sd_llc_shared to i32)
  %183 = inttoptr i32 %add.i428 to ptr
  %184 = ptrtoint ptr %183 to i32
  call void @__asan_load4_noabort(i32 %184)
  %185 = load volatile ptr, ptr %183, align 4
  %call.i = tail call i32 @rcu_read_lock_held() #20
  %tobool.not.i429 = icmp eq i32 %call.i, 0
  br i1 %tobool.not.i429, label %land.lhs.true.i430, label %do.end12.i

land.lhs.true.i430:                               ; preds = %if.then259
  %call7.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool8.not.i = icmp eq i32 %call7.i, 0
  br i1 %tobool8.not.i, label %do.end12.i, label %land.lhs.true9.i

land.lhs.true9.i:                                 ; preds = %land.lhs.true.i430
  %.b24.i = load i1, ptr @test_idle_cores.__warned, align 1
  br i1 %.b24.i, label %do.end12.i, label %if.then.i431

if.then.i431:                                     ; preds = %land.lhs.true9.i
  store i1 true, ptr @test_idle_cores.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 6152, ptr noundef nonnull @.str.16) #20
  br label %do.end12.i

do.end12.i:                                       ; preds = %if.then.i431, %land.lhs.true9.i, %land.lhs.true.i430, %if.then259
  %tobool14.not.i = icmp eq ptr %185, null
  br i1 %tobool14.not.i, label %land.lhs.true263, label %test_idle_cores.exit

test_idle_cores.exit:                             ; preds = %do.end12.i
  %has_idle_cores.i = getelementptr inbounds %struct.sched_domain_shared, ptr %185, i32 0, i32 2
  %186 = ptrtoint ptr %has_idle_cores.i to i32
  call void @__asan_load4_noabort(i32 %186)
  %187 = load volatile i32, ptr %has_idle_cores.i, align 4
  %tobool20.i.not = icmp eq i32 %187, 0
  br i1 %tobool20.i.not, label %land.lhs.true263, label %if.end271

land.lhs.true263:                                 ; preds = %test_idle_cores.exit, %do.end12.i
  %call264 = tail call zeroext i1 @cpus_share_cache(i32 noundef %prev, i32 noundef %target) #20
  br i1 %call264, label %if.then265, label %if.end271

if.then265:                                       ; preds = %land.lhs.true263
  %thread_sibling.i.i = getelementptr [4 x %struct.cpu_topology], ptr @cpu_topology, i32 0, i32 %prev, i32 5
  %call129.i = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef %thread_sibling.i.i) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %188 = load i32, ptr @nr_cpu_ids, align 4
  %cmp30.i = icmp ult i32 %call129.i, %188
  br i1 %cmp30.i, label %cpumask_test_cpu.exit.lr.ph.i, label %if.end271

cpumask_test_cpu.exit.lr.ph.i:                    ; preds = %if.then265
  %cpus_ptr.i433 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 33
  %span.i.i434 = getelementptr inbounds %struct.sched_domain, ptr %180, i32 0, i32 41
  br label %cpumask_test_cpu.exit.i

cpumask_test_cpu.exit.i:                          ; preds = %for.cond.backedge.i, %cpumask_test_cpu.exit.lr.ph.i
  %call131.i = phi i32 [ %call129.i, %cpumask_test_cpu.exit.lr.ph.i ], [ %call1.i437, %for.cond.backedge.i ]
  %189 = ptrtoint ptr %cpus_ptr.i433 to i32
  call void @__asan_load4_noabort(i32 %189)
  %190 = load ptr, ptr %cpus_ptr.i433, align 4
  %div3.i.i.i = lshr i32 %call131.i, 5
  %arrayidx.i.i.i = getelementptr i32, ptr %190, i32 %div3.i.i.i
  %191 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %191)
  %192 = load volatile i32, ptr %arrayidx.i.i.i, align 4
  %and.i.i.i435 = and i32 %call131.i, 31
  %193 = shl nuw i32 1, %and.i.i.i435
  %194 = and i32 %192, %193
  %tobool.not.i436 = icmp eq i32 %194, 0
  br i1 %tobool.not.i436, label %for.cond.backedge.i, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %cpumask_test_cpu.exit.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %195 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i19.i = icmp ugt i32 %195, %call131.i
  br i1 %cmp.not.i.i.i19.i, label %cpumask_test_cpu.exit28.i, label %land.rhs.i.i.i21.i

land.rhs.i.i.i21.i:                               ; preds = %lor.lhs.false.i
  %.b37.i.i.i20.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i20.i, label %cpumask_test_cpu.exit28.i, label %if.then.i.i.i22.i, !prof !259

if.then.i.i.i22.i:                                ; preds = %land.rhs.i.i.i21.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpumask_test_cpu.exit28.i

cpumask_test_cpu.exit28.i:                        ; preds = %if.then.i.i.i22.i, %land.rhs.i.i.i21.i, %lor.lhs.false.i
  %arrayidx.i.i24.i = getelementptr i32, ptr %span.i.i434, i32 %div3.i.i.i
  %196 = ptrtoint ptr %arrayidx.i.i24.i to i32
  call void @__asan_load4_noabort(i32 %196)
  %197 = load volatile i32, ptr %arrayidx.i.i24.i, align 4
  %198 = and i32 %197, %193
  %tobool5.not.i = icmp eq i32 %198, 0
  br i1 %tobool5.not.i, label %for.cond.backedge.i, label %if.end.i439

for.cond.backedge.i:                              ; preds = %lor.lhs.false8.i, %cpumask_test_cpu.exit28.i, %cpumask_test_cpu.exit.i
  %call1.i437 = tail call i32 @cpumask_next(i32 noundef %call131.i, ptr noundef %thread_sibling.i.i) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %199 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.i438 = icmp ult i32 %call1.i437, %199
  br i1 %cmp.i438, label %cpumask_test_cpu.exit.i, label %if.end271

if.end.i439:                                      ; preds = %cpumask_test_cpu.exit28.i
  %call6.i = tail call i32 @available_idle_cpu(i32 noundef %call131.i) #20
  %tobool7.not.i = icmp eq i32 %call6.i, 0
  br i1 %tobool7.not.i, label %lor.lhs.false8.i, label %select_idle_smt.exit

lor.lhs.false8.i:                                 ; preds = %if.end.i439
  %arrayidx.i.i440 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call131.i
  %200 = ptrtoint ptr %arrayidx.i.i440 to i32
  call void @__asan_load4_noabort(i32 %200)
  %201 = load i32, ptr %arrayidx.i.i440, align 4
  %add.i.i441 = add i32 %201, ptrtoint (ptr @runqueues to i32)
  %202 = inttoptr i32 %add.i.i441 to ptr
  %nr_running.i.i.i442 = getelementptr inbounds %struct.rq, ptr %202, i32 0, i32 1
  %203 = ptrtoint ptr %nr_running.i.i.i442 to i32
  call void @__asan_load4_noabort(i32 %203)
  %204 = load i32, ptr %nr_running.i.i.i442, align 4
  %idle_h_nr_running.i.i.i443 = getelementptr inbounds %struct.rq, ptr %202, i32 0, i32 14, i32 4
  %205 = ptrtoint ptr %idle_h_nr_running.i.i.i443 to i32
  call void @__asan_load4_noabort(i32 %205)
  %206 = load i32, ptr %idle_h_nr_running.i.i.i443, align 4
  %cmp.i.i.i444 = icmp ne i32 %204, %206
  %tobool.i.i.i445 = icmp eq i32 %204, 0
  %tobool10.not.i = or i1 %tobool.i.i.i445, %cmp.i.i.i444
  br i1 %tobool10.not.i, label %for.cond.backedge.i, label %select_idle_smt.exit

select_idle_smt.exit:                             ; preds = %lor.lhs.false8.i, %if.end.i439
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %207 = load i32, ptr @nr_cpu_ids, align 4
  %cmp267 = icmp ult i32 %call131.i, %207
  br i1 %cmp267, label %cleanup, label %if.end271

if.end271:                                        ; preds = %select_idle_smt.exit, %for.cond.backedge.i, %if.then265, %land.lhs.true263, %test_idle_cores.exit, %if.end257
  %has_idle_core.0.shrunk = phi i1 [ true, %test_idle_cores.exit ], [ false, %select_idle_smt.exit ], [ false, %land.lhs.true263 ], [ false, %if.end257 ], [ false, %if.then265 ], [ false, %for.cond.backedge.i ]
  %call273 = tail call fastcc i32 @select_idle_cpu(ptr noundef %p, ptr noundef nonnull %180, i1 noundef zeroext %has_idle_core.0.shrunk, i32 noundef %target)
  br label %cleanup.sink.split

cleanup.sink.split:                               ; preds = %if.end271, %for.inc.i, %if.end.i425, %if.then224
  %call273.sink458 = phi i32 [ %call273, %if.end271 ], [ -1, %if.then224 ], [ %best_cpu.2.ph.i, %for.inc.i ], [ %cpu.071.i, %if.end.i425 ]
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %208 = load i32, ptr @nr_cpu_ids, align 4
  %cmp274 = icmp ult i32 %call273.sink458, %208
  %call273.target = select i1 %cmp274, i32 %call273.sink458, i32 %target
  br label %cleanup

cleanup:                                          ; preds = %cleanup.sink.split, %select_idle_smt.exit, %do.end253, %if.then.i411, %land.lhs.true181, %if.then.i393, %land.lhs.true160, %if.then.i381, %land.lhs.true128, %if.then.i, %land.lhs.true116
  %retval.0 = phi i32 [ %target, %do.end253 ], [ %call131.i, %select_idle_smt.exit ], [ %target, %if.then.i ], [ %target, %land.lhs.true116 ], [ %prev, %if.then.i381 ], [ %prev, %land.lhs.true128 ], [ %prev, %if.then.i393 ], [ %prev, %land.lhs.true160 ], [ %104, %if.then.i411 ], [ %104, %land.lhs.true181 ], [ %call273.target, %cleanup.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @compute_energy(ptr noundef %p, i32 noundef %dst_cpu, ptr nocapture noundef readonly %pd) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %ue.sroa.0.i.i95 = alloca i32, align 8
  %ue.sroa.5.i.i96 = alloca i32, align 4
  %ue.sroa.0.i.i60 = alloca i32, align 8
  %ue.sroa.5.i.i61 = alloca i32, align 4
  %ue.sroa.0.i.i = alloca i32, align 8
  %ue.sroa.5.i.i = alloca i32, align 4
  %0 = ptrtoint ptr %pd to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %pd, align 4
  %cpus = getelementptr inbounds %struct.em_perf_domain, ptr %1, i32 0, i32 3
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %2 = load i32, ptr @nr_cpu_ids, align 4
  %call.i = tail call i32 @_find_first_bit_be(ptr noundef %cpus, i32 noundef %2) #20
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call.i
  %3 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %4, ptrtoint (ptr @cpu_scale to i32)
  %5 = inttoptr i32 %add.i to ptr
  %6 = ptrtoint ptr %5 to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %5, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %8 = load i32, ptr @nr_cpu_ids, align 4
  %call.i55 = tail call i32 @_find_first_bit_be(ptr noundef %cpus, i32 noundef %8) #20
  %arrayidx.i56 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call.i55
  %9 = ptrtoint ptr %arrayidx.i56 to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %arrayidx.i56, align 4
  %add.i57 = add i32 %10, ptrtoint (ptr @thermal_pressure to i32)
  %11 = inttoptr i32 %add.i57 to ptr
  %12 = ptrtoint ptr %11 to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %11, align 4
  %sub = sub i32 %7, %13
  %call4106 = tail call i32 @cpumask_next_and(i32 noundef -1, ptr noundef %cpus, ptr noundef nonnull @__cpu_online_mask) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %14 = load i32, ptr @nr_cpu_ids, align 4
  %cmp107 = icmp ult i32 %call4106, %14
  br i1 %cmp107, label %for.body.lr.ph, label %em_cpu_energy.exit

for.body.lr.ph:                                   ; preds = %entry
  %stack.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 1
  %util_avg.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 7
  %util_est.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9
  %ue.sroa.5.0.util_est.sroa_idx.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9, i32 1
  %cmp6.not.i68 = icmp eq i32 %dst_cpu, -1
  br label %for.body

for.body:                                         ; preds = %if.end, %for.body.lr.ph
  %call4110 = phi i32 [ %call4106, %for.body.lr.ph ], [ %call4, %if.end ]
  %max_util.0109 = phi i32 [ 0, %for.body.lr.ph ], [ %84, %if.end ]
  %sum_util.0108 = phi i32 [ 0, %for.body.lr.ph ], [ %add11, %if.end ]
  %arrayidx.i58 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call4110
  %15 = ptrtoint ptr %arrayidx.i58 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %arrayidx.i58, align 4
  %add.i59 = add i32 %16, ptrtoint (ptr @runqueues to i32)
  %17 = inttoptr i32 %add.i59 to ptr
  %util_avg.i = getelementptr inbounds %struct.rq, ptr %17, i32 0, i32 14, i32 17, i32 7
  %18 = ptrtoint ptr %util_avg.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load volatile i32, ptr %util_avg.i, align 8
  %20 = ptrtoint ptr %stack.i.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %stack.i.i, align 4
  %cpu.i.i = getelementptr inbounds %struct.thread_info, ptr %21, i32 0, i32 3
  %22 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %cpu.i.i, align 4
  %cmp.i = icmp ne i32 %23, %call4110
  %cmp6.not.i = icmp eq i32 %call4110, %dst_cpu
  %or.cond.i = or i1 %cmp6.not.i, %cmp.i
  br i1 %or.cond.i, label %if.else.i, label %do.body7.i

do.body7.i:                                       ; preds = %for.body
  %24 = ptrtoint ptr %util_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load volatile i32, ptr %util_avg.i.i, align 8
  %26 = tail call i32 @llvm.usub.sat.i32(i32 %19, i32 %25) #20
  br label %if.end20.i

if.else.i:                                        ; preds = %for.body
  %27 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load volatile i32, ptr %cpu.i.i, align 4
  %cmp14.not.i = icmp ne i32 %28, %call4110
  %or.cond73.i = and i1 %cmp6.not.i, %cmp14.not.i
  br i1 %or.cond73.i, label %if.then17.i, label %if.end20.i

if.then17.i:                                      ; preds = %if.else.i
  %29 = ptrtoint ptr %util_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load volatile i32, ptr %util_avg.i.i, align 8
  %add19.i = add i32 %30, %19
  br label %if.end20.i

if.end20.i:                                       ; preds = %if.then17.i, %if.else.i, %do.body7.i
  %util.0.i = phi i32 [ %26, %do.body7.i ], [ %add19.i, %if.then17.i ], [ %19, %if.else.i ]
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 20), i32 1), ptr blockaddress(@compute_energy, %cpu_util_next.exit)) #20
          to label %do.end25.i [label %cpu_util_next.exit], !srcloc !261

do.end25.i:                                       ; preds = %if.end20.i
  %util_est28.i = getelementptr inbounds %struct.rq, ptr %17, i32 0, i32 14, i32 17, i32 9
  %31 = ptrtoint ptr %util_est28.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load volatile i32, ptr %util_est28.i, align 16
  br i1 %cmp6.not.i, label %if.then30.i, label %if.end33.i

if.then30.i:                                      ; preds = %do.end25.i
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.0.i.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.5.i.i)
  %33 = ptrtoint ptr %util_est.i.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %ue.sroa.0.0.copyload.i.i = load volatile i32, ptr %util_est.i.i, align 16
  %34 = ptrtoint ptr %ue.sroa.0.i.i to i32
  call void @__asan_store4_noabort(i32 %34)
  store volatile i32 %ue.sroa.0.0.copyload.i.i, ptr %ue.sroa.0.i.i, align 8
  %35 = ptrtoint ptr %ue.sroa.5.0.util_est.sroa_idx.i.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %ue.sroa.5.0.copyload.i.i = load volatile i32, ptr %ue.sroa.5.0.util_est.sroa_idx.i.i, align 4
  %36 = ptrtoint ptr %ue.sroa.5.i.i to i32
  call void @__asan_store4_noabort(i32 %36)
  store volatile i32 %ue.sroa.5.0.copyload.i.i, ptr %ue.sroa.5.i.i, align 4
  %and.i.i = and i32 %ue.sroa.0.0.copyload.i.i, 2147483647
  %37 = tail call i32 @llvm.umax.i32(i32 %ue.sroa.5.0.copyload.i.i, i32 %and.i.i) #20
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.0.i.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.5.i.i)
  %add32.i = add i32 %37, %32
  br label %if.end33.i

if.end33.i:                                       ; preds = %if.then30.i, %do.end25.i
  %util_est.0.i = phi i32 [ %add32.i, %if.then30.i ], [ %32, %do.end25.i ]
  %38 = tail call i32 @llvm.umax.i32(i32 %util.0.i, i32 %util_est.0.i) #20
  br label %cpu_util_next.exit

cpu_util_next.exit:                               ; preds = %if.end33.i, %if.end20.i
  %util.1.i = phi i32 [ %38, %if.end33.i ], [ %util.0.i, %if.end20.i ]
  %39 = ptrtoint ptr %arrayidx.i58 to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load i32, ptr %arrayidx.i58, align 4
  %add.i.i = add i32 %40, ptrtoint (ptr @runqueues to i32)
  %41 = inttoptr i32 %add.i.i to ptr
  %cpu_capacity_orig.i.i = getelementptr inbounds %struct.rq, ptr %41, i32 0, i32 38
  %42 = ptrtoint ptr %cpu_capacity_orig.i.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load i32, ptr %cpu_capacity_orig.i.i, align 4
  %44 = tail call i32 @llvm.umin.i32(i32 %util.1.i, i32 %43) #20
  br i1 %cmp6.not.i, label %if.then, label %if.end

if.then:                                          ; preds = %cpu_util_next.exit
  %util_avg.i64 = getelementptr inbounds %struct.rq, ptr %41, i32 0, i32 14, i32 17, i32 7
  %45 = ptrtoint ptr %util_avg.i64 to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load volatile i32, ptr %util_avg.i64, align 8
  %47 = ptrtoint ptr %stack.i.i to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load ptr, ptr %stack.i.i, align 4
  %cpu.i.i66 = getelementptr inbounds %struct.thread_info, ptr %48, i32 0, i32 3
  %49 = ptrtoint ptr %cpu.i.i66 to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load volatile i32, ptr %cpu.i.i66, align 4
  %cmp.i67 = icmp ne i32 %50, %dst_cpu
  %or.cond.i69 = or i1 %cmp6.not.i68, %cmp.i67
  br i1 %or.cond.i69, label %if.else.i74, label %do.body7.i71

do.body7.i71:                                     ; preds = %if.then
  %51 = ptrtoint ptr %util_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load volatile i32, ptr %util_avg.i.i, align 8
  %53 = tail call i32 @llvm.usub.sat.i32(i32 %46, i32 %52) #20
  br label %if.end20.i79

if.else.i74:                                      ; preds = %if.then
  %54 = ptrtoint ptr %cpu.i.i66 to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load volatile i32, ptr %cpu.i.i66, align 4
  %56 = icmp ne i32 %55, -1
  %57 = and i1 %cmp6.not.i68, %56
  br i1 %57, label %if.then17.i77, label %if.end20.i79

if.then17.i77:                                    ; preds = %if.else.i74
  %58 = ptrtoint ptr %util_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load volatile i32, ptr %util_avg.i.i, align 8
  %add19.i76 = add i32 %59, %46
  br label %if.end20.i79

if.end20.i79:                                     ; preds = %if.then17.i77, %if.else.i74, %do.body7.i71
  %util.0.i78 = phi i32 [ %53, %do.body7.i71 ], [ %add19.i76, %if.then17.i77 ], [ %46, %if.else.i74 ]
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 20), i32 1), ptr blockaddress(@compute_energy, %cpu_util_next.exit94)) #20
          to label %do.end25.i81 [label %cpu_util_next.exit94], !srcloc !261

do.end25.i81:                                     ; preds = %if.end20.i79
  %util_est28.i80 = getelementptr inbounds %struct.rq, ptr %41, i32 0, i32 14, i32 17, i32 9
  %60 = ptrtoint ptr %util_est28.i80 to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load volatile i32, ptr %util_est28.i80, align 16
  br i1 %cmp6.not.i68, label %if.then30.i88, label %if.end33.i90

if.then30.i88:                                    ; preds = %do.end25.i81
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.0.i.i60)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.5.i.i61)
  %62 = ptrtoint ptr %util_est.i.i to i32
  call void @__asan_load4_noabort(i32 %62)
  %ue.sroa.0.0.copyload.i.i83 = load volatile i32, ptr %util_est.i.i, align 16
  %63 = ptrtoint ptr %ue.sroa.0.i.i60 to i32
  call void @__asan_store4_noabort(i32 %63)
  store volatile i32 %ue.sroa.0.0.copyload.i.i83, ptr %ue.sroa.0.i.i60, align 8
  %64 = ptrtoint ptr %ue.sroa.5.0.util_est.sroa_idx.i.i to i32
  call void @__asan_load4_noabort(i32 %64)
  %ue.sroa.5.0.copyload.i.i85 = load volatile i32, ptr %ue.sroa.5.0.util_est.sroa_idx.i.i, align 4
  %65 = ptrtoint ptr %ue.sroa.5.i.i61 to i32
  call void @__asan_store4_noabort(i32 %65)
  store volatile i32 %ue.sroa.5.0.copyload.i.i85, ptr %ue.sroa.5.i.i61, align 4
  %and.i.i86 = and i32 %ue.sroa.0.0.copyload.i.i83, 2147483647
  %66 = tail call i32 @llvm.umax.i32(i32 %ue.sroa.5.0.copyload.i.i85, i32 %and.i.i86) #20
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.0.i.i60)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.5.i.i61)
  %add32.i87 = add i32 %66, %61
  br label %if.end33.i90

if.end33.i90:                                     ; preds = %if.then30.i88, %do.end25.i81
  %util_est.0.i89 = phi i32 [ %add32.i87, %if.then30.i88 ], [ %61, %do.end25.i81 ]
  %67 = tail call i32 @llvm.umax.i32(i32 %util.0.i78, i32 %util_est.0.i89) #20
  br label %cpu_util_next.exit94

cpu_util_next.exit94:                             ; preds = %if.end33.i90, %if.end20.i79
  %util.1.i91 = phi i32 [ %67, %if.end33.i90 ], [ %util.0.i78, %if.end20.i79 ]
  %68 = ptrtoint ptr %arrayidx.i58 to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load i32, ptr %arrayidx.i58, align 4
  %add.i.i92 = add i32 %69, ptrtoint (ptr @runqueues to i32)
  %70 = inttoptr i32 %add.i.i92 to ptr
  %cpu_capacity_orig.i.i93 = getelementptr inbounds %struct.rq, ptr %70, i32 0, i32 38
  %71 = ptrtoint ptr %cpu_capacity_orig.i.i93 to i32
  call void @__asan_load4_noabort(i32 %71)
  %72 = load i32, ptr %cpu_capacity_orig.i.i93, align 4
  %73 = tail call i32 @llvm.umin.i32(i32 %util.1.i91, i32 %72) #20
  %74 = ptrtoint ptr %util_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %74)
  %75 = load volatile i32, ptr %util_avg.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.0.i.i95)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.5.i.i96)
  %76 = ptrtoint ptr %util_est.i.i to i32
  call void @__asan_load4_noabort(i32 %76)
  %ue.sroa.0.0.copyload.i.i99 = load volatile i32, ptr %util_est.i.i, align 16
  %77 = ptrtoint ptr %ue.sroa.0.i.i95 to i32
  call void @__asan_store4_noabort(i32 %77)
  store volatile i32 %ue.sroa.0.0.copyload.i.i99, ptr %ue.sroa.0.i.i95, align 8
  %78 = ptrtoint ptr %ue.sroa.5.0.util_est.sroa_idx.i.i to i32
  call void @__asan_load4_noabort(i32 %78)
  %ue.sroa.5.0.copyload.i.i101 = load volatile i32, ptr %ue.sroa.5.0.util_est.sroa_idx.i.i, align 4
  %79 = ptrtoint ptr %ue.sroa.5.i.i96 to i32
  call void @__asan_store4_noabort(i32 %79)
  store volatile i32 %ue.sroa.5.0.copyload.i.i101, ptr %ue.sroa.5.i.i96, align 4
  %and.i.i102 = and i32 %ue.sroa.0.0.copyload.i.i99, 2147483647
  %80 = tail call i32 @llvm.umax.i32(i32 %ue.sroa.5.0.copyload.i.i101, i32 %and.i.i102) #20
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.0.i.i95)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.5.i.i96)
  %81 = tail call i32 @llvm.umax.i32(i32 %75, i32 %80) #20
  %add = add i32 %81, %73
  br label %if.end

if.end:                                           ; preds = %cpu_util_next.exit94, %cpu_util_next.exit
  %util_running.0 = phi i32 [ %add, %cpu_util_next.exit94 ], [ %44, %cpu_util_next.exit ]
  %tsk.0 = phi ptr [ %p, %cpu_util_next.exit94 ], [ null, %cpu_util_next.exit ]
  %call9 = tail call i32 @effective_cpu_util(i32 noundef %call4110, i32 noundef %util_running.0, i32 noundef %7, i32 noundef 1, ptr noundef null) #20
  %82 = tail call i32 @llvm.umin.i32(i32 %call9, i32 %sub)
  %add11 = add i32 %82, %sum_util.0108
  %call12 = tail call i32 @effective_cpu_util(i32 noundef %call4110, i32 noundef %44, i32 noundef %7, i32 noundef 0, ptr noundef %tsk.0) #20
  %83 = tail call i32 @llvm.umin.i32(i32 %call12, i32 %sub)
  %84 = tail call i32 @llvm.umax.i32(i32 %max_util.0109, i32 %83)
  %call4 = tail call i32 @cpumask_next_and(i32 noundef %call4110, ptr noundef %cpus, ptr noundef nonnull @__cpu_online_mask) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %85 = load i32, ptr @nr_cpu_ids, align 4
  %cmp = icmp ult i32 %call4, %85
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %if.end
  %tobool.not.i = icmp eq i32 %add11, 0
  br i1 %tobool.not.i, label %em_cpu_energy.exit, label %if.end.i

if.end.i:                                         ; preds = %for.end
  %86 = ptrtoint ptr %pd to i32
  call void @__asan_load4_noabort(i32 %86)
  %87 = load ptr, ptr %pd, align 4
  %cpus.i = getelementptr inbounds %struct.em_perf_domain, ptr %87, i32 0, i32 3
  %call.i.i = tail call i32 @_find_first_bit_be(ptr noundef %cpus.i, i32 noundef %85) #20
  %arrayidx.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call.i.i
  %88 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %88)
  %89 = load i32, ptr %arrayidx.i.i, align 4
  %add.i.i103 = add i32 %89, ptrtoint (ptr @cpu_scale to i32)
  %90 = inttoptr i32 %add.i.i103 to ptr
  %91 = ptrtoint ptr %90 to i32
  call void @__asan_load4_noabort(i32 %91)
  %92 = load i32, ptr %90, align 4
  %93 = ptrtoint ptr %87 to i32
  call void @__asan_load4_noabort(i32 %93)
  %94 = load ptr, ptr %87, align 4
  %nr_perf_states.i = getelementptr inbounds %struct.em_perf_domain, ptr %87, i32 0, i32 1
  %95 = ptrtoint ptr %nr_perf_states.i to i32
  call void @__asan_load4_noabort(i32 %95)
  %96 = load i32, ptr %nr_perf_states.i, align 4
  %sub.i = add i32 %96, -1
  %arrayidx.i104 = getelementptr %struct.em_perf_state, ptr %94, i32 %sub.i
  %shr.i.i = lshr i32 %84, 2
  %add.i18.i = add i32 %shr.i.i, %84
  %97 = tail call i32 @llvm.umin.i32(i32 %add.i18.i, i32 %sub) #20
  %98 = ptrtoint ptr %arrayidx.i104 to i32
  call void @__asan_load4_noabort(i32 %98)
  %99 = load i32, ptr %arrayidx.i104, align 4
  %mul.i.i = mul i32 %99, %97
  %div.i.i = udiv i32 %mul.i.i, %92
  %flags.i.i = getelementptr inbounds %struct.em_perf_domain, ptr %87, i32 0, i32 2
  %cmp13.i.i = icmp sgt i32 %96, 0
  br i1 %cmp13.i.i, label %for.body.lr.ph.i.i, label %em_pd_get_efficient_state.exit.i

for.body.lr.ph.i.i:                               ; preds = %if.end.i
  %100 = shl i32 %96, 4
  %101 = add i32 %100, -16
  %uglygep.i.i = getelementptr i8, ptr %94, i32 %101
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.inc.i.i, %for.body.lr.ph.i.i
  %i.014.i.i = phi i32 [ 0, %for.body.lr.ph.i.i ], [ %inc.i.i, %for.inc.i.i ]
  %arrayidx.i19.i = getelementptr %struct.em_perf_state, ptr %94, i32 %i.014.i.i
  %102 = ptrtoint ptr %arrayidx.i19.i to i32
  call void @__asan_load4_noabort(i32 %102)
  %103 = load i32, ptr %arrayidx.i19.i, align 4
  %cmp1.not.i.i = icmp ult i32 %103, %div.i.i
  br i1 %cmp1.not.i.i, label %for.inc.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %for.body.i.i
  %104 = ptrtoint ptr %flags.i.i to i32
  call void @__asan_load4_noabort(i32 %104)
  %105 = load i32, ptr %flags.i.i, align 4
  %and.i.i105 = and i32 %105, 2
  %tobool.not.i.i = icmp eq i32 %and.i.i105, 0
  br i1 %tobool.not.i.i, label %em_pd_get_efficient_state.exit.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.then.i.i
  %flags2.i.i = getelementptr %struct.em_perf_state, ptr %94, i32 %i.014.i.i, i32 3
  %106 = ptrtoint ptr %flags2.i.i to i32
  call void @__asan_load4_noabort(i32 %106)
  %107 = load i32, ptr %flags2.i.i, align 4
  %and3.i.i = and i32 %107, 1
  %tobool4.not.i.i = icmp eq i32 %and3.i.i, 0
  br i1 %tobool4.not.i.i, label %em_pd_get_efficient_state.exit.i, label %for.inc.i.i

for.inc.i.i:                                      ; preds = %land.lhs.true.i.i, %for.body.i.i
  %inc.i.i = add nuw nsw i32 %i.014.i.i, 1
  %exitcond.not.i.i = icmp eq i32 %inc.i.i, %96
  br i1 %exitcond.not.i.i, label %em_pd_get_efficient_state.exit.i, label %for.body.i.i

em_pd_get_efficient_state.exit.i:                 ; preds = %for.inc.i.i, %land.lhs.true.i.i, %if.then.i.i, %if.end.i
  %ps.1.i.i = phi ptr [ inttoptr (i32 -1 to ptr), %if.end.i ], [ %uglygep.i.i, %for.inc.i.i ], [ %arrayidx.i19.i, %land.lhs.true.i.i ], [ %arrayidx.i19.i, %if.then.i.i ]
  %cost.i = getelementptr inbounds %struct.em_perf_state, ptr %ps.1.i.i, i32 0, i32 2
  %108 = ptrtoint ptr %cost.i to i32
  call void @__asan_load4_noabort(i32 %108)
  %109 = load i32, ptr %cost.i, align 4
  %mul.i = mul i32 %109, %add11
  %div.i = udiv i32 %mul.i, %92
  br label %em_cpu_energy.exit

em_cpu_energy.exit:                               ; preds = %em_pd_get_efficient_state.exit.i, %for.end, %entry
  %retval.0.i = phi i32 [ %div.i, %em_pd_get_efficient_state.exit.i ], [ 0, %for.end ], [ 0, %entry ]
  ret i32 %retval.0.i
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @effective_cpu_util(i32 noundef, i32 noundef, i32 noundef, i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @_find_first_bit_be(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @wake_affine_weight(ptr nocapture noundef readonly %sd, ptr nocapture noundef readonly %p, i32 noundef %this_cpu, i32 noundef %prev_cpu, i32 noundef %sync) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %this_cpu
  %0 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %arrayidx, align 4
  %add = add i32 %1, ptrtoint (ptr @runqueues to i32)
  %2 = inttoptr i32 %add to ptr
  %load_avg.i.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 14, i32 17, i32 5
  %3 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %load_avg.i.i, align 32
  %conv = zext i32 %4 to i64
  %tobool.not = icmp eq i32 %sync, 0
  br i1 %tobool.not, label %if.end8, label %if.then

if.then:                                          ; preds = %entry
  %5 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %5, -16384
  %6 = inttoptr i32 %and.i to ptr
  %task = getelementptr inbounds %struct.thread_info, ptr %6, i32 0, i32 2
  %7 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %task, align 8
  %cfs_rq.i.i = getelementptr inbounds %struct.task_struct, ptr %8, i32 0, i32 18, i32 11
  %9 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %cfs_rq.i.i, align 16
  %rq.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %10, i32 0, i32 27
  %11 = ptrtoint ptr %rq.i.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %rq.i.i.i, align 4
  %tg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %10, i32 0, i32 30
  %13 = ptrtoint ptr %tg.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %tg.i.i, align 4
  %se1.i.i = getelementptr inbounds %struct.task_group, ptr %14, i32 0, i32 1
  %15 = ptrtoint ptr %se1.i.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %se1.i.i, align 8
  %cpu.i.i.i = getelementptr inbounds %struct.rq, ptr %12, i32 0, i32 46
  %17 = ptrtoint ptr %cpu.i.i.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %cpu.i.i.i, align 4
  %arrayidx.i.i = getelementptr ptr, ptr %16, i32 %18
  %19 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %arrayidx.i.i, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %21 = load volatile i32, ptr @jiffies, align 128
  %last_h_load_update.i.i = getelementptr inbounds %struct.cfs_rq, ptr %10, i32 0, i32 25
  %22 = ptrtoint ptr %last_h_load_update.i.i to i32
  call void @__asan_load8_noabort(i32 %22)
  %23 = load i64, ptr %last_h_load_update.i.i, align 16
  %conv.i.i = zext i32 %21 to i64
  %cmp.i.i = icmp eq i64 %23, %conv.i.i
  br i1 %cmp.i.i, label %task_h_load.exit, label %do.body5.i.i

do.body5.i.i:                                     ; preds = %if.then
  %h_load_next.i.i = getelementptr inbounds %struct.cfs_rq, ptr %10, i32 0, i32 26
  %24 = ptrtoint ptr %h_load_next.i.i to i32
  call void @__asan_store4_noabort(i32 %24)
  store volatile ptr null, ptr %h_load_next.i.i, align 8
  %tobool.not82.i.i = icmp eq ptr %20, null
  br i1 %tobool.not82.i.i, label %if.then28.i.i, label %for.body.i.i

for.body.i.i:                                     ; preds = %for.inc.i.i, %do.body5.i.i
  %se.083.i.i = phi ptr [ %31, %for.inc.i.i ], [ %20, %do.body5.i.i ]
  %cfs_rq.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.083.i.i, i32 0, i32 11
  %25 = ptrtoint ptr %cfs_rq.i.i.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load ptr, ptr %cfs_rq.i.i.i, align 16
  %h_load_next16.i.i = getelementptr inbounds %struct.cfs_rq, ptr %26, i32 0, i32 26
  %27 = ptrtoint ptr %h_load_next16.i.i to i32
  call void @__asan_store4_noabort(i32 %27)
  store volatile ptr %se.083.i.i, ptr %h_load_next16.i.i, align 8
  %last_h_load_update21.i.i = getelementptr inbounds %struct.cfs_rq, ptr %26, i32 0, i32 25
  %28 = ptrtoint ptr %last_h_load_update21.i.i to i32
  call void @__asan_load8_noabort(i32 %28)
  %29 = load i64, ptr %last_h_load_update21.i.i, align 16
  %cmp23.i.i = icmp eq i64 %29, %conv.i.i
  br i1 %cmp23.i.i, label %if.end32.i.i, label %for.inc.i.i

for.inc.i.i:                                      ; preds = %for.body.i.i
  %parent.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.083.i.i, i32 0, i32 10
  %30 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i = icmp eq ptr %31, null
  br i1 %tobool.not.i.i, label %if.then28.i.i, label %for.body.i.i

if.then28.i.i:                                    ; preds = %for.inc.i.i, %do.body5.i.i
  %cfs_rq.addr.0.lcssa.i.i = phi ptr [ %10, %do.body5.i.i ], [ %26, %for.inc.i.i ]
  %load_avg.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.0.lcssa.i.i, i32 0, i32 17, i32 5
  %32 = ptrtoint ptr %load_avg.i.i.i to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %load_avg.i.i.i, align 32
  %h_load.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.0.lcssa.i.i, i32 0, i32 24
  %34 = ptrtoint ptr %h_load.i.i to i32
  call void @__asan_store4_noabort(i32 %34)
  store i32 %33, ptr %h_load.i.i, align 4
  %last_h_load_update31.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.0.lcssa.i.i, i32 0, i32 25
  %35 = ptrtoint ptr %last_h_load_update31.i.i to i32
  call void @__asan_store8_noabort(i32 %35)
  store i64 %conv.i.i, ptr %last_h_load_update31.i.i, align 16
  br label %if.end32.i.i

if.end32.i.i:                                     ; preds = %if.then28.i.i, %for.body.i.i
  %cfs_rq.addr.176.i.i = phi ptr [ %cfs_rq.addr.0.lcssa.i.i, %if.then28.i.i ], [ %26, %for.body.i.i ]
  %h_load_next3684.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.176.i.i, i32 0, i32 26
  %36 = ptrtoint ptr %h_load_next3684.i.i to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load volatile ptr, ptr %h_load_next3684.i.i, align 8
  %cmp37.not85.i.i = icmp eq ptr %37, null
  br i1 %cmp37.not85.i.i, label %task_h_load.exit, label %div_u64.exit.i.i

div_u64.exit.i.i:                                 ; preds = %div_u64.exit.i.i, %if.end32.i.i
  %38 = phi ptr [ %50, %div_u64.exit.i.i ], [ %37, %if.end32.i.i ]
  %cfs_rq.addr.286.i.i = phi ptr [ %46, %div_u64.exit.i.i ], [ %cfs_rq.addr.176.i.i, %if.end32.i.i ]
  %load_avg.i.i72 = getelementptr inbounds %struct.sched_entity, ptr %38, i32 0, i32 15, i32 5
  %39 = ptrtoint ptr %load_avg.i.i72 to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load i32, ptr %load_avg.i.i72, align 32
  %h_load39.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.286.i.i, i32 0, i32 24
  %41 = ptrtoint ptr %h_load39.i.i to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load i32, ptr %h_load39.i.i, align 4
  %mul.i.i = mul i32 %40, %42
  %load_avg.i74.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.286.i.i, i32 0, i32 17, i32 5
  %43 = ptrtoint ptr %load_avg.i74.i.i to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load i32, ptr %load_avg.i74.i.i, align 32
  %add.i.i = add i32 %44, 1
  %div172.i.i.i.i = udiv i32 %mul.i.i, %add.i.i
  %my_q.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %38, i32 0, i32 12
  %45 = ptrtoint ptr %my_q.i.i.i to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load ptr, ptr %my_q.i.i.i, align 4
  %h_load45.i.i = getelementptr inbounds %struct.cfs_rq, ptr %46, i32 0, i32 24
  %47 = ptrtoint ptr %h_load45.i.i to i32
  call void @__asan_store4_noabort(i32 %47)
  store i32 %div172.i.i.i.i, ptr %h_load45.i.i, align 4
  %last_h_load_update47.i.i = getelementptr inbounds %struct.cfs_rq, ptr %46, i32 0, i32 25
  %48 = ptrtoint ptr %last_h_load_update47.i.i to i32
  call void @__asan_store8_noabort(i32 %48)
  store i64 %conv.i.i, ptr %last_h_load_update47.i.i, align 16
  %h_load_next36.i.i = getelementptr inbounds %struct.cfs_rq, ptr %46, i32 0, i32 26
  %49 = ptrtoint ptr %h_load_next36.i.i to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load volatile ptr, ptr %h_load_next36.i.i, align 8
  %cmp37.not.i.i = icmp eq ptr %50, null
  br i1 %cmp37.not.i.i, label %task_h_load.exit, label %div_u64.exit.i.i

task_h_load.exit:                                 ; preds = %div_u64.exit.i.i, %if.end32.i.i, %if.then
  %h_load.i = getelementptr inbounds %struct.cfs_rq, ptr %10, i32 0, i32 24
  %51 = ptrtoint ptr %h_load.i to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load i32, ptr %h_load.i, align 4
  %load_avg.i = getelementptr inbounds %struct.task_struct, ptr %8, i32 0, i32 18, i32 15, i32 5
  %53 = ptrtoint ptr %load_avg.i to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load i32, ptr %load_avg.i, align 32
  %mul.i = mul i32 %52, %54
  %load_avg.i7.i = getelementptr inbounds %struct.cfs_rq, ptr %10, i32 0, i32 17, i32 5
  %55 = ptrtoint ptr %load_avg.i7.i to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load i32, ptr %load_avg.i7.i, align 32
  %add.i = add i32 %56, 1
  %div172.i.i.i = udiv i32 %mul.i, %add.i
  %cmp = icmp ult i32 %4, %div172.i.i.i
  %conv4 = zext i32 %div172.i.i.i to i64
  %sub = sub nsw i64 %conv, %conv4
  br i1 %cmp, label %cleanup47, label %if.end8

if.end8:                                          ; preds = %task_h_load.exit, %entry
  %this_eff_load.1 = phi i64 [ %sub, %task_h_load.exit ], [ %conv, %entry ]
  %cfs_rq.i.i73 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %57 = ptrtoint ptr %cfs_rq.i.i73 to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load ptr, ptr %cfs_rq.i.i73, align 16
  %rq.i.i.i74 = getelementptr inbounds %struct.cfs_rq, ptr %58, i32 0, i32 27
  %59 = ptrtoint ptr %rq.i.i.i74 to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load ptr, ptr %rq.i.i.i74, align 4
  %tg.i.i75 = getelementptr inbounds %struct.cfs_rq, ptr %58, i32 0, i32 30
  %61 = ptrtoint ptr %tg.i.i75 to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load ptr, ptr %tg.i.i75, align 4
  %se1.i.i76 = getelementptr inbounds %struct.task_group, ptr %62, i32 0, i32 1
  %63 = ptrtoint ptr %se1.i.i76 to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load ptr, ptr %se1.i.i76, align 8
  %cpu.i.i.i77 = getelementptr inbounds %struct.rq, ptr %60, i32 0, i32 46
  %65 = ptrtoint ptr %cpu.i.i.i77 to i32
  call void @__asan_load4_noabort(i32 %65)
  %66 = load i32, ptr %cpu.i.i.i77, align 4
  %arrayidx.i.i78 = getelementptr ptr, ptr %64, i32 %66
  %67 = ptrtoint ptr %arrayidx.i.i78 to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load ptr, ptr %arrayidx.i.i78, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %69 = load volatile i32, ptr @jiffies, align 128
  %last_h_load_update.i.i79 = getelementptr inbounds %struct.cfs_rq, ptr %58, i32 0, i32 25
  %70 = ptrtoint ptr %last_h_load_update.i.i79 to i32
  call void @__asan_load8_noabort(i32 %70)
  %71 = load i64, ptr %last_h_load_update.i.i79, align 16
  %conv.i.i80 = zext i32 %69 to i64
  %cmp.i.i81 = icmp eq i64 %71, %conv.i.i80
  br i1 %cmp.i.i81, label %task_h_load.exit338, label %do.body5.i.i84

do.body5.i.i84:                                   ; preds = %if.end8
  %h_load_next.i.i82 = getelementptr inbounds %struct.cfs_rq, ptr %58, i32 0, i32 26
  %72 = ptrtoint ptr %h_load_next.i.i82 to i32
  call void @__asan_store4_noabort(i32 %72)
  store volatile ptr null, ptr %h_load_next.i.i82, align 8
  %tobool.not82.i.i83 = icmp eq ptr %68, null
  br i1 %tobool.not82.i.i83, label %if.then28.i.i98, label %for.body.i.i90

for.body.i.i90:                                   ; preds = %for.inc.i.i93, %do.body5.i.i84
  %se.083.i.i85 = phi ptr [ %79, %for.inc.i.i93 ], [ %68, %do.body5.i.i84 ]
  %cfs_rq.i.i.i86 = getelementptr inbounds %struct.sched_entity, ptr %se.083.i.i85, i32 0, i32 11
  %73 = ptrtoint ptr %cfs_rq.i.i.i86 to i32
  call void @__asan_load4_noabort(i32 %73)
  %74 = load ptr, ptr %cfs_rq.i.i.i86, align 16
  %h_load_next16.i.i87 = getelementptr inbounds %struct.cfs_rq, ptr %74, i32 0, i32 26
  %75 = ptrtoint ptr %h_load_next16.i.i87 to i32
  call void @__asan_store4_noabort(i32 %75)
  store volatile ptr %se.083.i.i85, ptr %h_load_next16.i.i87, align 8
  %last_h_load_update21.i.i88 = getelementptr inbounds %struct.cfs_rq, ptr %74, i32 0, i32 25
  %76 = ptrtoint ptr %last_h_load_update21.i.i88 to i32
  call void @__asan_load8_noabort(i32 %76)
  %77 = load i64, ptr %last_h_load_update21.i.i88, align 16
  %cmp23.i.i89 = icmp eq i64 %77, %conv.i.i80
  br i1 %cmp23.i.i89, label %if.end32.i.i102, label %for.inc.i.i93

for.inc.i.i93:                                    ; preds = %for.body.i.i90
  %parent.i.i91 = getelementptr inbounds %struct.sched_entity, ptr %se.083.i.i85, i32 0, i32 10
  %78 = ptrtoint ptr %parent.i.i91 to i32
  call void @__asan_load4_noabort(i32 %78)
  %79 = load ptr, ptr %parent.i.i91, align 4
  %tobool.not.i.i92 = icmp eq ptr %79, null
  br i1 %tobool.not.i.i92, label %if.then28.i.i98, label %for.body.i.i90

if.then28.i.i98:                                  ; preds = %for.inc.i.i93, %do.body5.i.i84
  %cfs_rq.addr.0.lcssa.i.i94 = phi ptr [ %58, %do.body5.i.i84 ], [ %74, %for.inc.i.i93 ]
  %load_avg.i.i.i95 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.0.lcssa.i.i94, i32 0, i32 17, i32 5
  %80 = ptrtoint ptr %load_avg.i.i.i95 to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load i32, ptr %load_avg.i.i.i95, align 32
  %h_load.i.i96 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.0.lcssa.i.i94, i32 0, i32 24
  %82 = ptrtoint ptr %h_load.i.i96 to i32
  call void @__asan_store4_noabort(i32 %82)
  store i32 %81, ptr %h_load.i.i96, align 4
  %last_h_load_update31.i.i97 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.0.lcssa.i.i94, i32 0, i32 25
  %83 = ptrtoint ptr %last_h_load_update31.i.i97 to i32
  call void @__asan_store8_noabort(i32 %83)
  store i64 %conv.i.i80, ptr %last_h_load_update31.i.i97, align 16
  br label %if.end32.i.i102

if.end32.i.i102:                                  ; preds = %if.then28.i.i98, %for.body.i.i90
  %cfs_rq.addr.176.i.i99 = phi ptr [ %cfs_rq.addr.0.lcssa.i.i94, %if.then28.i.i98 ], [ %74, %for.body.i.i90 ]
  %h_load_next3684.i.i100 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.176.i.i99, i32 0, i32 26
  %84 = ptrtoint ptr %h_load_next3684.i.i100 to i32
  call void @__asan_load4_noabort(i32 %84)
  %85 = load volatile ptr, ptr %h_load_next3684.i.i100, align 8
  %cmp37.not85.i.i101 = icmp eq ptr %85, null
  br i1 %cmp37.not85.i.i101, label %task_h_load.exit338, label %div_u64.exit.i.i223

div_u64.exit.i.i223:                              ; preds = %div_u64.exit.i.i223, %if.end32.i.i102
  %86 = phi ptr [ %98, %div_u64.exit.i.i223 ], [ %85, %if.end32.i.i102 ]
  %cfs_rq.addr.286.i.i103 = phi ptr [ %94, %div_u64.exit.i.i223 ], [ %cfs_rq.addr.176.i.i99, %if.end32.i.i102 ]
  %load_avg.i.i105 = getelementptr inbounds %struct.sched_entity, ptr %86, i32 0, i32 15, i32 5
  %87 = ptrtoint ptr %load_avg.i.i105 to i32
  call void @__asan_load4_noabort(i32 %87)
  %88 = load i32, ptr %load_avg.i.i105, align 32
  %h_load39.i.i104 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.286.i.i103, i32 0, i32 24
  %89 = ptrtoint ptr %h_load39.i.i104 to i32
  call void @__asan_load4_noabort(i32 %89)
  %90 = load i32, ptr %h_load39.i.i104, align 4
  %mul.i.i106 = mul i32 %88, %90
  %load_avg.i74.i.i108 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.286.i.i103, i32 0, i32 17, i32 5
  %91 = ptrtoint ptr %load_avg.i74.i.i108 to i32
  call void @__asan_load4_noabort(i32 %91)
  %92 = load i32, ptr %load_avg.i74.i.i108, align 32
  %add.i.i109 = add i32 %92, 1
  %div172.i.i.i.i215 = udiv i32 %mul.i.i106, %add.i.i109
  %my_q.i.i.i218 = getelementptr inbounds %struct.sched_entity, ptr %86, i32 0, i32 12
  %93 = ptrtoint ptr %my_q.i.i.i218 to i32
  call void @__asan_load4_noabort(i32 %93)
  %94 = load ptr, ptr %my_q.i.i.i218, align 4
  %h_load45.i.i219 = getelementptr inbounds %struct.cfs_rq, ptr %94, i32 0, i32 24
  %95 = ptrtoint ptr %h_load45.i.i219 to i32
  call void @__asan_store4_noabort(i32 %95)
  store i32 %div172.i.i.i.i215, ptr %h_load45.i.i219, align 4
  %last_h_load_update47.i.i220 = getelementptr inbounds %struct.cfs_rq, ptr %94, i32 0, i32 25
  %96 = ptrtoint ptr %last_h_load_update47.i.i220 to i32
  call void @__asan_store8_noabort(i32 %96)
  store i64 %conv.i.i80, ptr %last_h_load_update47.i.i220, align 16
  %h_load_next36.i.i221 = getelementptr inbounds %struct.cfs_rq, ptr %94, i32 0, i32 26
  %97 = ptrtoint ptr %h_load_next36.i.i221 to i32
  call void @__asan_load4_noabort(i32 %97)
  %98 = load volatile ptr, ptr %h_load_next36.i.i221, align 8
  %cmp37.not.i.i222 = icmp eq ptr %98, null
  br i1 %cmp37.not.i.i222, label %task_h_load.exit338, label %div_u64.exit.i.i223

task_h_load.exit338:                              ; preds = %div_u64.exit.i.i223, %if.end32.i.i102, %if.end8
  %h_load.i225 = getelementptr inbounds %struct.cfs_rq, ptr %58, i32 0, i32 24
  %99 = ptrtoint ptr %h_load.i225 to i32
  call void @__asan_load4_noabort(i32 %99)
  %100 = load i32, ptr %h_load.i225, align 4
  %load_avg.i224 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 5
  %101 = ptrtoint ptr %load_avg.i224 to i32
  call void @__asan_load4_noabort(i32 %101)
  %102 = load i32, ptr %load_avg.i224, align 32
  %mul.i226 = mul i32 %100, %102
  %load_avg.i7.i228 = getelementptr inbounds %struct.cfs_rq, ptr %58, i32 0, i32 17, i32 5
  %103 = ptrtoint ptr %load_avg.i7.i228 to i32
  call void @__asan_load4_noabort(i32 %103)
  %104 = load i32, ptr %load_avg.i7.i228, align 32
  %add.i229 = add i32 %104, 1
  %div172.i.i.i335 = udiv i32 %mul.i226, %add.i229
  %conv10 = zext i32 %div172.i.i.i335 to i64
  %add11 = add nsw i64 %this_eff_load.1, %conv10
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 19), i32 1), ptr blockaddress(@wake_affine_weight, %static_branch_WA_BIAS.exit.thread)) #20
          to label %105 [label %static_branch_WA_BIAS.exit.thread], !srcloc !261

105:                                              ; preds = %task_h_load.exit338
  %mul = mul nsw i64 %add11, 100
  br label %static_branch_WA_BIAS.exit.thread

static_branch_WA_BIAS.exit.thread:                ; preds = %105, %task_h_load.exit338
  %106 = phi i64 [ %mul, %105 ], [ %add11, %task_h_load.exit338 ]
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %prev_cpu
  %107 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %107)
  %108 = load i32, ptr %arrayidx.i, align 4
  %add.i339 = add i32 %108, ptrtoint (ptr @runqueues to i32)
  %109 = inttoptr i32 %add.i339 to ptr
  %cpu_capacity.i = getelementptr inbounds %struct.rq, ptr %109, i32 0, i32 37
  %110 = ptrtoint ptr %cpu_capacity.i to i32
  call void @__asan_load4_noabort(i32 %110)
  %111 = load i32, ptr %cpu_capacity.i, align 16
  %conv16 = zext i32 %111 to i64
  %mul17 = mul i64 %106, %conv16
  %load_avg.i.i340 = getelementptr inbounds %struct.rq, ptr %109, i32 0, i32 14, i32 17, i32 5
  %112 = ptrtoint ptr %load_avg.i.i340 to i32
  call void @__asan_load4_noabort(i32 %112)
  %113 = load i32, ptr %load_avg.i.i340, align 32
  %conv28 = zext i32 %113 to i64
  %sub30 = sub nsw i64 %conv28, %conv10
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 19), i32 1), ptr blockaddress(@wake_affine_weight, %if.end37)) #20
          to label %if.then32 [label %if.end37], !srcloc !261

if.then32:                                        ; preds = %static_branch_WA_BIAS.exit.thread
  %imbalance_pct = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 6
  %114 = ptrtoint ptr %imbalance_pct to i32
  call void @__asan_load4_noabort(i32 %114)
  %115 = load i32, ptr %imbalance_pct, align 8
  %sub33 = add i32 %115, -100
  %div67 = lshr i32 %sub33, 1
  %add34 = add nuw i32 %div67, 100
  %conv35 = zext i32 %add34 to i64
  %mul36 = mul i64 %sub30, %conv35
  br label %if.end37

if.end37:                                         ; preds = %if.then32, %static_branch_WA_BIAS.exit.thread
  %prev_eff_load.0 = phi i64 [ %mul36, %if.then32 ], [ %sub30, %static_branch_WA_BIAS.exit.thread ]
  %116 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %116)
  %117 = load i32, ptr %arrayidx, align 4
  %add.i342 = add i32 %117, ptrtoint (ptr @runqueues to i32)
  %118 = inttoptr i32 %add.i342 to ptr
  %cpu_capacity.i343 = getelementptr inbounds %struct.rq, ptr %118, i32 0, i32 37
  %119 = ptrtoint ptr %cpu_capacity.i343 to i32
  call void @__asan_load4_noabort(i32 %119)
  %120 = load i32, ptr %cpu_capacity.i343, align 16
  %conv39 = zext i32 %120 to i64
  %mul40 = mul i64 %prev_eff_load.0, %conv39
  %not.tobool.not = xor i1 %tobool.not, true
  %add43 = zext i1 %not.tobool.not to i64
  %spec.select68 = add i64 %mul40, %add43
  %cmp45 = icmp slt i64 %mul17, %spec.select68
  br i1 %cmp45, label %cleanup47, label %cond.false

cond.false:                                       ; preds = %if.end37
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %121 = load i32, ptr @nr_cpu_ids, align 4
  br label %cleanup47

cleanup47:                                        ; preds = %cond.false, %if.end37, %task_h_load.exit
  %retval.1 = phi i32 [ %this_cpu, %task_h_load.exit ], [ %121, %cond.false ], [ %this_cpu, %if.end37 ]
  ret i32 %retval.1
}

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @cpus_share_cache(i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc ptr @find_idlest_group(ptr nocapture noundef readonly %sd, ptr noundef %p, i32 noundef %this_cpu) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %local_sgs = alloca %struct.sg_lb_stats, align 4
  %tmp_sgs = alloca %struct.sg_lb_stats, align 4
  %groups = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 2
  %0 = ptrtoint ptr %groups to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %groups, align 8
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %local_sgs) #20
  %2 = call ptr @memset(ptr %local_sgs, i32 255, i32 48)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %tmp_sgs) #20
  %3 = call ptr @memset(ptr %tmp_sgs, i32 255, i32 48)
  %cpus_ptr = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 33
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %this_cpu
  %core_cookie8.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 23
  %div3.i.i = lshr i32 %this_cpu, 5
  %and.i.i116 = and i32 %this_cpu, 31
  %4 = shl nuw i32 1, %and.i.i116
  %tmp_sgs.sroa.gep = getelementptr inbounds %struct.sg_lb_stats, ptr %tmp_sgs, i32 0, i32 9
  %tmp_sgs.sroa.gep132 = getelementptr inbounds %struct.sg_lb_stats, ptr %tmp_sgs, i32 0, i32 7
  %tmp_sgs.sroa.gep135 = getelementptr inbounds %struct.sg_lb_stats, ptr %tmp_sgs, i32 0, i32 3
  br label %do.body

do.body:                                          ; preds = %cleanup, %entry
  %idlest_sgs.sroa.0.0 = phi i32 [ -1, %entry ], [ %idlest_sgs.sroa.0.1, %cleanup ]
  %idlest_sgs.sroa.8123.0 = phi i32 [ 0, %entry ], [ %idlest_sgs.sroa.8123.1, %cleanup ]
  %idlest_sgs.sroa.9124.0 = phi i32 [ 0, %entry ], [ %idlest_sgs.sroa.9124.1, %cleanup ]
  %idlest_sgs.sroa.11126.0 = phi i32 [ 5, %entry ], [ %idlest_sgs.sroa.11126.1, %cleanup ]
  %group.0 = phi ptr [ %1, %entry ], [ %52, %cleanup ]
  %local.0 = phi ptr [ null, %entry ], [ %local.2, %cleanup ]
  %idlest.0 = phi ptr [ null, %entry ], [ %idlest.2, %cleanup ]
  %cpumask.i = getelementptr inbounds %struct.sched_group, ptr %group.0, i32 0, i32 6
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %5 = load i32, ptr @nr_cpu_ids, align 4
  %6 = ptrtoint ptr %cpus_ptr to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %cpus_ptr, align 4
  %call.i.i = call i32 @__bitmap_intersects(ptr noundef %cpumask.i, ptr noundef %7, i32 noundef %5) #20
  %tobool.i.not = icmp eq i32 %call.i.i, 0
  br i1 %tobool.i.not, label %cleanup, label %do.body2

do.body2:                                         ; preds = %do.body
  %8 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %arrayidx, align 4
  %add = add i32 %9, ptrtoint (ptr @runqueues to i32)
  %10 = inttoptr i32 %add to ptr
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__sched_core_enabled, ptr blockaddress(@find_idlest_group, %land.rhs.i.i)) #20
          to label %if.end6 [label %land.rhs.i.i], !srcloc !261

land.rhs.i.i:                                     ; preds = %do.body2
  %core_enabled.i.i = getelementptr inbounds %struct.rq, ptr %10, i32 0, i32 81
  %11 = ptrtoint ptr %core_enabled.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %core_enabled.i.i, align 128
  %tobool3.i.not.i = icmp eq i32 %12, 0
  br i1 %tobool3.i.not.i, label %if.end6, label %for.cond.preheader.i

for.cond.preheader.i:                             ; preds = %land.rhs.i.i
  %cpu.i.i.i = getelementptr inbounds %struct.rq, ptr %10, i32 0, i32 46
  %core.i.i = getelementptr inbounds %struct.rq, ptr %10, i32 0, i32 79
  br label %for.cond.i

for.cond.i:                                       ; preds = %lor.rhs.critedge.i.i, %for.cond.preheader.i
  %cpu.0.i = phi i32 [ %call2.i, %lor.rhs.critedge.i.i ], [ -1, %for.cond.preheader.i ]
  %13 = ptrtoint ptr %cpus_ptr to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %cpus_ptr, align 4
  %call2.i = call i32 @cpumask_next_and(i32 noundef %cpu.0.i, ptr noundef %cpumask.i, ptr noundef %14) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %15 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.i = icmp ult i32 %call2.i, %15
  br i1 %cmp.i, label %for.body.i, label %cleanup

for.body.i:                                       ; preds = %for.cond.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__sched_core_enabled, ptr blockaddress(@find_idlest_group, %land.rhs.i.i.i)) #20
          to label %if.end6 [label %land.rhs.i.i.i], !srcloc !261

land.rhs.i.i.i:                                   ; preds = %for.body.i
  %16 = ptrtoint ptr %core_enabled.i.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %core_enabled.i.i, align 128
  %tobool3.i.not.i.i = icmp eq i32 %17, 0
  br i1 %tobool3.i.not.i.i, label %if.end6, label %for.cond.i.i

for.cond.i.i:                                     ; preds = %for.body.i.i, %land.rhs.i.i.i
  %cpu.0.i.i = phi i32 [ %call3.i.i, %for.body.i.i ], [ -1, %land.rhs.i.i.i ]
  %18 = ptrtoint ptr %cpu.i.i.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %cpu.i.i.i, align 4
  %thread_sibling.i.i.i = getelementptr [4 x %struct.cpu_topology], ptr @cpu_topology, i32 0, i32 %19, i32 5
  %call3.i.i = call i32 @cpumask_next(i32 noundef %cpu.0.i.i, ptr noundef %thread_sibling.i.i.i) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %20 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.i.i = icmp ult i32 %call3.i.i, %20
  br i1 %cmp.i.i, label %for.body.i.i, label %if.end6

for.body.i.i:                                     ; preds = %for.cond.i.i
  %call4.i.i = call i32 @available_idle_cpu(i32 noundef %call3.i.i) #20
  %tobool.not.i.i = icmp eq i32 %call4.i.i, 0
  br i1 %tobool.not.i.i, label %lor.rhs.critedge.i.i, label %for.cond.i.i

lor.rhs.critedge.i.i:                             ; preds = %for.body.i.i
  %21 = ptrtoint ptr %core.i.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %core.i.i, align 8
  %core_cookie.i.i = getelementptr inbounds %struct.rq, ptr %22, i32 0, i32 86
  %23 = ptrtoint ptr %core_cookie.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %core_cookie.i.i, align 4
  %25 = ptrtoint ptr %core_cookie8.i.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %core_cookie8.i.i, align 16
  %cmp9.i.i = icmp eq i32 %24, %26
  br i1 %cmp9.i.i, label %if.end6, label %for.cond.i

if.end6:                                          ; preds = %lor.rhs.critedge.i.i, %for.cond.i.i, %land.rhs.i.i.i, %for.body.i, %land.rhs.i.i, %do.body2
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %27 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i = icmp ugt i32 %27, %this_cpu
  br i1 %cmp.not.i.i.i, label %cpumask_test_cpu.exit, label %land.rhs.i.i.i115

land.rhs.i.i.i115:                                ; preds = %if.end6
  %.b37.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i, label %cpumask_test_cpu.exit, label %if.then.i.i.i, !prof !259

if.then.i.i.i:                                    ; preds = %land.rhs.i.i.i115
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpumask_test_cpu.exit

cpumask_test_cpu.exit:                            ; preds = %if.then.i.i.i, %land.rhs.i.i.i115, %if.end6
  %arrayidx.i.i = getelementptr i32, ptr %cpumask.i, i32 %div3.i.i
  %28 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %arrayidx.i.i, align 4
  %30 = and i32 %29, %4
  %tobool.not = icmp eq i32 %30, 0
  %tmp_sgs.local_sgs = select i1 %tobool.not, ptr %tmp_sgs, ptr %local_sgs
  call fastcc void @update_sg_wakeup_stats(ptr noundef %sd, ptr noundef %group.0, ptr noundef nonnull %tmp_sgs.local_sgs, ptr noundef %p)
  br i1 %tobool.not, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %cpumask_test_cpu.exit
  %31 = ptrtoint ptr %tmp_sgs.sroa.gep to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %tmp_sgs.sroa.gep, align 4
  %cmp.i118 = icmp ult i32 %32, %idlest_sgs.sroa.11126.0
  br i1 %cmp.i118, label %if.then13, label %if.end.i

if.end.i:                                         ; preds = %land.lhs.true
  %cmp4.i = icmp ugt i32 %32, %idlest_sgs.sroa.11126.0
  br i1 %cmp4.i, label %cleanup, label %if.end6.i

if.end6.i:                                        ; preds = %if.end.i
  switch i32 %32, label %if.then13 [
    i32 5, label %sw.bb.i
    i32 1, label %sw.bb.i
    i32 4, label %cleanup
    i32 3, label %cleanup
    i32 2, label %sw.bb13.i
    i32 0, label %sw.bb19.i
  ]

sw.bb.i:                                          ; preds = %if.end6.i, %if.end6.i
  %33 = ptrtoint ptr %tmp_sgs.local_sgs to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %tmp_sgs.local_sgs, align 4
  %cmp9.not.i = icmp ugt i32 %idlest_sgs.sroa.0.0, %34
  br i1 %cmp9.not.i, label %if.then13, label %cleanup

sw.bb13.i:                                        ; preds = %if.end6.i
  %sgc.i = getelementptr inbounds %struct.sched_group, ptr %idlest.0, i32 0, i32 3
  %35 = ptrtoint ptr %sgc.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load ptr, ptr %sgc.i, align 4
  %max_capacity.i = getelementptr inbounds %struct.sched_group_capacity, ptr %36, i32 0, i32 3
  %37 = ptrtoint ptr %max_capacity.i to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %max_capacity.i, align 4
  %sgc14.i = getelementptr inbounds %struct.sched_group, ptr %group.0, i32 0, i32 3
  %39 = ptrtoint ptr %sgc14.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load ptr, ptr %sgc14.i, align 4
  %max_capacity15.i = getelementptr inbounds %struct.sched_group_capacity, ptr %40, i32 0, i32 3
  %41 = ptrtoint ptr %max_capacity15.i to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load i32, ptr %max_capacity15.i, align 4
  %cmp16.not.i = icmp ult i32 %38, %42
  br i1 %cmp16.not.i, label %if.then13, label %cleanup

sw.bb19.i:                                        ; preds = %if.end6.i
  %43 = ptrtoint ptr %tmp_sgs.sroa.gep132 to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load i32, ptr %tmp_sgs.sroa.gep132, align 4
  %cmp21.i = icmp ugt i32 %idlest_sgs.sroa.9124.0, %44
  br i1 %cmp21.i, label %cleanup, label %if.end23.i

if.end23.i:                                       ; preds = %sw.bb19.i
  %cmp26.i = icmp eq i32 %idlest_sgs.sroa.9124.0, %44
  br i1 %cmp26.i, label %land.lhs.true.i, label %if.then13

land.lhs.true.i:                                  ; preds = %if.end23.i
  %45 = ptrtoint ptr %tmp_sgs.sroa.gep135 to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load i32, ptr %tmp_sgs.sroa.gep135, align 4
  %cmp28.not.i = icmp ugt i32 %idlest_sgs.sroa.8123.0, %46
  br i1 %cmp28.not.i, label %if.then13, label %cleanup

if.then13:                                        ; preds = %land.lhs.true.i, %if.end23.i, %sw.bb13.i, %sw.bb.i, %if.end6.i, %land.lhs.true
  %47 = ptrtoint ptr %tmp_sgs.local_sgs to i32
  call void @__asan_load4_noabort(i32 %47)
  %idlest_sgs.sroa.0.0.copyload = load i32, ptr %tmp_sgs.local_sgs, align 4
  %48 = ptrtoint ptr %tmp_sgs.sroa.gep135 to i32
  call void @__asan_load4_noabort(i32 %48)
  %idlest_sgs.sroa.8123.0.copyload = load i32, ptr %tmp_sgs.sroa.gep135, align 4
  %49 = ptrtoint ptr %tmp_sgs.sroa.gep132 to i32
  call void @__asan_load4_noabort(i32 %49)
  %idlest_sgs.sroa.9124.0.copyload = load i32, ptr %tmp_sgs.sroa.gep132, align 4
  %50 = ptrtoint ptr %tmp_sgs.sroa.gep to i32
  call void @__asan_load4_noabort(i32 %50)
  %idlest_sgs.sroa.11126.0.copyload = load i32, ptr %tmp_sgs.sroa.gep, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.then13, %land.lhs.true.i, %sw.bb19.i, %sw.bb13.i, %sw.bb.i, %if.end6.i, %if.end6.i, %if.end.i, %cpumask_test_cpu.exit, %for.cond.i, %do.body
  %idlest_sgs.sroa.0.1 = phi i32 [ %idlest_sgs.sroa.0.0.copyload, %if.then13 ], [ %idlest_sgs.sroa.0.0, %cpumask_test_cpu.exit ], [ %idlest_sgs.sroa.0.0, %do.body ], [ %idlest_sgs.sroa.0.0, %if.end.i ], [ %idlest_sgs.sroa.0.0, %sw.bb.i ], [ %idlest_sgs.sroa.0.0, %if.end6.i ], [ %idlest_sgs.sroa.0.0, %if.end6.i ], [ %idlest_sgs.sroa.0.0, %sw.bb13.i ], [ %idlest_sgs.sroa.0.0, %sw.bb19.i ], [ %idlest_sgs.sroa.0.0, %land.lhs.true.i ], [ %idlest_sgs.sroa.0.0, %for.cond.i ]
  %idlest_sgs.sroa.8123.1 = phi i32 [ %idlest_sgs.sroa.8123.0.copyload, %if.then13 ], [ %idlest_sgs.sroa.8123.0, %cpumask_test_cpu.exit ], [ %idlest_sgs.sroa.8123.0, %do.body ], [ %idlest_sgs.sroa.8123.0, %if.end.i ], [ %idlest_sgs.sroa.8123.0, %sw.bb.i ], [ %idlest_sgs.sroa.8123.0, %if.end6.i ], [ %idlest_sgs.sroa.8123.0, %if.end6.i ], [ %idlest_sgs.sroa.8123.0, %sw.bb13.i ], [ %idlest_sgs.sroa.8123.0, %sw.bb19.i ], [ %idlest_sgs.sroa.8123.0, %land.lhs.true.i ], [ %idlest_sgs.sroa.8123.0, %for.cond.i ]
  %idlest_sgs.sroa.9124.1 = phi i32 [ %idlest_sgs.sroa.9124.0.copyload, %if.then13 ], [ %idlest_sgs.sroa.9124.0, %cpumask_test_cpu.exit ], [ %idlest_sgs.sroa.9124.0, %do.body ], [ %idlest_sgs.sroa.9124.0, %if.end.i ], [ %idlest_sgs.sroa.9124.0, %sw.bb.i ], [ %idlest_sgs.sroa.9124.0, %if.end6.i ], [ %idlest_sgs.sroa.9124.0, %if.end6.i ], [ %idlest_sgs.sroa.9124.0, %sw.bb13.i ], [ %idlest_sgs.sroa.9124.0, %sw.bb19.i ], [ %idlest_sgs.sroa.9124.0, %land.lhs.true.i ], [ %idlest_sgs.sroa.9124.0, %for.cond.i ]
  %idlest_sgs.sroa.11126.1 = phi i32 [ %idlest_sgs.sroa.11126.0.copyload, %if.then13 ], [ %idlest_sgs.sroa.11126.0, %cpumask_test_cpu.exit ], [ %idlest_sgs.sroa.11126.0, %do.body ], [ %idlest_sgs.sroa.11126.0, %if.end.i ], [ %idlest_sgs.sroa.11126.0, %sw.bb.i ], [ %idlest_sgs.sroa.11126.0, %if.end6.i ], [ %idlest_sgs.sroa.11126.0, %if.end6.i ], [ %idlest_sgs.sroa.11126.0, %sw.bb13.i ], [ %idlest_sgs.sroa.11126.0, %sw.bb19.i ], [ %idlest_sgs.sroa.11126.0, %land.lhs.true.i ], [ %idlest_sgs.sroa.11126.0, %for.cond.i ]
  %local.2 = phi ptr [ %local.0, %if.then13 ], [ %group.0, %cpumask_test_cpu.exit ], [ %local.0, %do.body ], [ %local.0, %if.end.i ], [ %local.0, %sw.bb.i ], [ %local.0, %if.end6.i ], [ %local.0, %if.end6.i ], [ %local.0, %sw.bb13.i ], [ %local.0, %sw.bb19.i ], [ %local.0, %land.lhs.true.i ], [ %local.0, %for.cond.i ]
  %idlest.2 = phi ptr [ %group.0, %if.then13 ], [ %idlest.0, %cpumask_test_cpu.exit ], [ %idlest.0, %do.body ], [ %idlest.0, %if.end.i ], [ %idlest.0, %sw.bb.i ], [ %idlest.0, %if.end6.i ], [ %idlest.0, %if.end6.i ], [ %idlest.0, %sw.bb13.i ], [ %idlest.0, %sw.bb19.i ], [ %idlest.0, %land.lhs.true.i ], [ %idlest.0, %for.cond.i ]
  %51 = ptrtoint ptr %group.0 to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load ptr, ptr %group.0, align 4
  %53 = ptrtoint ptr %groups to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load ptr, ptr %groups, align 8
  %cmp.not = icmp eq ptr %52, %54
  br i1 %cmp.not, label %do.end17, label %do.body

do.end17:                                         ; preds = %cleanup
  %tobool18.not = icmp eq ptr %idlest.2, null
  br i1 %tobool18.not, label %cleanup75, label %if.end20

if.end20:                                         ; preds = %do.end17
  %tobool21.not = icmp eq ptr %local.2, null
  br i1 %tobool21.not, label %cleanup75, label %if.end23

if.end23:                                         ; preds = %if.end20
  %group_type = getelementptr inbounds %struct.sg_lb_stats, ptr %local_sgs, i32 0, i32 9
  %55 = ptrtoint ptr %group_type to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load i32, ptr %group_type, align 4
  %cmp25 = icmp ult i32 %56, %idlest_sgs.sroa.11126.1
  br i1 %cmp25, label %cleanup75, label %if.end27

if.end27:                                         ; preds = %if.end23
  %cmp30 = icmp ugt i32 %56, %idlest_sgs.sroa.11126.1
  br i1 %cmp30, label %cleanup75, label %if.end32

if.end32:                                         ; preds = %if.end27
  switch i32 %56, label %sw.epilog [
    i32 5, label %sw.bb
    i32 1, label %sw.bb
    i32 4, label %cleanup75
    i32 3, label %cleanup75
    i32 2, label %sw.bb56
    i32 0, label %sw.bb62
  ]

sw.bb:                                            ; preds = %if.end32, %if.end32
  %imbalance_pct = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 6
  %57 = ptrtoint ptr %imbalance_pct to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load i32, ptr %imbalance_pct, align 8
  %sub = shl i32 %58, 10
  %mul = add i32 %sub, -102400
  %div = udiv i32 %mul, 100
  %flags = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 9
  %59 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load i32, ptr %flags, align 4
  %and = and i32 %60, 8192
  %tobool34.not = icmp eq i32 %and, 0
  br i1 %tobool34.not, label %if.end40, label %land.lhs.true35

land.lhs.true35:                                  ; preds = %sw.bb
  %add36 = add i32 %div, %idlest_sgs.sroa.0.1
  %61 = ptrtoint ptr %local_sgs to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load i32, ptr %local_sgs, align 4
  %cmp38.not = icmp ult i32 %add36, %62
  br i1 %cmp38.not, label %if.end40, label %cleanup75

if.end40:                                         ; preds = %land.lhs.true35, %sw.bb
  %63 = ptrtoint ptr %local_sgs to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load i32, ptr %local_sgs, align 4
  %add43 = add i32 %64, %div
  %cmp44.not = icmp ult i32 %idlest_sgs.sroa.0.1, %add43
  br i1 %cmp44.not, label %if.end46, label %cleanup75

if.end46:                                         ; preds = %if.end40
  %mul48 = mul i32 %64, 100
  %mul51 = mul i32 %58, %idlest_sgs.sroa.0.1
  %cmp52.not = icmp ugt i32 %mul48, %mul51
  br i1 %cmp52.not, label %sw.epilog, label %cleanup75

sw.bb56:                                          ; preds = %if.end32
  %sgc = getelementptr inbounds %struct.sched_group, ptr %local.2, i32 0, i32 3
  %65 = ptrtoint ptr %sgc to i32
  call void @__asan_load4_noabort(i32 %65)
  %66 = load ptr, ptr %sgc, align 4
  %max_capacity = getelementptr inbounds %struct.sched_group_capacity, ptr %66, i32 0, i32 3
  %67 = ptrtoint ptr %max_capacity to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load i32, ptr %max_capacity, align 4
  %sgc57 = getelementptr inbounds %struct.sched_group, ptr %idlest.2, i32 0, i32 3
  %69 = ptrtoint ptr %sgc57 to i32
  call void @__asan_load4_noabort(i32 %69)
  %70 = load ptr, ptr %sgc57, align 4
  %max_capacity58 = getelementptr inbounds %struct.sched_group_capacity, ptr %70, i32 0, i32 3
  %71 = ptrtoint ptr %max_capacity58 to i32
  call void @__asan_load4_noabort(i32 %71)
  %72 = load i32, ptr %max_capacity58, align 4
  %cmp59.not = icmp ult i32 %68, %72
  br i1 %cmp59.not, label %sw.epilog, label %cleanup75

sw.bb62:                                          ; preds = %if.end32
  %flags63 = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 9
  %73 = ptrtoint ptr %flags63 to i32
  call void @__asan_load4_noabort(i32 %73)
  %74 = load i32, ptr %flags63, align 4
  %and64 = and i32 %74, 8192
  %tobool65.not = icmp eq i32 %and64, 0
  br i1 %tobool65.not, label %if.end70, label %if.then66

if.then66:                                        ; preds = %sw.bb62
  %sum_nr_running = getelementptr inbounds %struct.sg_lb_stats, ptr %local_sgs, i32 0, i32 5
  %75 = ptrtoint ptr %sum_nr_running to i32
  call void @__asan_load4_noabort(i32 %75)
  %76 = load i32, ptr %sum_nr_running, align 4
  %span_weight = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 40
  %77 = ptrtoint ptr %span_weight to i32
  call void @__asan_load4_noabort(i32 %77)
  %78 = load i32, ptr %span_weight, align 8
  %shr.i = ashr i32 %78, 2
  %cmp.i120 = icmp sgt i32 %shr.i, %76
  br i1 %cmp.i120, label %cleanup75, label %if.end70

if.end70:                                         ; preds = %if.then66, %sw.bb62
  %idle_cpus = getelementptr inbounds %struct.sg_lb_stats, ptr %local_sgs, i32 0, i32 7
  %79 = ptrtoint ptr %idle_cpus to i32
  call void @__asan_load4_noabort(i32 %79)
  %80 = load i32, ptr %idle_cpus, align 4
  %cmp72.not = icmp ult i32 %80, %idlest_sgs.sroa.9124.1
  br i1 %cmp72.not, label %sw.epilog, label %cleanup75

sw.epilog:                                        ; preds = %if.end70, %sw.bb56, %if.end46, %if.end32
  br label %cleanup75

cleanup75:                                        ; preds = %sw.epilog, %if.end70, %if.then66, %sw.bb56, %if.end46, %if.end40, %land.lhs.true35, %if.end32, %if.end32, %if.end27, %if.end23, %if.end20, %do.end17
  %retval.0 = phi ptr [ %idlest.2, %sw.epilog ], [ null, %do.end17 ], [ %idlest.2, %if.end20 ], [ null, %if.end23 ], [ %idlest.2, %if.end27 ], [ null, %land.lhs.true35 ], [ null, %if.end40 ], [ null, %if.end46 ], [ null, %if.end32 ], [ null, %if.end32 ], [ null, %sw.bb56 ], [ null, %if.then66 ], [ null, %if.end70 ]
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %tmp_sgs) #20
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %local_sgs) #20
  ret ptr %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @find_idlest_group_cpu(ptr noundef %group, ptr nocapture noundef readonly %p, i32 noundef %this_cpu) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %group_weight = getelementptr inbounds %struct.sched_group, ptr %group, i32 0, i32 2
  %0 = ptrtoint ptr %group_weight to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %group_weight, align 4
  %cmp = icmp eq i32 %1, 1
  %cpumask.i = getelementptr inbounds %struct.sched_group, ptr %group, i32 0, i32 6
  br i1 %cmp, label %if.then, label %for.cond.preheader

for.cond.preheader:                               ; preds = %entry
  %cpus_ptr = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 33
  %2 = ptrtoint ptr %cpus_ptr to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %cpus_ptr, align 4
  %call398 = tail call i32 @cpumask_next_and(i32 noundef -1, ptr noundef %cpumask.i, ptr noundef %3) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %4 = load i32, ptr @nr_cpu_ids, align 4
  %cmp499 = icmp ult i32 %call398, %4
  br i1 %cmp499, label %for.body.lr.ph, label %for.end.thread

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %core_cookie8.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 23
  br label %for.body

if.then:                                          ; preds = %entry
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %5 = load i32, ptr @nr_cpu_ids, align 4
  %call.i = tail call i32 @_find_first_bit_be(ptr noundef %cpumask.i, i32 noundef %5) #20
  br label %cleanup49

for.body:                                         ; preds = %cleanup, %for.body.lr.ph
  %call3108 = phi i32 [ %call398, %for.body.lr.ph ], [ %call3, %cleanup ]
  %min_load.0107 = phi i32 [ -1, %for.body.lr.ph ], [ %min_load.2, %cleanup ]
  %min_exit_latency.0105 = phi i32 [ -1, %for.body.lr.ph ], [ %min_exit_latency.3, %cleanup ]
  %latest_idle_timestamp.0104 = phi i64 [ 0, %for.body.lr.ph ], [ %latest_idle_timestamp.3, %cleanup ]
  %least_loaded_cpu.0103 = phi i32 [ %this_cpu, %for.body.lr.ph ], [ %least_loaded_cpu.2, %cleanup ]
  %shallowest_idle_cpu.0100 = phi i32 [ -1, %for.body.lr.ph ], [ %shallowest_idle_cpu.3, %cleanup ]
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call3108
  %6 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %arrayidx, align 4
  %add = add i32 %7, ptrtoint (ptr @runqueues to i32)
  %8 = inttoptr i32 %add to ptr
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__sched_core_enabled, ptr blockaddress(@find_idlest_group_cpu, %land.rhs.i.i)) #20
          to label %if.end8 [label %land.rhs.i.i], !srcloc !261

land.rhs.i.i:                                     ; preds = %for.body
  %core_enabled.i.i = getelementptr inbounds %struct.rq, ptr %8, i32 0, i32 81
  %9 = ptrtoint ptr %core_enabled.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %core_enabled.i.i, align 128
  %tobool3.i.not.i = icmp eq i32 %10, 0
  br i1 %tobool3.i.not.i, label %if.end8, label %for.cond.preheader.i

for.cond.preheader.i:                             ; preds = %land.rhs.i.i
  %cpu.i.i = getelementptr inbounds %struct.rq, ptr %8, i32 0, i32 46
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %for.cond.preheader.i
  %cpu.0.i = phi i32 [ %call3.i, %for.body.i ], [ -1, %for.cond.preheader.i ]
  %11 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %cpu.i.i, align 4
  %thread_sibling.i.i = getelementptr [4 x %struct.cpu_topology], ptr @cpu_topology, i32 0, i32 %12, i32 5
  %call3.i = tail call i32 @cpumask_next(i32 noundef %cpu.0.i, ptr noundef %thread_sibling.i.i) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %13 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.i = icmp ult i32 %call3.i, %13
  br i1 %cmp.i, label %for.body.i, label %if.end8

for.body.i:                                       ; preds = %for.cond.i
  %call4.i = tail call i32 @available_idle_cpu(i32 noundef %call3.i) #20
  %tobool.not.i = icmp eq i32 %call4.i, 0
  br i1 %tobool.not.i, label %lor.rhs.critedge.i, label %for.cond.i

lor.rhs.critedge.i:                               ; preds = %for.body.i
  %core.i = getelementptr inbounds %struct.rq, ptr %8, i32 0, i32 79
  %14 = ptrtoint ptr %core.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %core.i, align 8
  %core_cookie.i = getelementptr inbounds %struct.rq, ptr %15, i32 0, i32 86
  %16 = ptrtoint ptr %core_cookie.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %core_cookie.i, align 4
  %18 = ptrtoint ptr %core_cookie8.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %core_cookie8.i, align 16
  %cmp9.i = icmp eq i32 %17, %19
  br i1 %cmp9.i, label %if.end8, label %cleanup

if.end8:                                          ; preds = %lor.rhs.critedge.i, %for.cond.i, %land.rhs.i.i, %for.body
  %20 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %arrayidx, align 4
  %add.i = add i32 %21, ptrtoint (ptr @runqueues to i32)
  %22 = inttoptr i32 %add.i to ptr
  %nr_running.i.i = getelementptr inbounds %struct.rq, ptr %22, i32 0, i32 1
  %23 = ptrtoint ptr %nr_running.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %nr_running.i.i, align 4
  %idle_h_nr_running.i.i = getelementptr inbounds %struct.rq, ptr %22, i32 0, i32 14, i32 4
  %25 = ptrtoint ptr %idle_h_nr_running.i.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %idle_h_nr_running.i.i, align 4
  %cmp.i.i = icmp ne i32 %24, %26
  %tobool.i.i = icmp eq i32 %24, 0
  %tobool.not = or i1 %tobool.i.i, %cmp.i.i
  br i1 %tobool.not, label %if.end11, label %cleanup49

if.end11:                                         ; preds = %if.end8
  %call12 = tail call i32 @available_idle_cpu(i32 noundef %call3108) #20
  %tobool13.not = icmp eq i32 %call12, 0
  br i1 %tobool13.not, label %if.else30, label %if.then14

if.then14:                                        ; preds = %if.end11
  %call.i85 = tail call i32 @rcu_read_lock_held() #20
  %tobool.not.i86 = icmp eq i32 %call.i85, 0
  br i1 %tobool.not.i86, label %land.rhs.i, label %idle_get_state.exit

land.rhs.i:                                       ; preds = %if.then14
  %.b39.i = load i1, ptr @idle_get_state.__already_done, align 1
  br i1 %.b39.i, label %idle_get_state.exit, label %if.then.i, !prof !259

if.then.i:                                        ; preds = %land.rhs.i
  store i1 true, ptr @idle_get_state.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 2300, i32 noundef 9, ptr noundef nonnull @.str.45) #20
  br label %idle_get_state.exit

idle_get_state.exit:                              ; preds = %if.then.i, %land.rhs.i, %if.then14
  %idle_state.i = getelementptr inbounds %struct.rq, ptr %8, i32 0, i32 75
  %27 = ptrtoint ptr %idle_state.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %idle_state.i, align 4
  %tobool16.not = icmp eq ptr %28, null
  br i1 %tobool16.not, label %land.lhs.true23, label %land.lhs.true

land.lhs.true:                                    ; preds = %idle_get_state.exit
  %exit_latency = getelementptr inbounds %struct.cpuidle_state, ptr %28, i32 0, i32 5
  %29 = ptrtoint ptr %exit_latency to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %exit_latency, align 4
  %cmp17 = icmp ult i32 %30, %min_exit_latency.0105
  br i1 %cmp17, label %if.then18, label %lor.lhs.false.critedge

if.then18:                                        ; preds = %land.lhs.true
  %idle_stamp = getelementptr inbounds %struct.rq, ptr %8, i32 0, i32 54
  %31 = ptrtoint ptr %idle_stamp to i32
  call void @__asan_load8_noabort(i32 %31)
  %32 = load i64, ptr %idle_stamp, align 128
  br label %cleanup

lor.lhs.false.critedge:                           ; preds = %land.lhs.true
  %cmp22 = icmp eq i32 %30, %min_exit_latency.0105
  br i1 %cmp22, label %land.lhs.true23, label %cleanup

land.lhs.true23:                                  ; preds = %lor.lhs.false.critedge, %idle_get_state.exit
  %idle_stamp24 = getelementptr inbounds %struct.rq, ptr %8, i32 0, i32 54
  %33 = ptrtoint ptr %idle_stamp24 to i32
  call void @__asan_load8_noabort(i32 %33)
  %34 = load i64, ptr %idle_stamp24, align 128
  %cmp25 = icmp ugt i64 %34, %latest_idle_timestamp.0104
  %spec.select = select i1 %cmp25, i32 %call3108, i32 %shallowest_idle_cpu.0100
  %35 = tail call i64 @llvm.umax.i64(i64 %34, i64 %latest_idle_timestamp.0104)
  br label %cleanup

if.else30:                                        ; preds = %if.end11
  %cmp31 = icmp eq i32 %shallowest_idle_cpu.0100, -1
  br i1 %cmp31, label %do.body33, label %cleanup

do.body33:                                        ; preds = %if.else30
  %36 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load i32, ptr %arrayidx, align 4
  %add41 = add i32 %37, ptrtoint (ptr @runqueues to i32)
  %38 = inttoptr i32 %add41 to ptr
  %load_avg.i.i = getelementptr inbounds %struct.rq, ptr %38, i32 0, i32 14, i32 17, i32 5
  %39 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load i32, ptr %load_avg.i.i, align 32
  %cmp43 = icmp ult i32 %40, %min_load.0107
  %spec.select82 = select i1 %cmp43, i32 %call3108, i32 %least_loaded_cpu.0103
  %41 = tail call i32 @llvm.umin.i32(i32 %40, i32 %min_load.0107)
  br label %cleanup

cleanup:                                          ; preds = %do.body33, %if.else30, %land.lhs.true23, %lor.lhs.false.critedge, %if.then18, %lor.rhs.critedge.i
  %shallowest_idle_cpu.3 = phi i32 [ %shallowest_idle_cpu.0100, %if.else30 ], [ %call3108, %if.then18 ], [ %shallowest_idle_cpu.0100, %lor.lhs.false.critedge ], [ %spec.select, %land.lhs.true23 ], [ -1, %do.body33 ], [ %shallowest_idle_cpu.0100, %lor.rhs.critedge.i ]
  %least_loaded_cpu.2 = phi i32 [ %least_loaded_cpu.0103, %if.else30 ], [ %least_loaded_cpu.0103, %if.then18 ], [ %least_loaded_cpu.0103, %lor.lhs.false.critedge ], [ %least_loaded_cpu.0103, %land.lhs.true23 ], [ %spec.select82, %do.body33 ], [ %least_loaded_cpu.0103, %lor.rhs.critedge.i ]
  %latest_idle_timestamp.3 = phi i64 [ %latest_idle_timestamp.0104, %if.else30 ], [ %32, %if.then18 ], [ %latest_idle_timestamp.0104, %lor.lhs.false.critedge ], [ %35, %land.lhs.true23 ], [ %latest_idle_timestamp.0104, %do.body33 ], [ %latest_idle_timestamp.0104, %lor.rhs.critedge.i ]
  %min_exit_latency.3 = phi i32 [ %min_exit_latency.0105, %if.else30 ], [ %30, %if.then18 ], [ %min_exit_latency.0105, %lor.lhs.false.critedge ], [ %min_exit_latency.0105, %land.lhs.true23 ], [ %min_exit_latency.0105, %do.body33 ], [ %min_exit_latency.0105, %lor.rhs.critedge.i ]
  %min_load.2 = phi i32 [ %min_load.0107, %if.else30 ], [ %min_load.0107, %if.then18 ], [ %min_load.0107, %lor.lhs.false.critedge ], [ %min_load.0107, %land.lhs.true23 ], [ %41, %do.body33 ], [ %min_load.0107, %lor.rhs.critedge.i ]
  %42 = ptrtoint ptr %cpus_ptr to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load ptr, ptr %cpus_ptr, align 4
  %call3 = tail call i32 @cpumask_next_and(i32 noundef %call3108, ptr noundef %cpumask.i, ptr noundef %43) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %44 = load i32, ptr @nr_cpu_ids, align 4
  %cmp4 = icmp ult i32 %call3, %44
  br i1 %cmp4, label %for.body, label %for.end

for.end:                                          ; preds = %cleanup
  %cmp48.not = icmp eq i32 %shallowest_idle_cpu.3, -1
  br i1 %cmp48.not, label %for.end.thread, label %cleanup49

for.end.thread:                                   ; preds = %for.end, %for.cond.preheader
  %least_loaded_cpu.0.lcssa115 = phi i32 [ %least_loaded_cpu.2, %for.end ], [ %this_cpu, %for.cond.preheader ]
  br label %cleanup49

cleanup49:                                        ; preds = %for.end.thread, %for.end, %if.end8, %if.then
  %retval.2 = phi i32 [ %call.i, %if.then ], [ %least_loaded_cpu.0.lcssa115, %for.end.thread ], [ %shallowest_idle_cpu.3, %for.end ], [ %call3108, %if.end8 ]
  ret i32 %retval.2
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__bitmap_intersects(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @update_sg_wakeup_stats(ptr nocapture noundef readonly %sd, ptr noundef readonly %group, ptr noundef %sgs, ptr noundef %p) unnamed_addr #7 align 64 {
entry:
  %ue.sroa.0.i.i.i.i = alloca i32, align 8
  %ue.sroa.5.i.i.i.i = alloca i32, align 4
  %ue.sroa.0.i.i = alloca i32, align 8
  %ue.sroa.5.i.i = alloca i32, align 4
  %0 = call ptr @memset(ptr %sgs, i32 0, i32 48)
  %cpumask.i = getelementptr inbounds %struct.sched_group, ptr %group, i32 0, i32 6
  %call1114 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef %cpumask.i) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %1 = load i32, ptr @nr_cpu_ids, align 4
  %cmp115 = icmp ult i32 %call1114, %1
  br i1 %cmp115, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %entry
  %stack.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 1
  %avg.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15
  %cfs_rq.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %load_avg.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 5
  %group_load = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 1
  %util_avg.i85.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 7
  %on_rq.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 12
  %util_est.i86.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9
  %ue.sroa.5.0.util_est.sroa_idx.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9, i32 1
  %group_util = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 3
  %runnable_avg11.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 6
  %group_runnable = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 4
  %sum_h_nr_running = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 6
  %sum_nr_running = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 5
  %idle_cpus = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 7
  br label %for.body

for.body:                                         ; preds = %if.end, %for.body.lr.ph
  %call1116 = phi i32 [ %call1114, %for.body.lr.ph ], [ %call1, %if.end ]
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call1116
  %2 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %arrayidx, align 4
  %add = add i32 %3, ptrtoint (ptr @runqueues to i32)
  %4 = inttoptr i32 %add to ptr
  %cpu.i.i = getelementptr inbounds %struct.rq, ptr %4, i32 0, i32 46
  %5 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %cpu.i.i, align 4
  %7 = ptrtoint ptr %stack.i.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %stack.i.i, align 4
  %cpu.i24.i = getelementptr inbounds %struct.thread_info, ptr %8, i32 0, i32 3
  %9 = ptrtoint ptr %cpu.i24.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load volatile i32, ptr %cpu.i24.i, align 4
  %cmp.not.i = icmp eq i32 %6, %10
  br i1 %cmp.not.i, label %do.end.i, label %if.then.i

do.end.i:                                         ; preds = %for.body
  %11 = ptrtoint ptr %avg.i to i32
  call void @__asan_load8_noabort(i32 %11)
  %12 = load volatile i64, ptr %avg.i, align 128
  %tobool.not.i = icmp eq i64 %12, 0
  br i1 %tobool.not.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %do.end.i, %for.body
  %load_avg.i.i.i = getelementptr inbounds %struct.rq, ptr %4, i32 0, i32 14, i32 17, i32 5
  %13 = ptrtoint ptr %load_avg.i.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %load_avg.i.i.i, align 32
  br label %cpu_load_without.exit

if.end.i:                                         ; preds = %do.end.i
  %load_avg.i = getelementptr inbounds %struct.rq, ptr %4, i32 0, i32 14, i32 17, i32 5
  %15 = ptrtoint ptr %load_avg.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %load_avg.i, align 32
  %17 = ptrtoint ptr %cfs_rq.i.i.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %cfs_rq.i.i.i, align 16
  %rq.i.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %18, i32 0, i32 27
  %19 = ptrtoint ptr %rq.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %rq.i.i.i.i, align 4
  %tg.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %18, i32 0, i32 30
  %21 = ptrtoint ptr %tg.i.i.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %tg.i.i.i, align 4
  %se1.i.i.i = getelementptr inbounds %struct.task_group, ptr %22, i32 0, i32 1
  %23 = ptrtoint ptr %se1.i.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %se1.i.i.i, align 8
  %cpu.i.i.i.i = getelementptr inbounds %struct.rq, ptr %20, i32 0, i32 46
  %25 = ptrtoint ptr %cpu.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %cpu.i.i.i.i, align 4
  %arrayidx.i.i.i = getelementptr ptr, ptr %24, i32 %26
  %27 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %arrayidx.i.i.i, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %29 = load volatile i32, ptr @jiffies, align 128
  %last_h_load_update.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %18, i32 0, i32 25
  %30 = ptrtoint ptr %last_h_load_update.i.i.i to i32
  call void @__asan_load8_noabort(i32 %30)
  %31 = load i64, ptr %last_h_load_update.i.i.i, align 16
  %conv.i.i.i = zext i32 %29 to i64
  %cmp.i.i.i = icmp eq i64 %31, %conv.i.i.i
  br i1 %cmp.i.i.i, label %task_h_load.exit.i, label %do.body5.i.i.i

do.body5.i.i.i:                                   ; preds = %if.end.i
  %h_load_next.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %18, i32 0, i32 26
  %32 = ptrtoint ptr %h_load_next.i.i.i to i32
  call void @__asan_store4_noabort(i32 %32)
  store volatile ptr null, ptr %h_load_next.i.i.i, align 8
  %tobool.not82.i.i.i = icmp eq ptr %28, null
  br i1 %tobool.not82.i.i.i, label %if.then28.i.i.i, label %for.body.i.i.i

for.body.i.i.i:                                   ; preds = %for.inc.i.i.i, %do.body5.i.i.i
  %se.083.i.i.i = phi ptr [ %39, %for.inc.i.i.i ], [ %28, %do.body5.i.i.i ]
  %cfs_rq.i.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.083.i.i.i, i32 0, i32 11
  %33 = ptrtoint ptr %cfs_rq.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load ptr, ptr %cfs_rq.i.i.i.i, align 16
  %h_load_next16.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %34, i32 0, i32 26
  %35 = ptrtoint ptr %h_load_next16.i.i.i to i32
  call void @__asan_store4_noabort(i32 %35)
  store volatile ptr %se.083.i.i.i, ptr %h_load_next16.i.i.i, align 8
  %last_h_load_update21.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %34, i32 0, i32 25
  %36 = ptrtoint ptr %last_h_load_update21.i.i.i to i32
  call void @__asan_load8_noabort(i32 %36)
  %37 = load i64, ptr %last_h_load_update21.i.i.i, align 16
  %cmp23.i.i.i = icmp eq i64 %37, %conv.i.i.i
  br i1 %cmp23.i.i.i, label %if.end32.i.i.i, label %for.inc.i.i.i

for.inc.i.i.i:                                    ; preds = %for.body.i.i.i
  %parent.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.083.i.i.i, i32 0, i32 10
  %38 = ptrtoint ptr %parent.i.i.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load ptr, ptr %parent.i.i.i, align 4
  %tobool.not.i.i.i = icmp eq ptr %39, null
  br i1 %tobool.not.i.i.i, label %if.then28.i.i.i, label %for.body.i.i.i

if.then28.i.i.i:                                  ; preds = %for.inc.i.i.i, %do.body5.i.i.i
  %cfs_rq.addr.0.lcssa.i.i.i = phi ptr [ %18, %do.body5.i.i.i ], [ %34, %for.inc.i.i.i ]
  %load_avg.i.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.0.lcssa.i.i.i, i32 0, i32 17, i32 5
  %40 = ptrtoint ptr %load_avg.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %load_avg.i.i.i.i, align 32
  %h_load.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.0.lcssa.i.i.i, i32 0, i32 24
  %42 = ptrtoint ptr %h_load.i.i.i to i32
  call void @__asan_store4_noabort(i32 %42)
  store i32 %41, ptr %h_load.i.i.i, align 4
  %last_h_load_update31.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.0.lcssa.i.i.i, i32 0, i32 25
  %43 = ptrtoint ptr %last_h_load_update31.i.i.i to i32
  call void @__asan_store8_noabort(i32 %43)
  store i64 %conv.i.i.i, ptr %last_h_load_update31.i.i.i, align 16
  br label %if.end32.i.i.i

if.end32.i.i.i:                                   ; preds = %if.then28.i.i.i, %for.body.i.i.i
  %cfs_rq.addr.176.i.i.i = phi ptr [ %cfs_rq.addr.0.lcssa.i.i.i, %if.then28.i.i.i ], [ %34, %for.body.i.i.i ]
  %h_load_next3684.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.176.i.i.i, i32 0, i32 26
  %44 = ptrtoint ptr %h_load_next3684.i.i.i to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load volatile ptr, ptr %h_load_next3684.i.i.i, align 8
  %cmp37.not85.i.i.i = icmp eq ptr %45, null
  br i1 %cmp37.not85.i.i.i, label %task_h_load.exit.i, label %div_u64.exit.i.i.i

div_u64.exit.i.i.i:                               ; preds = %div_u64.exit.i.i.i, %if.end32.i.i.i
  %46 = phi ptr [ %58, %div_u64.exit.i.i.i ], [ %45, %if.end32.i.i.i ]
  %cfs_rq.addr.286.i.i.i = phi ptr [ %54, %div_u64.exit.i.i.i ], [ %cfs_rq.addr.176.i.i.i, %if.end32.i.i.i ]
  %load_avg.i.i25.i = getelementptr inbounds %struct.sched_entity, ptr %46, i32 0, i32 15, i32 5
  %47 = ptrtoint ptr %load_avg.i.i25.i to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load i32, ptr %load_avg.i.i25.i, align 32
  %h_load39.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.286.i.i.i, i32 0, i32 24
  %49 = ptrtoint ptr %h_load39.i.i.i to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load i32, ptr %h_load39.i.i.i, align 4
  %mul.i.i.i = mul i32 %48, %50
  %load_avg.i74.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq.addr.286.i.i.i, i32 0, i32 17, i32 5
  %51 = ptrtoint ptr %load_avg.i74.i.i.i to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load i32, ptr %load_avg.i74.i.i.i, align 32
  %add.i.i.i = add i32 %52, 1
  %div172.i.i.i.i.i = udiv i32 %mul.i.i.i, %add.i.i.i
  %my_q.i.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %46, i32 0, i32 12
  %53 = ptrtoint ptr %my_q.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load ptr, ptr %my_q.i.i.i.i, align 4
  %h_load45.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %54, i32 0, i32 24
  %55 = ptrtoint ptr %h_load45.i.i.i to i32
  call void @__asan_store4_noabort(i32 %55)
  store i32 %div172.i.i.i.i.i, ptr %h_load45.i.i.i, align 4
  %last_h_load_update47.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %54, i32 0, i32 25
  %56 = ptrtoint ptr %last_h_load_update47.i.i.i to i32
  call void @__asan_store8_noabort(i32 %56)
  store i64 %conv.i.i.i, ptr %last_h_load_update47.i.i.i, align 16
  %h_load_next36.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %54, i32 0, i32 26
  %57 = ptrtoint ptr %h_load_next36.i.i.i to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load volatile ptr, ptr %h_load_next36.i.i.i, align 8
  %cmp37.not.i.i.i = icmp eq ptr %58, null
  br i1 %cmp37.not.i.i.i, label %task_h_load.exit.i, label %div_u64.exit.i.i.i

task_h_load.exit.i:                               ; preds = %div_u64.exit.i.i.i, %if.end32.i.i.i, %if.end.i
  %h_load.i.i = getelementptr inbounds %struct.cfs_rq, ptr %18, i32 0, i32 24
  %59 = ptrtoint ptr %h_load.i.i to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load i32, ptr %h_load.i.i, align 4
  %61 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load i32, ptr %load_avg.i.i, align 32
  %mul.i.i = mul i32 %60, %62
  %load_avg.i7.i.i = getelementptr inbounds %struct.cfs_rq, ptr %18, i32 0, i32 17, i32 5
  %63 = ptrtoint ptr %load_avg.i7.i.i to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load i32, ptr %load_avg.i7.i.i, align 32
  %add.i.i = add i32 %64, 1
  %div172.i.i.i.i = udiv i32 %mul.i.i, %add.i.i
  %65 = tail call i32 @llvm.usub.sat.i32(i32 %16, i32 %div172.i.i.i.i) #20
  br label %cpu_load_without.exit

cpu_load_without.exit:                            ; preds = %task_h_load.exit.i, %if.then.i
  %retval.0.i = phi i32 [ %14, %if.then.i ], [ %65, %task_h_load.exit.i ]
  %66 = ptrtoint ptr %group_load to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load i32, ptr %group_load, align 4
  %add4 = add i32 %67, %retval.0.i
  store i32 %add4, ptr %group_load, align 4
  %68 = ptrtoint ptr %stack.i.i to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load ptr, ptr %stack.i.i, align 4
  %cpu.i.i70 = getelementptr inbounds %struct.thread_info, ptr %69, i32 0, i32 3
  %70 = ptrtoint ptr %cpu.i.i70 to i32
  call void @__asan_load4_noabort(i32 %70)
  %71 = load volatile i32, ptr %cpu.i.i70, align 4
  %cmp.not.i71 = icmp eq i32 %71, %call1116
  br i1 %cmp.not.i71, label %do.end.i74, label %if.then.i76

do.end.i74:                                       ; preds = %cpu_load_without.exit
  %72 = ptrtoint ptr %avg.i to i32
  call void @__asan_load8_noabort(i32 %72)
  %73 = load volatile i64, ptr %avg.i, align 128
  %tobool.not.i73 = icmp eq i64 %73, 0
  br i1 %tobool.not.i73, label %if.then.i76, label %do.body2.i

if.then.i76:                                      ; preds = %do.end.i74, %cpu_load_without.exit
  %74 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %74)
  %75 = load i32, ptr %arrayidx, align 4
  %add.i.i75 = add i32 %75, ptrtoint (ptr @runqueues to i32)
  %76 = inttoptr i32 %add.i.i75 to ptr
  %util_avg.i.i = getelementptr inbounds %struct.rq, ptr %76, i32 0, i32 14, i32 17, i32 7
  %77 = ptrtoint ptr %util_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %77)
  %78 = load volatile i32, ptr %util_avg.i.i, align 8
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 20), i32 1), ptr blockaddress(@update_sg_wakeup_stats, %cpu_util_without.exit)) #20
          to label %if.then.i.i [label %cpu_util_without.exit], !srcloc !261

if.then.i.i:                                      ; preds = %if.then.i76
  %util_est.i.i = getelementptr inbounds %struct.rq, ptr %76, i32 0, i32 14, i32 17, i32 9
  %79 = ptrtoint ptr %util_est.i.i to i32
  call void @__asan_load4_noabort(i32 %79)
  %80 = load volatile i32, ptr %util_est.i.i, align 16
  %81 = tail call i32 @llvm.umax.i32(i32 %78, i32 %80) #20
  br label %cpu_util_without.exit

do.body2.i:                                       ; preds = %do.end.i74
  %82 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %82)
  %83 = load i32, ptr %arrayidx, align 4
  %add.i = add i32 %83, ptrtoint (ptr @runqueues to i32)
  %84 = inttoptr i32 %add.i to ptr
  %util_avg.i = getelementptr inbounds %struct.rq, ptr %84, i32 0, i32 14, i32 17, i32 7
  %85 = ptrtoint ptr %util_avg.i to i32
  call void @__asan_load4_noabort(i32 %85)
  %86 = load volatile i32, ptr %util_avg.i, align 8
  %87 = ptrtoint ptr %util_avg.i85.i to i32
  call void @__asan_load4_noabort(i32 %87)
  %88 = load volatile i32, ptr %util_avg.i85.i, align 8
  %89 = tail call i32 @llvm.usub.sat.i32(i32 %86, i32 %88) #20
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 20), i32 1), ptr blockaddress(@update_sg_wakeup_stats, %cpu_util_without.exit)) #20
          to label %if.then19.i [label %cpu_util_without.exit], !srcloc !261

if.then19.i:                                      ; preds = %do.body2.i
  %util_est.i = getelementptr inbounds %struct.rq, ptr %84, i32 0, i32 14, i32 17, i32 9
  %90 = ptrtoint ptr %util_est.i to i32
  call void @__asan_load4_noabort(i32 %90)
  %91 = load volatile i32, ptr %util_est.i, align 16
  %92 = ptrtoint ptr %on_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %92)
  %93 = load i32, ptr %on_rq.i.i, align 4
  %cmp.i.not.i = icmp eq i32 %93, 1
  br i1 %cmp.i.not.i, label %do.body32.i, label %lor.rhs.i, !prof !260

lor.rhs.i:                                        ; preds = %if.then19.i
  %94 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i = and i32 %94, -16384
  %95 = inttoptr i32 %and.i.i to ptr
  %task.i = getelementptr inbounds %struct.thread_info, ptr %95, i32 0, i32 2
  %96 = ptrtoint ptr %task.i to i32
  call void @__asan_load4_noabort(i32 %96)
  %97 = load ptr, ptr %task.i, align 8
  %cmp28.i = icmp eq ptr %97, %p
  br i1 %cmp28.i, label %do.body32.i, label %if.end44.i, !prof !260

do.body32.i:                                      ; preds = %lor.rhs.i, %if.then19.i
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.0.i.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.5.i.i)
  %98 = ptrtoint ptr %util_est.i86.i to i32
  call void @__asan_load4_noabort(i32 %98)
  %ue.sroa.0.0.copyload.i.i = load volatile i32, ptr %util_est.i86.i, align 16
  %99 = ptrtoint ptr %ue.sroa.0.i.i to i32
  call void @__asan_store4_noabort(i32 %99)
  store volatile i32 %ue.sroa.0.0.copyload.i.i, ptr %ue.sroa.0.i.i, align 8
  %100 = ptrtoint ptr %ue.sroa.5.0.util_est.sroa_idx.i.i to i32
  call void @__asan_load4_noabort(i32 %100)
  %ue.sroa.5.0.copyload.i.i = load volatile i32, ptr %ue.sroa.5.0.util_est.sroa_idx.i.i, align 4
  %101 = ptrtoint ptr %ue.sroa.5.i.i to i32
  call void @__asan_store4_noabort(i32 %101)
  store volatile i32 %ue.sroa.5.0.copyload.i.i, ptr %ue.sroa.5.i.i, align 4
  %and.i87.i = and i32 %ue.sroa.0.0.copyload.i.i, 2147483647
  %102 = tail call i32 @llvm.umax.i32(i32 %ue.sroa.5.0.copyload.i.i, i32 %and.i87.i) #20
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.0.i.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.5.i.i)
  %103 = tail call i32 @llvm.usub.sat.i32(i32 %91, i32 %102) #20
  br label %if.end44.i

if.end44.i:                                       ; preds = %do.body32.i, %lor.rhs.i
  %estimated.0.i = phi i32 [ %103, %do.body32.i ], [ %91, %lor.rhs.i ]
  %104 = tail call i32 @llvm.umax.i32(i32 %89, i32 %estimated.0.i) #20
  br label %cpu_util_without.exit

cpu_util_without.exit:                            ; preds = %if.end44.i, %do.body2.i, %if.then.i.i, %if.then.i76
  %util.0.i.i.sink = phi i32 [ %81, %if.then.i.i ], [ %78, %if.then.i76 ], [ %104, %if.end44.i ], [ %89, %do.body2.i ]
  %105 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %105)
  %106 = load i32, ptr %arrayidx, align 4
  %add.i.i.i77 = add i32 %106, ptrtoint (ptr @runqueues to i32)
  %107 = inttoptr i32 %add.i.i.i77 to ptr
  %cpu_capacity_orig.i.i.i = getelementptr inbounds %struct.rq, ptr %107, i32 0, i32 38
  %108 = ptrtoint ptr %cpu_capacity_orig.i.i.i to i32
  call void @__asan_load4_noabort(i32 %108)
  %109 = load i32, ptr %cpu_capacity_orig.i.i.i, align 4
  %110 = tail call i32 @llvm.umin.i32(i32 %util.0.i.i.sink, i32 %109) #20
  %111 = ptrtoint ptr %group_util to i32
  call void @__asan_load4_noabort(i32 %111)
  %112 = load i32, ptr %group_util, align 4
  %add6 = add i32 %112, %110
  store i32 %add6, ptr %group_util, align 4
  %113 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %113)
  %114 = load i32, ptr %cpu.i.i, align 4
  %115 = ptrtoint ptr %stack.i.i to i32
  call void @__asan_load4_noabort(i32 %115)
  %116 = load ptr, ptr %stack.i.i, align 4
  %cpu.i27.i = getelementptr inbounds %struct.thread_info, ptr %116, i32 0, i32 3
  %117 = ptrtoint ptr %cpu.i27.i to i32
  call void @__asan_load4_noabort(i32 %117)
  %118 = load volatile i32, ptr %cpu.i27.i, align 4
  %cmp.not.i81 = icmp eq i32 %114, %118
  br i1 %cmp.not.i81, label %do.end.i84, label %if.then.i85

do.end.i84:                                       ; preds = %cpu_util_without.exit
  %119 = ptrtoint ptr %avg.i to i32
  call void @__asan_load8_noabort(i32 %119)
  %120 = load volatile i64, ptr %avg.i, align 128
  %tobool.not.i83 = icmp eq i64 %120, 0
  br i1 %tobool.not.i83, label %if.then.i85, label %if.end.i86

if.then.i85:                                      ; preds = %do.end.i84, %cpu_util_without.exit
  %runnable_avg.i.i.i = getelementptr inbounds %struct.rq, ptr %4, i32 0, i32 14, i32 17, i32 6
  %121 = ptrtoint ptr %runnable_avg.i.i.i to i32
  call void @__asan_load4_noabort(i32 %121)
  %122 = load i32, ptr %runnable_avg.i.i.i, align 4
  br label %cpu_runnable_without.exit

if.end.i86:                                       ; preds = %do.end.i84
  %runnable_avg.i = getelementptr inbounds %struct.rq, ptr %4, i32 0, i32 14, i32 17, i32 6
  %123 = ptrtoint ptr %runnable_avg.i to i32
  call void @__asan_load4_noabort(i32 %123)
  %124 = load volatile i32, ptr %runnable_avg.i, align 4
  %125 = ptrtoint ptr %runnable_avg11.i to i32
  call void @__asan_load4_noabort(i32 %125)
  %126 = load i32, ptr %runnable_avg11.i, align 4
  %127 = tail call i32 @llvm.usub.sat.i32(i32 %124, i32 %126) #20
  br label %cpu_runnable_without.exit

cpu_runnable_without.exit:                        ; preds = %if.end.i86, %if.then.i85
  %retval.0.i87 = phi i32 [ %122, %if.then.i85 ], [ %127, %if.end.i86 ]
  %128 = ptrtoint ptr %group_runnable to i32
  call void @__asan_load4_noabort(i32 %128)
  %129 = load i32, ptr %group_runnable, align 4
  %add8 = add i32 %129, %retval.0.i87
  store i32 %add8, ptr %group_runnable, align 4
  %130 = ptrtoint ptr %stack.i.i to i32
  call void @__asan_load4_noabort(i32 %130)
  %131 = load ptr, ptr %stack.i.i, align 4
  %cpu.i.i89 = getelementptr inbounds %struct.thread_info, ptr %131, i32 0, i32 3
  %132 = ptrtoint ptr %cpu.i.i89 to i32
  call void @__asan_load4_noabort(i32 %132)
  %133 = load volatile i32, ptr %cpu.i.i89, align 4
  %cmp.not.i90 = icmp eq i32 %133, %call1116
  br i1 %cmp.not.i90, label %do.end.i93, label %task_running_on_cpu.exit

do.end.i93:                                       ; preds = %cpu_runnable_without.exit
  %134 = ptrtoint ptr %avg.i to i32
  call void @__asan_load8_noabort(i32 %134)
  %135 = load volatile i64, ptr %avg.i, align 128
  %tobool.not.i92 = icmp eq i64 %135, 0
  br i1 %tobool.not.i92, label %task_running_on_cpu.exit, label %if.end.i96

if.end.i96:                                       ; preds = %do.end.i93
  %136 = ptrtoint ptr %on_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %136)
  %137 = load i32, ptr %on_rq.i.i, align 4
  %cmp.i.not.i95 = icmp eq i32 %137, 1
  %..i = zext i1 %cmp.i.not.i95 to i32
  br label %task_running_on_cpu.exit

task_running_on_cpu.exit:                         ; preds = %if.end.i96, %do.end.i93, %cpu_runnable_without.exit
  %retval.0.i97 = phi i32 [ 0, %do.end.i93 ], [ 0, %cpu_runnable_without.exit ], [ %..i, %if.end.i96 ]
  %h_nr_running = getelementptr inbounds %struct.rq, ptr %4, i32 0, i32 14, i32 2
  %138 = ptrtoint ptr %h_nr_running to i32
  call void @__asan_load4_noabort(i32 %138)
  %139 = load i32, ptr %h_nr_running, align 4
  %sub = sub i32 %139, %retval.0.i97
  %140 = ptrtoint ptr %sum_h_nr_running to i32
  call void @__asan_load4_noabort(i32 %140)
  %141 = load i32, ptr %sum_h_nr_running, align 4
  %add10 = add i32 %sub, %141
  store i32 %add10, ptr %sum_h_nr_running, align 4
  %nr_running11 = getelementptr inbounds %struct.rq, ptr %4, i32 0, i32 1
  %142 = ptrtoint ptr %nr_running11 to i32
  call void @__asan_load4_noabort(i32 %142)
  %143 = load i32, ptr %nr_running11, align 4
  %sub12 = sub i32 %143, %retval.0.i97
  %144 = ptrtoint ptr %sum_nr_running to i32
  call void @__asan_load4_noabort(i32 %144)
  %145 = load i32, ptr %sum_nr_running, align 4
  %add13 = add i32 %sub12, %145
  store i32 %add13, ptr %sum_nr_running, align 4
  %tobool.not = icmp eq i32 %143, %retval.0.i97
  br i1 %tobool.not, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %task_running_on_cpu.exit
  %146 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %146)
  %147 = load i32, ptr %arrayidx, align 4
  %add.i99 = add i32 %147, ptrtoint (ptr @runqueues to i32)
  %148 = inttoptr i32 %add.i99 to ptr
  %curr.i = getelementptr inbounds %struct.rq, ptr %148, i32 0, i32 20
  %149 = ptrtoint ptr %curr.i to i32
  call void @__asan_load4_noabort(i32 %149)
  %150 = load ptr, ptr %curr.i, align 8
  %idle.i = getelementptr inbounds %struct.rq, ptr %148, i32 0, i32 21
  %151 = ptrtoint ptr %idle.i to i32
  call void @__asan_load4_noabort(i32 %151)
  %152 = load ptr, ptr %idle.i, align 4
  %cmp.not.i100 = icmp eq ptr %150, %152
  %cmp3.not.i = icmp eq ptr %150, %p
  %or.cond.i = or i1 %cmp3.not.i, %cmp.not.i100
  br i1 %or.cond.i, label %idle_cpu_without.exit, label %if.end

idle_cpu_without.exit:                            ; preds = %land.lhs.true
  %ttwu_pending.i = getelementptr inbounds %struct.rq, ptr %148, i32 0, i32 8
  %153 = ptrtoint ptr %ttwu_pending.i to i32
  call void @__asan_load4_noabort(i32 %153)
  %154 = load i32, ptr %ttwu_pending.i, align 8
  %tobool.not.i101.not = icmp eq i32 %154, 0
  br i1 %tobool.not.i101.not, label %if.then, label %if.end

if.then:                                          ; preds = %idle_cpu_without.exit
  %155 = ptrtoint ptr %idle_cpus to i32
  call void @__asan_load4_noabort(i32 %155)
  %156 = load i32, ptr %idle_cpus, align 4
  %inc = add i32 %156, 1
  store i32 %inc, ptr %idle_cpus, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %idle_cpu_without.exit, %land.lhs.true, %task_running_on_cpu.exit
  %call1 = tail call i32 @cpumask_next(i32 noundef %call1116, ptr noundef %cpumask.i) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %157 = load i32, ptr @nr_cpu_ids, align 4
  %cmp = icmp ult i32 %call1, %157
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %if.end, %entry
  %flags = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 9
  %158 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %158)
  %159 = load i32, ptr %flags, align 4
  %and = and i32 %159, 32
  %tobool16.not = icmp eq i32 %and, 0
  br i1 %tobool16.not, label %if.end21, label %land.lhs.true17

land.lhs.true17:                                  ; preds = %for.end
  %sgc = getelementptr inbounds %struct.sched_group, ptr %group, i32 0, i32 3
  %160 = ptrtoint ptr %sgc to i32
  call void @__asan_load4_noabort(i32 %160)
  %161 = load ptr, ptr %sgc, align 4
  %max_capacity = getelementptr inbounds %struct.sched_group_capacity, ptr %161, i32 0, i32 3
  %162 = ptrtoint ptr %max_capacity to i32
  call void @__asan_load4_noabort(i32 %162)
  %163 = load i32, ptr %max_capacity, align 4
  %util_avg.i.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 7
  %164 = ptrtoint ptr %util_avg.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %164)
  %165 = load volatile i32, ptr %util_avg.i.i.i.i, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.0.i.i.i.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %ue.sroa.5.i.i.i.i)
  %util_est.i.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9
  %166 = ptrtoint ptr %util_est.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %166)
  %ue.sroa.0.0.copyload.i.i.i.i = load volatile i32, ptr %util_est.i.i.i.i, align 16
  %167 = ptrtoint ptr %ue.sroa.0.i.i.i.i to i32
  call void @__asan_store4_noabort(i32 %167)
  store volatile i32 %ue.sroa.0.0.copyload.i.i.i.i, ptr %ue.sroa.0.i.i.i.i, align 8
  %ue.sroa.5.0.util_est.sroa_idx.i.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15, i32 9, i32 1
  %168 = ptrtoint ptr %ue.sroa.5.0.util_est.sroa_idx.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %168)
  %ue.sroa.5.0.copyload.i.i.i.i = load volatile i32, ptr %ue.sroa.5.0.util_est.sroa_idx.i.i.i.i, align 4
  %169 = ptrtoint ptr %ue.sroa.5.i.i.i.i to i32
  call void @__asan_store4_noabort(i32 %169)
  store volatile i32 %ue.sroa.5.0.copyload.i.i.i.i, ptr %ue.sroa.5.i.i.i.i, align 4
  %and.i.i.i.i = and i32 %ue.sroa.0.0.copyload.i.i.i.i, 2147483647
  %170 = tail call i32 @llvm.umax.i32(i32 %ue.sroa.5.0.copyload.i.i.i.i, i32 %and.i.i.i.i) #20
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.0.i.i.i.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %ue.sroa.5.i.i.i.i)
  %171 = tail call i32 @llvm.umax.i32(i32 %165, i32 %170) #20
  %call1.i.i = tail call i32 @uclamp_eff_value(ptr noundef %p, i32 noundef 0) #20
  %172 = tail call i32 @llvm.umax.i32(i32 %171, i32 %call1.i.i) #20
  %call2.i.i = tail call i32 @uclamp_eff_value(ptr noundef %p, i32 noundef 1) #20
  %173 = tail call i32 @llvm.umin.i32(i32 %172, i32 %call2.i.i) #20
  %mul.i = mul i32 %173, 1280
  %mul1.i = shl i32 %163, 10
  %cmp.i.not = icmp ult i32 %mul.i, %mul1.i
  br i1 %cmp.i.not, label %if.end21, label %if.then20

if.then20:                                        ; preds = %land.lhs.true17
  %group_misfit_task_load = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 11
  %174 = ptrtoint ptr %group_misfit_task_load to i32
  call void @__asan_store4_noabort(i32 %174)
  store i32 1, ptr %group_misfit_task_load, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %land.lhs.true17, %for.end
  %sgc22 = getelementptr inbounds %struct.sched_group, ptr %group, i32 0, i32 3
  %175 = ptrtoint ptr %sgc22 to i32
  call void @__asan_load4_noabort(i32 %175)
  %176 = load ptr, ptr %sgc22, align 4
  %capacity = getelementptr inbounds %struct.sched_group_capacity, ptr %176, i32 0, i32 1
  %177 = ptrtoint ptr %capacity to i32
  call void @__asan_load4_noabort(i32 %177)
  %178 = load i32, ptr %capacity, align 4
  %group_capacity = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 2
  %179 = ptrtoint ptr %group_capacity to i32
  call void @__asan_store4_noabort(i32 %179)
  store i32 %178, ptr %group_capacity, align 4
  %group_weight = getelementptr inbounds %struct.sched_group, ptr %group, i32 0, i32 2
  %180 = ptrtoint ptr %group_weight to i32
  call void @__asan_load4_noabort(i32 %180)
  %181 = load i32, ptr %group_weight, align 4
  %group_weight23 = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 8
  %182 = ptrtoint ptr %group_weight23 to i32
  call void @__asan_store4_noabort(i32 %182)
  store i32 %181, ptr %group_weight23, align 4
  %imbalance_pct = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 6
  %183 = ptrtoint ptr %imbalance_pct to i32
  call void @__asan_load4_noabort(i32 %183)
  %184 = load i32, ptr %imbalance_pct, align 8
  %sum_nr_running.i.i = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 5
  %185 = ptrtoint ptr %sum_nr_running.i.i to i32
  call void @__asan_load4_noabort(i32 %185)
  %186 = load i32, ptr %sum_nr_running.i.i, align 4
  %cmp.not.i.i = icmp ugt i32 %186, %181
  br i1 %cmp.not.i.i, label %if.end.i.i, label %if.end.i107

if.end.i.i:                                       ; preds = %if.end21
  %mul.i.i105 = mul i32 %178, 100
  %group_util.i.i = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 3
  %187 = ptrtoint ptr %group_util.i.i to i32
  call void @__asan_load4_noabort(i32 %187)
  %188 = load i32, ptr %group_util.i.i, align 4
  %mul1.i.i = mul i32 %188, %184
  %cmp2.i.i = icmp ult i32 %mul.i.i105, %mul1.i.i
  br i1 %cmp2.i.i, label %if.then29, label %group_is_overloaded.exit.i

group_is_overloaded.exit.i:                       ; preds = %if.end.i.i
  %mul6.i.i = mul i32 %184, %178
  %group_runnable.i.i = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 4
  %189 = ptrtoint ptr %group_runnable.i.i to i32
  call void @__asan_load4_noabort(i32 %189)
  %190 = load i32, ptr %group_runnable.i.i, align 4
  %mul7.i.i = mul i32 %190, 100
  %cmp8.i.i = icmp ult i32 %mul6.i.i, %mul7.i.i
  br i1 %cmp8.i.i, label %if.then29, label %if.end.i107

if.end.i107:                                      ; preds = %group_is_overloaded.exit.i, %if.end21
  %191 = ptrtoint ptr %sgc22 to i32
  call void @__asan_load4_noabort(i32 %191)
  %192 = load ptr, ptr %sgc22, align 4
  %imbalance.i.i = getelementptr inbounds %struct.sched_group_capacity, ptr %192, i32 0, i32 5
  %193 = ptrtoint ptr %imbalance.i.i to i32
  call void @__asan_load4_noabort(i32 %193)
  %194 = load i32, ptr %imbalance.i.i, align 4
  %tobool.not.i106 = icmp eq i32 %194, 0
  br i1 %tobool.not.i106, label %if.end3.i, label %group_classify.exit.thread

if.end3.i:                                        ; preds = %if.end.i107
  %group_asym_packing.i = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 10
  %195 = ptrtoint ptr %group_asym_packing.i to i32
  call void @__asan_load4_noabort(i32 %195)
  %196 = load i32, ptr %group_asym_packing.i, align 4
  %tobool4.not.i = icmp eq i32 %196, 0
  br i1 %tobool4.not.i, label %if.end6.i, label %group_classify.exit.thread

if.end6.i:                                        ; preds = %if.end3.i
  %group_misfit_task_load.i = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 11
  %197 = ptrtoint ptr %group_misfit_task_load.i to i32
  call void @__asan_load4_noabort(i32 %197)
  %198 = load i32, ptr %group_misfit_task_load.i, align 4
  %tobool7.not.i = icmp eq i32 %198, 0
  br i1 %tobool7.not.i, label %if.end9.i, label %group_classify.exit.thread

if.end9.i:                                        ; preds = %if.end6.i
  %cmp.i.i = icmp ult i32 %186, %181
  br i1 %cmp.i.i, label %group_classify.exit.thread, label %if.end.i24.i

if.end.i24.i:                                     ; preds = %if.end9.i
  %mul.i20.i = mul i32 %184, %178
  %group_runnable.i21.i = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 4
  %199 = ptrtoint ptr %group_runnable.i21.i to i32
  call void @__asan_load4_noabort(i32 %199)
  %200 = load i32, ptr %group_runnable.i21.i, align 4
  %mul1.i22.i = mul i32 %200, 100
  %cmp2.i23.i = icmp ult i32 %mul.i20.i, %mul1.i22.i
  br i1 %cmp2.i23.i, label %if.then29, label %group_has_capacity.exit.i

group_has_capacity.exit.i:                        ; preds = %if.end.i24.i
  %mul6.i25.i = mul i32 %178, 100
  %group_util.i26.i = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 3
  %201 = ptrtoint ptr %group_util.i26.i to i32
  call void @__asan_load4_noabort(i32 %201)
  %202 = load i32, ptr %group_util.i26.i, align 4
  %mul7.i27.i = mul i32 %202, %184
  %cmp8.i28.i = icmp ugt i32 %mul6.i25.i, %mul7.i27.i
  br i1 %cmp8.i28.i, label %group_classify.exit.thread, label %if.then29

group_classify.exit.thread:                       ; preds = %group_has_capacity.exit.i, %if.end9.i, %if.end6.i, %if.end3.i, %if.end.i107
  %retval.0.i108.ph = phi i32 [ 2, %if.end6.i ], [ 3, %if.end3.i ], [ 4, %if.end.i107 ], [ 0, %group_has_capacity.exit.i ], [ 0, %if.end9.i ]
  %group_type112 = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 9
  %203 = ptrtoint ptr %group_type112 to i32
  call void @__asan_store4_noabort(i32 %203)
  store i32 %retval.0.i108.ph, ptr %group_type112, align 4
  br label %if.end32

if.then29:                                        ; preds = %group_has_capacity.exit.i, %if.end.i24.i, %group_is_overloaded.exit.i, %if.end.i.i
  %retval.0.i108 = phi i32 [ 5, %group_is_overloaded.exit.i ], [ 1, %group_has_capacity.exit.i ], [ 5, %if.end.i.i ], [ 1, %if.end.i24.i ]
  %group_type = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 9
  %204 = ptrtoint ptr %group_type to i32
  call void @__asan_store4_noabort(i32 %204)
  store i32 %retval.0.i108, ptr %group_type, align 4
  %group_load30 = getelementptr inbounds %struct.sg_lb_stats, ptr %sgs, i32 0, i32 1
  %205 = ptrtoint ptr %group_load30 to i32
  call void @__asan_load4_noabort(i32 %205)
  %206 = load i32, ptr %group_load30, align 4
  %mul = shl i32 %206, 10
  %div = udiv i32 %mul, %178
  %207 = ptrtoint ptr %sgs to i32
  call void @__asan_store4_noabort(i32 %207)
  store i32 %div, ptr %sgs, align 4
  br label %if.end32

if.end32:                                         ; preds = %if.then29, %group_classify.exit.thread
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @select_idle_cpu(ptr nocapture noundef readonly %p, ptr noundef %sd, i1 noundef zeroext %has_idle_core, i32 noundef %target) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %idle_cpu = alloca i32, align 4
  %0 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i, align 4
  %add.i = add i32 %3, 1
  store volatile i32 %add.i, ptr %preempt_count.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !319
  %4 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i = and i32 %4, -16384
  %5 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %5, i32 0, i32 3
  %6 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %cpu, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %7
  %8 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %arrayidx, align 4
  %add = add i32 %9, ptrtoint (ptr @select_idle_mask to i32)
  %10 = inttoptr i32 %add to ptr
  %11 = ptrtoint ptr %10 to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile ptr, ptr %10, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !320
  %13 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i174 = and i32 %13, -16384
  %14 = inttoptr i32 %and.i.i.i174 to ptr
  %preempt_count.i.i175 = getelementptr inbounds %struct.thread_info, ptr %14, i32 0, i32 1
  %15 = ptrtoint ptr %preempt_count.i.i175 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %preempt_count.i.i175, align 4
  %sub.i = add i32 %16, -1
  store volatile i32 %sub.i, ptr %preempt_count.i.i175, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %idle_cpu) #20
  %17 = ptrtoint ptr %idle_cpu to i32
  call void @__asan_store4_noabort(i32 %17)
  store i32 -1, ptr %idle_cpu, align 4
  %18 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %cpu, align 4
  %arrayidx29 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %19
  %20 = ptrtoint ptr %arrayidx29 to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %arrayidx29, align 4
  %add30 = add i32 %21, ptrtoint (ptr @runqueues to i32)
  %22 = inttoptr i32 %add30 to ptr
  %add47 = add i32 %21, ptrtoint (ptr @sd_llc to i32)
  %23 = inttoptr i32 %add47 to ptr
  %24 = ptrtoint ptr %23 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load volatile ptr, ptr %23, align 4
  %call49 = tail call i32 @rcu_read_lock_held() #20
  %tobool.not = icmp eq i32 %call49, 0
  br i1 %tobool.not, label %land.lhs.true, label %do.end55

land.lhs.true:                                    ; preds = %entry
  %call50 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool51.not = icmp eq i32 %call50, 0
  br i1 %tobool51.not, label %do.end55, label %land.lhs.true52

land.lhs.true52:                                  ; preds = %land.lhs.true
  %.b172 = load i1, ptr @select_idle_cpu.__warned, align 1
  br i1 %.b172, label %do.end55, label %if.then

if.then:                                          ; preds = %land.lhs.true52
  store i1 true, ptr @select_idle_cpu.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 6279, ptr noundef nonnull @.str.16) #20
  br label %do.end55

do.end55:                                         ; preds = %if.then, %land.lhs.true52, %land.lhs.true, %entry
  %tobool57.not = icmp eq ptr %25, null
  br i1 %tobool57.not, label %cleanup, label %if.end.i.i

if.end.i.i:                                       ; preds = %do.end55
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %26 = load i32, ptr @nr_cpu_ids, align 4
  %cpus_ptr = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 33
  %27 = ptrtoint ptr %cpus_ptr to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %cpus_ptr, align 4
  %span.i = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 41
  %call.i.i = tail call i32 @__bitmap_and(ptr noundef %12, ptr noundef %span.i, ptr noundef %28, i32 noundef %26) #20
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 11), i32 1), ptr blockaddress(@select_idle_cpu, %if.end86)) #20
          to label %static_branch_SIS_PROP.exit [label %if.end86], !srcloc !261

static_branch_SIS_PROP.exit:                      ; preds = %if.end.i.i
  br i1 %has_idle_core, label %if.end86, label %if.then65

if.then65:                                        ; preds = %static_branch_SIS_PROP.exit
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %29 = load volatile i32, ptr @jiffies, align 128
  %wake_stamp = getelementptr inbounds %struct.rq, ptr %22, i32 0, i32 56
  %30 = ptrtoint ptr %wake_stamp to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load i32, ptr %wake_stamp, align 16
  %cmp = icmp ult i32 %31, %29
  br i1 %cmp, label %while.cond.preheader, label %if.end74, !prof !260

while.cond.preheader:                             ; preds = %if.then65
  %wake_avg_idle = getelementptr inbounds %struct.rq, ptr %22, i32 0, i32 57
  %32 = ptrtoint ptr %wake_stamp to i32
  call void @__asan_load4_noabort(i32 %32)
  %wake_stamp.promoted = load i32, ptr %wake_stamp, align 16
  %cmp70206 = icmp ult i32 %wake_stamp.promoted, %29
  br i1 %cmp70206, label %land.rhs.lr.ph, label %if.end74

land.rhs.lr.ph:                                   ; preds = %while.cond.preheader
  %33 = ptrtoint ptr %wake_avg_idle to i32
  call void @__asan_load8_noabort(i32 %33)
  %wake_avg_idle.promoted = load i64, ptr %wake_avg_idle, align 8
  br label %land.rhs

land.rhs:                                         ; preds = %while.body, %land.rhs.lr.ph
  %shr208 = phi i64 [ %wake_avg_idle.promoted, %land.rhs.lr.ph ], [ %shr, %while.body ]
  %inc205207 = phi i32 [ %wake_stamp.promoted, %land.rhs.lr.ph ], [ %inc, %while.body ]
  %tobool71.not = icmp eq i64 %shr208, 0
  br i1 %tobool71.not, label %if.end74, label %while.body

while.body:                                       ; preds = %land.rhs
  %inc = add nuw i32 %inc205207, 1
  %34 = ptrtoint ptr %wake_stamp to i32
  call void @__asan_store4_noabort(i32 %34)
  store i32 %inc, ptr %wake_stamp, align 16
  %shr = lshr i64 %shr208, 1
  %35 = ptrtoint ptr %wake_avg_idle to i32
  call void @__asan_store8_noabort(i32 %35)
  store i64 %shr, ptr %wake_avg_idle, align 8
  %exitcond.not = icmp eq i32 %inc, %29
  br i1 %exitcond.not, label %if.end74, label %land.rhs

if.end74:                                         ; preds = %while.body, %land.rhs, %while.cond.preheader, %if.then65
  %wake_avg_idle75 = getelementptr inbounds %struct.rq, ptr %22, i32 0, i32 57
  %36 = ptrtoint ptr %wake_avg_idle75 to i32
  call void @__asan_load8_noabort(i32 %36)
  %37 = load i64, ptr %wake_avg_idle75, align 8
  %avg_scan_cost = getelementptr inbounds %struct.sched_domain, ptr %25, i32 0, i32 16
  %38 = ptrtoint ptr %avg_scan_cost to i32
  call void @__asan_load8_noabort(i32 %38)
  %39 = load i64, ptr %avg_scan_cost, align 8
  %add76 = add i64 %39, 1
  %span_weight = getelementptr inbounds %struct.sched_domain, ptr %sd, i32 0, i32 40
  %40 = ptrtoint ptr %span_weight to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %span_weight, align 8
  %conv = zext i32 %41 to i64
  %mul = mul i64 %37, %conv
  %mul77 = shl i64 %add76, 2
  %cmp78 = icmp ugt i64 %mul, %mul77
  br i1 %cmp78, label %if.then80, label %if.end84

if.then80:                                        ; preds = %if.end74
  %conv81 = trunc i64 %add76 to i32
  %cmp164.i.i = icmp ult i64 %mul, 4294967296
  br i1 %cmp164.i.i, label %if.then168.i.i, label %if.else174.i.i, !prof !259

if.then168.i.i:                                   ; preds = %if.then80
  %conv169.i.i = trunc i64 %mul to i32
  %div172.i.i = udiv i32 %conv169.i.i, %conv81
  br label %if.end84

if.else174.i.i:                                   ; preds = %if.then80
  %42 = tail call { i64, i64 } asm ".ifnc $0,r0; .ifnc $0r0,fpr11; .ifnc $0r0,r11fp; .ifnc $0r0,ipr12; .ifnc $0r0,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09.ifnc $1,r2; .ifnc $1r2,fpr11; .ifnc $1r2,r11fp; .ifnc $1r2,ipr12; .ifnc $1r2,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09.ifnc $2,r4; .ifnc $2r4,fpr11; .ifnc $2r4,r11fp; .ifnc $2r4,ipr12; .ifnc $2r4,r12ip; .err; .endif; .endif; .endif; .endif; .endif\0A\09bl\09__do_div64", "={r0},={r2},{r4},{r0},~{r12},~{lr},~{cc}"(i32 %conv81, i64 %mul) #23, !srcloc !263
  %asmresult1.i.i.i = extractvalue { i64, i64 } %42, 1
  %extract.t203 = trunc i64 %asmresult1.i.i.i to i32
  br label %if.end84

if.end84:                                         ; preds = %if.else174.i.i, %if.then168.i.i, %if.end74
  %nr.0 = phi i32 [ 4, %if.end74 ], [ %div172.i.i, %if.then168.i.i ], [ %extract.t203, %if.else174.i.i ]
  %call.i = tail call i64 @sched_clock() #20
  br label %if.end86

if.end86:                                         ; preds = %if.end84, %static_branch_SIS_PROP.exit, %if.end.i.i
  %time.0 = phi i64 [ %call.i, %if.end84 ], [ 0, %static_branch_SIS_PROP.exit ], [ 0, %if.end.i.i ]
  %nr.1 = phi i32 [ %nr.0, %if.end84 ], [ 2147483647, %static_branch_SIS_PROP.exit ], [ 2147483647, %if.end.i.i ]
  %add87 = add i32 %target, 1
  %call89 = tail call i32 @cpumask_next_wrap(i32 noundef %target, ptr noundef %12, i32 noundef %add87, i1 noundef zeroext false) #20
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %43 = load i32, ptr @nr_cpu_ids, align 4
  %cmp90209 = icmp ult i32 %call89, %43
  br i1 %cmp90209, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %if.end86
  %core_cookie1.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 23
  br label %for.body

for.body:                                         ; preds = %for.inc, %for.body.lr.ph
  %cpu19.0211 = phi i32 [ %call89, %for.body.lr.ph ], [ %call110, %for.inc ]
  %nr.2210 = phi i32 [ %nr.1, %for.body.lr.ph ], [ %nr.3, %for.inc ]
  br i1 %has_idle_core, label %if.then93, label %if.else99

if.then93:                                        ; preds = %for.body
  %call94 = call fastcc i32 @select_idle_core(ptr noundef %p, i32 noundef %cpu19.0211, ptr noundef %12, ptr noundef nonnull %idle_cpu)
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %44 = load i32, ptr @nr_cpu_ids, align 4
  %cmp95 = icmp ult i32 %call94, %44
  br i1 %cmp95, label %cleanup, label %for.inc

if.else99:                                        ; preds = %for.body
  %dec = add i32 %nr.2210, -1
  %tobool100.not = icmp eq i32 %dec, 0
  br i1 %tobool100.not, label %cleanup, label %if.end102

if.end102:                                        ; preds = %if.else99
  %call.i182 = tail call i32 @available_idle_cpu(i32 noundef %cpu19.0211) #20
  %tobool.not.i = icmp eq i32 %call.i182, 0
  br i1 %tobool.not.i, label %lor.lhs.false.i, label %do.body.i

lor.lhs.false.i:                                  ; preds = %if.end102
  %arrayidx.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %cpu19.0211
  %45 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load i32, ptr %arrayidx.i.i, align 4
  %add.i.i183 = add i32 %46, ptrtoint (ptr @runqueues to i32)
  %47 = inttoptr i32 %add.i.i183 to ptr
  %nr_running.i.i.i = getelementptr inbounds %struct.rq, ptr %47, i32 0, i32 1
  %48 = ptrtoint ptr %nr_running.i.i.i to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load i32, ptr %nr_running.i.i.i, align 4
  %idle_h_nr_running.i.i.i = getelementptr inbounds %struct.rq, ptr %47, i32 0, i32 14, i32 4
  %50 = ptrtoint ptr %idle_h_nr_running.i.i.i to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load i32, ptr %idle_h_nr_running.i.i.i, align 4
  %cmp.i.i.i = icmp ne i32 %49, %51
  %tobool.i.i.i = icmp eq i32 %49, 0
  %tobool2.not.i = or i1 %tobool.i.i.i, %cmp.i.i.i
  br i1 %tobool2.not.i, label %__select_idle_cpu.exit.thread, label %do.body.i

do.body.i:                                        ; preds = %lor.lhs.false.i, %if.end102
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %cpu19.0211
  %52 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load i32, ptr %arrayidx.i, align 4
  %add.i184 = add i32 %53, ptrtoint (ptr @runqueues to i32)
  %54 = inttoptr i32 %add.i184 to ptr
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__sched_core_enabled, ptr blockaddress(@select_idle_cpu, %land.rhs.i.i.i)) #20
          to label %__select_idle_cpu.exit [label %land.rhs.i.i.i], !srcloc !261

land.rhs.i.i.i:                                   ; preds = %do.body.i
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %54, i32 0, i32 81
  %55 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool3.i.not.i.i = icmp eq i32 %56, 0
  br i1 %tobool3.i.not.i.i, label %__select_idle_cpu.exit, label %if.end.i.i186

if.end.i.i186:                                    ; preds = %land.rhs.i.i.i
  %core.i.i = getelementptr inbounds %struct.rq, ptr %54, i32 0, i32 79
  %57 = ptrtoint ptr %core.i.i to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load ptr, ptr %core.i.i, align 8
  %core_cookie.i.i = getelementptr inbounds %struct.rq, ptr %58, i32 0, i32 86
  %59 = ptrtoint ptr %core_cookie.i.i to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load i32, ptr %core_cookie.i.i, align 4
  %61 = ptrtoint ptr %core_cookie1.i.i to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load i32, ptr %core_cookie1.i.i, align 16
  %cmp.i.i185 = icmp eq i32 %60, %62
  br i1 %cmp.i.i185, label %__select_idle_cpu.exit, label %__select_idle_cpu.exit.thread

__select_idle_cpu.exit.thread:                    ; preds = %if.end.i.i186, %lor.lhs.false.i
  %63 = ptrtoint ptr %idle_cpu to i32
  call void @__asan_store4_noabort(i32 %63)
  store i32 -1, ptr %idle_cpu, align 4
  br label %for.inc

__select_idle_cpu.exit:                           ; preds = %if.end.i.i186, %land.rhs.i.i.i, %do.body.i
  %64 = ptrtoint ptr %idle_cpu to i32
  call void @__asan_store4_noabort(i32 %64)
  store i32 %cpu19.0211, ptr %idle_cpu, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %65 = load i32, ptr @nr_cpu_ids, align 4
  %cmp104 = icmp ult i32 %cpu19.0211, %65
  br i1 %cmp104, label %if.end113, label %for.inc

for.inc:                                          ; preds = %__select_idle_cpu.exit, %__select_idle_cpu.exit.thread, %if.then93
  %nr.3 = phi i32 [ %nr.2210, %if.then93 ], [ %dec, %__select_idle_cpu.exit ], [ %dec, %__select_idle_cpu.exit.thread ]
  %call110 = tail call i32 @cpumask_next_wrap(i32 noundef %cpu19.0211, ptr noundef %12, i32 noundef %add87, i1 noundef zeroext true) #20
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %66 = load i32, ptr @nr_cpu_ids, align 4
  %cmp90 = icmp ult i32 %call110, %66
  br i1 %cmp90, label %for.body, label %for.end

for.end:                                          ; preds = %for.inc, %if.end86
  br i1 %has_idle_core, label %if.then112, label %if.end113

if.then112:                                       ; preds = %for.end
  %arrayidx.i187 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %target
  %67 = ptrtoint ptr %arrayidx.i187 to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load i32, ptr %arrayidx.i187, align 4
  %add.i188 = add i32 %68, ptrtoint (ptr @sd_llc_shared to i32)
  %69 = inttoptr i32 %add.i188 to ptr
  %70 = ptrtoint ptr %69 to i32
  call void @__asan_load4_noabort(i32 %70)
  %71 = load volatile ptr, ptr %69, align 4
  %call.i189 = tail call i32 @rcu_read_lock_held() #20
  %tobool.not.i190 = icmp eq i32 %call.i189, 0
  br i1 %tobool.not.i190, label %land.lhs.true.i, label %do.end12.i

land.lhs.true.i:                                  ; preds = %if.then112
  %call7.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool8.not.i = icmp eq i32 %call7.i, 0
  br i1 %tobool8.not.i, label %do.end12.i, label %land.lhs.true9.i

land.lhs.true9.i:                                 ; preds = %land.lhs.true.i
  %.b27.i = load i1, ptr @set_idle_cores.__warned, align 1
  br i1 %.b27.i, label %do.end12.i, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true9.i
  store i1 true, ptr @set_idle_cores.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 6143, ptr noundef nonnull @.str.16) #20
  br label %do.end12.i

do.end12.i:                                       ; preds = %if.then.i, %land.lhs.true9.i, %land.lhs.true.i, %if.then112
  %tobool14.not.i = icmp eq ptr %71, null
  br i1 %tobool14.not.i, label %if.end113, label %do.body20.i

do.body20.i:                                      ; preds = %do.end12.i
  %has_idle_cores.i = getelementptr inbounds %struct.sched_domain_shared, ptr %71, i32 0, i32 2
  %72 = ptrtoint ptr %has_idle_cores.i to i32
  call void @__asan_store4_noabort(i32 %72)
  store volatile i32 0, ptr %has_idle_cores.i, align 4
  br label %if.end113

if.end113:                                        ; preds = %do.body20.i, %do.end12.i, %for.end, %__select_idle_cpu.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 11), i32 1), ptr blockaddress(@select_idle_cpu, %if.end128)) #20
          to label %static_branch_SIS_PROP.exit178 [label %if.end128], !srcloc !261

static_branch_SIS_PROP.exit178:                   ; preds = %if.end113
  br i1 %has_idle_core, label %if.end128, label %if.then118

if.then118:                                       ; preds = %static_branch_SIS_PROP.exit178
  %call.i191 = tail call i64 @sched_clock() #20
  %sub120 = sub i64 %call.i191, %time.0
  %wake_avg_idle121 = getelementptr inbounds %struct.rq, ptr %22, i32 0, i32 57
  %73 = ptrtoint ptr %wake_avg_idle121 to i32
  call void @__asan_load8_noabort(i32 %73)
  %74 = load i64, ptr %wake_avg_idle121, align 8
  %75 = tail call i64 @llvm.usub.sat.i64(i64 %74, i64 %sub120)
  %76 = ptrtoint ptr %wake_avg_idle121 to i32
  call void @__asan_store8_noabort(i32 %76)
  store i64 %75, ptr %wake_avg_idle121, align 8
  %avg_scan_cost127 = getelementptr inbounds %struct.sched_domain, ptr %25, i32 0, i32 16
  %77 = ptrtoint ptr %avg_scan_cost127 to i32
  call void @__asan_load8_noabort(i32 %77)
  %78 = load i64, ptr %avg_scan_cost127, align 8
  %sub.i192 = sub i64 %sub120, %78
  %div.i = sdiv i64 %sub.i192, 8
  %add.i193 = add i64 %div.i, %78
  store i64 %add.i193, ptr %avg_scan_cost127, align 8
  br label %if.end128

if.end128:                                        ; preds = %if.then118, %static_branch_SIS_PROP.exit178, %if.end113
  %79 = ptrtoint ptr %idle_cpu to i32
  call void @__asan_load4_noabort(i32 %79)
  %80 = load i32, ptr %idle_cpu, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end128, %if.else99, %if.then93, %do.end55
  %retval.0 = phi i32 [ %80, %if.end128 ], [ -1, %do.end55 ], [ -1, %if.else99 ], [ %call94, %if.then93 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %idle_cpu) #20
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @select_idle_core(ptr nocapture noundef readonly %p, i32 noundef %core, ptr noundef %cpus, ptr nocapture noundef %idle_cpu) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09b ${1:l}\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @sched_smt_present, i32 1), ptr blockaddress(@select_idle_core, %if.then)) #20
          to label %for.cond [label %if.then], !srcloc !312

if.then:                                          ; preds = %entry
  %call.i = tail call i32 @available_idle_cpu(i32 noundef %core) #20
  %tobool.not.i = icmp eq i32 %call.i, 0
  br i1 %tobool.not.i, label %lor.lhs.false.i, label %do.body.i

lor.lhs.false.i:                                  ; preds = %if.then
  %arrayidx.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %core
  %0 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %arrayidx.i.i, align 4
  %add.i.i = add i32 %1, ptrtoint (ptr @runqueues to i32)
  %2 = inttoptr i32 %add.i.i to ptr
  %nr_running.i.i.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 1
  %3 = ptrtoint ptr %nr_running.i.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %nr_running.i.i.i, align 4
  %idle_h_nr_running.i.i.i = getelementptr inbounds %struct.rq, ptr %2, i32 0, i32 14, i32 4
  %5 = ptrtoint ptr %idle_h_nr_running.i.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %idle_h_nr_running.i.i.i, align 4
  %cmp.i.i.i = icmp ne i32 %4, %6
  %tobool.i.i.i = icmp eq i32 %4, 0
  %tobool2.not.i = or i1 %tobool.i.i.i, %cmp.i.i.i
  br i1 %tobool2.not.i, label %if.end.i, label %do.body.i

do.body.i:                                        ; preds = %lor.lhs.false.i, %if.then
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %core
  %7 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %8, ptrtoint (ptr @runqueues to i32)
  %9 = inttoptr i32 %add.i to ptr
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__sched_core_enabled, ptr blockaddress(@select_idle_core, %land.rhs.i.i.i)) #20
          to label %cleanup [label %land.rhs.i.i.i], !srcloc !261

land.rhs.i.i.i:                                   ; preds = %do.body.i
  %core_enabled.i.i.i = getelementptr inbounds %struct.rq, ptr %9, i32 0, i32 81
  %10 = ptrtoint ptr %core_enabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %core_enabled.i.i.i, align 128
  %tobool3.i.not.i.i = icmp eq i32 %11, 0
  br i1 %tobool3.i.not.i.i, label %cleanup, label %if.end.i.i

if.end.i.i:                                       ; preds = %land.rhs.i.i.i
  %core.i.i = getelementptr inbounds %struct.rq, ptr %9, i32 0, i32 79
  %12 = ptrtoint ptr %core.i.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %core.i.i, align 8
  %core_cookie.i.i = getelementptr inbounds %struct.rq, ptr %13, i32 0, i32 86
  %14 = ptrtoint ptr %core_cookie.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %core_cookie.i.i, align 4
  %core_cookie1.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 23
  %16 = ptrtoint ptr %core_cookie1.i.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %core_cookie1.i.i, align 16
  %cmp.i.i = icmp eq i32 %15, %17
  br i1 %cmp.i.i, label %cleanup, label %if.end.i

if.end.i:                                         ; preds = %if.end.i.i, %lor.lhs.false.i
  br label %cleanup

for.cond:                                         ; preds = %if.then25, %cpumask_test_cpu.exit65, %if.end19, %cpumask_test_cpu.exit, %if.then11, %entry
  %cpu.0 = phi i32 [ -1, %entry ], [ %call6, %cpumask_test_cpu.exit ], [ %call6, %if.then11 ], [ %call6, %if.then25 ], [ %call6, %cpumask_test_cpu.exit65 ], [ %call6, %if.end19 ]
  %idle.0.off0 = phi i1 [ true, %entry ], [ false, %cpumask_test_cpu.exit ], [ false, %if.then11 ], [ %idle.0.off0, %if.then25 ], [ %idle.0.off0, %cpumask_test_cpu.exit65 ], [ %idle.0.off0, %if.end19 ]
  %thread_sibling.i = getelementptr [4 x %struct.cpu_topology], ptr @cpu_topology, i32 0, i32 %core, i32 5
  %call6 = tail call i32 @cpumask_next(i32 noundef %cpu.0, ptr noundef %thread_sibling.i) #24
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %18 = load i32, ptr @nr_cpu_ids, align 4
  %cmp = icmp ult i32 %call6, %18
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call7 = tail call i32 @available_idle_cpu(i32 noundef %call6) #20
  %tobool8.not = icmp eq i32 %call7, 0
  %19 = ptrtoint ptr %idle_cpu to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %idle_cpu, align 4
  %cmp10 = icmp eq i32 %20, -1
  br i1 %tobool8.not, label %if.then9, label %if.end19

if.then9:                                         ; preds = %for.body
  br i1 %cmp10, label %if.then11, label %if.end.i.i69

if.then11:                                        ; preds = %if.then9
  %arrayidx.i51 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call6
  %21 = ptrtoint ptr %arrayidx.i51 to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load i32, ptr %arrayidx.i51, align 4
  %add.i52 = add i32 %22, ptrtoint (ptr @runqueues to i32)
  %23 = inttoptr i32 %add.i52 to ptr
  %nr_running.i.i = getelementptr inbounds %struct.rq, ptr %23, i32 0, i32 1
  %24 = ptrtoint ptr %nr_running.i.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %nr_running.i.i, align 4
  %idle_h_nr_running.i.i = getelementptr inbounds %struct.rq, ptr %23, i32 0, i32 14, i32 4
  %26 = ptrtoint ptr %idle_h_nr_running.i.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %idle_h_nr_running.i.i, align 4
  %cmp.i.i53 = icmp ne i32 %25, %27
  %tobool.i.i = icmp eq i32 %25, 0
  %tobool13.not = or i1 %tobool.i.i, %cmp.i.i53
  br i1 %tobool13.not, label %for.cond, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then11
  %cpus_ptr = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 33
  %28 = ptrtoint ptr %cpus_ptr to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load ptr, ptr %cpus_ptr, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %30 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i = icmp ugt i32 %30, %call6
  br i1 %cmp.not.i.i.i, label %cpumask_test_cpu.exit, label %land.rhs.i.i.i54

land.rhs.i.i.i54:                                 ; preds = %land.lhs.true
  %.b37.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i, label %cpumask_test_cpu.exit, label %if.then.i.i.i, !prof !259

if.then.i.i.i:                                    ; preds = %land.rhs.i.i.i54
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpumask_test_cpu.exit

cpumask_test_cpu.exit:                            ; preds = %if.then.i.i.i, %land.rhs.i.i.i54, %land.lhs.true
  %div3.i.i = lshr i32 %call6, 5
  %arrayidx.i.i55 = getelementptr i32, ptr %29, i32 %div3.i.i
  %31 = ptrtoint ptr %arrayidx.i.i55 to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load volatile i32, ptr %arrayidx.i.i55, align 4
  %and.i.i = and i32 %call6, 31
  %33 = shl nuw i32 1, %and.i.i
  %34 = and i32 %32, %33
  %tobool15.not = icmp eq i32 %34, 0
  br i1 %tobool15.not, label %for.cond, label %if.then16

if.then16:                                        ; preds = %cpumask_test_cpu.exit
  %35 = ptrtoint ptr %idle_cpu to i32
  call void @__asan_store4_noabort(i32 %35)
  store i32 %call6, ptr %idle_cpu, align 4
  br label %if.end.i.i69

if.end19:                                         ; preds = %for.body
  br i1 %cmp10, label %land.lhs.true21, label %for.cond

land.lhs.true21:                                  ; preds = %if.end19
  %cpus_ptr22 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 33
  %36 = ptrtoint ptr %cpus_ptr22 to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load ptr, ptr %cpus_ptr22, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %38 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i56 = icmp ugt i32 %38, %call6
  br i1 %cmp.not.i.i.i56, label %cpumask_test_cpu.exit65, label %land.rhs.i.i.i58

land.rhs.i.i.i58:                                 ; preds = %land.lhs.true21
  %.b37.i.i.i57 = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i57, label %cpumask_test_cpu.exit65, label %if.then.i.i.i59, !prof !259

if.then.i.i.i59:                                  ; preds = %land.rhs.i.i.i58
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.17, i32 noundef 108, i32 noundef 9, ptr noundef null) #20
  br label %cpumask_test_cpu.exit65

cpumask_test_cpu.exit65:                          ; preds = %if.then.i.i.i59, %land.rhs.i.i.i58, %land.lhs.true21
  %div3.i.i60 = lshr i32 %call6, 5
  %arrayidx.i.i61 = getelementptr i32, ptr %37, i32 %div3.i.i60
  %39 = ptrtoint ptr %arrayidx.i.i61 to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load volatile i32, ptr %arrayidx.i.i61, align 4
  %and.i.i62 = and i32 %call6, 31
  %41 = shl nuw i32 1, %and.i.i62
  %42 = and i32 %40, %41
  %tobool24.not = icmp eq i32 %42, 0
  br i1 %tobool24.not, label %for.cond, label %if.then25

if.then25:                                        ; preds = %cpumask_test_cpu.exit65
  %43 = ptrtoint ptr %idle_cpu to i32
  call void @__asan_store4_noabort(i32 %43)
  store i32 %call6, ptr %idle_cpu, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br i1 %idle.0.off0, label %cleanup, label %if.end.i.i69

if.end.i.i69:                                     ; preds = %for.end, %if.then16, %if.then9
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %44 = load i32, ptr @nr_cpu_ids, align 4
  %call.i.i = tail call i32 @__bitmap_andnot(ptr noundef %cpus, ptr noundef %cpus, ptr noundef %thread_sibling.i, i32 noundef %44) #20
  br label %cleanup

cleanup:                                          ; preds = %if.end.i.i69, %for.end, %if.end.i, %if.end.i.i, %land.rhs.i.i.i, %do.body.i
  %retval.0 = phi i32 [ %core, %for.end ], [ -1, %if.end.i ], [ %core, %if.end.i.i ], [ %core, %do.body.i ], [ %core, %land.rhs.i.i.i ], [ -1, %if.end.i.i69 ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @sched_clock() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__bitmap_andnot(ptr noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @detach_entity_cfs_rq(ptr noundef %se) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %cfs_rq.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 11
  %0 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %cfs_rq.i, align 16
  tail call fastcc void @update_load_avg(ptr noundef %1, ptr noundef %se, i32 noundef 0)
  %load_avg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 17, i32 5
  %load_avg2.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 5
  %2 = ptrtoint ptr %load_avg2.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %load_avg2.i.i, align 32
  %4 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %load_avg.i.i, align 4
  %6 = tail call i32 @llvm.usub.sat.i32(i32 %5, i32 %3) #20
  %7 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_store4_noabort(i32 %7)
  store volatile i32 %6, ptr %load_avg.i.i, align 4
  %load_sum.i.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 17, i32 1
  %8 = ptrtoint ptr %se to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %se, align 128
  %conv.i.i = sext i32 %9 to i64
  %load_sum20.i.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 1
  %10 = ptrtoint ptr %load_sum20.i.i to i32
  call void @__asan_load8_noabort(i32 %10)
  %11 = load i64, ptr %load_sum20.i.i, align 8
  %mul.i.i = mul i64 %11, %conv.i.i
  %12 = ptrtoint ptr %load_sum.i.i to i32
  call void @__asan_load8_noabort(i32 %12)
  %13 = load volatile i64, ptr %load_sum.i.i, align 8
  %14 = tail call i64 @llvm.usub.sat.i64(i64 %13, i64 %mul.i.i) #20
  %15 = ptrtoint ptr %load_sum.i.i to i32
  call void @__asan_store8_noabort(i32 %15)
  store volatile i64 %14, ptr %load_sum.i.i, align 8
  %conv45.i.i = trunc i64 %14 to i32
  %mul48.i.i = mul i32 %6, 46718
  %16 = tail call i32 @llvm.umax.i32(i32 %mul48.i.i, i32 %conv45.i.i) #20
  %conv52.i.i = zext i32 %16 to i64
  %17 = ptrtoint ptr %load_sum.i.i to i32
  call void @__asan_store8_noabort(i32 %17)
  store i64 %conv52.i.i, ptr %load_sum.i.i, align 8
  %util_avg.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 17, i32 7
  %util_avg2.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 7
  %18 = ptrtoint ptr %util_avg2.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %util_avg2.i, align 8
  %20 = ptrtoint ptr %util_avg.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load volatile i32, ptr %util_avg.i, align 4
  %22 = tail call i32 @llvm.usub.sat.i32(i32 %21, i32 %19) #20
  %23 = ptrtoint ptr %util_avg.i to i32
  call void @__asan_store4_noabort(i32 %23)
  store volatile i32 %22, ptr %util_avg.i, align 4
  %util_sum.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 17, i32 3
  %util_sum20.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 3
  %24 = ptrtoint ptr %util_sum20.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %util_sum20.i, align 8
  %26 = ptrtoint ptr %util_sum.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load volatile i32, ptr %util_sum.i, align 4
  %28 = tail call i32 @llvm.usub.sat.i32(i32 %27, i32 %25) #20
  %29 = ptrtoint ptr %util_sum.i to i32
  call void @__asan_store4_noabort(i32 %29)
  store volatile i32 %28, ptr %util_sum.i, align 4
  %mul.i = mul i32 %22, 46718
  %30 = tail call i32 @llvm.umax.i32(i32 %28, i32 %mul.i) #20
  %31 = ptrtoint ptr %util_sum.i to i32
  call void @__asan_store4_noabort(i32 %31)
  store i32 %30, ptr %util_sum.i, align 8
  %runnable_avg.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 17, i32 6
  %runnable_avg55.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 6
  %32 = ptrtoint ptr %runnable_avg55.i to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %runnable_avg55.i, align 4
  %34 = ptrtoint ptr %runnable_avg.i to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load volatile i32, ptr %runnable_avg.i, align 4
  %36 = tail call i32 @llvm.usub.sat.i32(i32 %35, i32 %33) #20
  %37 = ptrtoint ptr %runnable_avg.i to i32
  call void @__asan_store4_noabort(i32 %37)
  store volatile i32 %36, ptr %runnable_avg.i, align 4
  %runnable_sum.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 17, i32 2
  %runnable_sum82.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 15, i32 2
  %38 = ptrtoint ptr %runnable_sum82.i to i32
  call void @__asan_load8_noabort(i32 %38)
  %39 = load i64, ptr %runnable_sum82.i, align 16
  %40 = ptrtoint ptr %runnable_sum.i to i32
  call void @__asan_load8_noabort(i32 %40)
  %41 = load volatile i64, ptr %runnable_sum.i, align 8
  %42 = tail call i64 @llvm.usub.sat.i64(i64 %41, i64 %39) #20
  %43 = ptrtoint ptr %runnable_sum.i to i32
  call void @__asan_store8_noabort(i32 %43)
  store volatile i64 %42, ptr %runnable_sum.i, align 8
  %conv.i = trunc i64 %42 to i32
  %mul108.i = mul i32 %36, 46718
  %44 = tail call i32 @llvm.umax.i32(i32 %mul108.i, i32 %conv.i) #20
  %conv116.i = zext i32 %44 to i64
  %45 = ptrtoint ptr %runnable_sum.i to i32
  call void @__asan_store8_noabort(i32 %45)
  store i64 %conv116.i, ptr %runnable_sum.i, align 16
  %46 = ptrtoint ptr %load_sum20.i.i to i32
  call void @__asan_load8_noabort(i32 %46)
  %47 = load i64, ptr %load_sum20.i.i, align 8
  %48 = trunc i64 %47 to i32
  %propagate.i.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 22
  %49 = ptrtoint ptr %propagate.i.i to i32
  call void @__asan_store4_noabort(i32 %49)
  store i32 1, ptr %propagate.i.i, align 4
  %prop_runnable_sum.i.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 23
  %50 = ptrtoint ptr %prop_runnable_sum.i.i to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load i32, ptr %prop_runnable_sum.i.i, align 8
  %add.i.i = sub i32 %51, %48
  store i32 %add.i.i, ptr %prop_runnable_sum.i.i, align 8
  %rq.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 27
  %52 = ptrtoint ptr %rq.i.i.i to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load ptr, ptr %rq.i.i.i, align 4
  %cfs.i.i = getelementptr inbounds %struct.rq, ptr %53, i32 0, i32 14
  %cmp.i.i = icmp eq ptr %cfs.i.i, %1
  br i1 %cmp.i.i, label %if.then.i.i, label %detach_entity_load_avg.exit

if.then.i.i:                                      ; preds = %entry
  tail call fastcc void @cpufreq_update_util(ptr noundef %53, i32 noundef 0) #20
  br label %detach_entity_load_avg.exit

detach_entity_load_avg.exit:                      ; preds = %if.then.i.i, %entry
  tail call fastcc void @trace_pelt_cfs_tp(ptr noundef %1) #20
  %54 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load i32, ptr %load_avg.i.i, align 32
  %tg_load_avg_contrib.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 21
  %56 = ptrtoint ptr %tg_load_avg_contrib.i to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load i32, ptr %tg_load_avg_contrib.i, align 128
  %sub.i = sub i32 %55, %57
  %tg.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 30
  %58 = ptrtoint ptr %tg.i to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load ptr, ptr %tg.i, align 4
  %cmp.i = icmp ne ptr %59, @root_task_group
  %60 = tail call i32 @llvm.abs.i32(i32 %sub.i, i1 false) #20
  %div21.i = lshr i32 %57, 6
  %cmp4.i = icmp ugt i32 %60, %div21.i
  %or.cond.i = select i1 %cmp.i, i1 %cmp4.i, i1 false
  br i1 %or.cond.i, label %if.then5.i, label %update_tg_load_avg.exit

if.then5.i:                                       ; preds = %detach_entity_load_avg.exit
  %load_avg7.i = getelementptr inbounds %struct.task_group, ptr %59, i32 0, i32 6
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %load_avg7.i, i32 noundef 4) #20
  tail call void @llvm.prefetch.p0(ptr %load_avg7.i, i32 1, i32 3, i32 1) #20
  %61 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %load_avg7.i, ptr %load_avg7.i, i32 %sub.i, ptr elementtype(i32) %load_avg7.i) #20, !srcloc !262
  %62 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load i32, ptr %load_avg.i.i, align 32
  %64 = ptrtoint ptr %tg_load_avg_contrib.i to i32
  call void @__asan_store4_noabort(i32 %64)
  store i32 %63, ptr %tg_load_avg_contrib.i, align 128
  br label %update_tg_load_avg.exit

update_tg_load_avg.exit:                          ; preds = %if.then5.i, %detach_entity_load_avg.exit
  %65 = ptrtoint ptr %cfs_rq.i to i32
  call void @__asan_load4_noabort(i32 %65)
  %66 = load ptr, ptr %cfs_rq.i, align 16
  %call1.i = tail call fastcc zeroext i1 @list_add_leaf_cfs_rq(ptr noundef %66) #20
  %se.addr.0.in19.i = getelementptr inbounds %struct.sched_entity, ptr %se, i32 0, i32 10
  %67 = ptrtoint ptr %se.addr.0.in19.i to i32
  call void @__asan_load4_noabort(i32 %67)
  %se.addr.020.i = load ptr, ptr %se.addr.0.in19.i, align 4
  %tobool.not21.i = icmp eq ptr %se.addr.020.i, null
  br i1 %tobool.not21.i, label %propagate_entity_cfs_rq.exit, label %for.body.i

for.body.i:                                       ; preds = %for.inc.i, %update_tg_load_avg.exit
  %se.addr.022.i = phi ptr [ %se.addr.0.i, %for.inc.i ], [ %se.addr.020.i, %update_tg_load_avg.exit ]
  %cfs_rq.i18.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.022.i, i32 0, i32 11
  %68 = ptrtoint ptr %cfs_rq.i18.i to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load ptr, ptr %cfs_rq.i18.i, align 16
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@detach_entity_cfs_rq, %land.rhs.i.i)) #20
          to label %cfs_rq_throttled.exit.i [label %land.rhs.i.i], !srcloc !261

land.rhs.i.i:                                     ; preds = %for.body.i
  %throttled.i.i = getelementptr inbounds %struct.cfs_rq, ptr %69, i32 0, i32 37
  %70 = ptrtoint ptr %throttled.i.i to i32
  call void @__asan_load4_noabort(i32 %70)
  %71 = load i32, ptr %throttled.i.i, align 8
  %tobool.i.i = icmp ne i32 %71, 0
  %phi.cast.i.i = zext i1 %tobool.i.i to i32
  br label %cfs_rq_throttled.exit.i

cfs_rq_throttled.exit.i:                          ; preds = %land.rhs.i.i, %for.body.i
  %72 = phi i32 [ %phi.cast.i.i, %land.rhs.i.i ], [ 0, %for.body.i ]
  %tobool4.not.i = icmp eq i32 %72, 0
  br i1 %tobool4.not.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %cfs_rq_throttled.exit.i
  tail call fastcc void @update_load_avg(ptr noundef %69, ptr noundef nonnull %se.addr.022.i, i32 noundef 1) #20
  %call5.i = tail call fastcc zeroext i1 @list_add_leaf_cfs_rq(ptr noundef %69) #20
  br label %for.inc.i

if.end.i:                                         ; preds = %cfs_rq_throttled.exit.i
  %call6.i = tail call fastcc zeroext i1 @list_add_leaf_cfs_rq(ptr noundef %69) #20
  br i1 %call6.i, label %propagate_entity_cfs_rq.exit, label %for.inc.i

for.inc.i:                                        ; preds = %if.end.i, %if.then.i
  %se.addr.0.in.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.022.i, i32 0, i32 10
  %73 = ptrtoint ptr %se.addr.0.in.i to i32
  call void @__asan_load4_noabort(i32 %73)
  %se.addr.0.i = load ptr, ptr %se.addr.0.in.i, align 4
  %tobool.not.i = icmp eq ptr %se.addr.0.i, null
  br i1 %tobool.not.i, label %propagate_entity_cfs_rq.exit, label %for.body.i

propagate_entity_cfs_rq.exit:                     ; preds = %for.inc.i, %if.end.i, %update_tg_load_avg.exit
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @unthrottle_offline_cfs_rqs(ptr noundef %rq) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @debug_locks to i32))
  %0 = load i32, ptr @debug_locks, align 4
  %tobool.not.i35 = icmp eq i32 %0, 0
  br i1 %tobool.not.i35, label %lockdep_assert_rq_held.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %entry
  %core_enabled.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 81
  %1 = ptrtoint ptr %core_enabled.i.i to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %core_enabled.i.i, align 128
  %tobool.not.i.i = icmp eq i32 %2, 0
  br i1 %tobool.not.i.i, label %__rq_lockp.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.rhs.i
  %core.i.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 79
  %3 = ptrtoint ptr %core.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %core.i.i, align 8
  br label %__rq_lockp.exit.i

__rq_lockp.exit.i:                                ; preds = %if.then.i.i, %land.rhs.i
  %retval.0.i.i = phi ptr [ %4, %if.then.i.i ], [ %rq, %land.rhs.i ]
  %dep_map.i = getelementptr inbounds %struct.raw_spinlock, ptr %retval.0.i.i, i32 0, i32 4
  %call.i.i = tail call i32 @lock_is_held_type(ptr noundef %dep_map.i, i32 noundef -1) #20
  %cmp.not.i = icmp eq i32 %call.i.i, 0
  br i1 %cmp.not.i, label %do.end.i, label %lockdep_assert_rq_held.exit, !prof !260

do.end.i:                                         ; preds = %__rq_lockp.exit.i
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.9, i32 noundef 1309, i32 noundef 9, ptr noundef null) #20
  br label %lockdep_assert_rq_held.exit

lockdep_assert_rq_held.exit:                      ; preds = %do.end.i, %__rq_lockp.exit.i, %entry
  %5 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i = and i32 %5, -16384
  %6 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %6, i32 0, i32 1
  %7 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %8, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !268
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #20
  %call.i = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %lockdep_assert_rq_held.exit
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 696, ptr noundef nonnull @.str.28) #20
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %lockdep_assert_rq_held.exit
  %call = tail call i32 @rcu_read_lock_any_held() #20
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %rcu_read_lock.exit
  %call1 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %do.end, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %land.lhs.true
  %.b34 = load i1, ptr @unthrottle_offline_cfs_rqs.__warned, align 1
  br i1 %.b34, label %do.end, label %if.then

if.then:                                          ; preds = %land.lhs.true3
  store i1 true, ptr @unthrottle_offline_cfs_rqs.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 5425, ptr noundef nonnull @.str.25) #20
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true3, %land.lhs.true, %rcu_read_lock.exit
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @task_groups to i32))
  %.pn47 = load volatile ptr, ptr @task_groups, align 4
  %cmp.not48 = icmp eq ptr %.pn47, @task_groups
  br i1 %cmp.not48, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %do.end
  %cpu.i = getelementptr inbounds %struct.rq, ptr %rq, i32 0, i32 46
  br label %for.body

for.body:                                         ; preds = %cleanup, %for.body.lr.ph
  %.pn49 = phi ptr [ %.pn47, %for.body.lr.ph ], [ %.pn, %cleanup ]
  %cfs_rq9 = getelementptr i8, ptr %.pn49, i32 -228
  %9 = ptrtoint ptr %cfs_rq9 to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %cfs_rq9, align 4
  %11 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %cpu.i, align 4
  %arrayidx = getelementptr ptr, ptr %10, i32 %12
  %13 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %arrayidx, align 4
  %runtime_enabled = getelementptr inbounds %struct.cfs_rq, ptr %14, i32 0, i32 32
  %15 = ptrtoint ptr %runtime_enabled to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %runtime_enabled, align 4
  %tobool11.not = icmp eq i32 %16, 0
  br i1 %tobool11.not, label %cleanup, label %if.end13

if.end13:                                         ; preds = %for.body
  %runtime_remaining = getelementptr inbounds %struct.cfs_rq, ptr %14, i32 0, i32 33
  %17 = ptrtoint ptr %runtime_remaining to i32
  call void @__asan_store8_noabort(i32 %17)
  store i64 1, ptr %runtime_remaining, align 8
  %18 = ptrtoint ptr %runtime_enabled to i32
  call void @__asan_store4_noabort(i32 %18)
  store i32 0, ptr %runtime_enabled, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@unthrottle_offline_cfs_rqs, %land.rhs.i36)) #20
          to label %cfs_rq_throttled.exit [label %land.rhs.i36], !srcloc !261

land.rhs.i36:                                     ; preds = %if.end13
  %throttled.i = getelementptr inbounds %struct.cfs_rq, ptr %14, i32 0, i32 37
  %19 = ptrtoint ptr %throttled.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %throttled.i, align 8
  %tobool.i = icmp ne i32 %20, 0
  %phi.cast.i = zext i1 %tobool.i to i32
  br label %cfs_rq_throttled.exit

cfs_rq_throttled.exit:                            ; preds = %land.rhs.i36, %if.end13
  %21 = phi i32 [ %phi.cast.i, %land.rhs.i36 ], [ 0, %if.end13 ]
  %tobool16.not = icmp eq i32 %21, 0
  br i1 %tobool16.not, label %cleanup, label %if.then17

if.then17:                                        ; preds = %cfs_rq_throttled.exit
  tail call void @unthrottle_cfs_rq(ptr noundef %14)
  br label %cleanup

cleanup:                                          ; preds = %if.then17, %cfs_rq_throttled.exit, %for.body
  %22 = ptrtoint ptr %.pn49 to i32
  call void @__asan_load4_noabort(i32 %22)
  %.pn = load volatile ptr, ptr %.pn49, align 4
  %cmp.not = icmp eq ptr %.pn, @task_groups
  br i1 %cmp.not, label %for.end, label %for.body

for.end:                                          ; preds = %cleanup, %do.end
  %call.i37 = tail call zeroext i1 @rcu_is_watching() #20
  br i1 %call.i37, label %rcu_read_unlock.exit, label %land.lhs.true.i40

land.lhs.true.i40:                                ; preds = %for.end
  %call1.i38 = tail call i32 @debug_lockdep_rcu_enabled() #20
  %tobool.not.i39 = icmp eq i32 %call1.i38, 0
  br i1 %tobool.not.i39, label %rcu_read_unlock.exit, label %land.lhs.true2.i42

land.lhs.true2.i42:                               ; preds = %land.lhs.true.i40
  %.b4.i41 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i41, label %rcu_read_unlock.exit, label %if.then.i43

if.then.i43:                                      ; preds = %land.lhs.true2.i42
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.27, i32 noundef 724, ptr noundef nonnull @.str.29) #20
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i43, %land.lhs.true2.i42, %land.lhs.true.i40, %for.end
  tail call void asm sideeffect "", "~{memory}"() #20, !srcloc !269
  %23 = tail call i32 @llvm.read_register.i32(metadata !248) #20
  %and.i.i.i.i.i44 = and i32 %23, -16384
  %24 = inttoptr i32 %and.i.i.i.i.i44 to ptr
  %preempt_count.i.i.i.i45 = getelementptr inbounds %struct.thread_info, ptr %24, i32 0, i32 1
  %25 = ptrtoint ptr %preempt_count.i.i.i.i45 to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load volatile i32, ptr %preempt_count.i.i.i.i45, align 4
  %sub.i.i.i = add i32 %26, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i45, align 4
  tail call void @rcu_read_unlock_strict() #20
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #20
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @entity_tick(ptr noundef %cfs_rq, ptr noundef %curr, i32 noundef %queued) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call fastcc void @update_curr(ptr noundef %cfs_rq)
  tail call fastcc void @update_load_avg(ptr noundef %cfs_rq, ptr noundef %curr, i32 noundef 1)
  %my_q.i.i = getelementptr inbounds %struct.sched_entity, ptr %curr, i32 0, i32 12
  %0 = ptrtoint ptr %my_q.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %my_q.i.i, align 4
  %tobool.not.i = icmp eq ptr %1, null
  br i1 %tobool.not.i, label %update_cfs_group.exit, label %if.end.i

if.end.i:                                         ; preds = %entry
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @__cfs_bandwidth_used, ptr blockaddress(@entity_tick, %land.rhs.i.i)) #20
          to label %if.end4.i [label %land.rhs.i.i], !srcloc !261

land.rhs.i.i:                                     ; preds = %if.end.i
  %throttle_count.i.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 38
  %2 = ptrtoint ptr %throttle_count.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %throttle_count.i.i, align 4
  %tobool.i.not.i = icmp eq i32 %3, 0
  br i1 %tobool.i.not.i, label %if.end4.i, label %update_cfs_group.exit

if.end4.i:                                        ; preds = %land.rhs.i.i, %if.end.i
  %tg1.i.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 30
  %4 = ptrtoint ptr %tg1.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %tg1.i.i, align 4
  %shares2.i.i = getelementptr inbounds %struct.task_group, ptr %5, i32 0, i32 3
  %6 = ptrtoint ptr %shares2.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %shares2.i.i, align 16
  %8 = ptrtoint ptr %1 to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %1, align 128
  %load_avg.i.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 17, i32 5
  %10 = ptrtoint ptr %load_avg.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %load_avg.i.i, align 32
  %12 = tail call i32 @llvm.umax.i32(i32 %9, i32 %11) #20
  %load_avg5.i.i = getelementptr inbounds %struct.task_group, ptr %5, i32 0, i32 6
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %load_avg5.i.i, i32 noundef 4) #20
  %13 = ptrtoint ptr %load_avg5.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %load_avg5.i.i, align 4
  %tg_load_avg_contrib.i.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 21
  %15 = ptrtoint ptr %tg_load_avg_contrib.i.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %tg_load_avg_contrib.i.i, align 128
  %sub.i.i = sub i32 %14, %16
  %add.i.i = add i32 %sub.i.i, %12
  %mul.i.i = mul i32 %12, %7
  %tobool.not.i.i = icmp eq i32 %add.i.i, 0
  br i1 %tobool.not.i.i, label %calc_group_shares.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.end4.i
  %div.i.i = sdiv i32 %mul.i.i, %add.i.i
  br label %calc_group_shares.exit.i

calc_group_shares.exit.i:                         ; preds = %if.then.i.i, %if.end4.i
  %shares.0.i.i = phi i32 [ %div.i.i, %if.then.i.i ], [ %mul.i.i, %if.end4.i ]
  %17 = tail call i32 @llvm.smax.i32(i32 %shares.0.i.i, i32 2) #20
  %18 = tail call i32 @llvm.smin.i32(i32 %17, i32 %7) #20
  %cfs_rq.i.i = getelementptr inbounds %struct.sched_entity, ptr %curr, i32 0, i32 11
  %19 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %cfs_rq.i.i, align 16
  tail call fastcc void @reweight_entity(ptr noundef %20, ptr noundef %curr, i32 noundef %18) #20
  br label %update_cfs_group.exit

update_cfs_group.exit:                            ; preds = %calc_group_shares.exit.i, %land.rhs.i.i, %entry
  %tobool.not = icmp eq i32 %queued, 0
  br i1 %tobool.not, label %if.end, label %if.end7.sink.split

if.end:                                           ; preds = %update_cfs_group.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 8), ptr blockaddress(@entity_tick, %if.end5)) #20
          to label %land.lhs.true [label %if.end5], !srcloc !261

land.lhs.true:                                    ; preds = %if.end
  %rq.i15 = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %21 = ptrtoint ptr %rq.i15 to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %rq.i15, align 4
  %hrtick_timer = getelementptr inbounds %struct.rq, ptr %22, i32 0, i32 66
  %call3 = tail call zeroext i1 @hrtimer_active(ptr noundef %hrtick_timer) #20
  br i1 %call3, label %if.end7, label %if.end5

if.end5:                                          ; preds = %land.lhs.true, %if.end
  %nr_running = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 1
  %23 = ptrtoint ptr %nr_running to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %nr_running, align 8
  %cmp = icmp ugt i32 %24, 1
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end5
  %call.i = tail call fastcc i64 @sched_slice(ptr noundef %cfs_rq, ptr noundef %curr) #20
  %conv.i = trunc i64 %call.i to i32
  %sum_exec_runtime.i = getelementptr inbounds %struct.sched_entity, ptr %curr, i32 0, i32 5
  %25 = ptrtoint ptr %sum_exec_runtime.i to i32
  call void @__asan_load8_noabort(i32 %25)
  %26 = load i64, ptr %sum_exec_runtime.i, align 8
  %prev_sum_exec_runtime.i = getelementptr inbounds %struct.sched_entity, ptr %curr, i32 0, i32 7
  %27 = ptrtoint ptr %prev_sum_exec_runtime.i to i32
  call void @__asan_load8_noabort(i32 %27)
  %28 = load i64, ptr %prev_sum_exec_runtime.i, align 8
  %sub.i = sub i64 %26, %28
  %conv1.i = trunc i64 %sub.i to i32
  %cmp.i = icmp ugt i32 %conv1.i, %conv.i
  br i1 %cmp.i, label %if.then.i, label %if.end.i17

if.then.i:                                        ; preds = %if.then6
  %rq.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %29 = ptrtoint ptr %rq.i.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %rq.i.i, align 4
  tail call void @resched_curr(ptr noundef %30) #20
  %last.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 13
  %31 = ptrtoint ptr %last.i.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %last.i.i, align 16
  %cmp.i.i = icmp eq ptr %32, %curr
  br i1 %cmp.i.i, label %if.then.i.i16, label %if.end.i.i

if.then.i.i16:                                    ; preds = %if.then.i
  %tobool.not8.i.i.i = icmp eq ptr %curr, null
  br i1 %tobool.not8.i.i.i, label %if.end7, label %for.body.i.i.i

for.body.i.i.i:                                   ; preds = %for.inc.i.i.i, %if.then.i.i16
  %se.addr.09.i.i.i = phi ptr [ %39, %for.inc.i.i.i ], [ %curr, %if.then.i.i16 ]
  %cfs_rq.i.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i.i.i, i32 0, i32 11
  %33 = ptrtoint ptr %cfs_rq.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load ptr, ptr %cfs_rq.i.i.i.i, align 16
  %last.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %34, i32 0, i32 13
  %35 = ptrtoint ptr %last.i.i.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load ptr, ptr %last.i.i.i, align 16
  %cmp.not.i.i.i = icmp eq ptr %36, %se.addr.09.i.i.i
  br i1 %cmp.not.i.i.i, label %for.inc.i.i.i, label %if.end.i.i

for.inc.i.i.i:                                    ; preds = %for.body.i.i.i
  %37 = ptrtoint ptr %last.i.i.i to i32
  call void @__asan_store4_noabort(i32 %37)
  store ptr null, ptr %last.i.i.i, align 16
  %parent.i.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i.i.i, i32 0, i32 10
  %38 = ptrtoint ptr %parent.i.i.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load ptr, ptr %parent.i.i.i, align 4
  %tobool.not.i.i.i = icmp eq ptr %39, null
  br i1 %tobool.not.i.i.i, label %if.end.i.i, label %for.body.i.i.i

if.end.i.i:                                       ; preds = %for.inc.i.i.i, %for.body.i.i.i, %if.then.i
  %next.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 12
  %40 = ptrtoint ptr %next.i.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load ptr, ptr %next.i.i, align 4
  %cmp1.i.i = icmp ne ptr %41, %curr
  %tobool.not8.i14.i.i = icmp eq ptr %curr, null
  %or.cond.i.i = or i1 %tobool.not8.i14.i.i, %cmp1.i.i
  br i1 %or.cond.i.i, label %if.end3.i.i, label %for.body.i18.i.i

for.body.i18.i.i:                                 ; preds = %for.inc.i21.i.i, %if.end.i.i
  %se.addr.09.i15.i.i = phi ptr [ %48, %for.inc.i21.i.i ], [ %curr, %if.end.i.i ]
  %cfs_rq.i.i16.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i15.i.i, i32 0, i32 11
  %42 = ptrtoint ptr %cfs_rq.i.i16.i.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load ptr, ptr %cfs_rq.i.i16.i.i, align 16
  %next.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %43, i32 0, i32 12
  %44 = ptrtoint ptr %next.i.i.i to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load ptr, ptr %next.i.i.i, align 4
  %cmp.not.i17.i.i = icmp eq ptr %45, %se.addr.09.i15.i.i
  br i1 %cmp.not.i17.i.i, label %for.inc.i21.i.i, label %if.end3.i.i

for.inc.i21.i.i:                                  ; preds = %for.body.i18.i.i
  %46 = ptrtoint ptr %next.i.i.i to i32
  call void @__asan_store4_noabort(i32 %46)
  store ptr null, ptr %next.i.i.i, align 4
  %parent.i19.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i15.i.i, i32 0, i32 10
  %47 = ptrtoint ptr %parent.i19.i.i to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load ptr, ptr %parent.i19.i.i, align 4
  %tobool.not.i20.i.i = icmp eq ptr %48, null
  br i1 %tobool.not.i20.i.i, label %if.end3.i.i, label %for.body.i18.i.i

if.end3.i.i:                                      ; preds = %for.inc.i21.i.i, %for.body.i18.i.i, %if.end.i.i
  %skip.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 14
  %49 = ptrtoint ptr %skip.i.i to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load ptr, ptr %skip.i.i, align 4
  %cmp4.i.i = icmp ne ptr %50, %curr
  %or.cond33.i.i = or i1 %tobool.not8.i14.i.i, %cmp4.i.i
  br i1 %or.cond33.i.i, label %if.end7, label %for.body.i26.i.i

for.body.i26.i.i:                                 ; preds = %for.inc.i29.i.i, %if.end3.i.i
  %se.addr.09.i23.i.i = phi ptr [ %57, %for.inc.i29.i.i ], [ %curr, %if.end3.i.i ]
  %cfs_rq.i.i24.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i23.i.i, i32 0, i32 11
  %51 = ptrtoint ptr %cfs_rq.i.i24.i.i to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load ptr, ptr %cfs_rq.i.i24.i.i, align 16
  %skip.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %52, i32 0, i32 14
  %53 = ptrtoint ptr %skip.i.i.i to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load ptr, ptr %skip.i.i.i, align 4
  %cmp.not.i25.i.i = icmp eq ptr %54, %se.addr.09.i23.i.i
  br i1 %cmp.not.i25.i.i, label %for.inc.i29.i.i, label %if.end7

for.inc.i29.i.i:                                  ; preds = %for.body.i26.i.i
  %55 = ptrtoint ptr %skip.i.i.i to i32
  call void @__asan_store4_noabort(i32 %55)
  store ptr null, ptr %skip.i.i.i, align 4
  %parent.i27.i.i = getelementptr inbounds %struct.sched_entity, ptr %se.addr.09.i23.i.i, i32 0, i32 10
  %56 = ptrtoint ptr %parent.i27.i.i to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load ptr, ptr %parent.i27.i.i, align 4
  %tobool.not.i28.i.i = icmp eq ptr %57, null
  br i1 %tobool.not.i28.i.i, label %if.end7, label %for.body.i26.i.i

if.end.i17:                                       ; preds = %if.then6
  %58 = load i32, ptr @sysctl_sched_min_granularity, align 4
  %cmp4.i = icmp ugt i32 %58, %conv1.i
  br i1 %cmp4.i, label %if.end7, label %if.end7.i

if.end7.i:                                        ; preds = %if.end.i17
  %rb_leftmost.i.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 10, i32 1
  %59 = ptrtoint ptr %rb_leftmost.i.i to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load ptr, ptr %rb_leftmost.i.i, align 4
  %tobool.not.i.i18 = icmp eq ptr %60, null
  %add.ptr.i.i = getelementptr i8, ptr %60, i32 -8
  %retval.0.i.i = select i1 %tobool.not.i.i18, ptr null, ptr %add.ptr.i.i
  %vruntime.i = getelementptr inbounds %struct.sched_entity, ptr %curr, i32 0, i32 6
  %61 = ptrtoint ptr %vruntime.i to i32
  call void @__asan_load8_noabort(i32 %61)
  %62 = load i64, ptr %vruntime.i, align 16
  %vruntime9.i = getelementptr inbounds %struct.sched_entity, ptr %retval.0.i.i, i32 0, i32 6
  %63 = ptrtoint ptr %vruntime9.i to i32
  call void @__asan_load8_noabort(i32 %63)
  %64 = load i64, ptr %vruntime9.i, align 16
  %sub10.i = sub i64 %62, %64
  %cmp11.i = icmp sgt i64 %sub10.i, -1
  %conv15.i = and i64 %call.i, 4294967295
  %cmp16.i = icmp sgt i64 %sub10.i, %conv15.i
  %or.cond.i = select i1 %cmp11.i, i1 %cmp16.i, i1 false
  br i1 %or.cond.i, label %if.end7.sink.split, label %if.end7

if.end7.sink.split:                               ; preds = %if.end7.i, %update_cfs_group.exit
  %rq.i35.i = getelementptr inbounds %struct.cfs_rq, ptr %cfs_rq, i32 0, i32 27
  %65 = ptrtoint ptr %rq.i35.i to i32
  call void @__asan_load4_noabort(i32 %65)
  %66 = load ptr, ptr %rq.i35.i, align 4
  tail call void @resched_curr(ptr noundef %66) #20
  br label %if.end7

if.end7:                                          ; preds = %if.end7.sink.split, %if.end7.i, %if.end.i17, %for.inc.i29.i.i, %for.body.i26.i.i, %if.end3.i.i, %if.then.i.i16, %if.end5, %land.lhs.true
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @hrtimer_active(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @task_move_group_fair(ptr noundef %p) unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %cfs_rq.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 11
  %0 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %cfs_rq.i.i, align 16
  %on_rq.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 12
  %2 = ptrtoint ptr %on_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %on_rq.i.i, align 4
  %tobool.not.i.i = icmp eq i32 %3, 0
  br i1 %tobool.not.i.i, label %if.end.i.i, label %detach_task_cfs_rq.exit

if.end.i.i:                                       ; preds = %entry
  %sum_exec_runtime.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 5
  %4 = ptrtoint ptr %sum_exec_runtime.i.i to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %sum_exec_runtime.i.i, align 8
  %tobool2.not.i.i = icmp eq i64 %5, 0
  br i1 %tobool2.not.i.i, label %detach_task_cfs_rq.exit, label %do.end.i.i

do.end.i.i:                                       ; preds = %if.end.i.i
  %6 = ptrtoint ptr %p to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %p, align 128
  %cmp.i.i = icmp eq i32 %7, 512
  br i1 %cmp.i.i, label %land.lhs.true.i.i, label %if.then.i

land.lhs.true.i.i:                                ; preds = %do.end.i.i
  %sched_remote_wakeup.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 65
  %8 = ptrtoint ptr %sched_remote_wakeup.i.i to i32
  call void @__asan_load2_noabort(i32 %8)
  %bf.load.i.i = load i16, ptr %sched_remote_wakeup.i.i, align 8
  %tobool3.not.i.i = icmp sgt i16 %bf.load.i.i, -1
  br i1 %tobool3.not.i.i, label %if.then.i, label %detach_task_cfs_rq.exit

if.then.i:                                        ; preds = %land.lhs.true.i.i, %do.end.i.i
  %min_vruntime.i.i = getelementptr inbounds %struct.cfs_rq, ptr %1, i32 0, i32 6
  %9 = ptrtoint ptr %min_vruntime.i.i to i32
  call void @__asan_load8_noabort(i32 %9)
  %10 = load i64, ptr %min_vruntime.i.i, align 32
  %my_q.i.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 12
  %11 = ptrtoint ptr %my_q.i.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %my_q.i.i.i, align 4
  %tobool.not.i.i.i = icmp eq ptr %12, null
  br i1 %tobool.not.i.i.i, label %task_of.exit.i.i.i, label %if.end.i.i.i

task_of.exit.i.i.i:                               ; preds = %if.then.i
  %policy.i.i.i.i = getelementptr %struct.task_struct, ptr %p, i32 0, i32 31
  %13 = ptrtoint ptr %policy.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %policy.i.i.i.i, align 4
  %cmp.i.i.i.i.i = icmp eq i32 %14, 5
  br label %se_is_idle.exit.i.i

if.end.i.i.i:                                     ; preds = %if.then.i
  %idle.i.i.i.i = getelementptr inbounds %struct.cfs_rq, ptr %12, i32 0, i32 31
  %15 = ptrtoint ptr %idle.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %idle.i.i.i.i, align 16
  %cmp.i.i.i.i = icmp sgt i32 %16, 0
  br label %se_is_idle.exit.i.i

se_is_idle.exit.i.i:                              ; preds = %if.end.i.i.i, %task_of.exit.i.i.i
  %retval.0.in.i.i.i = phi i1 [ %cmp.i.i.i.i, %if.end.i.i.i ], [ %cmp.i.i.i.i.i, %task_of.exit.i.i.i ]
  %sysctl_sched_min_granularity.val.i.i = load i32, ptr @sysctl_sched_min_granularity, align 4
  %sysctl_sched_latency.val.i.i = load i32, ptr @sysctl_sched_latency, align 4
  %thresh.0.i.i = select i1 %retval.0.in.i.i.i, i32 %sysctl_sched_min_granularity.val.i.i, i32 %sysctl_sched_latency.val.i.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @sched_feat_keys, i32 1), ptr blockaddress(@task_move_group_fair, %place_entity.exit.i)) #20
          to label %17 [label %place_entity.exit.i], !srcloc !261

17:                                               ; preds = %se_is_idle.exit.i.i
  %shr.i.i = lshr i32 %thresh.0.i.i, 1
  br label %place_entity.exit.i

place_entity.exit.i:                              ; preds = %17, %se_is_idle.exit.i.i
  %18 = phi i32 [ %shr.i.i, %17 ], [ %thresh.0.i.i, %se_is_idle.exit.i.i ]
  %conv.i.i = zext i32 %18 to i64
  %sub.i.i = sub i64 %10, %conv.i.i
  %vruntime12.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 6
  %19 = ptrtoint ptr %vruntime12.i.i to i32
  call void @__asan_load8_noabort(i32 %19)
  %20 = load i64, ptr %vruntime12.i.i, align 16
  %sub.i.i.i = sub i64 %sub.i.i, %20
  %cmp.i.i.i = icmp sgt i64 %sub.i.i.i, 0
  %spec.select.i.i.i = select i1 %cmp.i.i.i, i64 %sub.i.i, i64 %20
  store i64 %spec.select.i.i.i, ptr %vruntime12.i.i, align 16
  %21 = ptrtoint ptr %min_vruntime.i.i to i32
  call void @__asan_load8_noabort(i32 %21)
  %22 = load i64, ptr %min_vruntime.i.i, align 32
  %sub.i = sub i64 %spec.select.i.i.i, %22
  store i64 %sub.i, ptr %vruntime12.i.i, align 16
  br label %detach_task_cfs_rq.exit

detach_task_cfs_rq.exit:                          ; preds = %place_entity.exit.i, %land.lhs.true.i.i, %if.end.i.i, %entry
  %se1.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18
  tail call fastcc void @detach_entity_cfs_rq(ptr noundef %se1.i) #20
  %stack.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 1
  %23 = ptrtoint ptr %stack.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %stack.i, align 4
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %24, i32 0, i32 3
  %25 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load volatile i32, ptr %cpu.i, align 4
  %sched_task_group.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 25
  %27 = ptrtoint ptr %sched_task_group.i.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %sched_task_group.i.i, align 8
  %29 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %cfs_rq.i.i, align 16
  %cfs_rq2.i = getelementptr inbounds %struct.task_group, ptr %28, i32 0, i32 2
  %31 = ptrtoint ptr %cfs_rq2.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %cfs_rq2.i, align 4
  %arrayidx.i = getelementptr ptr, ptr %32, i32 %26
  %33 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load ptr, ptr %arrayidx.i, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr (i8, ptr getelementptr inbounds ([25 x %struct.static_key], ptr @sched_feat_keys, i32 0, i32 16), i32 1), ptr blockaddress(@task_move_group_fair, %set_task_rq.exit)) #20
          to label %if.end.i.i6 [label %set_task_rq.exit], !srcloc !261

if.end.i.i6:                                      ; preds = %detach_task_cfs_rq.exit
  %avg.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15
  %35 = ptrtoint ptr %avg.i.i to i32
  call void @__asan_load8_noabort(i32 %35)
  %36 = load i64, ptr %avg.i.i, align 128
  %tobool.not.i.i5 = icmp eq i64 %36, 0
  %tobool1.not.i.i = icmp eq ptr %30, null
  %or.cond.i.i = or i1 %tobool1.not.i.i, %tobool.not.i.i5
  br i1 %or.cond.i.i, label %set_task_rq.exit, label %do.body.preheader.i.i

do.body.preheader.i.i:                            ; preds = %if.end.i.i6
  %load_last_update_time_copy.i.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 18
  %load_last_update_time_copy4.i.i = getelementptr inbounds %struct.cfs_rq, ptr %34, i32 0, i32 18
  %avg9.i.i = getelementptr inbounds %struct.cfs_rq, ptr %30, i32 0, i32 17
  %avg11.i.i = getelementptr inbounds %struct.cfs_rq, ptr %34, i32 0, i32 17
  br label %do.body.i.i

do.body.i.i:                                      ; preds = %do.body.i.i, %do.body.preheader.i.i
  %37 = ptrtoint ptr %load_last_update_time_copy.i.i to i32
  call void @__asan_load8_noabort(i32 %37)
  %38 = load i64, ptr %load_last_update_time_copy.i.i, align 128
  %39 = ptrtoint ptr %load_last_update_time_copy4.i.i to i32
  call void @__asan_load8_noabort(i32 %39)
  %40 = load i64, ptr %load_last_update_time_copy4.i.i, align 128
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #20, !srcloc !264
  %41 = ptrtoint ptr %avg9.i.i to i32
  call void @__asan_load8_noabort(i32 %41)
  %42 = load i64, ptr %avg9.i.i, align 128
  %43 = ptrtoint ptr %avg11.i.i to i32
  call void @__asan_load8_noabort(i32 %43)
  %44 = load i64, ptr %avg11.i.i, align 128
  %cmp.not.i.i = icmp eq i64 %42, %38
  %cmp14.not.i.i = icmp eq i64 %44, %40
  %or.cond28.i.i = select i1 %cmp.not.i.i, i1 %cmp14.not.i.i, i1 false
  br i1 %or.cond28.i.i, label %do.end15.i.i, label %do.body.i.i

do.end15.i.i:                                     ; preds = %do.body.i.i
  %call16.i.i = tail call i32 @__update_load_avg_blocked_se(i64 noundef %38, ptr noundef %se1.i) #20
  %45 = ptrtoint ptr %avg.i.i to i32
  call void @__asan_store8_noabort(i32 %45)
  store i64 %40, ptr %avg.i.i, align 128
  br label %set_task_rq.exit

set_task_rq.exit:                                 ; preds = %do.end15.i.i, %if.end.i.i6, %detach_task_cfs_rq.exit
  %46 = ptrtoint ptr %cfs_rq2.i to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load ptr, ptr %cfs_rq2.i, align 4
  %arrayidx4.i = getelementptr ptr, ptr %47, i32 %26
  %48 = ptrtoint ptr %arrayidx4.i to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load ptr, ptr %arrayidx4.i, align 4
  %50 = ptrtoint ptr %cfs_rq.i.i to i32
  call void @__asan_store4_noabort(i32 %50)
  store ptr %49, ptr %cfs_rq.i.i, align 16
  %se7.i = getelementptr inbounds %struct.task_group, ptr %28, i32 0, i32 1
  %51 = ptrtoint ptr %se7.i to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load ptr, ptr %se7.i, align 8
  %arrayidx8.i = getelementptr ptr, ptr %52, i32 %26
  %53 = ptrtoint ptr %arrayidx8.i to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load ptr, ptr %arrayidx8.i, align 4
  %parent.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 10
  %55 = ptrtoint ptr %parent.i to i32
  call void @__asan_store4_noabort(i32 %55)
  store ptr %54, ptr %parent.i, align 4
  %rt_rq.i = getelementptr inbounds %struct.task_group, ptr %28, i32 0, i32 8
  %56 = ptrtoint ptr %rt_rq.i to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load ptr, ptr %rt_rq.i, align 8
  %arrayidx10.i = getelementptr ptr, ptr %57, i32 %26
  %58 = ptrtoint ptr %arrayidx10.i to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load ptr, ptr %arrayidx10.i, align 4
  %rt_rq11.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 19, i32 8
  %60 = ptrtoint ptr %rt_rq11.i to i32
  call void @__asan_store4_noabort(i32 %60)
  store ptr %59, ptr %rt_rq11.i, align 32
  %rt_se.i = getelementptr inbounds %struct.task_group, ptr %28, i32 0, i32 7
  %61 = ptrtoint ptr %rt_se.i to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load ptr, ptr %rt_se.i, align 4
  %arrayidx12.i = getelementptr ptr, ptr %62, i32 %26
  %63 = ptrtoint ptr %arrayidx12.i to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load ptr, ptr %arrayidx12.i, align 4
  %parent14.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 19, i32 7
  %65 = ptrtoint ptr %parent14.i to i32
  call void @__asan_store4_noabort(i32 %65)
  store ptr %64, ptr %parent14.i, align 4
  %avg = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 15
  %66 = ptrtoint ptr %avg to i32
  call void @__asan_store8_noabort(i32 %66)
  store i64 0, ptr %avg, align 128
  tail call fastcc void @attach_entity_cfs_rq(ptr noundef %se1.i) #20
  %67 = ptrtoint ptr %on_rq.i.i to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load i32, ptr %on_rq.i.i, align 4
  %tobool.not.i.i10 = icmp eq i32 %68, 0
  br i1 %tobool.not.i.i10, label %if.end.i.i13, label %attach_task_cfs_rq.exit

if.end.i.i13:                                     ; preds = %set_task_rq.exit
  %sum_exec_runtime.i.i11 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 5
  %69 = ptrtoint ptr %sum_exec_runtime.i.i11 to i32
  call void @__asan_load8_noabort(i32 %69)
  %70 = load i64, ptr %sum_exec_runtime.i.i11, align 8
  %tobool2.not.i.i12 = icmp eq i64 %70, 0
  br i1 %tobool2.not.i.i12, label %attach_task_cfs_rq.exit, label %do.end.i.i15

do.end.i.i15:                                     ; preds = %if.end.i.i13
  %71 = ptrtoint ptr %p to i32
  call void @__asan_load4_noabort(i32 %71)
  %72 = load volatile i32, ptr %p, align 128
  %cmp.i.i14 = icmp eq i32 %72, 512
  br i1 %cmp.i.i14, label %land.lhs.true.i.i19, label %if.then.i20

land.lhs.true.i.i19:                              ; preds = %do.end.i.i15
  %sched_remote_wakeup.i.i16 = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 65
  %73 = ptrtoint ptr %sched_remote_wakeup.i.i16 to i32
  call void @__asan_load2_noabort(i32 %73)
  %bf.load.i.i17 = load i16, ptr %sched_remote_wakeup.i.i16, align 8
  %tobool3.not.i.i18 = icmp sgt i16 %bf.load.i.i17, -1
  br i1 %tobool3.not.i.i18, label %if.then.i20, label %attach_task_cfs_rq.exit

if.then.i20:                                      ; preds = %land.lhs.true.i.i19, %do.end.i.i15
  %min_vruntime.i = getelementptr inbounds %struct.cfs_rq, ptr %49, i32 0, i32 6
  %74 = ptrtoint ptr %min_vruntime.i to i32
  call void @__asan_load8_noabort(i32 %74)
  %75 = load i64, ptr %min_vruntime.i, align 32
  %vruntime.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 18, i32 6
  %76 = ptrtoint ptr %vruntime.i to i32
  call void @__asan_load8_noabort(i32 %76)
  %77 = load i64, ptr %vruntime.i, align 16
  %add.i = add i64 %77, %75
  store i64 %add.i, ptr %vruntime.i, align 16
  br label %attach_task_cfs_rq.exit

attach_task_cfs_rq.exit:                          ; preds = %if.then.i20, %land.lhs.true.i.i19, %if.end.i.i13, %set_task_rq.exit
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @autogroup_path(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @kernfs_path_from_node(ptr noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.usub.sat.i32(i32, i32) #15

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i64 @llvm.usub.sat.i64(i64, i64) #15

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.umin.i32(i32, i32) #15

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.umax.i32(i32, i32) #15

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i64 @llvm.umin.i64(i64, i64) #15

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.smax.i32(i32, i32) #15

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.smin.i32(i32, i32) #15

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.abs.i32(i32, i1 immarg) #15

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i64 @llvm.umax.i64(i64, i64) #15

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i64 @llvm.abs.i64(i64, i1 immarg) #15

; Function Attrs: nounwind
declare void @llvm.arm.gnu.eabi.mcount() #20

declare void @__asan_load1_noabort(i32)

declare void @__asan_load2_noabort(i32)

declare void @__asan_load4_noabort(i32)

declare void @__asan_load8_noabort(i32)

declare void @__asan_store1_noabort(i32)

declare void @__asan_store4_noabort(i32)

declare void @__asan_store8_noabort(i32)

declare ptr @memcpy(ptr, ptr, i32)

declare ptr @memset(ptr, i32, i32)

declare void @__asan_register_globals(i32, i32)

declare void @__asan_unregister_globals(i32, i32)

; Function Attrs: nounwind uwtable(sync)
define internal void @asan.module_ctor() #21 {
  call void @__asan_register_globals(i32 ptrtoint (ptr @0 to i32), i32 59)
  ret void
}

; Function Attrs: nounwind uwtable(sync)
define internal void @asan.module_dtor() #21 {
  call void @__asan_unregister_globals(i32 ptrtoint (ptr @0 to i32), i32 59)
  ret void
}

attributes #0 = { cold nounwind null_pointer_is_valid optsize sanitize_address sspstrong uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #1 = { nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #2 = { argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #3 = { argmemonly nocallback nofree nosync nounwind willreturn }
attributes #4 = { null_pointer_is_valid "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #5 = { argmemonly mustprogress nofree nosync nounwind null_pointer_is_valid sanitize_address sspstrong willreturn uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #6 = { argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid sanitize_address sspstrong willreturn uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #7 = { inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #8 = { mustprogress nofree nounwind null_pointer_is_valid readonly willreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #9 = { nofree norecurse nosync nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #10 = { nofree norecurse nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #11 = { mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #12 = { nofree null_pointer_is_valid "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #13 = { mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #14 = { cold null_pointer_is_valid "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #15 = { nocallback nofree nosync nounwind readnone speculatable willreturn }
attributes #16 = { inaccessiblemem_or_argmemonly nocallback nofree nosync nounwind willreturn }
attributes #17 = { nounwind readonly }
attributes #18 = { null_pointer_is_valid allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #19 = { null_pointer_is_valid allocsize(2) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #20 = { nounwind }
attributes #21 = { nounwind uwtable(sync) "frame-pointer"="all" }
attributes #22 = { cold nounwind }
attributes #23 = { nounwind readnone }
attributes #24 = { nounwind readonly willreturn }
attributes #25 = { nounwind allocsize(0) }
attributes #26 = { nounwind allocsize(2) }

!llvm.asan.globals = !{!0, !2, !4, !6, !8, !10, !12, !14, !16, !18, !19, !21, !23, !25, !27, !28, !30, !31, !33, !34, !36, !37, !39, !41, !43, !45, !47, !49, !51, !53, !55, !57, !59, !61, !63, !65, !67, !69, !71, !72, !73, !75, !76, !77, !79, !80, !82, !83, !84, !85, !87, !89, !91, !93, !95, !97, !98, !100, !101, !103, !104, !105, !106, !107, !108, !110, !111, !112, !113, !115, !116, !118, !119, !121, !123, !124, !126, !127, !128, !129, !130, !131, !133, !134, !135, !136, !138, !139, !141, !142, !144, !145, !146, !148, !150, !152, !153, !155, !156, !158, !159, !161, !162, !164, !166, !167, !169, !171, !172, !174, !176, !178, !180, !181, !183, !185, !186, !188, !190, !191, !193, !194, !196, !198, !200, !202, !204, !206, !208, !210, !211, !212, !214, !215, !217, !218, !220, !221, !223, !225, !227, !229, !231, !233, !235, !236, !238, !240, !242, !244, !246}
!llvm.named.register.sp = !{!248}
!llvm.module.flags = !{!249, !250, !251, !252, !253, !254, !255, !256}
!llvm.ident = !{!257}

!0 = !{ptr @sysctl_sched_latency, !1, !"sysctl_sched_latency", i1 false, i1 false}
!1 = !{!"../kernel/sched/fair.c", i32 38, i32 14}
!2 = !{ptr @sysctl_sched_tunable_scaling, !3, !"sysctl_sched_tunable_scaling", i1 false, i1 false}
!3 = !{!"../kernel/sched/fair.c", i32 52, i32 14}
!4 = !{ptr @sysctl_sched_min_granularity, !5, !"sysctl_sched_min_granularity", i1 false, i1 false}
!5 = !{!"../kernel/sched/fair.c", i32 59, i32 14}
!6 = !{ptr @sysctl_sched_idle_min_granularity, !7, !"sysctl_sched_idle_min_granularity", i1 false, i1 false}
!7 = !{!"../kernel/sched/fair.c", i32 68, i32 14}
!8 = !{ptr @sysctl_sched_wakeup_granularity, !9, !"sysctl_sched_wakeup_granularity", i1 false, i1 false}
!9 = !{!"../kernel/sched/fair.c", i32 90, i32 14}
!10 = !{ptr @sysctl_sched_migration_cost, !11, !"sysctl_sched_migration_cost", i1 false, i1 false}
!11 = !{!"../kernel/sched/fair.c", i32 93, i32 26}
!12 = !{ptr @__setup_setup_sched_thermal_decay_shift, !13, !"__setup_setup_sched_thermal_decay_shift", i1 false, i1 false}
!13 = !{!"../kernel/sched/fair.c", i32 106, i32 1}
!14 = !{ptr @sysctl_sched_cfs_bandwidth_slice, !15, !"sysctl_sched_cfs_bandwidth_slice", i1 false, i1 false}
!15 = !{!"../kernel/sched/fair.c", i32 144, i32 14}
!16 = !{ptr @init_cfs_bandwidth.__key, !17, !"__key", i1 false, i1 false}
!17 = !{!"../kernel/sched/fair.c", i32 5349, i32 2}
!18 = !{ptr @.str, !17, !"<string literal>", i1 false, i1 false}
!19 = !{ptr @.str.1, !20, !"<string literal>", i1 false, i1 false}
!20 = !{!"../kernel/sched/fair.c", i32 5371, i32 2}
!21 = !{ptr @sched_smt_present, !22, !"sched_smt_present", i1 false, i1 false}
!22 = !{!"../kernel/sched/fair.c", i32 6136, i32 1}
!23 = !{ptr @__ksymtab_sched_smt_present, !24, !"__ksymtab_sched_smt_present", i1 false, i1 false}
!24 = !{!"../kernel/sched/fair.c", i32 6137, i32 1}
!25 = distinct !{null, !26, !"__already_done", i1 false, i1 false}
!26 = !{!"../kernel/sched/fair.c", i32 10549, i32 2}
!27 = !{ptr @.str.2, !26, !"<string literal>", i1 false, i1 false}
!28 = distinct !{null, !29, !"__already_done", i1 false, i1 false}
!29 = !{!"../kernel/sched/fair.c", i32 10585, i32 2}
!30 = !{ptr @.str.3, !29, !"<string literal>", i1 false, i1 false}
!31 = distinct !{null, !32, !"__already_done", i1 false, i1 false}
!32 = !{!"../kernel/sched/fair.c", i32 11102, i32 2}
!33 = !{ptr @.str.4, !32, !"<string literal>", i1 false, i1 false}
!34 = !{ptr @init_cfs_rq.__key, !35, !"__key", i1 false, i1 false}
!35 = !{!"../kernel/sched/fair.c", i32 11406, i32 2}
!36 = !{ptr @.str.5, !35, !"<string literal>", i1 false, i1 false}
!37 = distinct !{null, !38, !"__already_done", i1 false, i1 false}
!38 = !{!"../kernel/sched/fair.c", i32 11658, i32 7}
!39 = !{ptr @fair_sched_class, !40, !"fair_sched_class", i1 false, i1 false}
!40 = !{!"../kernel/sched/fair.c", i32 11735, i32 1}
!41 = !{ptr @__ksymtab_sched_trace_cfs_rq_avg, !42, !"__ksymtab_sched_trace_cfs_rq_avg", i1 false, i1 false}
!42 = !{!"../kernel/sched/fair.c", i32 11843, i32 1}
!43 = !{ptr @.str.6, !44, !"<string literal>", i1 false, i1 false}
!44 = !{!"../kernel/sched/fair.c", i32 11849, i32 17}
!45 = !{ptr @__ksymtab_sched_trace_cfs_rq_path, !46, !"__ksymtab_sched_trace_cfs_rq_path", i1 false, i1 false}
!46 = !{!"../kernel/sched/fair.c", i32 11857, i32 1}
!47 = !{ptr @__ksymtab_sched_trace_cfs_rq_cpu, !48, !"__ksymtab_sched_trace_cfs_rq_cpu", i1 false, i1 false}
!48 = !{!"../kernel/sched/fair.c", i32 11863, i32 1}
!49 = !{ptr @__ksymtab_sched_trace_rq_avg_rt, !50, !"__ksymtab_sched_trace_rq_avg_rt", i1 false, i1 false}
!50 = !{!"../kernel/sched/fair.c", i32 11873, i32 1}
!51 = !{ptr @__ksymtab_sched_trace_rq_avg_dl, !52, !"__ksymtab_sched_trace_rq_avg_dl", i1 false, i1 false}
!52 = !{!"../kernel/sched/fair.c", i32 11883, i32 1}
!53 = !{ptr @__ksymtab_sched_trace_rq_avg_irq, !54, !"__ksymtab_sched_trace_rq_avg_irq", i1 false, i1 false}
!54 = !{!"../kernel/sched/fair.c", i32 11893, i32 1}
!55 = !{ptr @__ksymtab_sched_trace_rq_cpu, !56, !"__ksymtab_sched_trace_rq_cpu", i1 false, i1 false}
!56 = !{!"../kernel/sched/fair.c", i32 11899, i32 1}
!57 = !{ptr @__ksymtab_sched_trace_rq_cpu_capacity, !58, !"__ksymtab_sched_trace_rq_cpu_capacity", i1 false, i1 false}
!58 = !{!"../kernel/sched/fair.c", i32 11911, i32 1}
!59 = !{ptr @__ksymtab_sched_trace_rd_span, !60, !"__ksymtab_sched_trace_rd_span", i1 false, i1 false}
!60 = !{!"../kernel/sched/fair.c", i32 11921, i32 1}
!61 = !{ptr @__ksymtab_sched_trace_rq_nr_running, !62, !"__ksymtab_sched_trace_rq_nr_running", i1 false, i1 false}
!62 = !{!"../kernel/sched/fair.c", i32 11927, i32 1}
!63 = !{ptr @sysctl_sched_child_runs_first, !64, !"sysctl_sched_child_runs_first", i1 false, i1 false}
!64 = !{!"../kernel/sched/fair.c", i32 79, i32 14}
!65 = !{ptr @sched_thermal_decay_shift, !66, !"sched_thermal_decay_shift", i1 false, i1 false}
!66 = !{!"../kernel/sched/fair.c", i32 95, i32 5}
!67 = !{ptr @__cfs_bandwidth_used, !68, !"__cfs_bandwidth_used", i1 false, i1 false}
!68 = !{!"../kernel/sched/fair.c", i32 4623, i32 26}
!69 = !{ptr @__pcpu_scope_load_balance_mask, !70, !"__pcpu_scope_load_balance_mask", i1 false, i1 false}
!70 = !{!"../kernel/sched/fair.c", i32 5781, i32 1}
!71 = !{ptr @__pcpu_unique_load_balance_mask, !70, !"__pcpu_unique_load_balance_mask", i1 false, i1 false}
!72 = !{ptr @load_balance_mask, !70, !"load_balance_mask", i1 false, i1 false}
!73 = !{ptr @__pcpu_scope_select_idle_mask, !74, !"__pcpu_scope_select_idle_mask", i1 false, i1 false}
!74 = !{!"../kernel/sched/fair.c", i32 5782, i32 1}
!75 = !{ptr @__pcpu_unique_select_idle_mask, !74, !"__pcpu_unique_select_idle_mask", i1 false, i1 false}
!76 = !{ptr @select_idle_mask, !74, !"select_idle_mask", i1 false, i1 false}
!77 = !{ptr @nohz, !78, !"nohz", i1 false, i1 false}
!78 = !{!"../kernel/sched/fair.c", i32 5793, i32 3}
!79 = !{ptr @__setup_str_setup_sched_thermal_decay_shift, !13, !"__setup_str_setup_sched_thermal_decay_shift", i1 false, i1 false}
!80 = !{ptr @.str.7, !81, !"<string literal>", i1 false, i1 false}
!81 = !{!"../kernel/sched/fair.c", i32 101, i32 3}
!82 = !{ptr @.str.8, !81, !"<string literal>", i1 false, i1 false}
!83 = !{ptr @setup_sched_thermal_decay_shift._entry, !81, !"_entry", i1 false, i1 false}
!84 = !{ptr @setup_sched_thermal_decay_shift._entry_ptr, !81, !"_entry_ptr", i1 false, i1 false}
!85 = !{ptr @sched_nr_latency, !86, !"sched_nr_latency", i1 false, i1 false}
!86 = !{!"../kernel/sched/fair.c", i32 73, i32 21}
!87 = !{ptr @normalized_sysctl_sched_min_granularity, !88, !"normalized_sysctl_sched_min_granularity", i1 false, i1 false}
!88 = !{!"../kernel/sched/fair.c", i32 60, i32 21}
!89 = !{ptr @normalized_sysctl_sched_latency, !90, !"normalized_sysctl_sched_latency", i1 false, i1 false}
!90 = !{!"../kernel/sched/fair.c", i32 39, i32 21}
!91 = !{ptr @normalized_sysctl_sched_wakeup_granularity, !92, !"normalized_sysctl_sched_wakeup_granularity", i1 false, i1 false}
!92 = !{!"../kernel/sched/fair.c", i32 91, i32 21}
!93 = !{ptr @.str.9, !94, !"<string literal>", i1 false, i1 false}
!94 = !{!"../kernel/sched/sched.h", i32 1309, i32 2}
!95 = distinct !{null, !96, !"__already_done", i1 false, i1 false}
!96 = !{!"../kernel/sched/sched.h", i32 1459, i32 2}
!97 = !{ptr @.str.10, !96, !"<string literal>", i1 false, i1 false}
!98 = distinct !{null, !99, !"__already_done", i1 false, i1 false}
!99 = !{!"../kernel/sched/fair.c", i32 3300, i32 2}
!100 = !{ptr @.str.11, !99, !"<string literal>", i1 false, i1 false}
!101 = distinct !{null, !102, !"__already_done", i1 false, i1 false}
!102 = !{!"../kernel/sched/stats.h", i32 65, i32 3}
!103 = !{ptr @.str.12, !102, !"<string literal>", i1 false, i1 false}
!104 = !{ptr @.str.13, !102, !"<string literal>", i1 false, i1 false}
!105 = !{ptr @.str.14, !102, !"<string literal>", i1 false, i1 false}
!106 = !{ptr @check_schedstat_required._entry, !102, !"_entry", i1 false, i1 false}
!107 = !{ptr @check_schedstat_required._entry_ptr, !102, !"_entry_ptr", i1 false, i1 false}
!108 = distinct !{null, !109, !"__already_done", i1 false, i1 false}
!109 = !{!"../include/trace/events/sched.h", i32 691, i32 1}
!110 = !{ptr @.str.15, !109, !"<string literal>", i1 false, i1 false}
!111 = distinct !{null, !109, !"__warned", i1 false, i1 false}
!112 = !{ptr @.str.16, !109, !"<string literal>", i1 false, i1 false}
!113 = distinct !{null, !114, !"__already_done", i1 false, i1 false}
!114 = !{!"../include/linux/cpumask.h", i32 108, i32 2}
!115 = !{ptr @.str.17, !114, !"<string literal>", i1 false, i1 false}
!116 = distinct !{null, !117, !"__already_done", i1 false, i1 false}
!117 = !{!"../include/trace/events/sched.h", i32 711, i32 1}
!118 = distinct !{null, !117, !"__warned", i1 false, i1 false}
!119 = distinct !{null, !120, !"__warned", i1 false, i1 false}
!120 = !{!"../kernel/sched/sched.h", i32 2835, i32 9}
!121 = distinct !{null, !122, !"__already_done", i1 false, i1 false}
!122 = !{!"../kernel/sched/fair.c", i32 387, i32 2}
!123 = !{ptr @.str.18, !122, !"<string literal>", i1 false, i1 false}
!124 = !{ptr @.str.19, !125, !"<string literal>", i1 false, i1 false}
!125 = !{!"../kernel/sched/fair.c", i32 5323, i32 5}
!126 = !{ptr @sched_cfs_period_timer._rs, !125, !"_rs", i1 false, i1 false}
!127 = !{ptr @__func__.sched_cfs_period_timer, !125, !"<string literal>", i1 false, i1 false}
!128 = !{ptr @.str.20, !125, !"<string literal>", i1 false, i1 false}
!129 = !{ptr @sched_cfs_period_timer._entry, !125, !"_entry", i1 false, i1 false}
!130 = !{ptr @sched_cfs_period_timer._entry_ptr, !125, !"_entry_ptr", i1 false, i1 false}
!131 = !{ptr @sched_cfs_period_timer._rs.21, !132, !"_rs", i1 false, i1 false}
!132 = !{!"../kernel/sched/fair.c", i32 5329, i32 5}
!133 = !{ptr @.str.23, !132, !"<string literal>", i1 false, i1 false}
!134 = !{ptr @sched_cfs_period_timer._entry.22, !132, !"_entry", i1 false, i1 false}
!135 = !{ptr @sched_cfs_period_timer._entry_ptr.24, !132, !"_entry_ptr", i1 false, i1 false}
!136 = distinct !{null, !137, !"__warned", i1 false, i1 false}
!137 = !{!"../kernel/sched/fair.c", i32 5010, i32 2}
!138 = !{ptr @.str.25, !137, !"<string literal>", i1 false, i1 false}
!139 = distinct !{null, !140, !"__already_done", i1 false, i1 false}
!140 = !{!"../kernel/sched/fair.c", i32 5020, i32 3}
!141 = !{ptr @.str.26, !140, !"<string literal>", i1 false, i1 false}
!142 = distinct !{null, !143, !"__warned", i1 false, i1 false}
!143 = !{!"../include/linux/rcupdate.h", i32 695, i32 2}
!144 = !{ptr @.str.27, !143, !"<string literal>", i1 false, i1 false}
!145 = !{ptr @.str.28, !143, !"<string literal>", i1 false, i1 false}
!146 = distinct !{null, !147, !"__warned", i1 false, i1 false}
!147 = !{!"../kernel/sched/fair.c", i32 6152, i32 8}
!148 = distinct !{null, !149, !"__warned", i1 false, i1 false}
!149 = !{!"../kernel/sched/fair.c", i32 6143, i32 8}
!150 = distinct !{null, !151, !"__warned", i1 false, i1 false}
!151 = !{!"../include/linux/rcupdate.h", i32 723, i32 2}
!152 = !{ptr @.str.29, !151, !"<string literal>", i1 false, i1 false}
!153 = distinct !{null, !154, !"__already_done", i1 false, i1 false}
!154 = !{!"../include/trace/events/sched.h", i32 517, i32 1}
!155 = distinct !{null, !154, !"__warned", i1 false, i1 false}
!156 = distinct !{null, !157, !"__warned", i1 false, i1 false}
!157 = !{!"../include/linux/cgroup.h", i32 481, i32 9}
!158 = !{ptr @.str.30, !157, !"<string literal>", i1 false, i1 false}
!159 = distinct !{null, !160, !"__already_done", i1 false, i1 false}
!160 = !{!"../kernel/sched/sched.h", i32 1376, i32 2}
!161 = !{ptr @.str.31, !160, !"<string literal>", i1 false, i1 false}
!162 = distinct !{null, !163, !"__already_done", i1 false, i1 false}
!163 = !{!"../kernel/sched/sched.h", i32 2190, i32 2}
!164 = distinct !{null, !165, !"__already_done", i1 false, i1 false}
!165 = !{!"../kernel/sched/fair.c", i32 5503, i32 2}
!166 = !{ptr @.str.32, !165, !"<string literal>", i1 false, i1 false}
!167 = !{ptr @max_load_balance_interval, !168, !"max_load_balance_interval", i1 false, i1 false}
!168 = !{!"../kernel/sched/fair.c", i32 7546, i32 36}
!169 = distinct !{null, !170, !"__already_done", i1 false, i1 false}
!170 = !{!"../include/trace/events/sched.h", i32 715, i32 1}
!171 = distinct !{null, !170, !"__warned", i1 false, i1 false}
!172 = distinct !{null, !173, !"__warned", i1 false, i1 false}
!173 = !{!"../kernel/sched/fair.c", i32 10536, i32 7}
!174 = distinct !{null, !175, !"__warned", i1 false, i1 false}
!175 = !{!"../kernel/sched/fair.c", i32 10345, i32 9}
!176 = distinct !{null, !177, !"__warned", i1 false, i1 false}
!177 = !{!"../kernel/sched/fair.c", i32 10566, i32 7}
!178 = distinct !{null, !179, !"__already_done", i1 false, i1 false}
!179 = !{!"../kernel/sched/fair.c", i32 10673, i32 2}
!180 = !{ptr @.str.33, !179, !"<string literal>", i1 false, i1 false}
!181 = distinct !{null, !182, !"__warned", i1 false, i1 false}
!182 = !{!"../kernel/sched/fair.c", i32 10275, i32 2}
!183 = !{ptr @.str.34, !184, !"<string literal>", i1 false, i1 false}
!184 = !{!"../kernel/sched/fair.c", i32 10220, i32 8}
!185 = !{ptr @balancing, !184, !"balancing", i1 false, i1 false}
!186 = distinct !{null, !187, !"__warned", i1 false, i1 false}
!187 = !{!"../kernel/sched/fair.c", i32 9484, i32 7}
!188 = distinct !{null, !189, !"__already_done", i1 false, i1 false}
!189 = !{!"../include/trace/events/sched.h", i32 719, i32 1}
!190 = distinct !{null, !189, !"__warned", i1 false, i1 false}
!191 = distinct !{null, !192, !"__already_done", i1 false, i1 false}
!192 = !{!"../kernel/sched/sched.h", i32 1545, i32 2}
!193 = !{ptr @.str.35, !192, !"<string literal>", i1 false, i1 false}
!194 = distinct !{null, !195, !"__warned", i1 false, i1 false}
!195 = !{!"../kernel/sched/fair.c", i32 10179, i32 2}
!196 = distinct !{null, !197, !"__warned", i1 false, i1 false}
!197 = !{!"../kernel/sched/fair.c", i32 10885, i32 7}
!198 = distinct !{null, !199, !"__warned", i1 false, i1 false}
!199 = !{!"../kernel/sched/fair.c", i32 10904, i32 2}
!200 = distinct !{null, !201, !"__warned", i1 false, i1 false}
!201 = !{!"../kernel/sched/fair.c", i32 10455, i32 7}
!202 = distinct !{null, !203, !"__warned", i1 false, i1 false}
!203 = !{!"../kernel/sched/fair.c", i32 10468, i32 7}
!204 = distinct !{null, !205, !"__warned", i1 false, i1 false}
!205 = !{!"../kernel/sched/fair.c", i32 10483, i32 7}
!206 = distinct !{null, !207, !"__warned", i1 false, i1 false}
!207 = !{!"../kernel/sched/fair.c", i32 10504, i32 8}
!208 = !{ptr @.str.40, !209, !"<string literal>", i1 false, i1 false}
!209 = !{!"../kernel/sched/fair.c", i32 11576, i32 8}
!210 = !{ptr @.str.41, !209, !"<string literal>", i1 false, i1 false}
!211 = !{ptr @shares_mutex, !209, !"shares_mutex", i1 false, i1 false}
!212 = distinct !{null, !213, !"__already_done", i1 false, i1 false}
!213 = !{!"../include/trace/events/sched.h", i32 723, i32 1}
!214 = distinct !{null, !213, !"__warned", i1 false, i1 false}
!215 = distinct !{null, !216, !"__already_done", i1 false, i1 false}
!216 = !{!"../kernel/sched/fair.c", i32 7065, i32 7}
!217 = !{ptr @.str.42, !216, !"<string literal>", i1 false, i1 false}
!218 = distinct !{null, !219, !"__already_done", i1 false, i1 false}
!219 = !{!"../include/trace/events/sched.h", i32 727, i32 1}
!220 = distinct !{null, !219, !"__warned", i1 false, i1 false}
!221 = distinct !{null, !222, !"__already_done", i1 false, i1 false}
!222 = !{!"../kernel/sched/fair.c", i32 7054, i32 7}
!223 = distinct !{null, !224, !"__warned", i1 false, i1 false}
!224 = !{!"../kernel/sched/fair.c", i32 6886, i32 2}
!225 = distinct !{null, !226, !"__warned", i1 false, i1 false}
!226 = !{!"../kernel/sched/fair.c", i32 6742, i32 7}
!227 = distinct !{null, !228, !"__warned", i1 false, i1 false}
!228 = !{!"../kernel/sched/fair.c", i32 6750, i32 7}
!229 = distinct !{null, !230, !"<string literal>", i1 false, i1 false}
!230 = !{!"../kernel/sched/fair.c", i32 5899, i32 15}
!231 = distinct !{null, !232, !"__warned", i1 false, i1 false}
!232 = !{!"../kernel/sched/fair.c", i32 6115, i32 3}
!233 = distinct !{null, !234, !"__already_done", i1 false, i1 false}
!234 = !{!"../kernel/sched/sched.h", i32 2300, i32 2}
!235 = !{ptr @.str.45, !234, !"<string literal>", i1 false, i1 false}
!236 = distinct !{null, !237, !"__already_done", i1 false, i1 false}
!237 = !{!"../kernel/sched/fair.c", i32 6410, i32 2}
!238 = distinct !{null, !239, !"__warned", i1 false, i1 false}
!239 = !{!"../kernel/sched/fair.c", i32 6457, i32 8}
!240 = distinct !{null, !241, !"__warned", i1 false, i1 false}
!241 = !{!"../kernel/sched/fair.c", i32 6472, i32 7}
!242 = distinct !{null, !243, !"__warned", i1 false, i1 false}
!243 = !{!"../kernel/sched/fair.c", i32 6279, i32 12}
!244 = distinct !{null, !245, !"__warned", i1 false, i1 false}
!245 = !{!"../kernel/sched/fair.c", i32 5406, i32 2}
!246 = distinct !{null, !247, !"__warned", i1 false, i1 false}
!247 = !{!"../kernel/sched/fair.c", i32 5425, i32 2}
!248 = !{!"sp"}
!249 = !{i32 1, !"wchar_size", i32 2}
!250 = !{i32 1, !"min_enum_size", i32 4}
!251 = !{i32 8, !"branch-target-enforcement", i32 0}
!252 = !{i32 8, !"sign-return-address", i32 0}
!253 = !{i32 8, !"sign-return-address-all", i32 0}
!254 = !{i32 8, !"sign-return-address-with-bkey", i32 0}
!255 = !{i32 7, !"uwtable", i32 1}
!256 = !{i32 7, !"frame-pointer", i32 2}
!257 = !{!"clang version 15.0.0 (git@github.com:linkeLi0421/llvm-project15-IRDumperPass.git 23ab625cb005cd08da083f9b643a7feed9af8abe)"}
!258 = !{i32 0, i32 33}
!259 = !{!"branch_weights", i32 2000, i32 1}
!260 = !{!"branch_weights", i32 1, i32 2000}
!261 = !{i64 2148631665, i64 2148631670, i64 2148631683, i64 2148631727, i64 2148631761, i64 2148631782}
!262 = !{i64 2148818272, i64 2148818298, i64 2148818327, i64 2148818361, i64 2148818392, i64 2148818415}
!263 = !{i64 2148656852, i64 2148657132, i64 2148657466, i64 2148657800}
!264 = !{i64 2158848169}
!265 = !{i64 2149671178}
!266 = !{i64 1171308, i64 1171335, i64 1171357, i64 1171385}
!267 = !{i64 1171716, i64 1171743, i64 1171776, i64 1171797, i64 1171824, i64 1171850}
!268 = !{i64 2149645786}
!269 = !{i64 2149646052}
!270 = !{!"branch_weights", i32 2146410443, i32 1073205}
!271 = !{i64 2158771912}
!272 = !{i64 2148826410, i64 2148826436, i64 2148826465, i64 2148826499, i64 2148826530, i64 2148826553}
!273 = !{i64 2148820737, i64 2148820763, i64 2148820792, i64 2148820826, i64 2148820857, i64 2148820880}
!274 = !{i64 2160245162}
!275 = !{i64 2148915542}
!276 = !{i64 2148825517, i64 2148825549, i64 2148825578, i64 2148825612, i64 2148825643, i64 2148825666}
!277 = !{i64 2148915773}
!278 = !{i64 2160263576}
!279 = !{i64 1212530, i64 1212591}
!280 = !{i64 1215262}
!281 = !{i64 1215547}
!282 = !{i64 2148917062}
!283 = !{i64 2148827130, i64 2148827162, i64 2148827191, i64 2148827225, i64 2148827256, i64 2148827279}
!284 = !{i64 2148917289}
!285 = !{i64 1212965}
!286 = !{i64 1212775}
!287 = !{i64 2158955178}
!288 = !{i64 2159847971, i64 2159848456, i64 2159848008, i64 2159848064, i64 2159848098, i64 2159848122, i64 2159848163, i64 2159848184, i64 2159848212, i64 2159848246}
!289 = !{i64 2159843981}
!290 = !{i64 2158926838}
!291 = !{i64 2158039750}
!292 = !{i64 2158039947}
!293 = !{i64 2149654345}
!294 = !{i64 2149655381}
!295 = !{i64 2158121129}
!296 = !{i64 2158121316}
!297 = !{i64 2157913500}
!298 = !{i64 2157913743}
!299 = !{i64 2158136866}
!300 = !{i64 2158137075}
!301 = !{i64 2160003279}
!302 = !{i64 2160020197}
!303 = !{i64 2160044238, i64 2160044723, i64 2160044275, i64 2160044331, i64 2160044365, i64 2160044389, i64 2160044430, i64 2160044451, i64 2160044479, i64 2160044513}
!304 = !{i64 2160063155, i64 2160063641, i64 2160063192, i64 2160063248, i64 2160063282, i64 2160063306, i64 2160063347, i64 2160063368, i64 2160063396, i64 2160063430}
!305 = !{i64 2158157672}
!306 = !{i64 2158157909}
!307 = !{i64 2159868523, i64 2159869008, i64 2159868560, i64 2159868616, i64 2159868650, i64 2159868674, i64 2159868715, i64 2159868736, i64 2159868764, i64 2159868798}
!308 = !{i64 2158174275}
!309 = !{i64 2158174492}
!310 = !{i64 2158190717}
!311 = !{i64 2158190924}
!312 = !{i64 2148632068, i64 2148632073, i64 2148632094, i64 2148632138, i64 2148632172, i64 2148632193}
!313 = !{i64 2159656372}
!314 = !{i64 2159661306}
!315 = !{i64 2159682988}
!316 = !{i64 2159687882}
!317 = !{i64 2159389774}
!318 = !{i64 2159406547}
!319 = !{i64 2159288719}
!320 = !{i64 2159305492}
