; ModuleID = '/llk/IR_all_yes/mm/memcontrol.c_pt.bc'
source_filename = "../mm/memcontrol.c"
target datalayout = "E-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64"
target triple = "armebv6k-unknown-linux-gnueabi"

module asm ".syntax unified"
module asm "\09.section \22___kcrctab+memory_cgrp_subsys\22, \22a\22\09"
module asm "\09.weak\09__crc_memory_cgrp_subsys\09\09\09\09"
module asm "\09.long\09__crc_memory_cgrp_subsys\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_memory_cgrp_subsys:\09\09\09\09\09"
module asm "\09.asciz \09\22memory_cgrp_subsys\22\09\09\09\09\09"
module asm "__kstrtabns_memory_cgrp_subsys:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+int_active_memcg\22, \22a\22\09"
module asm "\09.weak\09__crc_int_active_memcg\09\09\09\09"
module asm "\09.long\09__crc_int_active_memcg\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_int_active_memcg:\09\09\09\09\09"
module asm "\09.asciz \09\22int_active_memcg\22\09\09\09\09\09"
module asm "__kstrtabns_int_active_memcg:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+memcg_kmem_enabled_key\22, \22a\22\09"
module asm "\09.weak\09__crc_memcg_kmem_enabled_key\09\09\09\09"
module asm "\09.long\09__crc_memcg_kmem_enabled_key\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_memcg_kmem_enabled_key:\09\09\09\09\09"
module asm "\09.asciz \09\22memcg_kmem_enabled_key\22\09\09\09\09\09"
module asm "__kstrtabns_memcg_kmem_enabled_key:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+__mod_lruvec_page_state\22, \22a\22\09"
module asm "\09.weak\09__crc___mod_lruvec_page_state\09\09\09\09"
module asm "\09.long\09__crc___mod_lruvec_page_state\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab___mod_lruvec_page_state:\09\09\09\09\09"
module asm "\09.asciz \09\22__mod_lruvec_page_state\22\09\09\09\09\09"
module asm "__kstrtabns___mod_lruvec_page_state:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+mem_cgroup_from_task\22, \22a\22\09"
module asm "\09.weak\09__crc_mem_cgroup_from_task\09\09\09\09"
module asm "\09.long\09__crc_mem_cgroup_from_task\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_mem_cgroup_from_task:\09\09\09\09\09"
module asm "\09.asciz \09\22mem_cgroup_from_task\22\09\09\09\09\09"
module asm "__kstrtabns_mem_cgroup_from_task:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+get_mem_cgroup_from_mm\22, \22a\22\09"
module asm "\09.weak\09__crc_get_mem_cgroup_from_mm\09\09\09\09"
module asm "\09.long\09__crc_get_mem_cgroup_from_mm\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_get_mem_cgroup_from_mm:\09\09\09\09\09"
module asm "\09.asciz \09\22get_mem_cgroup_from_mm\22\09\09\09\09\09"
module asm "__kstrtabns_get_mem_cgroup_from_mm:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___kcrctab+memcg_sockets_enabled_key\22, \22a\22\09"
module asm "\09.weak\09__crc_memcg_sockets_enabled_key\09\09\09\09"
module asm "\09.long\09__crc_memcg_sockets_enabled_key\09\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_memcg_sockets_enabled_key:\09\09\09\09\09"
module asm "\09.asciz \09\22memcg_sockets_enabled_key\22\09\09\09\09\09"
module asm "__kstrtabns_memcg_sockets_enabled_key:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"

%struct.cgroup_subsys = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i8, i32, ptr, ptr, ptr, %struct.idr, %struct.list_head, ptr, ptr, i32 }
%struct.idr = type { %struct.xarray, i32, i32 }
%struct.xarray = type { %struct.spinlock, i32, ptr }
%struct.spinlock = type { %union.anon.2 }
%union.anon.2 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock_t, i32, i32, ptr, %struct.lockdep_map }
%struct.arch_spinlock_t = type { %union.anon.0 }
%union.anon.0 = type { i32 }
%struct.lockdep_map = type { ptr, [2 x ptr], ptr, i8, i8, i8, i32, i32 }
%struct.list_head = type { ptr, ptr }
%struct.kernel_symbol = type { i32, ptr, ptr }
%struct.rw_semaphore = type { %struct.atomic_t, %struct.atomic_t, %struct.optimistic_spin_queue, %struct.raw_spinlock, %struct.list_head, ptr, %struct.lockdep_map }
%struct.atomic_t = type { i32 }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.static_key_true = type { %struct.static_key }
%struct.static_key = type { %struct.atomic_t, %union.anon.65 }
%union.anon.65 = type { i32 }
%struct.pi_entry = type { ptr, ptr, ptr, i32, ptr, ptr }
%struct.wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.mem_cgroup_tree = type { [1 x ptr] }
%struct.cftype = type { [64 x i8], i32, i32, i32, i32, ptr, %struct.list_head, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, %struct.lock_class_key }
%struct.lock_class_key = type { %union.anon }
%union.anon = type { %struct.hlist_node }
%struct.hlist_node = type { ptr, ptr }
%struct.obs_kernel_param = type { ptr, ptr, i32 }
%struct.memcg_stock_pcp = type { ptr, i32, %struct.obj_stock, %struct.obj_stock, %struct.work_struct, i32 }
%struct.obj_stock = type { ptr, ptr, i32, i32, i32 }
%struct.work_struct = type { %struct.atomic_t, %struct.list_head, ptr, %struct.lockdep_map }
%struct.pglist_data = type { [4 x %struct.zone], [1 x %struct.zonelist], i32, ptr, ptr, i32, i32, i32, i32, %struct.wait_queue_head, %struct.wait_queue_head, [4 x %struct.wait_queue_head], %struct.atomic_t, i32, ptr, i32, i32, i32, i32, i32, %struct.wait_queue_head, ptr, i8, i32, [36 x i8], %struct.zone_padding, %struct.lruvec, i32, [12 x i8], %struct.zone_padding, ptr, [40 x %struct.atomic_t], [92 x i8] }
%struct.zone = type { [3 x i32], i32, i32, [4 x i32], ptr, ptr, ptr, i32, i32, ptr, i32, %struct.atomic_t, i32, i32, i32, ptr, i32, i32, [36 x i8], %struct.zone_padding, [12 x %struct.free_area], i32, %struct.spinlock, [96 x i8], %struct.zone_padding, i32, i32, [2 x i32], i32, i32, i32, i32, i32, i8, i8, [90 x i8], %struct.zone_padding, [11 x %struct.atomic_t], [0 x %struct.atomic_t], [84 x i8] }
%struct.free_area = type { [6 x %struct.list_head], i32 }
%struct.zonelist = type { [5 x %struct.zoneref] }
%struct.zoneref = type { ptr, i32 }
%struct.lruvec = type { [5 x %struct.list_head], %struct.spinlock, i32, i32, %struct.atomic_t, [2 x i32], i32, ptr }
%struct.zone_padding = type { [0 x i8] }
%struct.mutex = type { %struct.atomic_t, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.list_head, ptr, %struct.lockdep_map }
%struct.memory_stat = type { ptr, i32 }
%struct.cpumask = type { [1 x i32] }
%struct.move_charge_struct = type { %struct.spinlock, ptr, ptr, ptr, i32, i32, i32, i32, ptr, %struct.wait_queue_head }
%struct.tracepoint = type { ptr, %struct.static_key, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.ida = type { %struct.xarray }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, ptr, i32 }
%struct.timer_list = type { %struct.hlist_node, i32, ptr, i32, %struct.lockdep_map }
%struct.mm_walk_ops = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.cgroup_root = type { ptr, i32, i32, %struct.cgroup, i64, %struct.atomic_t, %struct.list_head, i32, [4096 x i8], [64 x i8] }
%struct.cgroup = type { %struct.cgroup_subsys_state, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, ptr, %struct.cgroup_file, %struct.cgroup_file, i16, i16, i16, i16, [14 x ptr], ptr, %struct.list_head, [14 x %struct.list_head], ptr, ptr, ptr, %struct.list_head, %struct.cgroup_base_stat, %struct.cgroup_base_stat, %struct.prev_cputime, %struct.list_head, %struct.mutex, %struct.wait_queue_head, %struct.work_struct, %struct.psi_group, %struct.cgroup_bpf, %struct.atomic_t, %struct.cgroup_freezer_state, [0 x i64] }
%struct.cgroup_subsys_state = type { ptr, ptr, %struct.percpu_ref, %struct.list_head, %struct.list_head, %struct.list_head, i32, i32, i64, %struct.atomic_t, %struct.work_struct, %struct.rcu_work, ptr }
%struct.percpu_ref = type { i32, ptr }
%struct.rcu_work = type { %struct.work_struct, %struct.callback_head, ptr }
%struct.callback_head = type { ptr, ptr }
%struct.cgroup_file = type { ptr, i32, %struct.timer_list }
%struct.cgroup_base_stat = type { %struct.task_cputime }
%struct.task_cputime = type { i64, i64, i64 }
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.psi_group = type { %struct.mutex, ptr, [6 x i64], i64, i64, %struct.delayed_work, [2 x [6 x i64]], [6 x [3 x i32]], ptr, %struct.timer_list, %struct.wait_queue_head, %struct.atomic_t, %struct.mutex, %struct.list_head, [6 x i32], i32, i64, [6 x i64], i64, i64 }
%struct.cgroup_bpf = type { [23 x ptr], [23 x %struct.list_head], [23 x i32], %struct.list_head, ptr, %struct.percpu_ref, %struct.work_struct }
%struct.cgroup_freezer_state = type { i8, i32, i32, i32 }
%struct.mem_cgroup = type { %struct.cgroup_subsys_state, %struct.mem_cgroup_id, %struct.page_counter, %union.anon.57, %struct.page_counter, %struct.page_counter, %struct.work_struct, i32, %struct.vmpressure, i8, i8, i32, i32, i32, %struct.cgroup_file, %struct.cgroup_file, %struct.cgroup_file, %struct.mutex, %struct.mem_cgroup_thresholds, %struct.mem_cgroup_thresholds, %struct.list_head, i32, %struct.spinlock, i32, [20 x i8], %struct.memcg_padding, %struct.memcg_vmstats, [9 x %struct.atomic_t], [9 x %struct.atomic_t], i32, i8, i32, i32, ptr, %struct.list_head, [92 x i8], %struct.memcg_padding, %struct.atomic_t, ptr, ptr, %struct.list_head, %struct.wb_domain, [4 x %struct.memcg_cgwb_frn], %struct.list_head, %struct.spinlock, [0 x ptr], [84 x i8] }
%struct.mem_cgroup_id = type { i32, %struct.refcount_struct }
%struct.refcount_struct = type { %struct.atomic_t }
%union.anon.57 = type { %struct.page_counter }
%struct.page_counter = type { %struct.atomic_t, i32, i32, i32, i32, i32, %struct.atomic_t, %struct.atomic_t, i32, %struct.atomic_t, %struct.atomic_t, i32, i32, ptr }
%struct.vmpressure = type { i32, i32, i32, i32, %struct.spinlock, %struct.list_head, %struct.mutex, %struct.work_struct }
%struct.mem_cgroup_thresholds = type { ptr, ptr }
%struct.memcg_vmstats = type { [44 x i32], [76 x i32], [44 x i32], [76 x i32] }
%struct.memcg_padding = type { [0 x i8] }
%struct.wb_domain = type { %struct.spinlock, %struct.fprop_global, %struct.timer_list, i32, i32, i32 }
%struct.fprop_global = type { %struct.percpu_counter, i32, %struct.seqcount }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, ptr }
%struct.seqcount = type { i32, %struct.lockdep_map }
%struct.memcg_cgwb_frn = type { i64, i32, i64, %struct.wb_completion }
%struct.wb_completion = type { %struct.atomic_t, ptr }
%struct.page = type { i32, %union.anon.25, %union.anon.78, %struct.atomic_t, i32 }
%union.anon.25 = type { %struct.anon.26 }
%struct.anon.26 = type { %struct.list_head, ptr, i32, i32 }
%union.anon.78 = type { %struct.atomic_t }
%struct.thread_info = type { i32, i32, ptr, i32, i32, %struct.cpu_context_save, i32, [16 x i8], [2 x i32], %union.fp_state, %union.vfp_state, i32 }
%struct.cpu_context_save = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [2 x i32] }
%union.fp_state = type { %struct.iwmmxt_struct }
%struct.iwmmxt_struct = type { [38 x i32] }
%union.vfp_state = type { %struct.vfp_hard_struct }
%struct.vfp_hard_struct = type { [32 x i64], i32, i32, i32, i32, i32 }
%struct.obj_cgroup = type { %struct.percpu_ref, ptr, %struct.atomic_t, %union.anon.58 }
%union.anon.58 = type { %struct.list_head }
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.lockdep_map, ptr, ptr, %struct.rb_node, ptr, i32, %union.anon.37, ptr, i64, i16, i16, ptr }
%struct.rb_node = type { i32, ptr, ptr }
%union.anon.37 = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { ptr, ptr, i64, ptr }
%struct.mem_cgroup_per_node = type { %struct.lruvec, ptr, %struct.lruvec_stats, [4 x [5 x i32]], %struct.mem_cgroup_reclaim_iter, ptr, %struct.rb_node, i32, i8, ptr }
%struct.lruvec_stats = type { [40 x i32], [40 x i32] }
%struct.mem_cgroup_reclaim_iter = type { ptr, i32 }
%struct.slab = type { i32, %union.anon.66, ptr, ptr, %union.anon.68, i32, %struct.atomic_t, i32 }
%union.anon.66 = type { %struct.list_head }
%union.anon.68 = type { i32 }
%struct.kmem_cache = type { ptr, i32, i32, i32, i32, %struct.reciprocal_value, i32, i32, i32, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, i32, i32, ptr, i32, i32, i32, ptr, %struct.list_head, %struct.kobject, i32, ptr, %struct.kasan_cache, i32, i32, [1 x ptr] }
%struct.reciprocal_value = type { i32, i8, i8 }
%struct.kmem_cache_order_objects = type { i32 }
%struct.kobject = type { ptr, %struct.list_head, ptr, ptr, ptr, ptr, %struct.kref, %struct.delayed_work, i8 }
%struct.kref = type { %struct.refcount_struct }
%struct.kasan_cache = type { i32, i32, i8 }
%struct.memcg_vmstats_percpu = type { [44 x i32], [76 x i32], [44 x i32], [76 x i32], i32, [2 x i32] }
%struct.task_struct = type { i32, ptr, %struct.refcount_struct, i32, i32, i32, %struct.__call_single_node, i32, i32, ptr, i32, i32, i32, i32, i32, i32, i32, [56 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.sched_dl_entity, ptr, %struct.rb_node, i32, i32, ptr, [2 x %struct.uclamp_se], [2 x %struct.uclamp_se], [116 x i8], %struct.sched_statistics, i32, i32, i32, ptr, ptr, %struct.cpumask, ptr, i16, i16, i32, i8, i8, i32, %struct.list_head, i32, i32, %union.rcu_special, i8, %struct.list_head, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, ptr, ptr, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i32, i32, i8, [3 x i8], i16, i32, %struct.restart_block, i32, i32, i32, ptr, ptr, %struct.list_head, %struct.list_head, ptr, %struct.list_head, %struct.list_head, ptr, [4 x %struct.hlist_node], %struct.list_head, %struct.list_head, ptr, ptr, ptr, ptr, i64, i64, i64, %struct.prev_cputime, i32, i32, i64, i64, i32, i32, %struct.posix_cputimers, ptr, ptr, ptr, ptr, [16 x i8], ptr, %struct.sysv_sem, %struct.sysv_shm, i32, i32, ptr, ptr, ptr, ptr, ptr, ptr, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i32, i32, i32, ptr, %struct.kuid_t, i32, %struct.seccomp, %struct.syscall_user_dispatch, i64, i64, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root_cached, ptr, ptr, ptr, i32, %struct.irqtrace_events, i32, i64, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, %struct.task_io_accounting, i32, i64, i64, i64, %struct.nodemask_t, %struct.seqcount_spinlock, i32, i32, ptr, %struct.list_head, ptr, %struct.list_head, ptr, %struct.mutex, i32, [2 x ptr], %struct.mutex, %struct.list_head, ptr, i32, i32, %struct.tlbflush_unmap_batch, %union.anon.56, ptr, %struct.page_frag, ptr, i32, i32, i32, i32, i32, i32, [32 x %struct.latency_record], i64, i64, i32, ptr, i32, i32, i32, i32, ptr, ptr, i64, i32, i32, ptr, i32, i32, i32, ptr, ptr, ptr, i32, i32, %struct.kmap_ctrl, i32, i32, ptr, ptr, ptr, ptr, %struct.llist_head, %struct.thread_struct, [84 x i8] }
%struct.__call_single_node = type { %struct.llist_node, %union.anon.29 }
%struct.llist_node = type { ptr }
%union.anon.29 = type { i32 }
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, i32, ptr, ptr, ptr, i32, [36 x i8], %struct.sched_avg }
%struct.load_weight = type { i32, i32 }
%struct.sched_avg = type { i64, i64, i64, i32, i32, i32, i32, i32, [4 x i8], %struct.util_est, [72 x i8] }
%struct.util_est = type { i32, i32 }
%struct.sched_rt_entity = type { %struct.list_head, i32, i32, i32, i16, i16, ptr, ptr, ptr, ptr }
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i64, i32, i8, %struct.hrtimer, %struct.hrtimer, ptr }
%struct.hrtimer = type { %struct.timerqueue_node, i64, ptr, ptr, i8, i8, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.uclamp_se = type { i16, [2 x i8] }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [24 x i8] }
%union.rcu_special = type { i32 }
%struct.sched_info = type { i32, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.vmacache = type { i64, [4 x ptr] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i32, ptr, %union.anon.31 }
%union.anon.31 = type { %struct.anon.32 }
%struct.anon.32 = type { ptr, i32, i32, i32, i64, ptr }
%struct.posix_cputimers = type { [3 x %struct.posix_cputimer_base], i32, i32 }
%struct.posix_cputimer_base = type { i64, %struct.timerqueue_head }
%struct.timerqueue_head = type { %struct.rb_root_cached }
%struct.sysv_sem = type { ptr }
%struct.sysv_shm = type { %struct.list_head }
%struct.sigset_t = type { [2 x i32] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.kuid_t = type { i32 }
%struct.seccomp = type { i32, %struct.atomic_t, ptr }
%struct.syscall_user_dispatch = type {}
%struct.wake_q_node = type { ptr }
%struct.rb_root_cached = type { %struct.rb_root, ptr }
%struct.rb_root = type { ptr }
%struct.irqtrace_events = type { i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.held_lock = type { i64, i32, ptr, ptr, i64, i64, i32, i32 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i32] }
%struct.seqcount_spinlock = type { %struct.seqcount, ptr }
%struct.tlbflush_unmap_batch = type {}
%union.anon.56 = type { %struct.callback_head }
%struct.page_frag = type { ptr, i16, i16 }
%struct.latency_record = type { [12 x i32], i32, i32, i32 }
%struct.kmap_ctrl = type { i32, [33 x i32] }
%struct.llist_head = type { ptr }
%struct.thread_struct = type { i32, i32, i32, %struct.debug_info }
%struct.debug_info = type { [32 x ptr] }
%struct.anon.28 = type { ptr, %struct.rb_root, i64, ptr, i32, i32, i32, i32, ptr, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i32, i32, i32, i32, %struct.atomic64_t, i32, i32, i32, i32, %struct.seqcount, %struct.spinlock, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [42 x i32], %struct.mm_rss_stat, ptr, %struct.mm_context_t, i32, %struct.spinlock, ptr, ptr, ptr, ptr, ptr, %struct.atomic_t, %struct.uprobes_state, %struct.work_struct, i32 }
%struct.atomic64_t = type { i64 }
%struct.mm_rss_stat = type { [4 x %struct.atomic_t] }
%struct.mm_context_t = type { %struct.atomic64_t, i32, i32, i32, i32, i32 }
%struct.uprobes_state = type { ptr }
%struct.mem_cgroup_reclaim_cookie = type { ptr, i32 }
%struct.css_task_iter = type { ptr, i32, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, %struct.list_head }
%struct.anon.153 = type { i32, %struct.list_head, ptr, i32, ptr, %struct.atomic_t, %struct.atomic_t, i32 }
%struct.seq_buf = type { ptr, i32, i32, i64 }
%struct.oom_wait_info = type { ptr, %struct.wait_queue_entry }
%struct.wait_queue_entry = type { i32, ptr, ptr, %struct.list_head }
%struct.mem_cgroup_eventfd_list = type { %struct.list_head, ptr }
%struct.oom_control = type { ptr, ptr, ptr, i32, i32, i32, ptr, i32, i32 }
%struct.signal_struct = type { %struct.refcount_struct, %struct.atomic_t, i32, %struct.list_head, %struct.wait_queue_head, ptr, %struct.sigpending, %struct.hlist_head, i32, i32, ptr, i32, i32, ptr, i8, i32, %struct.list_head, %struct.hrtimer, i64, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.posix_cputimers, [4 x ptr], ptr, i32, ptr, ptr, %struct.seqlock_t, i64, i64, i64, i64, i64, i64, %struct.prev_cputime, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, ptr, i32, ptr, i8, i16, i16, ptr, %struct.mutex, %struct.rw_semaphore }
%struct.hlist_head = type { ptr }
%struct.cpu_itimer = type { i64, i64 }
%struct.thread_group_cputimer = type { %struct.task_cputime_atomic }
%struct.task_cputime_atomic = type { %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t }
%struct.seqlock_t = type { %struct.seqcount_spinlock, %struct.spinlock }
%struct.rlimit = type { i32, i32 }
%struct.pacct_struct = type { i32, i32, i32, i64, i64, i32, i32 }
%struct.mem_cgroup_tree_per_node = type { %struct.rb_root, ptr, %struct.spinlock }
%struct.bdi_writeback = type { ptr, i32, i32, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.spinlock, %struct.atomic_t, [4 x %struct.percpu_counter], i32, i32, i32, i32, i32, i32, i32, i32, %struct.fprop_local_percpu, i32, i32, %struct.spinlock, %struct.list_head, %struct.delayed_work, %struct.delayed_work, i32, %struct.list_head, %struct.percpu_ref, %struct.fprop_local_percpu, ptr, ptr, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.27 }
%struct.fprop_local_percpu = type { %struct.percpu_counter, i32, %struct.raw_spinlock }
%union.anon.27 = type { %struct.work_struct }
%struct.lruvec_stats_percpu = type { [40 x i32], [40 x i32] }
%struct.uncharge_gather = type { ptr, i32, i32, i32, i32 }
%struct.sock = type { %struct.sock_common, ptr, i32, i32, %struct.socket_lock_t, %struct.atomic_t, i32, %struct.sk_buff_head, %struct.sk_buff_head, %struct.anon.131, %struct.llist_head, i32, i32, i32, i32, i32, ptr, %union.anon.132, [2 x ptr], ptr, %struct.atomic_t, i32, i32, %struct.refcount_struct, i32, %union.anon.133, %struct.sk_buff_head, i32, i32, i32, i32, i32, %struct.timer_list, i32, i32, i32, i32, %struct.page_frag, i64, i32, i32, i32, i32, i8, i8, i16, i16, i16, i32, ptr, %struct.rwlock_t, i32, i32, i32, i32, %struct.kuid_t, i8, i16, %struct.spinlock, i32, ptr, ptr, i32, i64, %struct.seqlock_t, i16, i8, %struct.atomic_t, %struct.atomic_t, i8, i8, ptr, ptr, ptr, %struct.sock_cgroup_data, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, %struct.callback_head, ptr }
%struct.sock_common = type { %union.anon.18, %union.anon.20, %union.anon.21, i16, i8, i8, i32, %union.anon.23, ptr, %struct.possible_net_t, %struct.in6_addr, %struct.in6_addr, %struct.atomic64_t, %union.anon.127, [0 x i32], %union.anon.128, i16, i16, %union.anon.129, %struct.refcount_struct, [0 x i32], %union.anon.130 }
%union.anon.18 = type { i64 }
%union.anon.20 = type { i32 }
%union.anon.21 = type { i32 }
%union.anon.23 = type { %struct.hlist_node }
%struct.possible_net_t = type { ptr }
%struct.in6_addr = type { %union.anon.103 }
%union.anon.103 = type { [4 x i32] }
%union.anon.127 = type { i32 }
%union.anon.128 = type { %struct.hlist_node }
%union.anon.129 = type { i32 }
%union.anon.130 = type { i32 }
%struct.socket_lock_t = type { %struct.spinlock, i32, %struct.wait_queue_head, %struct.lockdep_map }
%struct.anon.131 = type { %struct.atomic_t, i32, ptr, ptr }
%union.anon.132 = type { ptr }
%union.anon.133 = type { ptr }
%struct.sk_buff_head = type { %union.anon.89, i32, %struct.spinlock }
%union.anon.89 = type { %struct.anon.90 }
%struct.anon.90 = type { ptr, ptr }
%struct.rwlock_t = type { %struct.arch_rwlock_t, i32, i32, ptr, %struct.lockdep_map }
%struct.arch_rwlock_t = type { i32 }
%struct.sock_cgroup_data = type { ptr, i32, i16 }
%struct.percpu_ref_data = type { %struct.atomic_t, ptr, ptr, i8, %struct.callback_head, ptr }
%struct.mm_walk = type { ptr, ptr, ptr, ptr, i32, i8, ptr }
%struct.address_space = type { ptr, %struct.xarray, %struct.rw_semaphore, i32, %struct.atomic_t, %struct.rb_root_cached, %struct.rw_semaphore, i32, i32, ptr, i32, i32, %struct.spinlock, %struct.list_head, ptr }
%struct.vm_area_struct = type { i32, i32, ptr, ptr, %struct.rb_node, i32, ptr, i32, i32, %union.anon.62, %struct.list_head, ptr, ptr, i32, ptr, ptr, %struct.atomic_t, %struct.vm_userfaultfd_ctx }
%union.anon.62 = type { %struct.anon.63 }
%struct.anon.63 = type { %struct.rb_node, i32 }
%struct.vm_userfaultfd_ctx = type { ptr }
%struct.file = type { %union.anon.1, %struct.path, ptr, ptr, %struct.spinlock, i32, %struct.atomic_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, ptr, %struct.file_ra_state, i64, ptr, ptr, ptr, ptr, i32, i32 }
%union.anon.1 = type { %struct.callback_head }
%struct.path = type { ptr, ptr }
%struct.fown_struct = type { %struct.rwlock_t, ptr, i32, %struct.kuid_t, %struct.kuid_t, i32 }
%struct.file_ra_state = type { i32, i32, i32, i32, i32, i64 }
%union.mc_target = type { ptr }
%struct.backing_dev_info = type { i64, %struct.rb_node, %struct.list_head, i32, i32, %struct.kref, i32, i32, i32, i32, %struct.atomic_t, %struct.bdi_writeback, %struct.list_head, %struct.xarray, %struct.mutex, %struct.rw_semaphore, %struct.wait_queue_head, ptr, [64 x i8], ptr, %struct.timer_list, ptr }
%struct.seq_file = type { ptr, i32, i32, i32, i32, i64, i64, %struct.mutex, ptr, i32, ptr, ptr }
%struct.mem_cgroup_event = type { ptr, ptr, %struct.list_head, ptr, ptr, %struct.poll_table_struct, ptr, %struct.wait_queue_entry, %struct.work_struct }
%struct.poll_table_struct = type { ptr, i32 }
%struct.vfsmount = type { ptr, ptr, i32, ptr }
%struct.dentry = type { i32, %struct.seqcount_spinlock, %struct.hlist_bl_node, ptr, %struct.qstr, ptr, [36 x i8], %struct.lockref, ptr, ptr, i32, ptr, %union.anon.149, %struct.list_head, %struct.list_head, %union.anon.150 }
%struct.hlist_bl_node = type { ptr, ptr }
%struct.qstr = type { %union.anon.3, ptr }
%union.anon.3 = type { i64 }
%struct.lockref = type { %union.anon.147 }
%union.anon.147 = type { %struct.anon.148 }
%struct.anon.148 = type { %struct.spinlock, i32 }
%union.anon.149 = type { %struct.list_head }
%union.anon.150 = type { %struct.hlist_node }
%struct.file_operations = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.mem_cgroup_threshold_ary = type { i32, i32, [0 x %struct.mem_cgroup_threshold] }
%struct.mem_cgroup_threshold = type { ptr, i32 }

@memory_cgrp_subsys = dso_local global %struct.cgroup_subsys { ptr @mem_cgroup_css_alloc, ptr @mem_cgroup_css_online, ptr @mem_cgroup_css_offline, ptr @mem_cgroup_css_released, ptr @mem_cgroup_css_free, ptr @mem_cgroup_css_reset, ptr @mem_cgroup_css_rstat_flush, ptr null, ptr @mem_cgroup_can_attach, ptr @mem_cgroup_cancel_attach, ptr null, ptr @mem_cgroup_move_task, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0, i32 0, ptr null, ptr null, ptr null, %struct.idr zeroinitializer, %struct.list_head zeroinitializer, ptr @memory_files, ptr @mem_cgroup_legacy_files, i32 0 }, section ".data..read_mostly", align 4
@__kstrtab_memory_cgrp_subsys = external dso_local constant [0 x i8], align 1
@__kstrtabns_memory_cgrp_subsys = external dso_local constant [0 x i8], align 1
@__ksymtab_memory_cgrp_subsys = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @memory_cgrp_subsys to i32), ptr @__kstrtab_memory_cgrp_subsys, ptr @__kstrtabns_memory_cgrp_subsys }, section "___ksymtab+memory_cgrp_subsys", align 4
@int_active_memcg = weak dso_local global ptr null, section ".data..percpu", align 4
@__kstrtab_int_active_memcg = external dso_local constant [0 x i8], align 1
@__kstrtabns_int_active_memcg = external dso_local constant [0 x i8], align 1
@__ksymtab_int_active_memcg = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @int_active_memcg to i32), ptr @__kstrtab_int_active_memcg, ptr @__kstrtabns_int_active_memcg }, section "___ksymtab_gpl+int_active_memcg", align 4
@root_mem_cgroup = dso_local local_unnamed_addr global ptr null, section ".data..read_mostly", align 4
@cgroup_memory_nokmem = internal unnamed_addr global i1 false, section ".data..ro_after_init", align 1
@memcg_cache_ids_sem = internal global { %struct.rw_semaphore, [32 x i8] } { %struct.rw_semaphore { %struct.atomic_t zeroinitializer, %struct.atomic_t zeroinitializer, %struct.optimistic_spin_queue zeroinitializer, %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.49, i8 0, i8 2, i8 0, i32 0, i32 0 } }, %struct.list_head { ptr getelementptr (i8, ptr @memcg_cache_ids_sem, i64 56), ptr getelementptr (i8, ptr @memcg_cache_ids_sem, i64 56) }, ptr @memcg_cache_ids_sem, %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.50, i8 0, i8 4, i8 0, i32 0, i32 0 } }, [32 x i8] zeroinitializer }, align 32
@memcg_kmem_enabled_key = dso_local global { { { %struct.atomic_t, { ptr } } }, [24 x i8] } zeroinitializer, align 32
@__kstrtab_memcg_kmem_enabled_key = external dso_local constant [0 x i8], align 1
@__kstrtabns_memcg_kmem_enabled_key = external dso_local constant [0 x i8], align 1
@__ksymtab_memcg_kmem_enabled_key = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @memcg_kmem_enabled_key to i32), ptr @__kstrtab_memcg_kmem_enabled_key, ptr @__kstrtabns_memcg_kmem_enabled_key }, section "___ksymtab+memcg_kmem_enabled_key", align 4
@memory_cgrp_subsys_on_dfl_key = external dso_local global %struct.static_key_true, align 4
@stats_flush_threshold = internal global { %struct.atomic_t, [28 x i8] } zeroinitializer, align 32
@__per_cpu_offset = external dso_local local_unnamed_addr global [4 x i32], align 4
@__kstrtab___mod_lruvec_page_state = external dso_local constant [0 x i8], align 1
@__kstrtabns___mod_lruvec_page_state = external dso_local constant [0 x i8], align 1
@__ksymtab___mod_lruvec_page_state = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @__mod_lruvec_page_state to i32), ptr @__kstrtab___mod_lruvec_page_state, ptr @__kstrtabns___mod_lruvec_page_state }, section "___ksymtab+__mod_lruvec_page_state", align 4
@mem_map = external dso_local local_unnamed_addr global ptr, align 4
@__pv_phys_pfn_offset = external dso_local local_unnamed_addr global i32, align 4
@__kstrtab_mem_cgroup_from_task = external dso_local constant [0 x i8], align 1
@__kstrtabns_mem_cgroup_from_task = external dso_local constant [0 x i8], align 1
@__ksymtab_mem_cgroup_from_task = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @mem_cgroup_from_task to i32), ptr @__kstrtab_mem_cgroup_from_task, ptr @__kstrtabns_mem_cgroup_from_task }, section "___ksymtab+mem_cgroup_from_task", align 4
@get_mem_cgroup_from_mm.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@.str.1 = internal constant { [16 x i8], [16 x i8] } { [16 x i8] c"mm/memcontrol.c\00", [16 x i8] zeroinitializer }, align 32
@.str.2 = internal constant { [41 x i8], [55 x i8] } { [41 x i8] c"suspicious rcu_dereference_check() usage\00", [55 x i8] zeroinitializer }, align 32
@__kstrtab_get_mem_cgroup_from_mm = external dso_local constant [0 x i8], align 1
@__kstrtabns_get_mem_cgroup_from_mm = external dso_local constant [0 x i8], align 1
@__ksymtab_get_mem_cgroup_from_mm = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @get_mem_cgroup_from_mm to i32), ptr @__kstrtab_get_mem_cgroup_from_mm, ptr @__kstrtabns_get_mem_cgroup_from_mm }, section "___ksymtab+get_mem_cgroup_from_mm", align 4
@.str.3 = internal constant { [57 x i8], [39 x i8] } { [57 x i8] c"VM_BUG_ON_FOLIO(lruvec_memcg(lruvec) != root_mem_cgroup)\00", [39 x i8] zeroinitializer }, align 32
@.str.4 = internal constant { [47 x i8], [49 x i8] } { [47 x i8] c"VM_BUG_ON_FOLIO(lruvec_memcg(lruvec) != memcg)\00", [49 x i8] zeroinitializer }, align 32
@mem_cgroup_update_lru_size.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.5 = internal constant { [30 x i8], [34 x i8] } { [30 x i8] c"%s(%p, %d, %d): lru_size %ld\0A\00", [34 x i8] zeroinitializer }, align 32
@__func__.mem_cgroup_update_lru_size = private unnamed_addr constant [27 x i8] c"mem_cgroup_update_lru_size\00", align 1
@mem_cgroup_print_oom_context._entry = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str.6, ptr @.str.7, ptr @.str.1, i32 1522, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str.6 = internal constant { [14 x i8], [18 x i8] } { [14 x i8] c"\01c,oom_memcg=\00", [18 x i8] zeroinitializer }, align 32
@.str.7 = internal constant { [29 x i8], [35 x i8] } { [29 x i8] c"mem_cgroup_print_oom_context\00", [35 x i8] zeroinitializer }, align 32
@mem_cgroup_print_oom_context._entry_ptr = internal global ptr @mem_cgroup_print_oom_context._entry, section ".printk_index", align 4
@mem_cgroup_print_oom_context._entry.8 = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str.9, ptr @.str.7, ptr @.str.1, i32 1525, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str.9 = internal constant { [14 x i8], [18 x i8] } { [14 x i8] c"\01c,global_oom\00", [18 x i8] zeroinitializer }, align 32
@mem_cgroup_print_oom_context._entry_ptr.10 = internal global ptr @mem_cgroup_print_oom_context._entry.8, section ".printk_index", align 4
@mem_cgroup_print_oom_context._entry.11 = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str.12, ptr @.str.7, ptr @.str.1, i32 1527, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str.12 = internal constant { [15 x i8], [17 x i8] } { [15 x i8] c"\01c,task_memcg=\00", [17 x i8] zeroinitializer }, align 32
@mem_cgroup_print_oom_context._entry_ptr.13 = internal global ptr @mem_cgroup_print_oom_context._entry.11, section ".printk_index", align 4
@mem_cgroup_print_oom_meminfo._entry = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str.14, ptr @.str.15, ptr @.str.1, i32 1544, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str.14 = internal constant { [51 x i8], [45 x i8] } { [51 x i8] c"\016memory: usage %llukB, limit %llukB, failcnt %lu\0A\00", [45 x i8] zeroinitializer }, align 32
@.str.15 = internal constant { [29 x i8], [35 x i8] } { [29 x i8] c"mem_cgroup_print_oom_meminfo\00", [35 x i8] zeroinitializer }, align 32
@mem_cgroup_print_oom_meminfo._entry_ptr = internal global ptr @mem_cgroup_print_oom_meminfo._entry, section ".printk_index", align 4
@mem_cgroup_print_oom_meminfo._entry.16 = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str.17, ptr @.str.15, ptr @.str.1, i32 1548, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str.17 = internal constant { [49 x i8], [47 x i8] } { [49 x i8] c"\016swap: usage %llukB, limit %llukB, failcnt %lu\0A\00", [47 x i8] zeroinitializer }, align 32
@mem_cgroup_print_oom_meminfo._entry_ptr.18 = internal global ptr @mem_cgroup_print_oom_meminfo._entry.16, section ".printk_index", align 4
@mem_cgroup_print_oom_meminfo._entry.19 = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str.20, ptr @.str.15, ptr @.str.1, i32 1552, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str.20 = internal constant { [56 x i8], [40 x i8] } { [56 x i8] c"\016memory+swap: usage %llukB, limit %llukB, failcnt %lu\0A\00", [40 x i8] zeroinitializer }, align 32
@mem_cgroup_print_oom_meminfo._entry_ptr.21 = internal global ptr @mem_cgroup_print_oom_meminfo._entry.19, section ".printk_index", align 4
@mem_cgroup_print_oom_meminfo._entry.22 = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str.23, ptr @.str.15, ptr @.str.1, i32 1555, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str.23 = internal constant { [49 x i8], [47 x i8] } { [49 x i8] c"\016kmem: usage %llukB, limit %llukB, failcnt %lu\0A\00", [47 x i8] zeroinitializer }, align 32
@mem_cgroup_print_oom_meminfo._entry_ptr.24 = internal global ptr @mem_cgroup_print_oom_meminfo._entry.22, section ".printk_index", align 4
@mem_cgroup_print_oom_meminfo._entry.25 = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str.26, ptr @.str.15, ptr @.str.1, i32 1558, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str.26 = internal constant { [27 x i8], [37 x i8] } { [27 x i8] c"\016Memory cgroup stats for \00", [37 x i8] zeroinitializer }, align 32
@mem_cgroup_print_oom_meminfo._entry_ptr.27 = internal global ptr @mem_cgroup_print_oom_meminfo._entry.25, section ".printk_index", align 4
@mem_cgroup_print_oom_meminfo._entry.28 = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str.29, ptr @.str.15, ptr @.str.1, i32 1560, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str.29 = internal constant { [4 x i8], [28 x i8] } { [4 x i8] c"\01c:\00", [28 x i8] zeroinitializer }, align 32
@mem_cgroup_print_oom_meminfo._entry_ptr.30 = internal global ptr @mem_cgroup_print_oom_meminfo._entry.28, section ".printk_index", align 4
@mem_cgroup_print_oom_meminfo._entry.31 = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str.32, ptr @.str.15, ptr @.str.1, i32 1564, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str.32 = internal constant { [5 x i8], [27 x i8] } { [5 x i8] c"\016%s\00", [27 x i8] zeroinitializer }, align 32
@mem_cgroup_print_oom_meminfo._entry_ptr.33 = internal global ptr @mem_cgroup_print_oom_meminfo._entry.31, section ".printk_index", align 4
@total_swap_pages = external dso_local local_unnamed_addr global i32, align 4
@memcg_oom_waitq = internal global { %struct.wait_queue_head, [44 x i8] } { %struct.wait_queue_head { %struct.spinlock { %union.anon.2 { %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.94, i8 0, i8 3, i8 0, i32 0, i32 0 } } } }, %struct.list_head { ptr getelementptr (i8, ptr @memcg_oom_waitq, i64 44), ptr getelementptr (i8, ptr @memcg_oom_waitq, i64 44) } }, [44 x i8] zeroinitializer }, align 32
@mem_cgroup_print_oom_group._entry = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str.34, ptr @.str.35, ptr @.str.1, i32 1992, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str.34 = internal constant { [12 x i8], [20 x i8] } { [12 x i8] c"\016Tasks in \00", [20 x i8] zeroinitializer }, align 32
@.str.35 = internal constant { [27 x i8], [37 x i8] } { [27 x i8] c"mem_cgroup_print_oom_group\00", [37 x i8] zeroinitializer }, align 32
@mem_cgroup_print_oom_group._entry_ptr = internal global ptr @mem_cgroup_print_oom_group._entry, section ".printk_index", align 4
@mem_cgroup_print_oom_group._entry.36 = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str.37, ptr @.str.35, ptr @.str.1, i32 1994, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str.37 = internal constant { [55 x i8], [41 x i8] } { [55 x i8] c"\01c are going to be killed due to memory.oom.group set\0A\00", [41 x i8] zeroinitializer }, align 32
@mem_cgroup_print_oom_group._entry_ptr.38 = internal global ptr @mem_cgroup_print_oom_group._entry.36, section ".printk_index", align 4
@get_obj_cgroup_from_current.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@soft_limit_tree = internal unnamed_addr global %struct.mem_cgroup_tree zeroinitializer, section ".data..read_mostly", align 4
@dirty_expire_interval = external dso_local local_unnamed_addr global i32, align 4
@jiffies_64 = external dso_local local_unnamed_addr global i64, section ".data..cacheline_aligned", align 128
@mem_cgroup_from_id.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@mem_cgroup_idr = internal global { %struct.idr, [36 x i8] } { %struct.idr { %struct.xarray { %struct.spinlock { %union.anon.2 { %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.109, i8 0, i8 3, i8 0, i32 0, i32 0 } } } }, i32 67108868, ptr null }, i32 0, i32 0 }, [36 x i8] zeroinitializer }, align 32
@memory_files = internal global { [10 x %struct.cftype], [368 x i8] } { [10 x %struct.cftype] [%struct.cftype { [64 x i8] c"current\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 2, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @memory_current_read, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"min\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 2, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @memory_min_show, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @memory_min_write, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"low\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 2, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @memory_low_show, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @memory_low_write, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"high\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 2, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @memory_high_show, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @memory_high_write, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"max\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 2, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @memory_max_show, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @memory_max_write, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"events\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 2, i32 668, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @memory_events_show, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"events.local\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 2, i32 724, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @memory_events_local_show, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"stat\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @memory_stat_show, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"oom.group\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 6, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @memory_oom_group_show, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @memory_oom_group_write, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype zeroinitializer], [368 x i8] zeroinitializer }, align 32
@mem_cgroup_legacy_files = internal global { [23 x %struct.cftype], [888 x i8] } { [23 x %struct.cftype] [%struct.cftype { [64 x i8] c"usage_in_bytes\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_read_u64, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"max_usage_in_bytes\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 2, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_read_u64, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_reset, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"limit_in_bytes\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 1, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_read_u64, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_write, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"soft_limit_in_bytes\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 4, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_read_u64, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_write, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"failcnt\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 3, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_read_u64, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_reset, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"stat\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @memcg_stat_show, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"force_empty\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_force_empty_write, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"use_hierarchy\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_hierarchy_read, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_hierarchy_write, ptr null, ptr null, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"cgroup.event_control\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 24, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @memcg_write_event_control, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"swappiness\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_swappiness_read, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_swappiness_write, ptr null, ptr null, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"move_charge_at_immigrate\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_move_charge_read, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_move_charge_write, ptr null, ptr null, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"oom_control\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 131072, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_oom_control_read, ptr null, ptr null, ptr null, ptr @mem_cgroup_oom_control_write, ptr null, ptr null, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"pressure_level\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"kmem.limit_in_bytes\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 196609, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_read_u64, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_write, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"kmem.usage_in_bytes\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 196608, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_read_u64, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"kmem.failcnt\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 196611, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_read_u64, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_reset, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"kmem.max_usage_in_bytes\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 196610, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_read_u64, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_reset, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"kmem.slabinfo\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_slab_show, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"kmem.tcp.limit_in_bytes\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 262145, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_read_u64, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_write, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"kmem.tcp.usage_in_bytes\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 262144, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_read_u64, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"kmem.tcp.failcnt\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 262147, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_read_u64, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_reset, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"kmem.tcp.max_usage_in_bytes\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 262146, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_read_u64, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_reset, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype zeroinitializer], [888 x i8] zeroinitializer }, align 32
@.str.39 = internal constant { [41 x i8], [55 x i8] } { [41 x i8] c"VM_BUG_ON_FOLIO(!folio_test_locked(old))\00", [55 x i8] zeroinitializer }, align 32
@.str.40 = internal constant { [41 x i8], [55 x i8] } { [41 x i8] c"VM_BUG_ON_FOLIO(!folio_test_locked(new))\00", [55 x i8] zeroinitializer }, align 32
@.str.41 = internal constant { [62 x i8], [34 x i8] } { [62 x i8] c"VM_BUG_ON_FOLIO(folio_test_anon(old) != folio_test_anon(new))\00", [34 x i8] zeroinitializer }, align 32
@.str.42 = internal constant { [49 x i8], [47 x i8] } { [49 x i8] c"VM_BUG_ON_FOLIO(folio_nr_pages(old) != nr_pages)\00", [47 x i8] zeroinitializer }, align 32
@mem_cgroup_migrate.__warned = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.43 = internal constant { [30 x i8], [34 x i8] } { [30 x i8] c"VM_WARN_ON_ONCE_FOLIO(!memcg)\00", [34 x i8] zeroinitializer }, align 32
@memcg_sockets_enabled_key = dso_local global { { { %struct.atomic_t, { ptr } } }, [24 x i8] } zeroinitializer, align 32
@__kstrtab_memcg_sockets_enabled_key = external dso_local constant [0 x i8], align 1
@__kstrtabns_memcg_sockets_enabled_key = external dso_local constant [0 x i8], align 1
@__ksymtab_memcg_sockets_enabled_key = internal constant %struct.kernel_symbol { i32 ptrtoint (ptr @memcg_sockets_enabled_key to i32), ptr @__kstrtab_memcg_sockets_enabled_key, ptr @__kstrtabns_memcg_sockets_enabled_key }, section "___ksymtab+memcg_sockets_enabled_key", align 4
@__setup_str_cgroup_memory = internal constant [15 x i8] c"cgroup.memory=\00", section ".init.rodata", align 1
@__setup_cgroup_memory = internal global %struct.obs_kernel_param { ptr @__setup_str_cgroup_memory, ptr @cgroup_memory, i32 0 }, section ".init.setup", align 4
@__initcall__kmod_memcontrol__736_7101_mem_cgroup_init4 = internal global ptr @mem_cgroup_init, section ".initcall4.init", align 4
@.str.44 = internal constant { [30 x i8], [34 x i8] } { [30 x i8] c"VM_BUG_ON_PAGE(PageLRU(page))\00", [34 x i8] zeroinitializer }, align 32
@.str.45 = internal constant { [33 x i8], [63 x i8] } { [33 x i8] c"VM_BUG_ON_PAGE(page_count(page))\00", [63 x i8] zeroinitializer }, align 32
@mem_cgroup_swapout.__warned = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.46 = internal constant { [29 x i8], [35 x i8] } { [29 x i8] c"VM_WARN_ON_ONCE_PAGE(!memcg)\00", [35 x i8] zeroinitializer }, align 32
@.str.47 = internal constant { [22 x i8], [42 x i8] } { [22 x i8] c"VM_BUG_ON_PAGE(oldid)\00", [42 x i8] zeroinitializer }, align 32
@cgroup_memory_noswap = dso_local local_unnamed_addr global i8 0, section ".data..ro_after_init", align 1
@__mem_cgroup_try_charge_swap.__warned = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.48 = internal constant { [34 x i8], [62 x i8] } { [34 x i8] c"VM_BUG_ON_PAGE(!PageLocked(page))\00", [62 x i8] zeroinitializer }, align 32
@__setup_str_setup_swap_account = internal constant [13 x i8] c"swapaccount=\00", section ".init.rodata", align 1
@__setup_setup_swap_account = internal global %struct.obs_kernel_param { ptr @__setup_str_setup_swap_account, ptr @setup_swap_account, i32 0 }, section ".init.setup", align 4
@__initcall__kmod_memcontrol__744_7457_mem_cgroup_swap_init1 = internal global ptr @mem_cgroup_swap_init, section ".initcall1.init", align 4
@__pcpu_scope_int_active_memcg = dso_local local_unnamed_addr global i8 0, section ".discard", align 1
@__pcpu_unique_int_active_memcg = dso_local local_unnamed_addr global i8 0, section ".discard", align 1
@memcg_nr_cache_ids = dso_local global { i32, [28 x i8] } zeroinitializer, align 32
@__pcpu_unique_stats_updates = dso_local local_unnamed_addr global i8 0, section ".discard", align 1
@stats_updates = weak dso_local global i32 0, section ".data..percpu", align 4
@__pcpu_unique_memcg_stock = dso_local local_unnamed_addr global i8 0, section ".discard", align 1
@memcg_stock = weak dso_local global %struct.memcg_stock_pcp zeroinitializer, section ".data..percpu", align 4
@.str.49 = internal constant { [30 x i8], [34 x i8] } { [30 x i8] c"memcg_cache_ids_sem.wait_lock\00", [34 x i8] zeroinitializer }, align 32
@.str.50 = internal constant { [20 x i8], [44 x i8] } { [20 x i8] c"memcg_cache_ids_sem\00", [44 x i8] zeroinitializer }, align 32
@rcu_lock_map = external dso_local global %struct.lockdep_map, align 4
@rcu_read_lock.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@.str.51 = internal constant { [25 x i8], [39 x i8] } { [25 x i8] c"include/linux/rcupdate.h\00", [39 x i8] zeroinitializer }, align 32
@.str.52 = internal constant { [42 x i8], [54 x i8] } { [42 x i8] c"rcu_read_lock() used illegally while idle\00", [54 x i8] zeroinitializer }, align 32
@rcu_read_unlock.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@.str.53 = internal constant { [44 x i8], [52 x i8] } { [44 x i8] c"rcu_read_unlock() used illegally while idle\00", [52 x i8] zeroinitializer }, align 32
@__num_online_cpus = external dso_local global %struct.atomic_t, align 4
@stats_flush_lock = internal global { %struct.spinlock, [52 x i8] } { %struct.spinlock { %union.anon.2 { %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.54, i8 0, i8 3, i8 0, i32 0, i32 0 } } } }, [52 x i8] zeroinitializer }, align 32
@.str.54 = internal constant { [17 x i8], [47 x i8] } { [17 x i8] c"stats_flush_lock\00", [47 x i8] zeroinitializer }, align 32
@memory_cgrp_subsys_enabled_key = external dso_local global %struct.static_key_true, align 4
@contig_page_data = external dso_local global %struct.pglist_data, align 128
@task_css.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@cgroup_mutex = external dso_local global %struct.mutex, align 4
@css_set_lock = external dso_local global %struct.spinlock, align 4
@.str.57 = internal constant { [23 x i8], [41 x i8] } { [23 x i8] c"include/linux/cgroup.h\00", [41 x i8] zeroinitializer }, align 32
@.str.58 = internal constant { [40 x i8], [56 x i8] } { [40 x i8] c"VM_BUG_ON_FOLIO(folio_test_slab(folio))\00", [56 x i8] zeroinitializer }, align 32
@folio_lruvec.__warned = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.61 = internal constant { [56 x i8], [40 x i8] } { [56 x i8] c"VM_WARN_ON_ONCE_FOLIO(!memcg && !mem_cgroup_disabled())\00", [40 x i8] zeroinitializer }, align 32
@.str.62 = internal constant { [27 x i8], [37 x i8] } { [27 x i8] c"include/linux/memcontrol.h\00", [37 x i8] zeroinitializer }, align 32
@memory_stats = internal constant { [26 x %struct.memory_stat], [48 x i8] } { [26 x %struct.memory_stat] [%struct.memory_stat { ptr @.str.68, i32 17 }, %struct.memory_stat { ptr @.str.69, i32 19 }, %struct.memory_stat { ptr @.str.70, i32 37 }, %struct.memory_stat { ptr @.str.71, i32 38 }, %struct.memory_stat { ptr @.str.72, i32 42 }, %struct.memory_stat { ptr @.str.73, i32 41 }, %struct.memory_stat { ptr @.str.74, i32 43 }, %struct.memory_stat { ptr @.str.75, i32 23 }, %struct.memory_stat { ptr @.str.76, i32 18 }, %struct.memory_stat { ptr @.str.77, i32 20 }, %struct.memory_stat { ptr @.str.78, i32 21 }, %struct.memory_stat { ptr @.str.79, i32 39 }, %struct.memory_stat { ptr @.str.80, i32 0 }, %struct.memory_stat { ptr @.str.81, i32 1 }, %struct.memory_stat { ptr @.str.82, i32 2 }, %struct.memory_stat { ptr @.str.83, i32 3 }, %struct.memory_stat { ptr @.str.84, i32 4 }, %struct.memory_stat { ptr @.str.85, i32 5 }, %struct.memory_stat { ptr @.str.86, i32 6 }, %struct.memory_stat { ptr @.str.87, i32 10 }, %struct.memory_stat { ptr @.str.88, i32 11 }, %struct.memory_stat { ptr @.str.89, i32 12 }, %struct.memory_stat { ptr @.str.90, i32 13 }, %struct.memory_stat { ptr @.str.91, i32 14 }, %struct.memory_stat { ptr @.str.92, i32 15 }, %struct.memory_stat { ptr @.str.93, i32 16 }], [48 x i8] zeroinitializer }, align 32
@.str.63 = internal constant { [9 x i8], [23 x i8] } { [9 x i8] c"%s %llu\0A\00", [23 x i8] zeroinitializer }, align 32
@.str.64 = internal constant { [11 x i8], [21 x i8] } { [11 x i8] c"slab %llu\0A\00", [21 x i8] zeroinitializer }, align 32
@.str.65 = internal constant { [8 x i8], [24 x i8] } { [8 x i8] c"%s %lu\0A\00", [24 x i8] zeroinitializer }, align 32
@.str.66 = internal constant { [12 x i8], [20 x i8] } { [12 x i8] c"pgscan %lu\0A\00", [20 x i8] zeroinitializer }, align 32
@.str.67 = internal constant { [13 x i8], [19 x i8] } { [13 x i8] c"pgsteal %lu\0A\00", [19 x i8] zeroinitializer }, align 32
@memory_stat_format.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@kmalloc_caches = external dso_local local_unnamed_addr global [4 x [14 x ptr]], align 4
@.str.68 = internal constant { [5 x i8], [27 x i8] } { [5 x i8] c"anon\00", [27 x i8] zeroinitializer }, align 32
@.str.69 = internal constant { [5 x i8], [27 x i8] } { [5 x i8] c"file\00", [27 x i8] zeroinitializer }, align 32
@.str.70 = internal constant { [13 x i8], [19 x i8] } { [13 x i8] c"kernel_stack\00", [19 x i8] zeroinitializer }, align 32
@.str.71 = internal constant { [11 x i8], [21 x i8] } { [11 x i8] c"pagetables\00", [21 x i8] zeroinitializer }, align 32
@.str.72 = internal constant { [7 x i8], [25 x i8] } { [7 x i8] c"percpu\00", [25 x i8] zeroinitializer }, align 32
@.str.73 = internal constant { [5 x i8], [27 x i8] } { [5 x i8] c"sock\00", [27 x i8] zeroinitializer }, align 32
@.str.74 = internal constant { [8 x i8], [24 x i8] } { [8 x i8] c"vmalloc\00", [24 x i8] zeroinitializer }, align 32
@.str.75 = internal constant { [6 x i8], [26 x i8] } { [6 x i8] c"shmem\00", [26 x i8] zeroinitializer }, align 32
@.str.76 = internal constant { [12 x i8], [20 x i8] } { [12 x i8] c"file_mapped\00", [20 x i8] zeroinitializer }, align 32
@.str.77 = internal constant { [11 x i8], [21 x i8] } { [11 x i8] c"file_dirty\00", [21 x i8] zeroinitializer }, align 32
@.str.78 = internal constant { [15 x i8], [17 x i8] } { [15 x i8] c"file_writeback\00", [17 x i8] zeroinitializer }, align 32
@.str.79 = internal constant { [11 x i8], [21 x i8] } { [11 x i8] c"swapcached\00", [21 x i8] zeroinitializer }, align 32
@.str.80 = internal constant { [14 x i8], [18 x i8] } { [14 x i8] c"inactive_anon\00", [18 x i8] zeroinitializer }, align 32
@.str.81 = internal constant { [12 x i8], [20 x i8] } { [12 x i8] c"active_anon\00", [20 x i8] zeroinitializer }, align 32
@.str.82 = internal constant { [14 x i8], [18 x i8] } { [14 x i8] c"inactive_file\00", [18 x i8] zeroinitializer }, align 32
@.str.83 = internal constant { [12 x i8], [20 x i8] } { [12 x i8] c"active_file\00", [20 x i8] zeroinitializer }, align 32
@.str.84 = internal constant { [12 x i8], [20 x i8] } { [12 x i8] c"unevictable\00", [20 x i8] zeroinitializer }, align 32
@.str.85 = internal constant { [17 x i8], [47 x i8] } { [17 x i8] c"slab_reclaimable\00", [47 x i8] zeroinitializer }, align 32
@.str.86 = internal constant { [19 x i8], [45 x i8] } { [19 x i8] c"slab_unreclaimable\00", [45 x i8] zeroinitializer }, align 32
@.str.87 = internal constant { [24 x i8], [40 x i8] } { [24 x i8] c"workingset_refault_anon\00", [40 x i8] zeroinitializer }, align 32
@.str.88 = internal constant { [24 x i8], [40 x i8] } { [24 x i8] c"workingset_refault_file\00", [40 x i8] zeroinitializer }, align 32
@.str.89 = internal constant { [25 x i8], [39 x i8] } { [25 x i8] c"workingset_activate_anon\00", [39 x i8] zeroinitializer }, align 32
@.str.90 = internal constant { [25 x i8], [39 x i8] } { [25 x i8] c"workingset_activate_file\00", [39 x i8] zeroinitializer }, align 32
@.str.91 = internal constant { [24 x i8], [40 x i8] } { [24 x i8] c"workingset_restore_anon\00", [40 x i8] zeroinitializer }, align 32
@.str.92 = internal constant { [24 x i8], [40 x i8] } { [24 x i8] c"workingset_restore_file\00", [40 x i8] zeroinitializer }, align 32
@.str.93 = internal constant { [23 x i8], [41 x i8] } { [23 x i8] c"workingset_nodereclaim\00", [41 x i8] zeroinitializer }, align 32
@vmstat_text = external dso_local local_unnamed_addr constant [0 x ptr], align 4
@vm_swappiness = external dso_local local_unnamed_addr global i32, align 4
@.str.94 = internal constant { [21 x i8], [43 x i8] } { [21 x i8] c"memcg_oom_waitq.lock\00", [43 x i8] zeroinitializer }, align 32
@memcg_oom_lock = internal global { %struct.spinlock, [52 x i8] } { %struct.spinlock { %union.anon.2 { %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.95, i8 0, i8 3, i8 0, i32 0, i32 0 } } } }, [52 x i8] zeroinitializer }, align 32
@.str.95 = internal constant { [15 x i8], [17 x i8] } { [15 x i8] c"memcg_oom_lock\00", [17 x i8] zeroinitializer }, align 32
@memcg_oom_lock_dep_map = internal global { %struct.lockdep_map, [36 x i8] } { %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.95, i8 0, i8 0, i8 0, i32 0, i32 0 }, [36 x i8] zeroinitializer }, align 32
@oom_lock = external dso_local global %struct.mutex, align 4
@.str.96 = internal constant { [31 x i8], [33 x i8] } { [31 x i8] c"VM_BUG_ON_PAGE(PageTail(page))\00", [33 x i8] zeroinitializer }, align 32
@.str.98 = internal constant { [64 x i8], [32 x i8] } { [64 x i8] c"VM_BUG_ON_PAGE(memcg_data && !(memcg_data & MEMCG_DATA_OBJCGS))\00", [32 x i8] zeroinitializer }, align 32
@.str.99 = internal constant { [45 x i8], [51 x i8] } { [45 x i8] c"VM_BUG_ON_PAGE(memcg_data & MEMCG_DATA_KMEM)\00", [51 x i8] zeroinitializer }, align 32
@__kfence_pool = external dso_local local_unnamed_addr global ptr, align 4
@percpu_charge_mutex = internal global { %struct.mutex, [36 x i8] } { %struct.mutex { %struct.atomic_t zeroinitializer, %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.100, i8 0, i8 2, i8 0, i32 0, i32 0 } }, %struct.optimistic_spin_queue zeroinitializer, %struct.list_head { ptr getelementptr (i8, ptr @percpu_charge_mutex, i64 52), ptr getelementptr (i8, ptr @percpu_charge_mutex, i64 52) }, ptr @percpu_charge_mutex, %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.101, i8 0, i8 4, i8 0, i32 0, i32 0 } }, [36 x i8] zeroinitializer }, align 32
@__cpu_online_mask = external dso_local global %struct.cpumask, align 4
@nr_cpu_ids = external dso_local local_unnamed_addr global i32, align 4
@.str.100 = internal constant { [30 x i8], [34 x i8] } { [30 x i8] c"percpu_charge_mutex.wait_lock\00", [34 x i8] zeroinitializer }, align 32
@.str.101 = internal constant { [20 x i8], [44 x i8] } { [20 x i8] c"percpu_charge_mutex\00", [44 x i8] zeroinitializer }, align 32
@system_wq = external dso_local local_unnamed_addr global ptr, align 4
@mc = internal global { %struct.move_charge_struct, [32 x i8] } { %struct.move_charge_struct { %struct.spinlock { %union.anon.2 { %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.102, i8 0, i8 3, i8 0, i32 0, i32 0 } } } }, ptr null, ptr null, ptr null, i32 0, i32 0, i32 0, i32 0, ptr null, %struct.wait_queue_head { %struct.spinlock { %union.anon.2 { %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.103, i8 0, i8 3, i8 0, i32 0, i32 0 } } } }, %struct.list_head { ptr getelementptr (i8, ptr @mc, i64 120), ptr getelementptr (i8, ptr @mc, i64 120) } } }, [32 x i8] zeroinitializer }, align 32
@.str.102 = internal constant { [8 x i8], [24 x i8] } { [8 x i8] c"mc.lock\00", [24 x i8] zeroinitializer }, align 32
@.str.103 = internal constant { [14 x i8], [18 x i8] } { [14 x i8] c"mc.waitq.lock\00", [18 x i8] zeroinitializer }, align 32
@.str.104 = internal constant { [39 x i8], [57 x i8] } { [39 x i8] c"VM_BUG_ON_PAGE(PageTail(&folio->page))\00", [57 x i8] zeroinitializer }, align 32
@.str.105 = internal constant { [55 x i8], [41 x i8] } { [55 x i8] c"VM_BUG_ON_FOLIO(folio->memcg_data & MEMCG_DATA_OBJCGS)\00", [41 x i8] zeroinitializer }, align 32
@__tracepoint_track_foreign_dirty = external dso_local global %struct.tracepoint, align 4
@.str.107 = internal constant { [33 x i8], [63 x i8] } { [33 x i8] c"include/trace/events/writeback.h\00", [63 x i8] zeroinitializer }, align 32
@trace_track_foreign_dirty.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@cpu_max_bits_warn.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.108 = internal constant { [24 x i8], [40 x i8] } { [24 x i8] c"include/linux/cpumask.h\00", [40 x i8] zeroinitializer }, align 32
@__tracepoint_flush_foreign = external dso_local global %struct.tracepoint, align 4
@trace_flush_foreign.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@.str.109 = internal constant { [23 x i8], [41 x i8] } { [23 x i8] c"mem_cgroup_idr.xa_lock\00", [41 x i8] zeroinitializer }, align 32
@cgroup_memory_nosocket = internal unnamed_addr global i1 false, section ".data..ro_after_init", align 1
@mem_cgroup_alloc.__key = internal global { %struct.lock_class_key, [24 x i8] } zeroinitializer, align 32
@.str.110 = internal constant { [37 x i8], [59 x i8] } { [37 x i8] c"(work_completion)(&memcg->high_work)\00", [59 x i8] zeroinitializer }, align 32
@mem_cgroup_alloc.__key.111 = internal global { %struct.lock_class_key, [24 x i8] } zeroinitializer, align 32
@.str.112 = internal constant { [24 x i8], [40 x i8] } { [24 x i8] c"&memcg->thresholds_lock\00", [40 x i8] zeroinitializer }, align 32
@mem_cgroup_alloc.__key.113 = internal global { %struct.lock_class_key, [24 x i8] } zeroinitializer, align 32
@.str.114 = internal constant { [18 x i8], [46 x i8] } { [18 x i8] c"&memcg->move_lock\00", [46 x i8] zeroinitializer }, align 32
@mem_cgroup_alloc.__key.115 = internal global { %struct.lock_class_key, [24 x i8] } zeroinitializer, align 32
@.str.116 = internal constant { [24 x i8], [40 x i8] } { [24 x i8] c"&memcg->event_list_lock\00", [40 x i8] zeroinitializer }, align 32
@jiffies = external dso_local global i32, section ".data..cacheline_aligned", align 128
@memcg_cgwb_frn_waitq = internal global { %struct.wait_queue_head, [44 x i8] } { %struct.wait_queue_head { %struct.spinlock { %union.anon.2 { %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.117, i8 0, i8 3, i8 0, i32 0, i32 0 } } } }, %struct.list_head { ptr getelementptr (i8, ptr @memcg_cgwb_frn_waitq, i64 44), ptr getelementptr (i8, ptr @memcg_cgwb_frn_waitq, i64 44) } }, [44 x i8] zeroinitializer }, align 32
@.str.117 = internal constant { [26 x i8], [38 x i8] } { [26 x i8] c"memcg_cgwb_frn_waitq.lock\00", [38 x i8] zeroinitializer }, align 32
@memcg_cache_ida = internal global { %struct.ida, [44 x i8] } { %struct.ida { %struct.xarray { %struct.spinlock { %union.anon.2 { %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.118, i8 0, i8 3, i8 0, i32 0, i32 0 } } } }, i32 67108869, ptr null } }, [44 x i8] zeroinitializer }, align 32
@.str.118 = internal constant { [24 x i8], [40 x i8] } { [24 x i8] c"memcg_cache_ida.xa_lock\00", [40 x i8] zeroinitializer }, align 32
@obj_cgroup_release.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@objcg_lock = internal global { %struct.spinlock, [52 x i8] } { %struct.spinlock { %union.anon.2 { %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.119, i8 0, i8 3, i8 0, i32 0, i32 0 } } } }, [52 x i8] zeroinitializer }, align 32
@.str.119 = internal constant { [11 x i8], [21 x i8] } { [11 x i8] c"objcg_lock\00", [21 x i8] zeroinitializer }, align 32
@system_unbound_wq = external dso_local local_unnamed_addr global ptr, align 4
@stats_flush_dwork = internal global { %struct.delayed_work, [60 x i8] } { %struct.delayed_work { %struct.work_struct { %struct.atomic_t { i32 -48 }, %struct.list_head { ptr getelementptr (i8, ptr @stats_flush_dwork, i64 4), ptr getelementptr (i8, ptr @stats_flush_dwork, i64 4) }, ptr @flush_memcg_stats_dwork, %struct.lockdep_map { ptr @stats_flush_dwork, [2 x ptr] zeroinitializer, ptr @.str.120, i8 0, i8 0, i8 0, i32 0, i32 0 } }, %struct.timer_list { %struct.hlist_node { ptr inttoptr (i32 768 to ptr), ptr null }, i32 0, ptr @delayed_work_timer_fn, i32 2621440, %struct.lockdep_map { ptr @.str.121, [2 x ptr] zeroinitializer, ptr @.str.121, i8 0, i8 0, i8 0, i32 0, i32 0 } }, ptr null, i32 0 }, [60 x i8] zeroinitializer }, align 32
@.str.120 = internal constant { [25 x i8], [39 x i8] } { [25 x i8] c"(stats_flush_dwork).work\00", [39 x i8] zeroinitializer }, align 32
@.str.121 = internal constant { [20 x i8], [44 x i8] } { [20 x i8] c"mm/memcontrol.c:627\00", [44 x i8] zeroinitializer }, align 32
@mem_cgroup_can_attach.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@precharge_walk_ops = internal constant { %struct.mm_walk_ops, [56 x i8] } { %struct.mm_walk_ops { ptr null, ptr null, ptr null, ptr @mem_cgroup_count_precharge_pte_range, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null }, [56 x i8] zeroinitializer }, align 32
@__tracepoint_mmap_lock_start_locking = external dso_local global %struct.tracepoint, align 4
@__tracepoint_mmap_lock_acquire_returned = external dso_local global %struct.tracepoint, align 4
@pgprot_kernel = external dso_local local_unnamed_addr global i32, align 4
@__tracepoint_page_ref_mod_unless = external dso_local global %struct.tracepoint, align 4
@swapper_spaces = external dso_local local_unnamed_addr global [0 x ptr], align 4
@.str.122 = internal constant { [42 x i8], [54 x i8] } { [42 x i8] c"VM_BUG_ON_PAGE(page_ref_count(page) == 0)\00", [54 x i8] zeroinitializer }, align 32
@__tracepoint_page_ref_mod_and_test = external dso_local global %struct.tracepoint, align 4
@__tracepoint_mmap_lock_released = external dso_local global %struct.tracepoint, align 4
@charge_walk_ops = internal constant { %struct.mm_walk_ops, [56 x i8] } { %struct.mm_walk_ops { ptr null, ptr null, ptr null, ptr @mem_cgroup_move_charge_pte_range, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null }, [56 x i8] zeroinitializer }, align 32
@.str.123 = internal constant { [39 x i8], [57 x i8] } { [39 x i8] c"VM_BUG_ON_FOLIO(folio_test_lru(folio))\00", [57 x i8] zeroinitializer }, align 32
@.str.124 = internal constant { [5 x i8], [27 x i8] } { [5 x i8] c"max\0A\00", [27 x i8] zeroinitializer }, align 32
@.str.125 = internal constant { [6 x i8], [26 x i8] } { [6 x i8] c"%llu\0A\00", [26 x i8] zeroinitializer }, align 32
@.str.126 = internal constant { [4 x i8], [28 x i8] } { [4 x i8] c"max\00", [28 x i8] zeroinitializer }, align 32
@.str.127 = internal constant { [9 x i8], [23 x i8] } { [9 x i8] c"low %lu\0A\00", [23 x i8] zeroinitializer }, align 32
@.str.128 = internal constant { [10 x i8], [22 x i8] } { [10 x i8] c"high %lu\0A\00", [22 x i8] zeroinitializer }, align 32
@.str.129 = internal constant { [9 x i8], [23 x i8] } { [9 x i8] c"max %lu\0A\00", [23 x i8] zeroinitializer }, align 32
@.str.130 = internal constant { [9 x i8], [23 x i8] } { [9 x i8] c"oom %lu\0A\00", [23 x i8] zeroinitializer }, align 32
@.str.131 = internal constant { [14 x i8], [18 x i8] } { [14 x i8] c"oom_kill %lu\0A\00", [18 x i8] zeroinitializer }, align 32
@.str.132 = internal constant { [20 x i8], [44 x i8] } { [20 x i8] c"oom_group_kill %lu\0A\00", [44 x i8] zeroinitializer }, align 32
@.str.133 = internal constant { [4 x i8], [28 x i8] } { [4 x i8] c"%d\0A\00", [28 x i8] zeroinitializer }, align 32
@.str.134 = internal constant { [3 x i8], [29 x i8] } { [3 x i8] c"-1\00", [29 x i8] zeroinitializer }, align 32
@memcg_max_mutex = internal global { %struct.mutex, [36 x i8] } { %struct.mutex { %struct.atomic_t zeroinitializer, %struct.raw_spinlock { %struct.arch_spinlock_t zeroinitializer, i32 -559067475, i32 -1, ptr inttoptr (i32 -1 to ptr), %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.135, i8 0, i8 2, i8 0, i32 0, i32 0 } }, %struct.optimistic_spin_queue zeroinitializer, %struct.list_head { ptr getelementptr (i8, ptr @memcg_max_mutex, i64 52), ptr getelementptr (i8, ptr @memcg_max_mutex, i64 52) }, ptr @memcg_max_mutex, %struct.lockdep_map { ptr null, [2 x ptr] zeroinitializer, ptr @.str.136, i8 0, i8 4, i8 0, i32 0, i32 0 } }, [36 x i8] zeroinitializer }, align 32
@.str.135 = internal constant { [26 x i8], [38 x i8] } { [26 x i8] c"memcg_max_mutex.wait_lock\00", [38 x i8] zeroinitializer }, align 32
@.str.136 = internal constant { [16 x i8], [16 x i8] } { [16 x i8] c"memcg_max_mutex\00", [16 x i8] zeroinitializer }, align 32
@memcg1_stats = internal constant { [7 x i32], [36 x i8] } { [7 x i32] [i32 19, i32 17, i32 23, i32 18, i32 20, i32 21, i32 40], [36 x i8] zeroinitializer }, align 32
@memcg1_stat_names = internal constant { [7 x ptr], [36 x i8] } { [7 x ptr] [ptr @.str.142, ptr @.str.143, ptr @.str.75, ptr @.str.144, ptr @.str.145, ptr @.str.146, ptr @.str.147], [36 x i8] zeroinitializer }, align 32
@.str.137 = internal constant { [32 x i8], [32 x i8] } { [32 x i8] c"hierarchical_memory_limit %llu\0A\00", [32 x i8] zeroinitializer }, align 32
@.str.138 = internal constant { [31 x i8], [33 x i8] } { [31 x i8] c"hierarchical_memsw_limit %llu\0A\00", [33 x i8] zeroinitializer }, align 32
@.str.139 = internal constant { [15 x i8], [17 x i8] } { [15 x i8] c"total_%s %llu\0A\00", [17 x i8] zeroinitializer }, align 32
@.str.140 = internal constant { [15 x i8], [17 x i8] } { [15 x i8] c"anon_cost %lu\0A\00", [17 x i8] zeroinitializer }, align 32
@.str.141 = internal constant { [15 x i8], [17 x i8] } { [15 x i8] c"file_cost %lu\0A\00", [17 x i8] zeroinitializer }, align 32
@__cpu_possible_mask = external dso_local global %struct.cpumask, align 4
@.str.142 = internal constant { [6 x i8], [26 x i8] } { [6 x i8] c"cache\00", [26 x i8] zeroinitializer }, align 32
@.str.143 = internal constant { [4 x i8], [28 x i8] } { [4 x i8] c"rss\00", [28 x i8] zeroinitializer }, align 32
@.str.144 = internal constant { [12 x i8], [20 x i8] } { [12 x i8] c"mapped_file\00", [20 x i8] zeroinitializer }, align 32
@.str.145 = internal constant { [6 x i8], [26 x i8] } { [6 x i8] c"dirty\00", [26 x i8] zeroinitializer }, align 32
@.str.146 = internal constant { [10 x i8], [22 x i8] } { [10 x i8] c"writeback\00", [22 x i8] zeroinitializer }, align 32
@.str.147 = internal constant { [5 x i8], [27 x i8] } { [5 x i8] c"swap\00", [27 x i8] zeroinitializer }, align 32
@mem_cgroup_hierarchy_write.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@mem_cgroup_hierarchy_write._entry = internal constant { %struct.pi_entry, [40 x i8] } { %struct.pi_entry { ptr @.str.148, ptr @.str.149, ptr @.str.1, i32 3549, ptr null, ptr null }, [40 x i8] zeroinitializer }, align 32
@.str.148 = internal constant { [126 x i8], [34 x i8] } { [126 x i8] c"\014Non-hierarchical mode is deprecated. Please report your usecase to linux-mm@kvack.org if you depend on this functionality.\0A\00", [34 x i8] zeroinitializer }, align 32
@.str.149 = internal constant { [27 x i8], [37 x i8] } { [27 x i8] c"mem_cgroup_hierarchy_write\00", [37 x i8] zeroinitializer }, align 32
@mem_cgroup_hierarchy_write._entry_ptr = internal global ptr @mem_cgroup_hierarchy_write._entry, section ".printk_index", align 4
@memcg_write_event_control.__key = internal global { %struct.lock_class_key, [24 x i8] } zeroinitializer, align 32
@.str.150 = internal constant { [34 x i8], [62 x i8] } { [34 x i8] c"(work_completion)(&event->remove)\00", [62 x i8] zeroinitializer }, align 32
@.str.151 = internal constant { [22 x i8], [42 x i8] } { [22 x i8] c"memory.usage_in_bytes\00", [42 x i8] zeroinitializer }, align 32
@.str.152 = internal constant { [19 x i8], [45 x i8] } { [19 x i8] c"memory.oom_control\00", [45 x i8] zeroinitializer }, align 32
@.str.153 = internal constant { [22 x i8], [42 x i8] } { [22 x i8] c"memory.pressure_level\00", [42 x i8] zeroinitializer }, align 32
@.str.154 = internal constant { [28 x i8], [36 x i8] } { [28 x i8] c"memory.memsw.usage_in_bytes\00", [36 x i8] zeroinitializer }, align 32
@__mem_cgroup_threshold.__warned = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@__mem_cgroup_threshold.__warned.155 = internal unnamed_addr global i1 false, section ".data.unlikely", align 1
@.str.156 = internal constant { [21 x i8], [43 x i8] } { [21 x i8] c"oom_kill_disable %d\0A\00", [43 x i8] zeroinitializer }, align 32
@.str.157 = internal constant { [14 x i8], [18 x i8] } { [14 x i8] c"under_oom %d\0A\00", [18 x i8] zeroinitializer }, align 32
@cgrp_dfl_root = external dso_local local_unnamed_addr global %struct.cgroup_root, align 8
@percpu_ref_tryget_live_rcu.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.158 = internal constant { [32 x i8], [32 x i8] } { [32 x i8] c"include/linux/percpu-refcount.h\00", [32 x i8] zeroinitializer }, align 32
@.str.159 = internal constant { [35 x i8], [61 x i8] } { [35 x i8] c"VM_BUG_ON_PAGE(PagePoisoned(page))\00", [61 x i8] zeroinitializer }, align 32
@.str.160 = internal constant { [36 x i8], [60 x i8] } { [36 x i8] c"VM_BUG_ON_FOLIO(folio_memcg(folio))\00", [60 x i8] zeroinitializer }, align 32
@.str.162 = internal constant { [2 x i8], [30 x i8] } { [2 x i8] c",\00", [30 x i8] zeroinitializer }, align 32
@.str.163 = internal constant { [9 x i8], [23 x i8] } { [9 x i8] c"nosocket\00", [23 x i8] zeroinitializer }, align 32
@.str.164 = internal constant { [7 x i8], [25 x i8] } { [7 x i8] c"nokmem\00", [25 x i8] zeroinitializer }, align 32
@.str.165 = internal constant { [16 x i8], [16 x i8] } { [16 x i8] c"mm/memctrl:dead\00", [16 x i8] zeroinitializer }, align 32
@mem_cgroup_init.__key = internal global { %struct.lock_class_key, [24 x i8] } zeroinitializer, align 32
@.str.166 = internal constant { [336 x i8], [80 x i8] } { [336 x i8] c"(work_completion)(&({ do { const void *__vpp_verify = (typeof((&memcg_stock) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long __ptr; __ptr = (unsigned long) ((typeof(*((&memcg_stock))) *)((&memcg_stock))); (typeof((typeof(*((&memcg_stock))) *)((&memcg_stock)))) (__ptr + (((__per_cpu_offset[(cpu)])))); }); })->work)\00", [80 x i8] zeroinitializer }, align 32
@mem_cgroup_init.__key.167 = internal global { %struct.lock_class_key, [24 x i8] } zeroinitializer, align 32
@.str.168 = internal constant { [12 x i8], [20 x i8] } { [12 x i8] c"&rtpn->lock\00", [20 x i8] zeroinitializer }, align 32
@.str.169 = internal constant { [67 x i8], [61 x i8] } { [67 x i8] c"VM_BUG_ON_PAGE(PagePoisoned(((typeof(page))_compound_head(page))))\00", [61 x i8] zeroinitializer }, align 32
@mem_cgroup_id_get_online.__already_done = internal unnamed_addr global i1 false, section ".data.once", align 1
@.str.170 = internal constant { [32 x i8], [32 x i8] } { [32 x i8] c"VM_BUG_ON_PAGE(PagePoisoned(p))\00", [32 x i8] zeroinitializer }, align 32
@nr_swap_pages = external dso_local global %struct.atomic_t, align 4
@.str.171 = internal constant { [2 x i8], [30 x i8] } { [2 x i8] c"1\00", [30 x i8] zeroinitializer }, align 32
@.str.172 = internal constant { [2 x i8], [30 x i8] } { [2 x i8] c"0\00", [30 x i8] zeroinitializer }, align 32
@swap_files = internal global { [5 x %struct.cftype], [168 x i8] } { [5 x %struct.cftype] [%struct.cftype { [64 x i8] c"swap.current\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 2, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @swap_current_read, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"swap.high\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 2, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @swap_high_show, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @swap_high_write, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"swap.max\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 2, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @swap_max_show, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @swap_max_write, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"swap.events\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 0, i32 0, i32 2, i32 780, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @swap_events_show, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype zeroinitializer], [168 x i8] zeroinitializer }, align 32
@memsw_files = internal global { [5 x %struct.cftype], [168 x i8] } { [5 x %struct.cftype] [%struct.cftype { [64 x i8] c"memsw.usage_in_bytes\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 65536, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_read_u64, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"memsw.max_usage_in_bytes\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 65538, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_read_u64, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_reset, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"memsw.limit_in_bytes\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 65537, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_read_u64, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_write, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype { [64 x i8] c"memsw.failcnt\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i32 65539, i32 0, i32 0, i32 0, ptr null, %struct.list_head zeroinitializer, ptr null, ptr null, ptr null, ptr @mem_cgroup_read_u64, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @mem_cgroup_reset, ptr null, %struct.lock_class_key zeroinitializer }, %struct.cftype zeroinitializer], [168 x i8] zeroinitializer }, align 32
@.str.173 = internal constant { [10 x i8], [22 x i8] } { [10 x i8] c"fail %lu\0A\00", [22 x i8] zeroinitializer }, align 32
@___asan_gen_.174 = private unnamed_addr constant [20 x i8] c"memcg_cache_ids_sem\00", align 1
@___asan_gen_.177 = private unnamed_addr constant [23 x i8] c"memcg_kmem_enabled_key\00", align 1
@___asan_gen_.179 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 398, i32 1 }
@___asan_gen_.180 = private unnamed_addr constant [22 x i8] c"stats_flush_threshold\00", align 1
@___asan_gen_.182 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 630, i32 17 }
@___asan_gen_.188 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 937, i32 32 }
@___asan_gen_.191 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1176, i32 3 }
@___asan_gen_.194 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1178, i32 3 }
@___asan_gen_.197 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1280, i32 6 }
@___asan_gen_.206 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1522, i32 3 }
@___asan_gen_.212 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1525, i32 3 }
@___asan_gen_.218 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1527, i32 3 }
@___asan_gen_.227 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1542, i32 2 }
@___asan_gen_.233 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1546, i32 3 }
@___asan_gen_.239 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1550, i32 3 }
@___asan_gen_.245 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1553, i32 3 }
@___asan_gen_.251 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1558, i32 2 }
@___asan_gen_.257 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1560, i32 2 }
@___asan_gen_.263 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1564, i32 2 }
@___asan_gen_.264 = private unnamed_addr constant [16 x i8] c"memcg_oom_waitq\00", align 1
@___asan_gen_.275 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1992, i32 2 }
@___asan_gen_.281 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1994, i32 2 }
@___asan_gen_.282 = private unnamed_addr constant [15 x i8] c"mem_cgroup_idr\00", align 1
@___asan_gen_.285 = private unnamed_addr constant [13 x i8] c"memory_files\00", align 1
@___asan_gen_.287 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6430, i32 22 }
@___asan_gen_.288 = private unnamed_addr constant [24 x i8] c"mem_cgroup_legacy_files\00", align 1
@___asan_gen_.290 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 4871, i32 22 }
@___asan_gen_.293 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6927, i32 2 }
@___asan_gen_.296 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6928, i32 2 }
@___asan_gen_.299 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6929, i32 2 }
@___asan_gen_.302 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6930, i32 2 }
@___asan_gen_.305 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6940, i32 2 }
@___asan_gen_.306 = private unnamed_addr constant [26 x i8] c"memcg_sockets_enabled_key\00", align 1
@___asan_gen_.308 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6960, i32 1 }
@___asan_gen_.311 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 7135, i32 2 }
@___asan_gen_.314 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 7136, i32 2 }
@___asan_gen_.317 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 7146, i32 2 }
@___asan_gen_.320 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 7162, i32 2 }
@___asan_gen_.323 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 7282, i32 2 }
@___asan_gen_.324 = private unnamed_addr constant [19 x i8] c"memcg_nr_cache_ids\00", align 1
@___asan_gen_.326 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 362, i32 5 }
@___asan_gen_.332 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 365, i32 8 }
@___asan_gen_.338 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.340, i32 695, i32 2 }
@___asan_gen_.340 = private unnamed_addr constant [28 x i8] c"../include/linux/rcupdate.h\00", align 1
@___asan_gen_.341 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.340, i32 723, i32 2 }
@___asan_gen_.342 = private unnamed_addr constant [17 x i8] c"stats_flush_lock\00", align 1
@___asan_gen_.347 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 628, i32 8 }
@___asan_gen_.349 = private unnamed_addr constant [26 x i8] c"../include/linux/cgroup.h\00", align 1
@___asan_gen_.350 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.349, i32 494, i32 9 }
@___asan_gen_.353 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.499, i32 396, i32 2 }
@___asan_gen_.359 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.499, i32 746, i32 2 }
@___asan_gen_.360 = private unnamed_addr constant [13 x i8] c"memory_stats\00", align 1
@___asan_gen_.362 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1371, i32 33 }
@___asan_gen_.365 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1462, i32 22 }
@___asan_gen_.368 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1467, i32 23 }
@___asan_gen_.371 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1473, i32 21 }
@___asan_gen_.374 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1479, i32 21 }
@___asan_gen_.377 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1482, i32 21 }
@___asan_gen_.380 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1372, i32 4 }
@___asan_gen_.383 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1373, i32 4 }
@___asan_gen_.386 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1374, i32 4 }
@___asan_gen_.389 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1375, i32 4 }
@___asan_gen_.392 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1376, i32 4 }
@___asan_gen_.395 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1377, i32 4 }
@___asan_gen_.398 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1378, i32 4 }
@___asan_gen_.401 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1379, i32 4 }
@___asan_gen_.404 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1380, i32 4 }
@___asan_gen_.407 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1381, i32 4 }
@___asan_gen_.410 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1382, i32 4 }
@___asan_gen_.413 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1384, i32 4 }
@___asan_gen_.416 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1391, i32 4 }
@___asan_gen_.419 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1392, i32 4 }
@___asan_gen_.422 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1393, i32 4 }
@___asan_gen_.425 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1394, i32 4 }
@___asan_gen_.428 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1395, i32 4 }
@___asan_gen_.431 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1396, i32 4 }
@___asan_gen_.434 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1397, i32 4 }
@___asan_gen_.437 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1400, i32 4 }
@___asan_gen_.440 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1401, i32 4 }
@___asan_gen_.443 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1402, i32 4 }
@___asan_gen_.446 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1403, i32 4 }
@___asan_gen_.449 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1404, i32 4 }
@___asan_gen_.452 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1405, i32 4 }
@___asan_gen_.455 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1406, i32 4 }
@___asan_gen_.458 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1761, i32 8 }
@___asan_gen_.459 = private unnamed_addr constant [15 x i8] c"memcg_oom_lock\00", align 1
@___asan_gen_.464 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1680, i32 8 }
@___asan_gen_.465 = private unnamed_addr constant [23 x i8] c"memcg_oom_lock_dep_map\00", align 1
@___asan_gen_.467 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 1675, i32 27 }
@___asan_gen_.470 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.721, i32 260, i32 2 }
@___asan_gen_.473 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.475, i32 444, i32 2 }
@___asan_gen_.475 = private unnamed_addr constant [13 x i8] c"../mm/slab.h\00", align 1
@___asan_gen_.476 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.475, i32 446, i32 2 }
@___asan_gen_.477 = private unnamed_addr constant [20 x i8] c"percpu_charge_mutex\00", align 1
@___asan_gen_.485 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 2111, i32 8 }
@___asan_gen_.486 = private unnamed_addr constant [3 x i8] c"mc\00", align 1
@___asan_gen_.488 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 195, i32 3 }
@___asan_gen_.491 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 196, i32 10 }
@___asan_gen_.494 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 197, i32 11 }
@___asan_gen_.497 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.499, i32 537, i32 2 }
@___asan_gen_.499 = private unnamed_addr constant [30 x i8] c"../include/linux/memcontrol.h\00", align 1
@___asan_gen_.500 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.499, i32 538, i32 2 }
@___asan_gen_.502 = private unnamed_addr constant [36 x i8] c"../include/trace/events/writeback.h\00", align 1
@___asan_gen_.503 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.502, i32 237, i32 1 }
@___asan_gen_.505 = private unnamed_addr constant [27 x i8] c"../include/linux/cpumask.h\00", align 1
@___asan_gen_.506 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.505, i32 108, i32 2 }
@___asan_gen_.509 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 5024, i32 8 }
@___asan_gen_.515 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 5159, i32 2 }
@___asan_gen_.521 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 5161, i32 2 }
@___asan_gen_.527 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 5162, i32 2 }
@___asan_gen_.533 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 5165, i32 2 }
@___asan_gen_.534 = private unnamed_addr constant [21 x i8] c"memcg_cgwb_frn_waitq\00", align 1
@___asan_gen_.539 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 97, i32 8 }
@___asan_gen_.540 = private unnamed_addr constant [16 x i8] c"memcg_cache_ida\00", align 1
@___asan_gen_.545 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 361, i32 8 }
@___asan_gen_.546 = private unnamed_addr constant [11 x i8] c"objcg_lock\00", align 1
@___asan_gen_.551 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 257, i32 8 }
@___asan_gen_.552 = private unnamed_addr constant [18 x i8] c"stats_flush_dwork\00", align 1
@___asan_gen_.560 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 627, i32 8 }
@___asan_gen_.561 = private unnamed_addr constant [19 x i8] c"precharge_walk_ops\00", align 1
@___asan_gen_.563 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 5821, i32 33 }
@___asan_gen_.566 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.724, i32 717, i32 2 }
@___asan_gen_.567 = private unnamed_addr constant [16 x i8] c"charge_walk_ops\00", align 1
@___asan_gen_.569 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6097, i32 33 }
@___asan_gen_.572 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 5579, i32 2 }
@___asan_gen_.575 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6158, i32 15 }
@___asan_gen_.578 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6160, i32 17 }
@___asan_gen_.581 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6187, i32 35 }
@___asan_gen_.584 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6323, i32 16 }
@___asan_gen_.587 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6324, i32 16 }
@___asan_gen_.590 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6325, i32 16 }
@___asan_gen_.593 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6326, i32 16 }
@___asan_gen_.596 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6327, i32 16 }
@___asan_gen_.599 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6329, i32 16 }
@___asan_gen_.602 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 6403, i32 16 }
@___asan_gen_.605 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 3739, i32 35 }
@___asan_gen_.606 = private unnamed_addr constant [16 x i8] c"memcg_max_mutex\00", align 1
@___asan_gen_.614 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 3359, i32 8 }
@___asan_gen_.615 = private unnamed_addr constant [13 x i8] c"memcg1_stats\00", align 1
@___asan_gen_.617 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 3932, i32 27 }
@___asan_gen_.618 = private unnamed_addr constant [18 x i8] c"memcg1_stat_names\00", align 1
@___asan_gen_.620 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 3945, i32 26 }
@___asan_gen_.623 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 4001, i32 16 }
@___asan_gen_.626 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 4004, i32 17 }
@___asan_gen_.629 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 4013, i32 17 }
@___asan_gen_.632 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 4040, i32 17 }
@___asan_gen_.635 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 4041, i32 17 }
@___asan_gen_.638 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 3946, i32 2 }
@___asan_gen_.641 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 3947, i32 2 }
@___asan_gen_.644 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 3952, i32 2 }
@___asan_gen_.647 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 3953, i32 2 }
@___asan_gen_.650 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 3954, i32 2 }
@___asan_gen_.653 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 3955, i32 2 }
@___asan_gen_.654 = private unnamed_addr constant [7 x i8] c"_entry\00", align 1
@___asan_gen_.662 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 3547, i32 2 }
@___asan_gen_.668 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 4763, i32 2 }
@___asan_gen_.671 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 4799, i32 20 }
@___asan_gen_.674 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 4802, i32 27 }
@___asan_gen_.677 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 4805, i32 27 }
@___asan_gen_.680 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 4808, i32 27 }
@___asan_gen_.683 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 4401, i32 17 }
@___asan_gen_.686 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 4402, i32 17 }
@___asan_gen_.688 = private unnamed_addr constant [35 x i8] c"../include/linux/percpu-refcount.h\00", align 1
@___asan_gen_.689 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.688, i32 280, i32 2 }
@___asan_gen_.692 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.721, i32 698, i32 1 }
@___asan_gen_.695 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 2739, i32 2 }
@___asan_gen_.698 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 7048, i32 29 }
@___asan_gen_.701 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 7051, i32 22 }
@___asan_gen_.704 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 7053, i32 22 }
@___asan_gen_.707 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 7080, i32 49 }
@___asan_gen_.713 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 7084, i32 3 }
@___asan_gen_.714 = private unnamed_addr constant [6 x i8] c"__key\00", align 1
@___asan_gen_.719 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 7095, i32 3 }
@___asan_gen_.721 = private unnamed_addr constant [30 x i8] c"../include/linux/page-flags.h\00", align 1
@___asan_gen_.722 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.721, i32 422, i32 1 }
@___asan_gen_.724 = private unnamed_addr constant [22 x i8] c"../include/linux/mm.h\00", align 1
@___asan_gen_.725 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.724, i32 1368, i32 10 }
@___asan_gen_.728 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 7306, i32 17 }
@___asan_gen_.731 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 7308, i32 22 }
@___asan_gen_.732 = private unnamed_addr constant [11 x i8] c"swap_files\00", align 1
@___asan_gen_.734 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 7382, i32 22 }
@___asan_gen_.735 = private unnamed_addr constant [12 x i8] c"memsw_files\00", align 1
@___asan_gen_.737 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 7409, i32 22 }
@___asan_gen_.738 = private unnamed_addr constant [17 x i8] c"<string literal>\00", align 1
@___asan_gen_.739 = private constant [19 x i8] c"../mm/memcontrol.c\00", align 1
@___asan_gen_.740 = private unnamed_addr constant { ptr, i32, i32 } { ptr @___asan_gen_.739, i32 7376, i32 16 }
@llvm.compiler.used = appending global [213 x ptr] [ptr @__initcall__kmod_memcontrol__736_7101_mem_cgroup_init4, ptr @__initcall__kmod_memcontrol__744_7457_mem_cgroup_swap_init1, ptr @__ksymtab___mod_lruvec_page_state, ptr @__ksymtab_get_mem_cgroup_from_mm, ptr @__ksymtab_int_active_memcg, ptr @__ksymtab_mem_cgroup_from_task, ptr @__ksymtab_memcg_kmem_enabled_key, ptr @__ksymtab_memcg_sockets_enabled_key, ptr @__ksymtab_memory_cgrp_subsys, ptr @__setup_cgroup_memory, ptr @__setup_setup_swap_account, ptr @mem_cgroup_hierarchy_write._entry, ptr @mem_cgroup_hierarchy_write._entry_ptr, ptr @mem_cgroup_print_oom_context._entry, ptr @mem_cgroup_print_oom_context._entry.11, ptr @mem_cgroup_print_oom_context._entry.8, ptr @mem_cgroup_print_oom_context._entry_ptr, ptr @mem_cgroup_print_oom_context._entry_ptr.10, ptr @mem_cgroup_print_oom_context._entry_ptr.13, ptr @mem_cgroup_print_oom_group._entry, ptr @mem_cgroup_print_oom_group._entry.36, ptr @mem_cgroup_print_oom_group._entry_ptr, ptr @mem_cgroup_print_oom_group._entry_ptr.38, ptr @mem_cgroup_print_oom_meminfo._entry, ptr @mem_cgroup_print_oom_meminfo._entry.16, ptr @mem_cgroup_print_oom_meminfo._entry.19, ptr @mem_cgroup_print_oom_meminfo._entry.22, ptr @mem_cgroup_print_oom_meminfo._entry.25, ptr @mem_cgroup_print_oom_meminfo._entry.28, ptr @mem_cgroup_print_oom_meminfo._entry.31, ptr @mem_cgroup_print_oom_meminfo._entry_ptr, ptr @mem_cgroup_print_oom_meminfo._entry_ptr.18, ptr @mem_cgroup_print_oom_meminfo._entry_ptr.21, ptr @mem_cgroup_print_oom_meminfo._entry_ptr.24, ptr @mem_cgroup_print_oom_meminfo._entry_ptr.27, ptr @mem_cgroup_print_oom_meminfo._entry_ptr.30, ptr @mem_cgroup_print_oom_meminfo._entry_ptr.33, ptr @memcg_cache_ids_sem, ptr @memcg_kmem_enabled_key, ptr @stats_flush_threshold, ptr @.str.1, ptr @.str.2, ptr @.str.3, ptr @.str.4, ptr @.str.5, ptr @.str.6, ptr @.str.7, ptr @.str.9, ptr @.str.12, ptr @.str.14, ptr @.str.15, ptr @.str.17, ptr @.str.20, ptr @.str.23, ptr @.str.26, ptr @.str.29, ptr @.str.32, ptr @memcg_oom_waitq, ptr @.str.34, ptr @.str.35, ptr @.str.37, ptr @mem_cgroup_idr, ptr @memory_files, ptr @mem_cgroup_legacy_files, ptr @.str.39, ptr @.str.40, ptr @.str.41, ptr @.str.42, ptr @.str.43, ptr @memcg_sockets_enabled_key, ptr @.str.44, ptr @.str.45, ptr @.str.46, ptr @.str.47, ptr @.str.48, ptr @memcg_nr_cache_ids, ptr @.str.49, ptr @.str.50, ptr @.str.51, ptr @.str.52, ptr @.str.53, ptr @stats_flush_lock, ptr @.str.54, ptr @.str.57, ptr @.str.58, ptr @.str.61, ptr @.str.62, ptr @memory_stats, ptr @.str.63, ptr @.str.64, ptr @.str.65, ptr @.str.66, ptr @.str.67, ptr @.str.68, ptr @.str.69, ptr @.str.70, ptr @.str.71, ptr @.str.72, ptr @.str.73, ptr @.str.74, ptr @.str.75, ptr @.str.76, ptr @.str.77, ptr @.str.78, ptr @.str.79, ptr @.str.80, ptr @.str.81, ptr @.str.82, ptr @.str.83, ptr @.str.84, ptr @.str.85, ptr @.str.86, ptr @.str.87, ptr @.str.88, ptr @.str.89, ptr @.str.90, ptr @.str.91, ptr @.str.92, ptr @.str.93, ptr @.str.94, ptr @memcg_oom_lock, ptr @.str.95, ptr @memcg_oom_lock_dep_map, ptr @.str.96, ptr @.str.98, ptr @.str.99, ptr @percpu_charge_mutex, ptr @.str.100, ptr @.str.101, ptr @mc, ptr @.str.102, ptr @.str.103, ptr @.str.104, ptr @.str.105, ptr @.str.107, ptr @.str.108, ptr @.str.109, ptr @mem_cgroup_alloc.__key, ptr @.str.110, ptr @mem_cgroup_alloc.__key.111, ptr @.str.112, ptr @mem_cgroup_alloc.__key.113, ptr @.str.114, ptr @mem_cgroup_alloc.__key.115, ptr @.str.116, ptr @memcg_cgwb_frn_waitq, ptr @.str.117, ptr @memcg_cache_ida, ptr @.str.118, ptr @objcg_lock, ptr @.str.119, ptr @stats_flush_dwork, ptr @.str.120, ptr @.str.121, ptr @precharge_walk_ops, ptr @.str.122, ptr @charge_walk_ops, ptr @.str.123, ptr @.str.124, ptr @.str.125, ptr @.str.126, ptr @.str.127, ptr @.str.128, ptr @.str.129, ptr @.str.130, ptr @.str.131, ptr @.str.132, ptr @.str.133, ptr @.str.134, ptr @memcg_max_mutex, ptr @.str.135, ptr @.str.136, ptr @memcg1_stats, ptr @memcg1_stat_names, ptr @.str.137, ptr @.str.138, ptr @.str.139, ptr @.str.140, ptr @.str.141, ptr @.str.142, ptr @.str.143, ptr @.str.144, ptr @.str.145, ptr @.str.146, ptr @.str.147, ptr @.str.148, ptr @.str.149, ptr @memcg_write_event_control.__key, ptr @.str.150, ptr @.str.151, ptr @.str.152, ptr @.str.153, ptr @.str.154, ptr @.str.156, ptr @.str.157, ptr @.str.158, ptr @.str.159, ptr @.str.160, ptr @.str.162, ptr @.str.163, ptr @.str.164, ptr @.str.165, ptr @mem_cgroup_init.__key, ptr @.str.166, ptr @mem_cgroup_init.__key.167, ptr @.str.168, ptr @.str.169, ptr @.str.170, ptr @.str.171, ptr @.str.172, ptr @swap_files, ptr @memsw_files, ptr @.str.173], section "llvm.metadata"
@0 = internal global [189 x { i32, i32, i32, i32, i32, i32, i32, i32 }] [{ i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @memcg_cache_ids_sem to i32), i32 96, i32 128, i32 ptrtoint (ptr @___asan_gen_.174 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.332 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @memcg_kmem_enabled_key to i32), i32 8, i32 32, i32 ptrtoint (ptr @___asan_gen_.177 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.179 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @stats_flush_threshold to i32), i32 4, i32 32, i32 ptrtoint (ptr @___asan_gen_.180 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.182 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.1 to i32), i32 16, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.188 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.2 to i32), i32 41, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.188 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.3 to i32), i32 57, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.191 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.4 to i32), i32 47, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.194 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.5 to i32), i32 30, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.197 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_print_oom_context._entry to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.654 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.206 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.6 to i32), i32 14, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.206 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.7 to i32), i32 29, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.206 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_print_oom_context._entry.8 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.654 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.212 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.9 to i32), i32 14, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.212 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_print_oom_context._entry.11 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.654 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.218 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.12 to i32), i32 15, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.218 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_print_oom_meminfo._entry to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.654 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.227 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.14 to i32), i32 51, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.227 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.15 to i32), i32 29, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.227 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_print_oom_meminfo._entry.16 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.654 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.233 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.17 to i32), i32 49, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.233 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_print_oom_meminfo._entry.19 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.654 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.239 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.20 to i32), i32 56, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.239 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_print_oom_meminfo._entry.22 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.654 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.245 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.23 to i32), i32 49, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.245 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_print_oom_meminfo._entry.25 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.654 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.251 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.26 to i32), i32 27, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.251 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_print_oom_meminfo._entry.28 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.654 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.257 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.29 to i32), i32 4, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.257 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_print_oom_meminfo._entry.31 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.654 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.263 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.32 to i32), i32 5, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.263 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @memcg_oom_waitq to i32), i32 52, i32 96, i32 ptrtoint (ptr @___asan_gen_.264 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.458 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_print_oom_group._entry to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.654 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.275 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.34 to i32), i32 12, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.275 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.35 to i32), i32 27, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.275 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_print_oom_group._entry.36 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.654 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.281 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.37 to i32), i32 55, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.281 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_idr to i32), i32 60, i32 96, i32 ptrtoint (ptr @___asan_gen_.282 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.509 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @memory_files to i32), i32 1520, i32 1888, i32 ptrtoint (ptr @___asan_gen_.285 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.287 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_legacy_files to i32), i32 3496, i32 4384, i32 ptrtoint (ptr @___asan_gen_.288 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.290 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.39 to i32), i32 41, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.293 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.40 to i32), i32 41, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.296 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.41 to i32), i32 62, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.299 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.42 to i32), i32 49, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.302 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.43 to i32), i32 30, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.305 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @memcg_sockets_enabled_key to i32), i32 8, i32 32, i32 ptrtoint (ptr @___asan_gen_.306 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.308 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.44 to i32), i32 30, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.311 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.45 to i32), i32 33, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.314 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.46 to i32), i32 29, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.317 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.47 to i32), i32 22, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.320 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.48 to i32), i32 34, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.323 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @memcg_nr_cache_ids to i32), i32 4, i32 32, i32 ptrtoint (ptr @___asan_gen_.324 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.326 to i32), i32 0 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.49 to i32), i32 30, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.332 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.50 to i32), i32 20, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.332 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.51 to i32), i32 25, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.338 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.52 to i32), i32 42, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.338 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.53 to i32), i32 44, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.341 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @stats_flush_lock to i32), i32 44, i32 96, i32 ptrtoint (ptr @___asan_gen_.342 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.347 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.54 to i32), i32 17, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.347 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.57 to i32), i32 23, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.350 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.58 to i32), i32 40, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.353 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.61 to i32), i32 56, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.359 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.62 to i32), i32 27, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.359 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @memory_stats to i32), i32 208, i32 256, i32 ptrtoint (ptr @___asan_gen_.360 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.362 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.63 to i32), i32 9, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.365 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.64 to i32), i32 11, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.368 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.65 to i32), i32 8, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.371 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.66 to i32), i32 12, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.374 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.67 to i32), i32 13, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.377 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.68 to i32), i32 5, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.380 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.69 to i32), i32 5, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.383 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.70 to i32), i32 13, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.386 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.71 to i32), i32 11, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.389 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.72 to i32), i32 7, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.392 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.73 to i32), i32 5, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.395 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.74 to i32), i32 8, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.398 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.75 to i32), i32 6, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.401 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.76 to i32), i32 12, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.404 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.77 to i32), i32 11, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.407 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.78 to i32), i32 15, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.410 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.79 to i32), i32 11, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.413 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.80 to i32), i32 14, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.416 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.81 to i32), i32 12, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.419 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.82 to i32), i32 14, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.422 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.83 to i32), i32 12, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.425 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.84 to i32), i32 12, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.428 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.85 to i32), i32 17, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.431 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.86 to i32), i32 19, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.434 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.87 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.437 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.88 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.440 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.89 to i32), i32 25, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.443 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.90 to i32), i32 25, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.446 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.91 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.449 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.92 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.452 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.93 to i32), i32 23, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.455 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.94 to i32), i32 21, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.458 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @memcg_oom_lock to i32), i32 44, i32 96, i32 ptrtoint (ptr @___asan_gen_.459 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.464 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.95 to i32), i32 15, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.464 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @memcg_oom_lock_dep_map to i32), i32 28, i32 64, i32 ptrtoint (ptr @___asan_gen_.465 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.467 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.96 to i32), i32 31, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.470 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.98 to i32), i32 64, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.473 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.99 to i32), i32 45, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.476 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @percpu_charge_mutex to i32), i32 92, i32 128, i32 ptrtoint (ptr @___asan_gen_.477 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.485 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.100 to i32), i32 30, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.485 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.101 to i32), i32 20, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.485 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mc to i32), i32 128, i32 160, i32 ptrtoint (ptr @___asan_gen_.486 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.488 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.102 to i32), i32 8, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.491 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.103 to i32), i32 14, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.494 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.104 to i32), i32 39, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.497 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.105 to i32), i32 55, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.500 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.107 to i32), i32 33, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.503 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.108 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.506 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.109 to i32), i32 23, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.509 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_alloc.__key to i32), i32 8, i32 32, i32 ptrtoint (ptr @___asan_gen_.714 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.515 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.110 to i32), i32 37, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.515 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_alloc.__key.111 to i32), i32 8, i32 32, i32 ptrtoint (ptr @___asan_gen_.714 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.521 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.112 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.521 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_alloc.__key.113 to i32), i32 8, i32 32, i32 ptrtoint (ptr @___asan_gen_.714 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.527 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.114 to i32), i32 18, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.527 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_alloc.__key.115 to i32), i32 8, i32 32, i32 ptrtoint (ptr @___asan_gen_.714 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.533 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.116 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.533 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @memcg_cgwb_frn_waitq to i32), i32 52, i32 96, i32 ptrtoint (ptr @___asan_gen_.534 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.539 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.117 to i32), i32 26, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.539 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @memcg_cache_ida to i32), i32 52, i32 96, i32 ptrtoint (ptr @___asan_gen_.540 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.545 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.118 to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.545 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @objcg_lock to i32), i32 44, i32 96, i32 ptrtoint (ptr @___asan_gen_.546 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.551 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.119 to i32), i32 11, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.551 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @stats_flush_dwork to i32), i32 100, i32 160, i32 ptrtoint (ptr @___asan_gen_.552 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.560 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.120 to i32), i32 25, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.560 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.121 to i32), i32 20, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.560 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @precharge_walk_ops to i32), i32 40, i32 96, i32 ptrtoint (ptr @___asan_gen_.561 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.563 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.122 to i32), i32 42, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.566 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @charge_walk_ops to i32), i32 40, i32 96, i32 ptrtoint (ptr @___asan_gen_.567 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.569 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.123 to i32), i32 39, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.572 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.124 to i32), i32 5, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.575 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.125 to i32), i32 6, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.578 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.126 to i32), i32 4, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.581 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.127 to i32), i32 9, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.584 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.128 to i32), i32 10, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.587 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.129 to i32), i32 9, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.590 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.130 to i32), i32 9, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.593 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.131 to i32), i32 14, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.596 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.132 to i32), i32 20, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.599 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.133 to i32), i32 4, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.602 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.134 to i32), i32 3, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.605 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @memcg_max_mutex to i32), i32 92, i32 128, i32 ptrtoint (ptr @___asan_gen_.606 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.614 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.135 to i32), i32 26, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.614 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.136 to i32), i32 16, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.614 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @memcg1_stats to i32), i32 28, i32 64, i32 ptrtoint (ptr @___asan_gen_.615 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.617 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @memcg1_stat_names to i32), i32 28, i32 64, i32 ptrtoint (ptr @___asan_gen_.618 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.620 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.137 to i32), i32 32, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.623 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.138 to i32), i32 31, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.626 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.139 to i32), i32 15, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.629 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.140 to i32), i32 15, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.632 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.141 to i32), i32 15, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.635 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.142 to i32), i32 6, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.638 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.143 to i32), i32 4, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.641 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.144 to i32), i32 12, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.644 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.145 to i32), i32 6, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.647 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.146 to i32), i32 10, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.650 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.147 to i32), i32 5, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.653 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_hierarchy_write._entry to i32), i32 24, i32 64, i32 ptrtoint (ptr @___asan_gen_.654 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.662 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.148 to i32), i32 126, i32 160, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.662 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.149 to i32), i32 27, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.662 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @memcg_write_event_control.__key to i32), i32 8, i32 32, i32 ptrtoint (ptr @___asan_gen_.714 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.668 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.150 to i32), i32 34, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.668 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.151 to i32), i32 22, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.671 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.152 to i32), i32 19, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.674 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.153 to i32), i32 22, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.677 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.154 to i32), i32 28, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.680 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.156 to i32), i32 21, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.683 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.157 to i32), i32 14, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.686 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.158 to i32), i32 32, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.689 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.159 to i32), i32 35, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.692 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.160 to i32), i32 36, i32 96, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.695 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.162 to i32), i32 2, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.698 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.163 to i32), i32 9, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.701 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.164 to i32), i32 7, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.704 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.165 to i32), i32 16, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.707 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_init.__key to i32), i32 8, i32 32, i32 ptrtoint (ptr @___asan_gen_.714 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.713 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.166 to i32), i32 336, i32 416, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.713 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @mem_cgroup_init.__key.167 to i32), i32 8, i32 32, i32 ptrtoint (ptr @___asan_gen_.714 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.719 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.168 to i32), i32 12, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.719 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.169 to i32), i32 67, i32 128, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.722 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.170 to i32), i32 32, i32 64, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.725 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.171 to i32), i32 2, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.728 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.172 to i32), i32 2, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.731 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @swap_files to i32), i32 760, i32 928, i32 ptrtoint (ptr @___asan_gen_.732 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.734 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @memsw_files to i32), i32 760, i32 928, i32 ptrtoint (ptr @___asan_gen_.735 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.737 to i32), i32 -1 }, { i32, i32, i32, i32, i32, i32, i32, i32 } { i32 ptrtoint (ptr @.str.173 to i32), i32 10, i32 32, i32 ptrtoint (ptr @___asan_gen_.738 to i32), i32 ptrtoint (ptr @___asan_gen_.739 to i32), i32 0, i32 ptrtoint (ptr @___asan_gen_.740 to i32), i32 -1 }]
@llvm.used = appending global [2 x ptr] [ptr @asan.module_ctor, ptr @asan.module_dtor], section "llvm.metadata"
@llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 1, ptr @asan.module_ctor, ptr null }]
@llvm.global_dtors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 1, ptr @asan.module_dtor, ptr null }]

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync)
define dso_local ptr @memcg_to_vmpressure(ptr noundef readnone %memcg) local_unnamed_addr #0 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tobool.not = icmp eq ptr %memcg, null
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = load ptr, ptr @root_mem_cgroup, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %memcg.addr.0 = phi ptr [ %memcg, %entry ], [ %0, %if.then ]
  %vmpressure = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 8
  ret ptr %vmpressure
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync)
define dso_local ptr @vmpressure_to_memcg(ptr noundef readnone %vmpr) local_unnamed_addr #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %vmpr, i32 -448
  ret ptr %add.ptr
}

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #2

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync)
define dso_local zeroext i1 @mem_cgroup_kmem_disabled() local_unnamed_addr #0 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %.b1 = load i1, ptr @cgroup_memory_nokmem, align 1
  ret i1 %.b1
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @memcg_get_cache_ids() local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call void @down_read(ptr noundef nonnull @memcg_cache_ids_sem) #23
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @down_read(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @memcg_put_cache_ids() local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call void @up_read(ptr noundef nonnull @memcg_cache_ids_sem) #23
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @up_read(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @mem_cgroup_css_from_page(ptr noundef %page) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = getelementptr inbounds %struct.page, ptr %page, i32 0, i32 1
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %0, align 4
  %and.i.i = and i32 %2, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.end.i.i, label %if.then.i.i, !prof !460

if.then.i.i:                                      ; preds = %entry
  %sub.i.i = add i32 %2, -1
  br label %page_memcg.exit

if.end.i.i:                                       ; preds = %entry
  %3 = ptrtoint ptr %page to i32
  br label %page_memcg.exit

page_memcg.exit:                                  ; preds = %if.end.i.i, %if.then.i.i
  %retval.0.i.i = phi i32 [ %sub.i.i, %if.then.i.i ], [ %3, %if.end.i.i ]
  %4 = inttoptr i32 %retval.0.i.i to ptr
  %call1.i = tail call fastcc ptr @folio_memcg(ptr noundef %4) #23
  %tobool.not = icmp eq ptr %call1.i, null
  br i1 %tobool.not, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %page_memcg.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_css_from_page, %if.then)) #23
          to label %if.end [label %if.then], !srcloc !461

if.then:                                          ; preds = %lor.lhs.false, %page_memcg.exit
  %5 = load ptr, ptr @root_mem_cgroup, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %memcg.0 = phi ptr [ %5, %if.then ], [ %call1.i, %lor.lhs.false ]
  ret ptr %memcg.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @page_cgroup_ino(ptr noundef %page) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %3, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %entry
  %memcg_data1.i = getelementptr inbounds %struct.page, ptr %page, i32 0, i32 4
  %4 = ptrtoint ptr %memcg_data1.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %memcg_data1.i, align 4
  %and.i = and i32 %5, 1
  %tobool.not.i10 = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i10, label %if.end.i, label %if.end

if.end.i:                                         ; preds = %rcu_read_lock.exit
  %and2.i = and i32 %5, 2
  %tobool3.not.i = icmp eq i32 %and2.i, 0
  %and7.i = and i32 %5, -4
  %6 = inttoptr i32 %and7.i to ptr
  br i1 %tobool3.not.i, label %page_memcg_check.exit, label %if.then4.i

if.then4.i:                                       ; preds = %if.end.i
  %memcg.i.i = getelementptr inbounds %struct.obj_cgroup, ptr %6, i32 0, i32 1
  %7 = ptrtoint ptr %memcg.i.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load volatile ptr, ptr %memcg.i.i, align 4
  br label %page_memcg_check.exit

page_memcg_check.exit:                            ; preds = %if.then4.i, %if.end.i
  %retval.0.i = phi ptr [ %8, %if.then4.i ], [ %6, %if.end.i ]
  %tobool.not23 = icmp eq ptr %retval.0.i, null
  br i1 %tobool.not23, label %if.end, label %land.rhs

land.rhs:                                         ; preds = %while.body, %page_memcg_check.exit
  %memcg.024 = phi ptr [ %add.ptr.i, %while.body ], [ %retval.0.i, %page_memcg_check.exit ]
  %flags = getelementptr inbounds %struct.cgroup_subsys_state, ptr %memcg.024, i32 0, i32 7
  %9 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %flags, align 4
  %and = and i32 %10, 2
  %tobool1.not = icmp eq i32 %and, 0
  br i1 %tobool1.not, label %while.body, label %if.then.critedge

while.body:                                       ; preds = %land.rhs
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.024, i32 0, i32 2, i32 13
  %11 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %parent.i, align 4
  %tobool.not.i11 = icmp eq ptr %12, null
  %add.ptr.i = getelementptr i8, ptr %12, i32 -176
  %tobool.not29 = icmp eq ptr %add.ptr.i, null
  %tobool.not = or i1 %tobool.not.i11, %tobool.not29
  br i1 %tobool.not, label %if.end, label %land.rhs

if.then.critedge:                                 ; preds = %land.rhs
  %13 = ptrtoint ptr %memcg.024 to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %memcg.024, align 128
  %kn.i = getelementptr inbounds %struct.cgroup, ptr %14, i32 0, i32 11
  %15 = ptrtoint ptr %kn.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %kn.i, align 8
  %id.i.i = getelementptr inbounds %struct.kernfs_node, ptr %16, i32 0, i32 10
  %17 = ptrtoint ptr %id.i.i to i32
  call void @__asan_load8_noabort(i32 %17)
  %18 = load i64, ptr %id.i.i, align 8
  %conv.i.i.i = trunc i64 %18 to i32
  br label %if.end

if.end:                                           ; preds = %if.then.critedge, %while.body, %page_memcg_check.exit, %rcu_read_lock.exit
  %ino.0 = phi i32 [ %conv.i.i.i, %if.then.critedge ], [ 0, %page_memcg_check.exit ], [ 0, %rcu_read_lock.exit ], [ 0, %while.body ]
  %call.i13 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i13, label %rcu_read_unlock.exit, label %land.lhs.true.i16

land.lhs.true.i16:                                ; preds = %if.end
  %call1.i14 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i15 = icmp eq i32 %call1.i14, 0
  br i1 %tobool.not.i15, label %rcu_read_unlock.exit, label %land.lhs.true2.i18

land.lhs.true2.i18:                               ; preds = %land.lhs.true.i16
  %.b4.i17 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i17, label %rcu_read_unlock.exit, label %if.then.i19

if.then.i19:                                      ; preds = %land.lhs.true2.i18
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i19, %land.lhs.true2.i18, %land.lhs.true.i16, %if.end
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %19 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i20 = and i32 %19, -16384
  %20 = inttoptr i32 %and.i.i.i.i.i20 to ptr
  %preempt_count.i.i.i.i21 = getelementptr inbounds %struct.thread_info, ptr %20, i32 0, i32 1
  %21 = ptrtoint ptr %preempt_count.i.i.i.i21 to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load volatile i32, ptr %preempt_count.i.i.i.i21, align 4
  %sub.i.i.i = add i32 %22, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i21, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  ret i32 %ino.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mem_cgroup_flush_stats() local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @stats_flush_threshold, i32 noundef 4) #23
  %0 = load volatile i32, ptr @stats_flush_threshold, align 4
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @__num_online_cpus, i32 noundef 4) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__num_online_cpus to i32))
  %1 = load volatile i32, ptr @__num_online_cpus, align 4
  %cmp = icmp ugt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call fastcc void @__mem_cgroup_flush_stats()
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @__mem_cgroup_flush_stats() unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i = and i32 %0, 128
  %tobool.not = icmp eq i32 %and.i, 0
  br i1 %tobool.not, label %do.end11, label %do.end11.thread

do.end11:                                         ; preds = %entry
  tail call void @trace_hardirqs_off() #23
  %call14 = tail call i32 @_raw_spin_trylock(ptr noundef nonnull @stats_flush_lock) #23
  %tobool15.not = icmp eq i32 %call14, 0
  br i1 %tobool15.not, label %if.then25, label %if.end50

do.end11.thread:                                  ; preds = %entry
  %call1455 = tail call i32 @_raw_spin_trylock(ptr noundef nonnull @stats_flush_lock) #23
  %tobool15.not56 = icmp eq i32 %call1455, 0
  br i1 %tobool15.not56, label %do.body27, label %if.end50

if.then25:                                        ; preds = %do.end11
  tail call void @trace_hardirqs_on() #23
  br label %do.body27

do.body27:                                        ; preds = %if.then25, %do.end11.thread
  %1 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i = and i32 %1, 128
  %tobool35.not = icmp eq i32 %and.i.i, 0
  br i1 %tobool35.not, label %if.then39, label %do.end42, !prof !466

if.then39:                                        ; preds = %do.body27
  tail call void @warn_bogus_irq_restore() #23
  br label %do.end42

do.end42:                                         ; preds = %if.then39, %do.body27
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %0) #23, !srcloc !467
  br label %cleanup

if.end50:                                         ; preds = %do.end11.thread, %do.end11
  %2 = load ptr, ptr @root_mem_cgroup, align 4
  %3 = ptrtoint ptr %2 to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %2, align 128
  tail call void @cgroup_rstat_flush_irqsafe(ptr noundef %4) #23
  %call.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef nonnull @stats_flush_threshold, i32 noundef 4) #23
  store volatile i32 0, ptr @stats_flush_threshold, align 4
  tail call void @_raw_spin_unlock_irqrestore(ptr noundef nonnull @stats_flush_lock, i32 noundef %0) #23
  br label %cleanup

cleanup:                                          ; preds = %if.end50, %do.end42
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @__mod_memcg_state(ptr nocapture noundef readonly %memcg, i32 noundef %idx, i32 noundef %val) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@__mod_memcg_state, %return)) #23
          to label %if.end [label %return], !srcloc !461

if.end:                                           ; preds = %entry
  %vmstats_percpu = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 39
  %0 = ptrtoint ptr %vmstats_percpu to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %vmstats_percpu, align 8
  %arrayidx = getelementptr [44 x i32], ptr %1, i32 0, i32 %idx
  %2 = ptrtoint ptr %arrayidx to i32
  %3 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i = and i32 %3, -16384
  %4 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %4, i32 0, i32 3
  %5 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %cpu, align 4
  %arrayidx8 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %6
  %7 = ptrtoint ptr %arrayidx8 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %arrayidx8, align 4
  %add = add i32 %8, %2
  %9 = inttoptr i32 %add to ptr
  %10 = ptrtoint ptr %9 to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %9, align 4
  %add9 = add i32 %11, %val
  store i32 %add9, ptr %9, align 4
  %12 = ptrtoint ptr %memcg to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %memcg, align 128
  %14 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i = and i32 %14, -16384
  %15 = inttoptr i32 %and.i.i to ptr
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %15, i32 0, i32 3
  %16 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %cpu.i, align 4
  tail call void @cgroup_rstat_updated(ptr noundef %13, i32 noundef %17) #23
  %18 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %cpu.i, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %19
  %20 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %21, ptrtoint (ptr @stats_updates to i32)
  %22 = inttoptr i32 %add.i to ptr
  %23 = tail call i32 @llvm.abs.i32(i32 %val, i1 false) #23
  %24 = ptrtoint ptr %22 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %22, align 4
  %add10.i = add i32 %25, %23
  store i32 %add10.i, ptr %22, align 4
  %cmp13.i = icmp ugt i32 %add10.i, 32
  br i1 %cmp13.i, label %if.then.i, label %return

if.then.i:                                        ; preds = %if.end
  %div39.i = lshr i32 %add10.i, 5
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef nonnull @stats_flush_threshold, i32 noundef 4) #23
  tail call void @llvm.prefetch.p0(ptr nonnull @stats_flush_threshold, i32 1, i32 3, i32 1) #23
  %26 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr nonnull elementtype(i32) @stats_flush_threshold, ptr nonnull @stats_flush_threshold, i32 %div39.i, ptr nonnull elementtype(i32) @stats_flush_threshold) #23, !srcloc !468
  %27 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load i32, ptr %cpu.i, align 4
  %arrayidx29.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %28
  %29 = ptrtoint ptr %arrayidx29.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %arrayidx29.i, align 4
  %add30.i = add i32 %30, ptrtoint (ptr @stats_updates to i32)
  %31 = inttoptr i32 %add30.i to ptr
  %32 = ptrtoint ptr %31 to i32
  call void @__asan_store4_noabort(i32 %32)
  store i32 0, ptr %31, align 4
  br label %return

return:                                           ; preds = %if.then.i, %if.end, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @__mod_memcg_lruvec_state(ptr nocapture noundef readonly %lruvec, i32 noundef %idx, i32 noundef %val) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %memcg1 = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %lruvec, i32 0, i32 9
  %0 = ptrtoint ptr %memcg1 to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %memcg1, align 4
  %vmstats_percpu = getelementptr inbounds %struct.mem_cgroup, ptr %1, i32 0, i32 39
  %2 = ptrtoint ptr %vmstats_percpu to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %vmstats_percpu, align 8
  %arrayidx = getelementptr [44 x i32], ptr %3, i32 0, i32 %idx
  %4 = ptrtoint ptr %arrayidx to i32
  %5 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i = and i32 %5, -16384
  %6 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %6, i32 0, i32 3
  %7 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %cpu, align 4
  %arrayidx10 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %8
  %9 = ptrtoint ptr %arrayidx10 to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %arrayidx10, align 4
  %add = add i32 %10, %4
  %11 = inttoptr i32 %add to ptr
  %12 = ptrtoint ptr %11 to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %11, align 4
  %add11 = add i32 %13, %val
  store i32 %add11, ptr %11, align 4
  %lruvec_stats_percpu = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %lruvec, i32 0, i32 1
  %14 = ptrtoint ptr %lruvec_stats_percpu to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %lruvec_stats_percpu, align 4
  %arrayidx29 = getelementptr [40 x i32], ptr %15, i32 0, i32 %idx
  %16 = ptrtoint ptr %arrayidx29 to i32
  %17 = load i32, ptr %cpu, align 4
  %arrayidx33 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %17
  %18 = ptrtoint ptr %arrayidx33 to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %arrayidx33, align 4
  %add34 = add i32 %19, %16
  %20 = inttoptr i32 %add34 to ptr
  %21 = ptrtoint ptr %20 to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load i32, ptr %20, align 4
  %add35 = add i32 %22, %val
  store i32 %add35, ptr %20, align 4
  %23 = ptrtoint ptr %1 to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %1, align 128
  %25 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i = and i32 %25, -16384
  %26 = inttoptr i32 %and.i.i to ptr
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %26, i32 0, i32 3
  %27 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load i32, ptr %cpu.i, align 4
  tail call void @cgroup_rstat_updated(ptr noundef %24, i32 noundef %28) #23
  %29 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %cpu.i, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %30
  %31 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %32, ptrtoint (ptr @stats_updates to i32)
  %33 = inttoptr i32 %add.i to ptr
  %34 = tail call i32 @llvm.abs.i32(i32 %val, i1 false) #23
  %35 = ptrtoint ptr %33 to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %33, align 4
  %add10.i = add i32 %36, %34
  store i32 %add10.i, ptr %33, align 4
  %cmp13.i = icmp ugt i32 %add10.i, 32
  br i1 %cmp13.i, label %if.then.i, label %memcg_rstat_updated.exit

if.then.i:                                        ; preds = %entry
  %div39.i = lshr i32 %add10.i, 5
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef nonnull @stats_flush_threshold, i32 noundef 4) #23
  tail call void @llvm.prefetch.p0(ptr nonnull @stats_flush_threshold, i32 1, i32 3, i32 1) #23
  %37 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr nonnull elementtype(i32) @stats_flush_threshold, ptr nonnull @stats_flush_threshold, i32 %div39.i, ptr nonnull elementtype(i32) @stats_flush_threshold) #23, !srcloc !468
  %38 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load i32, ptr %cpu.i, align 4
  %arrayidx29.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %39
  %40 = ptrtoint ptr %arrayidx29.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %arrayidx29.i, align 4
  %add30.i = add i32 %41, ptrtoint (ptr @stats_updates to i32)
  %42 = inttoptr i32 %add30.i to ptr
  %43 = ptrtoint ptr %42 to i32
  call void @__asan_store4_noabort(i32 %43)
  store i32 0, ptr %42, align 4
  br label %memcg_rstat_updated.exit

memcg_rstat_updated.exit:                         ; preds = %if.then.i, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @__mod_lruvec_state(ptr nocapture noundef readonly %lruvec, i32 noundef %idx, i32 noundef %val) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %pgdat.i = getelementptr inbounds %struct.lruvec, ptr %lruvec, i32 0, i32 7
  %0 = ptrtoint ptr %pgdat.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %pgdat.i, align 4
  tail call void @__mod_node_page_state(ptr noundef %1, i32 noundef %idx, i32 noundef %val) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@__mod_lruvec_state, %if.end)) #23
          to label %if.then [label %if.end], !srcloc !461

if.then:                                          ; preds = %entry
  tail call void @__mod_memcg_lruvec_state(ptr noundef %lruvec, i32 noundef %idx, i32 noundef %val)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @__mod_node_page_state(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @__mod_lruvec_page_state(ptr noundef %page, i32 noundef %idx, i32 noundef %val) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = getelementptr inbounds %struct.page, ptr %page, i32 0, i32 1
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %0, align 4
  %and.i = and i32 %2, 1
  %tobool.not.i12 = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i12, label %if.end.i, label %if.then.i13, !prof !460

if.then.i13:                                      ; preds = %entry
  %sub.i = add i32 %2, -1
  br label %_compound_head.exit

if.end.i:                                         ; preds = %entry
  %3 = ptrtoint ptr %page to i32
  br label %_compound_head.exit

_compound_head.exit:                              ; preds = %if.end.i, %if.then.i13
  %retval.0.i = phi i32 [ %sub.i, %if.then.i13 ], [ %3, %if.end.i ]
  %4 = inttoptr i32 %retval.0.i to ptr
  %5 = ptrtoint ptr %page to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %page, align 4
  %cmp.i.not.i.i = icmp eq i32 %6, -1
  br i1 %cmp.i.not.i.i, label %if.then.i.i, label %page_pgdat.exit, !prof !466

if.then.i.i:                                      ; preds = %_compound_head.exit
  tail call void @dump_page(ptr noundef %page, ptr noundef nonnull @.str.170) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/mm.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1368, 0\0A.popsection", ""() #23, !srcloc !469
  unreachable

page_pgdat.exit:                                  ; preds = %_compound_head.exit
  %7 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %7, -16384
  %8 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %8, i32 0, i32 1
  %9 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %10, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %page_pgdat.exit
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %page_pgdat.exit
  %11 = getelementptr inbounds %struct.page, ptr %4, i32 0, i32 1
  %12 = ptrtoint ptr %11 to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load volatile i32, ptr %11, align 4
  %and.i.i = and i32 %13, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %page_memcg.exit, label %if.then.i.i14, !prof !460

if.then.i.i14:                                    ; preds = %rcu_read_lock.exit
  %sub.i.i = add i32 %13, -1
  %.pre = inttoptr i32 %sub.i.i to ptr
  br label %page_memcg.exit

page_memcg.exit:                                  ; preds = %if.then.i.i14, %rcu_read_lock.exit
  %.pre-phi = phi ptr [ %4, %rcu_read_lock.exit ], [ %.pre, %if.then.i.i14 ]
  %call1.i15 = tail call fastcc ptr @folio_memcg(ptr noundef %.pre-phi) #23
  %tobool.not = icmp eq ptr %call1.i15, null
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %page_memcg.exit
  %call.i16 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i16, label %rcu_read_unlock.exit, label %land.lhs.true.i19

land.lhs.true.i19:                                ; preds = %if.then
  %call1.i17 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i18 = icmp eq i32 %call1.i17, 0
  br i1 %tobool.not.i18, label %rcu_read_unlock.exit, label %land.lhs.true2.i21

land.lhs.true2.i21:                               ; preds = %land.lhs.true.i19
  %.b4.i20 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i20, label %rcu_read_unlock.exit, label %if.then.i22

if.then.i22:                                      ; preds = %land.lhs.true2.i21
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i22, %land.lhs.true2.i21, %land.lhs.true.i19, %if.then
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %14 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i23 = and i32 %14, -16384
  %15 = inttoptr i32 %and.i.i.i.i.i23 to ptr
  %preempt_count.i.i.i.i24 = getelementptr inbounds %struct.thread_info, ptr %15, i32 0, i32 1
  %16 = ptrtoint ptr %preempt_count.i.i.i.i24 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load volatile i32, ptr %preempt_count.i.i.i.i24, align 4
  %sub.i.i.i = add i32 %17, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i24, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  tail call void @__mod_node_page_state(ptr noundef nonnull @contig_page_data, i32 noundef %idx, i32 noundef %val) #23
  br label %cleanup

if.end:                                           ; preds = %page_memcg.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@__mod_lruvec_page_state, %out.i)) #23
          to label %if.end2.i [label %out.i], !srcloc !461

if.end2.i:                                        ; preds = %if.end
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 8) to i32))
  %18 = load i32, ptr getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 8), align 64
  %arrayidx.i = getelementptr %struct.mem_cgroup, ptr %call1.i15, i32 0, i32 45, i32 %18
  %19 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %arrayidx.i, align 4
  br label %out.i

out.i:                                            ; preds = %if.end2.i, %if.end
  %lruvec.0.i = phi ptr [ %20, %if.end2.i ], [ getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 26), %if.end ]
  %pgdat4.i = getelementptr inbounds %struct.lruvec, ptr %lruvec.0.i, i32 0, i32 7
  %21 = ptrtoint ptr %pgdat4.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %pgdat4.i, align 4
  %cmp.not.i = icmp eq ptr %22, @contig_page_data
  br i1 %cmp.not.i, label %mem_cgroup_lruvec.exit, label %if.then7.i, !prof !460

if.then7.i:                                       ; preds = %out.i
  %23 = ptrtoint ptr %pgdat4.i to i32
  call void @__asan_store4_noabort(i32 %23)
  store ptr @contig_page_data, ptr %pgdat4.i, align 4
  br label %mem_cgroup_lruvec.exit

mem_cgroup_lruvec.exit:                           ; preds = %if.then7.i, %out.i
  %24 = ptrtoint ptr %pgdat4.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %pgdat4.i, align 4
  tail call void @__mod_node_page_state(ptr noundef %25, i32 noundef %idx, i32 noundef %val) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@__mod_lruvec_page_state, %__mod_lruvec_state.exit)) #23
          to label %if.then.i28 [label %__mod_lruvec_state.exit], !srcloc !461

if.then.i28:                                      ; preds = %mem_cgroup_lruvec.exit
  tail call void @__mod_memcg_lruvec_state(ptr noundef %lruvec.0.i, i32 noundef %idx, i32 noundef %val) #23
  br label %__mod_lruvec_state.exit

__mod_lruvec_state.exit:                          ; preds = %if.then.i28, %mem_cgroup_lruvec.exit
  %call.i30 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i30, label %rcu_read_unlock.exit40, label %land.lhs.true.i33

land.lhs.true.i33:                                ; preds = %__mod_lruvec_state.exit
  %call1.i31 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i32 = icmp eq i32 %call1.i31, 0
  br i1 %tobool.not.i32, label %rcu_read_unlock.exit40, label %land.lhs.true2.i35

land.lhs.true2.i35:                               ; preds = %land.lhs.true.i33
  %.b4.i34 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i34, label %rcu_read_unlock.exit40, label %if.then.i36

if.then.i36:                                      ; preds = %land.lhs.true2.i35
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit40

rcu_read_unlock.exit40:                           ; preds = %if.then.i36, %land.lhs.true2.i35, %land.lhs.true.i33, %__mod_lruvec_state.exit
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %26 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i37 = and i32 %26, -16384
  %27 = inttoptr i32 %and.i.i.i.i.i37 to ptr
  %preempt_count.i.i.i.i38 = getelementptr inbounds %struct.thread_info, ptr %27, i32 0, i32 1
  %28 = ptrtoint ptr %preempt_count.i.i.i.i38 to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %preempt_count.i.i.i.i38, align 4
  %sub.i.i.i39 = add i32 %29, -1
  store volatile i32 %sub.i.i.i39, ptr %preempt_count.i.i.i.i38, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  br label %cleanup

cleanup:                                          ; preds = %rcu_read_unlock.exit40, %rcu_read_unlock.exit
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @__mod_lruvec_kmem_state(ptr noundef %p, i32 noundef %idx, i32 noundef %val) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @mem_map to i32))
  %0 = load ptr, ptr @mem_map, align 4
  %1 = ptrtoint ptr %p to i32
  %sub = add i32 %1, 1073741824
  %shr = lshr i32 %sub, 12
  %add.ptr = getelementptr %struct.page, ptr %0, i32 %shr
  %2 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %add.ptr, align 4
  %cmp.i.not.i.i = icmp eq i32 %3, -1
  br i1 %cmp.i.not.i.i, label %if.then.i.i, label %page_pgdat.exit, !prof !466

if.then.i.i:                                      ; preds = %entry
  tail call void @dump_page(ptr noundef %add.ptr, ptr noundef nonnull @.str.170) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/mm.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1368, 0\0A.popsection", ""() #23, !srcloc !469
  unreachable

page_pgdat.exit:                                  ; preds = %entry
  %4 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %4, -16384
  %5 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %5, i32 0, i32 1
  %6 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %7, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %page_pgdat.exit
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %page_pgdat.exit
  %call2 = tail call ptr @mem_cgroup_from_obj(ptr noundef %p)
  %tobool.not = icmp eq ptr %call2, null
  br i1 %tobool.not, label %if.then, label %if.else

if.then:                                          ; preds = %rcu_read_lock.exit
  tail call void @__mod_node_page_state(ptr noundef nonnull @contig_page_data, i32 noundef %idx, i32 noundef %val) #23
  br label %if.end

if.else:                                          ; preds = %rcu_read_lock.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@__mod_lruvec_kmem_state, %out.i)) #23
          to label %if.end2.i [label %out.i], !srcloc !461

if.end2.i:                                        ; preds = %if.else
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 8) to i32))
  %8 = load i32, ptr getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 8), align 64
  %arrayidx.i = getelementptr %struct.mem_cgroup, ptr %call2, i32 0, i32 45, i32 %8
  %9 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %arrayidx.i, align 4
  br label %out.i

out.i:                                            ; preds = %if.end2.i, %if.else
  %lruvec.0.i = phi ptr [ %10, %if.end2.i ], [ getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 26), %if.else ]
  %pgdat4.i = getelementptr inbounds %struct.lruvec, ptr %lruvec.0.i, i32 0, i32 7
  %11 = ptrtoint ptr %pgdat4.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %pgdat4.i, align 4
  %cmp.not.i = icmp eq ptr %12, @contig_page_data
  br i1 %cmp.not.i, label %mem_cgroup_lruvec.exit, label %if.then7.i, !prof !460

if.then7.i:                                       ; preds = %out.i
  %13 = ptrtoint ptr %pgdat4.i to i32
  call void @__asan_store4_noabort(i32 %13)
  store ptr @contig_page_data, ptr %pgdat4.i, align 4
  br label %mem_cgroup_lruvec.exit

mem_cgroup_lruvec.exit:                           ; preds = %if.then7.i, %out.i
  %14 = ptrtoint ptr %pgdat4.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %pgdat4.i, align 4
  tail call void @__mod_node_page_state(ptr noundef %15, i32 noundef %idx, i32 noundef %val) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@__mod_lruvec_kmem_state, %if.end)) #23
          to label %if.then.i11 [label %if.end], !srcloc !461

if.then.i11:                                      ; preds = %mem_cgroup_lruvec.exit
  tail call void @__mod_memcg_lruvec_state(ptr noundef %lruvec.0.i, i32 noundef %idx, i32 noundef %val) #23
  br label %if.end

if.end:                                           ; preds = %if.then.i11, %mem_cgroup_lruvec.exit, %if.then
  %call.i13 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i13, label %rcu_read_unlock.exit, label %land.lhs.true.i16

land.lhs.true.i16:                                ; preds = %if.end
  %call1.i14 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i15 = icmp eq i32 %call1.i14, 0
  br i1 %tobool.not.i15, label %rcu_read_unlock.exit, label %land.lhs.true2.i18

land.lhs.true2.i18:                               ; preds = %land.lhs.true.i16
  %.b4.i17 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i17, label %rcu_read_unlock.exit, label %if.then.i19

if.then.i19:                                      ; preds = %land.lhs.true2.i18
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i19, %land.lhs.true2.i18, %land.lhs.true.i16, %if.end
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %16 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i20 = and i32 %16, -16384
  %17 = inttoptr i32 %and.i.i.i.i.i20 to ptr
  %preempt_count.i.i.i.i21 = getelementptr inbounds %struct.thread_info, ptr %17, i32 0, i32 1
  %18 = ptrtoint ptr %preempt_count.i.i.i.i21 to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load volatile i32, ptr %preempt_count.i.i.i.i21, align 4
  %sub.i.i.i = add i32 %19, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i21, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @mem_cgroup_from_obj(ptr noundef %p) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_from_obj, %cleanup17)) #23
          to label %if.end [label %cleanup17], !srcloc !461

if.end:                                           ; preds = %entry
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @mem_map to i32))
  %0 = load ptr, ptr @mem_map, align 4
  %1 = ptrtoint ptr %p to i32
  %sub.i = add i32 %1, 1073741824
  %shr.i = lshr i32 %sub.i, 12
  %2 = getelementptr %struct.page, ptr %0, i32 %shr.i, i32 1
  %3 = ptrtoint ptr %2 to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load volatile i32, ptr %2, align 4
  %and.i.i = and i32 %4, 1
  %tobool.not.i.i26 = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i26, label %if.end.i.i, label %if.then.i.i27, !prof !460

if.then.i.i27:                                    ; preds = %if.end
  %sub.i.i = add i32 %4, -1
  br label %virt_to_folio.exit

if.end.i.i:                                       ; preds = %if.end
  %add.ptr.i = getelementptr %struct.page, ptr %0, i32 %shr.i
  %5 = ptrtoint ptr %add.ptr.i to i32
  br label %virt_to_folio.exit

virt_to_folio.exit:                               ; preds = %if.end.i.i, %if.then.i.i27
  %retval.0.i.i28 = phi i32 [ %sub.i.i, %if.then.i.i27 ], [ %5, %if.end.i.i ]
  %6 = inttoptr i32 %retval.0.i.i28 to ptr
  %7 = getelementptr inbounds %struct.page, ptr %6, i32 0, i32 1
  %8 = ptrtoint ptr %7 to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load volatile i32, ptr %7, align 4
  %and.i.i.i = and i32 %9, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i.i, label %folio_test_slab.exit, label %if.then.i.i, !prof !460

if.then.i.i:                                      ; preds = %virt_to_folio.exit
  tail call void @dump_page(ptr noundef %6, ptr noundef nonnull @.str.96) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #23, !srcloc !470
  unreachable

folio_test_slab.exit:                             ; preds = %virt_to_folio.exit
  %10 = ptrtoint ptr %6 to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %6, align 4
  %12 = and i32 %11, 512
  %tobool.i.not = icmp eq i32 %12, 0
  br i1 %tobool.i.not, label %if.end15, label %if.then3

if.then3:                                         ; preds = %folio_test_slab.exit
  %memcg_data1.i = getelementptr inbounds %struct.slab, ptr %6, i32 0, i32 7
  %13 = ptrtoint ptr %memcg_data1.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %memcg_data1.i, align 4
  %tobool.not.i = icmp ne i32 %14, 0
  %and.i = and i32 %14, 1
  %tobool3.not.i = icmp eq i32 %and.i, 0
  %15 = and i1 %tobool.not.i, %tobool3.not.i
  br i1 %15, label %if.then.i, label %do.body15.i, !prof !466

if.then.i:                                        ; preds = %if.then3
  tail call void @dump_page(ptr noundef %6, ptr noundef nonnull @.str.98) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/slab.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 445, 0\0A.popsection", ""() #23, !srcloc !471
  unreachable

do.body15.i:                                      ; preds = %if.then3
  %and16.i = and i32 %14, 2
  %tobool17.not.i = icmp eq i32 %and16.i, 0
  br i1 %tobool17.not.i, label %slab_objcgs.exit, label %if.then24.i, !prof !460

if.then24.i:                                      ; preds = %do.body15.i
  tail call void @dump_page(ptr noundef %6, ptr noundef nonnull @.str.99) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/slab.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 446, 0\0A.popsection", ""() #23, !srcloc !472
  unreachable

slab_objcgs.exit:                                 ; preds = %do.body15.i
  %and35.i = and i32 %14, -4
  %16 = inttoptr i32 %and35.i to ptr
  %tobool.not = icmp eq i32 %and35.i, 0
  br i1 %tobool.not, label %cleanup17, label %if.end6

if.end6:                                          ; preds = %slab_objcgs.exit
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__kfence_pool to i32))
  %17 = load ptr, ptr @__kfence_pool, align 4
  %sub.ptr.rhs.cast.i.i = ptrtoint ptr %17 to i32
  %sub.ptr.sub.i.i = sub i32 %1, %sub.ptr.rhs.cast.i.i
  %cmp.i.i = icmp ult i32 %sub.ptr.sub.i.i, 2097152
  %tobool.i.i = icmp ne ptr %17, null
  %spec.select.i.i = select i1 %cmp.i.i, i1 %tobool.i.i, i1 false
  br i1 %spec.select.i.i, label %obj_to_index.exit, label %if.end.i

if.end.i:                                         ; preds = %if.end6
  %slab_cache = getelementptr inbounds %struct.slab, ptr %6, i32 0, i32 2
  %18 = ptrtoint ptr %slab_cache to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load ptr, ptr %slab_cache, align 4
  %call.i.i.i = tail call ptr @page_address(ptr noundef %6) #23
  %sub.ptr.rhs.cast.i5.i = ptrtoint ptr %call.i.i.i to i32
  %sub.ptr.sub.i6.i = sub i32 %1, %sub.ptr.rhs.cast.i5.i
  %reciprocal_size.i.i = getelementptr inbounds %struct.kmem_cache, ptr %19, i32 0, i32 5
  %20 = ptrtoint ptr %reciprocal_size.i.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %.unpack.i.i = load i32, ptr %reciprocal_size.i.i, align 4
  %.elt2.i.i = getelementptr inbounds %struct.kmem_cache, ptr %19, i32 0, i32 5, i32 1
  %21 = ptrtoint ptr %.elt2.i.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %.unpack3.i.i = load i32, ptr %.elt2.i.i, align 4
  %R.sroa.2.4.extract.shift.i.i.i = lshr i32 %.unpack3.i.i, 24
  %R.sroa.4.4.extract.shift.i.i.i = lshr i32 %.unpack3.i.i, 16
  %conv.i.i.i = zext i32 %sub.ptr.sub.i6.i to i64
  %conv1.i.i.i = zext i32 %.unpack.i.i to i64
  %mul.i.i.i = mul nuw i64 %conv.i.i.i, %conv1.i.i.i
  %shr.i.i.i = lshr i64 %mul.i.i.i, 32
  %conv2.i.i.i = trunc i64 %shr.i.i.i to i32
  %sub.i.i.i = sub i32 %sub.ptr.sub.i6.i, %conv2.i.i.i
  %shr4.i.i.i = lshr i32 %sub.i.i.i, %R.sroa.2.4.extract.shift.i.i.i
  %add.i.i.i = add i32 %shr4.i.i.i, %conv2.i.i.i
  %conv5.i.i.i = and i32 %R.sroa.4.4.extract.shift.i.i.i, 255
  %shr6.i.i.i = lshr i32 %add.i.i.i, %conv5.i.i.i
  br label %obj_to_index.exit

obj_to_index.exit:                                ; preds = %if.end.i, %if.end6
  %retval.0.i = phi i32 [ %shr6.i.i.i, %if.end.i ], [ 0, %if.end6 ]
  %arrayidx = getelementptr ptr, ptr %16, i32 %retval.0.i
  %22 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %arrayidx, align 4
  %tobool8.not = icmp eq ptr %23, null
  br i1 %tobool8.not, label %cleanup17, label %cleanup17.sink.split

if.end15:                                         ; preds = %folio_test_slab.exit
  %memcg_data1.i29 = getelementptr inbounds %struct.page, ptr %6, i32 0, i32 4
  %24 = ptrtoint ptr %memcg_data1.i29 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load volatile i32, ptr %memcg_data1.i29, align 4
  %and.i30 = and i32 %25, 1
  %tobool.not.i31 = icmp eq i32 %and.i30, 0
  br i1 %tobool.not.i31, label %if.end.i33, label %cleanup17

if.end.i33:                                       ; preds = %if.end15
  %and2.i = and i32 %25, 2
  %tobool3.not.i32 = icmp eq i32 %and2.i, 0
  %and7.i = and i32 %25, -4
  %26 = inttoptr i32 %and7.i to ptr
  br i1 %tobool3.not.i32, label %cleanup17, label %cleanup17.sink.split

cleanup17.sink.split:                             ; preds = %if.end.i33, %obj_to_index.exit
  %.sink = phi ptr [ %23, %obj_to_index.exit ], [ %26, %if.end.i33 ]
  %memcg.i.i = getelementptr inbounds %struct.obj_cgroup, ptr %.sink, i32 0, i32 1
  %27 = ptrtoint ptr %memcg.i.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load volatile ptr, ptr %memcg.i.i, align 4
  br label %cleanup17

cleanup17:                                        ; preds = %cleanup17.sink.split, %if.end.i33, %if.end15, %obj_to_index.exit, %slab_objcgs.exit, %entry
  %retval.1 = phi ptr [ null, %slab_objcgs.exit ], [ null, %obj_to_index.exit ], [ null, %if.end15 ], [ %26, %if.end.i33 ], [ null, %entry ], [ %28, %cleanup17.sink.split ]
  ret ptr %retval.1
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @__count_memcg_events(ptr nocapture noundef readonly %memcg, i32 noundef %idx, i32 noundef %count) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@__count_memcg_events, %return)) #23
          to label %if.end [label %return], !srcloc !461

if.end:                                           ; preds = %entry
  %vmstats_percpu = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 39
  %0 = ptrtoint ptr %vmstats_percpu to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %vmstats_percpu, align 8
  %arrayidx = getelementptr %struct.memcg_vmstats_percpu, ptr %1, i32 0, i32 1, i32 %idx
  %2 = ptrtoint ptr %arrayidx to i32
  %3 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i = and i32 %3, -16384
  %4 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %4, i32 0, i32 3
  %5 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %cpu, align 4
  %arrayidx8 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %6
  %7 = ptrtoint ptr %arrayidx8 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %arrayidx8, align 4
  %add = add i32 %8, %2
  %9 = inttoptr i32 %add to ptr
  %10 = ptrtoint ptr %9 to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %9, align 4
  %add9 = add i32 %11, %count
  store i32 %add9, ptr %9, align 4
  %12 = ptrtoint ptr %memcg to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %memcg, align 128
  %14 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i = and i32 %14, -16384
  %15 = inttoptr i32 %and.i.i to ptr
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %15, i32 0, i32 3
  %16 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %cpu.i, align 4
  tail call void @cgroup_rstat_updated(ptr noundef %13, i32 noundef %17) #23
  %18 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %cpu.i, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %19
  %20 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %21, ptrtoint (ptr @stats_updates to i32)
  %22 = inttoptr i32 %add.i to ptr
  %23 = tail call i32 @llvm.abs.i32(i32 %count, i1 false) #23
  %24 = ptrtoint ptr %22 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %22, align 4
  %add10.i = add i32 %25, %23
  store i32 %add10.i, ptr %22, align 4
  %cmp13.i = icmp ugt i32 %add10.i, 32
  br i1 %cmp13.i, label %if.then.i, label %return

if.then.i:                                        ; preds = %if.end
  %div39.i = lshr i32 %add10.i, 5
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef nonnull @stats_flush_threshold, i32 noundef 4) #23
  tail call void @llvm.prefetch.p0(ptr nonnull @stats_flush_threshold, i32 1, i32 3, i32 1) #23
  %26 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr nonnull elementtype(i32) @stats_flush_threshold, ptr nonnull @stats_flush_threshold, i32 %div39.i, ptr nonnull elementtype(i32) @stats_flush_threshold) #23, !srcloc !468
  %27 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load i32, ptr %cpu.i, align 4
  %arrayidx29.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %28
  %29 = ptrtoint ptr %arrayidx29.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %arrayidx29.i, align 4
  %add30.i = add i32 %30, ptrtoint (ptr @stats_updates to i32)
  %31 = inttoptr i32 %add30.i to ptr
  %32 = ptrtoint ptr %31 to i32
  call void @__asan_store4_noabort(i32 %32)
  store i32 0, ptr %31, align 4
  br label %return

return:                                           ; preds = %if.then.i, %if.end, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @mem_cgroup_from_task(ptr noundef %p) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tobool.not = icmp eq ptr %p, null
  br i1 %tobool.not, label %return, label %if.end, !prof !466

if.end:                                           ; preds = %entry
  %cgroups.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 164
  %0 = ptrtoint ptr %cgroups.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile ptr, ptr %cgroups.i, align 16
  %call.i.i = tail call i32 @lock_is_held_type(ptr noundef getelementptr inbounds (%struct.mutex, ptr @cgroup_mutex, i32 0, i32 5), i32 noundef -1) #23
  %tobool.not.i = icmp eq i32 %call.i.i, 0
  br i1 %tobool.not.i, label %lor.lhs.false.i, label %task_css.exit

lor.lhs.false.i:                                  ; preds = %if.end
  %call.i2.i = tail call i32 @lock_is_held_type(ptr noundef getelementptr inbounds (%struct.spinlock, ptr @css_set_lock, i32 0, i32 0, i32 0, i32 4), i32 noundef -1) #23
  %tobool3.not.i = icmp eq i32 %call.i2.i, 0
  br i1 %tobool3.not.i, label %lor.lhs.false4.i, label %task_css.exit

lor.lhs.false4.i:                                 ; preds = %lor.lhs.false.i
  %flags.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 3
  %2 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %flags.i, align 4
  %and.i = and i32 %3, 4
  %tobool5.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool5.not.i, label %lor.lhs.false6.i, label %task_css.exit

lor.lhs.false6.i:                                 ; preds = %lor.lhs.false4.i
  %call7.i = tail call i32 @rcu_read_lock_held() #23
  %tobool8.not.i = icmp eq i32 %call7.i, 0
  br i1 %tobool8.not.i, label %land.lhs.true.i, label %task_css.exit

land.lhs.true.i:                                  ; preds = %lor.lhs.false6.i
  %call9.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool10.not.i = icmp eq i32 %call9.i, 0
  br i1 %tobool10.not.i, label %task_css.exit, label %land.lhs.true11.i

land.lhs.true11.i:                                ; preds = %land.lhs.true.i
  %.b1.i = load i1, ptr @task_css.__warned, align 1
  br i1 %.b1.i, label %task_css.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true11.i
  store i1 true, ptr @task_css.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.57, i32 noundef 494, ptr noundef nonnull @.str.2) #23
  br label %task_css.exit

task_css.exit:                                    ; preds = %if.then.i, %land.lhs.true11.i, %land.lhs.true.i, %lor.lhs.false6.i, %lor.lhs.false4.i, %lor.lhs.false.i, %if.end
  %arrayidx.i = getelementptr [14 x ptr], ptr %1, i32 0, i32 4
  %4 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %arrayidx.i, align 4
  br label %return

return:                                           ; preds = %task_css.exit, %entry
  %retval.0 = phi ptr [ %5, %task_css.exit ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @get_mem_cgroup_from_mm(ptr noundef %mm) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@get_mem_cgroup_from_mm, %cleanup)) #23
          to label %if.end [label %cleanup], !srcloc !461

if.end:                                           ; preds = %entry
  %tobool.not = icmp eq ptr %mm, null
  br i1 %tobool.not, label %if.then4, label %if.end28, !prof !466

if.then4:                                         ; preds = %if.end
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i, align 4
  %and.i = and i32 %3, 15728640
  %4 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i27.i = and i32 %4, -16384
  %5 = inttoptr i32 %and.i.i27.i to ptr
  %preempt_count.i28.i = getelementptr inbounds %struct.thread_info, ptr %5, i32 0, i32 1
  %6 = ptrtoint ptr %preempt_count.i28.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %preempt_count.i28.i, align 4
  %and2.i = and i32 %7, 983040
  %or.i = or i32 %and2.i, %and.i
  %8 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i29.i = and i32 %8, -16384
  %9 = inttoptr i32 %and.i.i29.i to ptr
  %preempt_count.i30.i = getelementptr inbounds %struct.thread_info, ptr %9, i32 0, i32 1
  %10 = ptrtoint ptr %preempt_count.i30.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %preempt_count.i30.i, align 4
  %and5.i = and i32 %11, 256
  %or6.i = or i32 %or.i, %and5.i
  %tobool.not.i = icmp eq i32 %or6.i, 0
  %12 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i33.i = and i32 %12, -16384
  %13 = inttoptr i32 %and.i33.i to ptr
  br i1 %tobool.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %if.then4
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 1
  %14 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %add.i.i = add i32 %15, 1
  store volatile i32 %add.i.i, ptr %preempt_count.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !473
  %16 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i = and i32 %16, -16384
  %17 = inttoptr i32 %and.i.i to ptr
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %17, i32 0, i32 3
  %18 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %cpu.i, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %19
  %20 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %21, ptrtoint (ptr @int_active_memcg to i32)
  %22 = inttoptr i32 %add.i to ptr
  %23 = ptrtoint ptr %22 to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load volatile ptr, ptr %22, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !474
  %25 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i31.i = and i32 %25, -16384
  %26 = inttoptr i32 %and.i.i.i31.i to ptr
  %preempt_count.i.i32.i = getelementptr inbounds %struct.thread_info, ptr %26, i32 0, i32 1
  %27 = ptrtoint ptr %preempt_count.i.i32.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load volatile i32, ptr %preempt_count.i.i32.i, align 4
  %sub.i.i = add i32 %28, -1
  store volatile i32 %sub.i.i, ptr %preempt_count.i.i32.i, align 4
  br label %active_memcg.exit

if.else.i:                                        ; preds = %if.then4
  %task.i = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 2
  %29 = ptrtoint ptr %task.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %task.i, align 8
  %active_memcg.i = getelementptr inbounds %struct.task_struct, ptr %30, i32 0, i32 206
  %31 = ptrtoint ptr %active_memcg.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %active_memcg.i, align 8
  br label %active_memcg.exit

active_memcg.exit:                                ; preds = %if.else.i, %if.then.i
  %retval.0.i = phi ptr [ %24, %if.then.i ], [ %32, %if.else.i ]
  %tobool6.not = icmp eq ptr %retval.0.i, null
  br i1 %tobool6.not, label %if.end14, label %if.then13, !prof !460

if.then13:                                        ; preds = %active_memcg.exit
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %retval.0.i, i32 0, i32 7
  %33 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %flags.i, align 4
  %and.i70 = and i32 %34, 1
  %tobool.not.i71 = icmp eq i32 %and.i70, 0
  br i1 %tobool.not.i71, label %if.then.i72, label %cleanup

if.then.i72:                                      ; preds = %if.then13
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %retval.0.i, i32 0, i32 2
  tail call fastcc void @percpu_ref_get_many(ptr noundef %refcnt.i, i32 noundef 1) #23
  br label %cleanup

if.end14:                                         ; preds = %active_memcg.exit
  %35 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i73 = and i32 %35, -16384
  %36 = inttoptr i32 %and.i73 to ptr
  %task = getelementptr inbounds %struct.thread_info, ptr %36, i32 0, i32 2
  %37 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load ptr, ptr %task, align 8
  %mm16 = getelementptr inbounds %struct.task_struct, ptr %38, i32 0, i32 53
  %39 = ptrtoint ptr %mm16 to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load ptr, ptr %mm16, align 8
  %tobool17.not = icmp eq ptr %40, null
  br i1 %tobool17.not, label %if.then26, label %if.end28, !prof !466

if.then26:                                        ; preds = %if.end14
  %41 = load ptr, ptr @root_mem_cgroup, align 4
  br label %cleanup

if.end28:                                         ; preds = %if.end14, %if.end
  %mm.addr.0 = phi ptr [ %40, %if.end14 ], [ %mm, %if.end ]
  %42 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %42, -16384
  %43 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %43, i32 0, i32 1
  %44 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %45, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end28
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i68 = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i68, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i69

if.then.i69:                                      ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i69, %land.lhs.true2.i, %land.lhs.true.i, %if.end28
  %owner = getelementptr inbounds %struct.anon.28, ptr %mm.addr.0, i32 0, i32 46
  br label %do.body

do.body:                                          ; preds = %css_tryget.exit, %rcu_read_lock.exit
  %46 = ptrtoint ptr %owner to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load volatile ptr, ptr %owner, align 4
  %call31 = tail call i32 @rcu_read_lock_held() #23
  %tobool32.not = icmp eq i32 %call31, 0
  br i1 %tobool32.not, label %land.lhs.true, label %do.end40

land.lhs.true:                                    ; preds = %do.body
  %call33 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool34.not = icmp eq i32 %call33, 0
  br i1 %tobool34.not, label %do.end40, label %land.lhs.true35

land.lhs.true35:                                  ; preds = %land.lhs.true
  %.b67 = load i1, ptr @get_mem_cgroup_from_mm.__warned, align 1
  br i1 %.b67, label %do.end40, label %if.then37

if.then37:                                        ; preds = %land.lhs.true35
  store i1 true, ptr @get_mem_cgroup_from_mm.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 937, ptr noundef nonnull @.str.2) #23
  br label %do.end40

do.end40:                                         ; preds = %if.then37, %land.lhs.true35, %land.lhs.true, %do.body
  %call42 = tail call ptr @mem_cgroup_from_task(ptr noundef %47)
  %tobool43.not = icmp eq ptr %call42, null
  br i1 %tobool43.not, label %if.then52, label %do.cond54, !prof !466

if.then52:                                        ; preds = %do.end40
  %48 = load ptr, ptr @root_mem_cgroup, align 4
  br label %do.cond54

do.cond54:                                        ; preds = %if.then52, %do.end40
  %memcg.0 = phi ptr [ %48, %if.then52 ], [ %call42, %do.end40 ]
  %flags.i74 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %memcg.0, i32 0, i32 7
  %49 = ptrtoint ptr %flags.i74 to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load i32, ptr %flags.i74, align 4
  %and.i75 = and i32 %50, 1
  %tobool.not.i76 = icmp eq i32 %and.i75, 0
  br i1 %tobool.not.i76, label %css_tryget.exit, label %do.end59

css_tryget.exit:                                  ; preds = %do.cond54
  %refcnt.i77 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %memcg.0, i32 0, i32 2
  %call.i78 = tail call fastcc zeroext i1 @percpu_ref_tryget(ptr noundef %refcnt.i77) #23
  br i1 %call.i78, label %do.end59, label %do.body

do.end59:                                         ; preds = %css_tryget.exit, %do.cond54
  %call.i81 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i81, label %rcu_read_unlock.exit, label %land.lhs.true.i84

land.lhs.true.i84:                                ; preds = %do.end59
  %call1.i82 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i83 = icmp eq i32 %call1.i82, 0
  br i1 %tobool.not.i83, label %rcu_read_unlock.exit, label %land.lhs.true2.i86

land.lhs.true2.i86:                               ; preds = %land.lhs.true.i84
  %.b4.i85 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i85, label %rcu_read_unlock.exit, label %if.then.i87

if.then.i87:                                      ; preds = %land.lhs.true2.i86
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i87, %land.lhs.true2.i86, %land.lhs.true.i84, %do.end59
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %51 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i88 = and i32 %51, -16384
  %52 = inttoptr i32 %and.i.i.i.i.i88 to ptr
  %preempt_count.i.i.i.i89 = getelementptr inbounds %struct.thread_info, ptr %52, i32 0, i32 1
  %53 = ptrtoint ptr %preempt_count.i.i.i.i89 to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load volatile i32, ptr %preempt_count.i.i.i.i89, align 4
  %sub.i.i.i = add i32 %54, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i89, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  br label %cleanup

cleanup:                                          ; preds = %rcu_read_unlock.exit, %if.then26, %if.then.i72, %if.then13, %entry
  %retval.0 = phi ptr [ %41, %if.then26 ], [ %memcg.0, %rcu_read_unlock.exit ], [ %retval.0.i, %if.then13 ], [ %retval.0.i, %if.then.i72 ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @rcu_read_lock_held() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @debug_lockdep_rcu_enabled() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @lockdep_rcu_suspicious(ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @mem_cgroup_iter(ptr noundef %root, ptr noundef %prev, ptr noundef %reclaim) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_iter, %cleanup105)) #23
          to label %if.end [label %cleanup105], !srcloc !461

if.end:                                           ; preds = %entry
  %tobool.not = icmp eq ptr %root, null
  br i1 %tobool.not, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  %0 = load ptr, ptr @root_mem_cgroup, align 4
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %if.end
  %root.addr.0 = phi ptr [ %root, %if.end ], [ %0, %if.then1 ]
  %tobool3.not = icmp eq ptr %prev, null
  %tobool3.not.not = xor i1 %tobool3.not, true
  %tobool4.not = icmp eq ptr %reclaim, null
  %or.cond = and i1 %tobool4.not, %tobool3.not.not
  %pos.0 = select i1 %or.cond, ptr %prev, ptr null
  %1 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %1, -16384
  %2 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %2, i32 0, i32 1
  %3 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %4, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end2
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %if.end2
  br i1 %tobool4.not, label %if.end40, label %if.then8

if.then8:                                         ; preds = %rcu_read_lock.exit
  %5 = ptrtoint ptr %reclaim to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %reclaim, align 4
  %node_id = getelementptr inbounds %struct.pglist_data, ptr %6, i32 0, i32 8
  %7 = ptrtoint ptr %node_id to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %node_id, align 64
  %arrayidx = getelementptr %struct.mem_cgroup, ptr %root.addr.0, i32 0, i32 45, i32 %8
  %9 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %arrayidx, align 4
  %iter9 = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %10, i32 0, i32 4
  br i1 %tobool3.not, label %if.end14, label %land.lhs.true11

land.lhs.true11:                                  ; preds = %if.then8
  %generation = getelementptr inbounds %struct.mem_cgroup_reclaim_cookie, ptr %reclaim, i32 0, i32 1
  %11 = ptrtoint ptr %generation to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %generation, align 4
  %generation12 = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %10, i32 0, i32 4, i32 1
  %13 = ptrtoint ptr %generation12 to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %generation12, align 4
  %cmp.not = icmp eq i32 %12, %14
  br i1 %cmp.not, label %if.end14, label %out_unlock

if.end14:                                         ; preds = %land.lhs.true11, %if.then8
  %15 = ptrtoint ptr %iter9 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile ptr, ptr %iter9, align 4
  %tobool15.not192 = icmp eq ptr %16, null
  br i1 %tobool15.not192, label %if.end40, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %__cmpxchg.exit, %if.end14
  %17 = phi ptr [ %23, %__cmpxchg.exit ], [ %16, %if.end14 ]
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %17, i32 0, i32 7
  %18 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %flags.i, align 4
  %and.i = and i32 %19, 1
  %tobool.not.i149 = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i149, label %css_tryget.exit, label %if.end40

css_tryget.exit:                                  ; preds = %lor.lhs.false
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %17, i32 0, i32 2
  %call.i150 = tail call fastcc zeroext i1 @percpu_ref_tryget(ptr noundef %refcnt.i) #23
  br i1 %call.i150, label %if.end40, label %if.end19

if.end19:                                         ; preds = %css_tryget.exit
  %call.i147 = tail call zeroext i1 @__kasan_check_write(ptr noundef %iter9, i32 noundef 4) #23
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !475
  %20 = ptrtoint ptr %17 to i32
  tail call void @llvm.prefetch.p0(ptr %iter9, i32 1, i32 3, i32 1) #23
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.end19
  %21 = tail call { i32, i32 } asm sideeffect "@ __cmpxchg4\0A\09ldrex\09$1, [$2]\0A\09mov\09$0, #0\0A\09teq\09$1, $3\0A\09strexeq $0, $4, [$2]\0A", "=&r,=&r,r,Ir,r,~{memory},~{cc}"(ptr %iter9, i32 %20, i32 0) #23, !srcloc !476
  %asmresult.i = extractvalue { i32, i32 } %21, 0
  %tobool.not.i152 = icmp eq i32 %asmresult.i, 0
  br i1 %tobool.not.i152, label %__cmpxchg.exit, label %do.body.i

__cmpxchg.exit:                                   ; preds = %do.body.i
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !477
  %22 = ptrtoint ptr %iter9 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile ptr, ptr %iter9, align 4
  %tobool15.not = icmp eq ptr %23, null
  br i1 %tobool15.not, label %if.end40, label %lor.lhs.false

if.end40:                                         ; preds = %__cmpxchg.exit, %css_tryget.exit, %lor.lhs.false, %if.end14, %rcu_read_lock.exit
  %pos.2 = phi ptr [ %pos.0, %rcu_read_lock.exit ], [ null, %if.end14 ], [ null, %__cmpxchg.exit ], [ %17, %css_tryget.exit ], [ %17, %lor.lhs.false ]
  %iter.0 = phi ptr [ inttoptr (i32 -1 to ptr), %rcu_read_lock.exit ], [ %iter9, %if.end14 ], [ %iter9, %lor.lhs.false ], [ %iter9, %css_tryget.exit ], [ %iter9, %__cmpxchg.exit ]
  %tobool41.not = icmp eq ptr %pos.2, null
  br label %for.cond

for.cond:                                         ; preds = %for.cond.backedge, %if.end40
  %css.1 = phi ptr [ %pos.2, %if.end40 ], [ %call46, %for.cond.backedge ]
  %call46 = tail call ptr @css_next_descendant_pre(ptr noundef %css.1, ptr noundef %root.addr.0) #23
  %tobool47.not = icmp eq ptr %call46, null
  br i1 %tobool47.not, label %if.then48, label %if.end52

if.then48:                                        ; preds = %for.cond
  br i1 %tobool3.not, label %for.cond.backedge, label %for.end

for.cond.backedge:                                ; preds = %css_tryget.exit160, %if.then48
  br label %for.cond

if.end52:                                         ; preds = %for.cond
  %cmp55 = icmp eq ptr %call46, %root.addr.0
  br i1 %cmp55, label %for.end, label %if.end57

if.end57:                                         ; preds = %if.end52
  %flags.i153 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call46, i32 0, i32 7
  %24 = ptrtoint ptr %flags.i153 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %flags.i153, align 4
  %and.i154 = and i32 %25, 1
  %tobool.not.i155 = icmp eq i32 %and.i154, 0
  br i1 %tobool.not.i155, label %css_tryget.exit160, label %for.end

css_tryget.exit160:                               ; preds = %if.end57
  %refcnt.i156 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call46, i32 0, i32 2
  %call.i157 = tail call fastcc zeroext i1 @percpu_ref_tryget(ptr noundef %refcnt.i156) #23
  br i1 %call.i157, label %for.end, label %for.cond.backedge

for.end:                                          ; preds = %css_tryget.exit160, %if.end57, %if.end52, %if.then48
  %call46.lcssa = phi ptr [ %call46, %if.end57 ], [ %call46, %css_tryget.exit160 ], [ %root.addr.0, %if.end52 ], [ null, %if.then48 ]
  br i1 %tobool4.not, label %out_unlock, label %if.then62

if.then62:                                        ; preds = %for.end
  %call.i148 = tail call zeroext i1 @__kasan_check_write(ptr noundef %iter.0, i32 noundef 4) #23
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !478
  %26 = ptrtoint ptr %pos.2 to i32
  %27 = ptrtoint ptr %call46.lcssa to i32
  tail call void @llvm.prefetch.p0(ptr %iter.0, i32 1, i32 3, i32 1) #23
  br label %do.body.i163

do.body.i163:                                     ; preds = %do.body.i163, %if.then62
  %28 = tail call { i32, i32 } asm sideeffect "@ __cmpxchg4\0A\09ldrex\09$1, [$2]\0A\09mov\09$0, #0\0A\09teq\09$1, $3\0A\09strexeq $0, $4, [$2]\0A", "=&r,=&r,r,Ir,r,~{memory},~{cc}"(ptr %iter.0, i32 %26, i32 %27) #23, !srcloc !476
  %asmresult.i161 = extractvalue { i32, i32 } %28, 0
  %tobool.not.i162 = icmp eq i32 %asmresult.i161, 0
  br i1 %tobool.not.i162, label %__cmpxchg.exit165, label %do.body.i163

__cmpxchg.exit165:                                ; preds = %do.body.i163
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !479
  br i1 %tobool41.not, label %if.end88, label %if.then86

if.then86:                                        ; preds = %__cmpxchg.exit165
  %flags.i166 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %pos.2, i32 0, i32 7
  %29 = ptrtoint ptr %flags.i166 to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %flags.i166, align 4
  %and.i167 = and i32 %30, 1
  %tobool.not.i168 = icmp eq i32 %and.i167, 0
  br i1 %tobool.not.i168, label %if.then.i170, label %if.end88

if.then.i170:                                     ; preds = %if.then86
  %refcnt.i169 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %pos.2, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i169) #23
  br label %if.end88

if.end88:                                         ; preds = %if.then.i170, %if.then86, %__cmpxchg.exit165
  %tobool89.not = icmp eq ptr %call46.lcssa, null
  br i1 %tobool89.not, label %if.then90, label %if.else

if.then90:                                        ; preds = %if.end88
  %generation91 = getelementptr inbounds %struct.mem_cgroup_reclaim_iter, ptr %iter.0, i32 0, i32 1
  %31 = ptrtoint ptr %generation91 to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load i32, ptr %generation91, align 4
  %inc = add i32 %32, 1
  store i32 %inc, ptr %generation91, align 4
  br label %out_unlock

if.else:                                          ; preds = %if.end88
  br i1 %tobool3.not, label %if.then93, label %out_unlock

if.then93:                                        ; preds = %if.else
  %generation94 = getelementptr inbounds %struct.mem_cgroup_reclaim_iter, ptr %iter.0, i32 0, i32 1
  %33 = ptrtoint ptr %generation94 to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %generation94, align 4
  %generation95 = getelementptr inbounds %struct.mem_cgroup_reclaim_cookie, ptr %reclaim, i32 0, i32 1
  %35 = ptrtoint ptr %generation95 to i32
  call void @__asan_store4_noabort(i32 %35)
  store i32 %34, ptr %generation95, align 4
  br label %out_unlock

out_unlock:                                       ; preds = %if.then93, %if.else, %if.then90, %for.end, %land.lhs.true11
  %memcg.2 = phi ptr [ %call46.lcssa, %if.else ], [ %call46.lcssa, %if.then93 ], [ null, %if.then90 ], [ %call46.lcssa, %for.end ], [ null, %land.lhs.true11 ]
  %call.i171 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i171, label %rcu_read_unlock.exit, label %land.lhs.true.i174

land.lhs.true.i174:                               ; preds = %out_unlock
  %call1.i172 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i173 = icmp eq i32 %call1.i172, 0
  br i1 %tobool.not.i173, label %rcu_read_unlock.exit, label %land.lhs.true2.i176

land.lhs.true2.i176:                              ; preds = %land.lhs.true.i174
  %.b4.i175 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i175, label %rcu_read_unlock.exit, label %if.then.i177

if.then.i177:                                     ; preds = %land.lhs.true2.i176
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i177, %land.lhs.true2.i176, %land.lhs.true.i174, %out_unlock
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %36 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i178 = and i32 %36, -16384
  %37 = inttoptr i32 %and.i.i.i.i.i178 to ptr
  %preempt_count.i.i.i.i179 = getelementptr inbounds %struct.thread_info, ptr %37, i32 0, i32 1
  %38 = ptrtoint ptr %preempt_count.i.i.i.i179 to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load volatile i32, ptr %preempt_count.i.i.i.i179, align 4
  %sub.i.i.i = add i32 %39, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i179, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  %cmp101.not = icmp eq ptr %root.addr.0, %prev
  %or.cond146 = select i1 %tobool3.not, i1 true, i1 %cmp101.not
  br i1 %or.cond146, label %cleanup105, label %if.then102

if.then102:                                       ; preds = %rcu_read_unlock.exit
  %flags.i180 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %prev, i32 0, i32 7
  %40 = ptrtoint ptr %flags.i180 to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %flags.i180, align 4
  %and.i181 = and i32 %41, 1
  %tobool.not.i182 = icmp eq i32 %and.i181, 0
  br i1 %tobool.not.i182, label %if.then.i184, label %cleanup105

if.then.i184:                                     ; preds = %if.then102
  %refcnt.i183 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %prev, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i183) #23
  br label %cleanup105

cleanup105:                                       ; preds = %if.then.i184, %if.then102, %rcu_read_unlock.exit, %entry
  %retval.0 = phi ptr [ %memcg.2, %rcu_read_unlock.exit ], [ %memcg.2, %if.then102 ], [ %memcg.2, %if.then.i184 ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @css_next_descendant_pre(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mem_cgroup_iter_break(ptr noundef readnone %root, ptr noundef %prev) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tobool.not = icmp eq ptr %root, null
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = load ptr, ptr @root_mem_cgroup, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %root.addr.0 = phi ptr [ %root, %entry ], [ %0, %if.then ]
  %tobool1.not = icmp eq ptr %prev, null
  %cmp.not = icmp eq ptr %root.addr.0, %prev
  %or.cond = select i1 %tobool1.not, i1 true, i1 %cmp.not
  br i1 %or.cond, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %prev, i32 0, i32 7
  %1 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %flags.i, align 4
  %and.i = and i32 %2, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.then.i, label %if.end3

if.then.i:                                        ; preds = %if.then2
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %prev, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i) #23
  br label %if.end3

if.end3:                                          ; preds = %if.then.i, %if.then2, %if.end
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @mem_cgroup_scan_tasks(ptr noundef %memcg, ptr nocapture noundef readonly %fn, ptr noundef %arg) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %it = alloca %struct.css_task_iter, align 4
  %0 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp = icmp eq ptr %0, %memcg
  br i1 %cmp, label %do.body2, label %do.end7, !prof !466

do.body2:                                         ; preds = %entry
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1147, 0\0A.popsection", ""() #23, !srcloc !480
  unreachable

do.end7:                                          ; preds = %entry
  %call = tail call ptr @mem_cgroup_iter(ptr noundef %memcg, ptr noundef null, ptr noundef null)
  %cmp8.not32 = icmp eq ptr %call, null
  br i1 %cmp8.not32, label %for.end, label %for.body

for.body:                                         ; preds = %for.inc, %do.end7
  %iter.033 = phi ptr [ %call17, %for.inc ], [ %call, %do.end7 ]
  call void @llvm.lifetime.start.p0(i64 52, ptr nonnull %it) #23
  %1 = call ptr @memset(ptr %it, i32 255, i32 52)
  call void @css_task_iter_start(ptr noundef nonnull %iter.033, i32 noundef 1, ptr noundef nonnull %it) #23
  br label %land.rhs

land.rhs:                                         ; preds = %while.body, %for.body
  %call10 = call ptr @css_task_iter_next(ptr noundef nonnull %it) #23
  %tobool11.not = icmp eq ptr %call10, null
  br i1 %tobool11.not, label %for.inc, label %while.body

while.body:                                       ; preds = %land.rhs
  %call12 = call i32 %fn(ptr noundef nonnull %call10, ptr noundef %arg) #23
  %tobool9.not = icmp eq i32 %call12, 0
  br i1 %tobool9.not, label %land.rhs, label %if.then14.critedge

if.then14.critedge:                               ; preds = %while.body
  call void @css_task_iter_end(ptr noundef nonnull %it) #23
  %tobool.not.i = icmp eq ptr %memcg, null
  br i1 %tobool.not.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then14.critedge
  %2 = load ptr, ptr @root_mem_cgroup, align 4
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.then14.critedge
  %root.addr.0.i = phi ptr [ %memcg, %if.then14.critedge ], [ %2, %if.then.i ]
  %cmp.not.i = icmp eq ptr %root.addr.0.i, %iter.033
  br i1 %cmp.not.i, label %cleanup.thread, label %if.then2.i

if.then2.i:                                       ; preds = %if.end.i
  %flags.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %iter.033, i32 0, i32 7
  %3 = ptrtoint ptr %flags.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %flags.i.i, align 4
  %and.i.i = and i32 %4, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.then.i.i, label %cleanup.thread

if.then.i.i:                                      ; preds = %if.then2.i
  %refcnt.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %iter.033, i32 0, i32 2
  call fastcc void @percpu_ref_put(ptr noundef %refcnt.i.i) #23
  br label %cleanup.thread

cleanup.thread:                                   ; preds = %if.then.i.i, %if.then2.i, %if.end.i
  call void @llvm.lifetime.end.p0(i64 52, ptr nonnull %it) #23
  br label %for.end

for.inc:                                          ; preds = %land.rhs
  call void @css_task_iter_end(ptr noundef nonnull %it) #23
  call void @llvm.lifetime.end.p0(i64 52, ptr nonnull %it) #23
  %call17 = call ptr @mem_cgroup_iter(ptr noundef %memcg, ptr noundef nonnull %iter.033, ptr noundef null)
  %cmp8.not = icmp eq ptr %call17, null
  br i1 %cmp8.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %cleanup.thread, %do.end7
  %ret.2 = phi i32 [ %call12, %cleanup.thread ], [ 0, %do.end7 ], [ 0, %for.inc ]
  ret i32 %ret.2
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @css_task_iter_start(ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @css_task_iter_next(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @css_task_iter_end(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @lruvec_memcg_debug(ptr nocapture noundef readonly %lruvec, ptr noundef %folio) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@lruvec_memcg_debug, %cleanup)) #23
          to label %if.end [label %cleanup], !srcloc !461

if.end:                                           ; preds = %entry
  %call1 = tail call fastcc ptr @folio_memcg(ptr noundef %folio)
  %tobool.not = icmp eq ptr %call1, null
  br i1 %tobool.not, label %do.body, label %do.body14

do.body:                                          ; preds = %if.end
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@lruvec_memcg_debug, %lruvec_memcg.exit)) #23
          to label %if.end.i [label %lruvec_memcg.exit], !srcloc !461

if.end.i:                                         ; preds = %do.body
  %memcg.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %lruvec, i32 0, i32 9
  %0 = ptrtoint ptr %memcg.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %memcg.i, align 4
  br label %lruvec_memcg.exit

lruvec_memcg.exit:                                ; preds = %if.end.i, %do.body
  %retval.0.i = phi ptr [ %1, %if.end.i ], [ null, %do.body ]
  %2 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.not = icmp eq ptr %retval.0.i, %2
  br i1 %cmp.not, label %cleanup, label %if.then6, !prof !460

if.then6:                                         ; preds = %lruvec_memcg.exit
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.3) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1176, 0\0A.popsection", ""() #23, !srcloc !481
  unreachable

do.body14:                                        ; preds = %if.end
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@lruvec_memcg_debug, %lruvec_memcg.exit41)) #23
          to label %if.end.i39 [label %lruvec_memcg.exit41], !srcloc !461

if.end.i39:                                       ; preds = %do.body14
  %memcg.i38 = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %lruvec, i32 0, i32 9
  %3 = ptrtoint ptr %memcg.i38 to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %memcg.i38, align 4
  br label %lruvec_memcg.exit41

lruvec_memcg.exit41:                              ; preds = %if.end.i39, %do.body14
  %retval.0.i40 = phi ptr [ %4, %if.end.i39 ], [ null, %do.body14 ]
  %cmp16.not = icmp eq ptr %retval.0.i40, %call1
  br i1 %cmp16.not, label %cleanup, label %if.then23, !prof !460

if.then23:                                        ; preds = %lruvec_memcg.exit41
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.4) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1178, 0\0A.popsection", ""() #23, !srcloc !482
  unreachable

cleanup:                                          ; preds = %lruvec_memcg.exit41, %lruvec_memcg.exit, %entry
  ret void
}

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc ptr @folio_memcg(ptr noundef %folio) unnamed_addr #5 align 64 {
entry:
  %0 = getelementptr inbounds %struct.page, ptr %folio, i32 0, i32 1
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %0, align 4
  %and.i.i = and i32 %2, 1
  %tobool.not.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i, label %do.body7.i, label %if.then.i, !prof !460

if.then.i:                                        ; preds = %entry
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.104) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/memcontrol.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 537, 0\0A.popsection", ""() #23, !srcloc !483
  unreachable

do.body7.i:                                       ; preds = %entry
  %memcg_data.i = getelementptr inbounds %struct.anon.153, ptr %folio, i32 0, i32 7
  %3 = ptrtoint ptr %memcg_data.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %memcg_data.i, align 4
  %and.i = and i32 %4, 1
  %tobool8.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool8.not.i, label %folio_memcg_kmem.exit, label %if.then15.i, !prof !460

if.then15.i:                                      ; preds = %do.body7.i
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.105) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/memcontrol.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 538, 0\0A.popsection", ""() #23, !srcloc !484
  unreachable

folio_memcg_kmem.exit:                            ; preds = %do.body7.i
  %and23.i = and i32 %4, 2
  %tobool24.i.not = icmp eq i32 %and23.i, 0
  %5 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %0, align 4
  %and.i.i.i.i9 = and i32 %6, 1
  %tobool.not.i.i.i10 = icmp eq i32 %and.i.i.i.i9, 0
  br i1 %tobool24.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %folio_memcg_kmem.exit
  br i1 %tobool.not.i.i.i10, label %folio_test_slab.exit.i, label %if.then.i.i.i, !prof !460

if.then.i.i.i:                                    ; preds = %if.then
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.96) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #23, !srcloc !470
  unreachable

folio_test_slab.exit.i:                           ; preds = %if.then
  %7 = ptrtoint ptr %folio to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load volatile i32, ptr %folio, align 4
  %9 = and i32 %8, 512
  %tobool.i.not.i = icmp eq i32 %9, 0
  br i1 %tobool.i.not.i, label %__folio_objcg.exit, label %if.then.i6, !prof !460

if.then.i6:                                       ; preds = %folio_test_slab.exit.i
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.58) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/memcontrol.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 417, 0\0A.popsection", ""() #23, !srcloc !485
  unreachable

__folio_objcg.exit:                               ; preds = %folio_test_slab.exit.i
  %and48.i = and i32 %4, -4
  %10 = inttoptr i32 %and48.i to ptr
  %memcg.i = getelementptr inbounds %struct.obj_cgroup, ptr %10, i32 0, i32 1
  %11 = ptrtoint ptr %memcg.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile ptr, ptr %memcg.i, align 4
  br label %return

if.end:                                           ; preds = %folio_memcg_kmem.exit
  br i1 %tobool.not.i.i.i10, label %folio_test_slab.exit.i13, label %if.then.i.i.i11, !prof !460

if.then.i.i.i11:                                  ; preds = %if.end
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.96) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #23, !srcloc !470
  unreachable

folio_test_slab.exit.i13:                         ; preds = %if.end
  %13 = ptrtoint ptr %folio to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %folio, align 4
  %15 = and i32 %14, 512
  %tobool.i.not.i12 = icmp eq i32 %15, 0
  br i1 %tobool.i.not.i12, label %__folio_memcg.exit, label %if.then.i14, !prof !460

if.then.i14:                                      ; preds = %folio_test_slab.exit.i13
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.58) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/memcontrol.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 396, 0\0A.popsection", ""() #23, !srcloc !486
  unreachable

__folio_memcg.exit:                               ; preds = %folio_test_slab.exit.i13
  %and46.i = and i32 %4, -4
  %16 = inttoptr i32 %and46.i to ptr
  br label %return

return:                                           ; preds = %__folio_memcg.exit, %__folio_objcg.exit
  %retval.0 = phi ptr [ %12, %__folio_objcg.exit ], [ %16, %__folio_memcg.exit ]
  ret ptr %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @dump_page(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @folio_lruvec_lock(ptr noundef %folio) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call.i = tail call fastcc ptr @folio_memcg(ptr noundef %folio) #23
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %land.rhs.i, label %if.end35.i

land.rhs.i:                                       ; preds = %entry
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@folio_lruvec_lock, %if.end35.i)) #23
          to label %land.rhs5.i [label %if.end35.i], !srcloc !461

land.rhs5.i:                                      ; preds = %land.rhs.i
  %.b50.i = load i1, ptr @folio_lruvec.__warned, align 1
  br i1 %.b50.i, label %if.end35.i, label %if.then.i, !prof !460

if.then.i:                                        ; preds = %land.rhs5.i
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.61) #23
  store i1 true, ptr @folio_lruvec.__warned, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.62, i32 noundef 746, i32 noundef 9, ptr noundef null) #23
  br label %if.end35.i

if.end35.i:                                       ; preds = %if.then.i, %land.rhs5.i, %land.rhs.i, %entry
  %0 = ptrtoint ptr %folio to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile i32, ptr %folio, align 4
  %cmp.i.not.i.i.i.i = icmp eq i32 %1, -1
  br i1 %cmp.i.not.i.i.i.i, label %if.then.i.i.i.i, label %folio_pgdat.exit.i, !prof !466

if.then.i.i.i.i:                                  ; preds = %if.end35.i
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.170) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/mm.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1368, 0\0A.popsection", ""() #23, !srcloc !469
  unreachable

folio_pgdat.exit.i:                               ; preds = %if.end35.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@folio_lruvec_lock, %out.i.i)) #23
          to label %if.end.i.i [label %out.i.i], !srcloc !461

if.end.i.i:                                       ; preds = %folio_pgdat.exit.i
  br i1 %tobool.not.i, label %if.then1.i.i, label %if.end2.i.i

if.then1.i.i:                                     ; preds = %if.end.i.i
  %2 = load ptr, ptr @root_mem_cgroup, align 4
  br label %if.end2.i.i

if.end2.i.i:                                      ; preds = %if.then1.i.i, %if.end.i.i
  %memcg.addr.0.i.i = phi ptr [ %call.i, %if.end.i.i ], [ %2, %if.then1.i.i ]
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 8) to i32))
  %3 = load i32, ptr getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 8), align 64
  %arrayidx.i.i = getelementptr %struct.mem_cgroup, ptr %memcg.addr.0.i.i, i32 0, i32 45, i32 %3
  %4 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %arrayidx.i.i, align 4
  br label %out.i.i

out.i.i:                                          ; preds = %if.end2.i.i, %folio_pgdat.exit.i
  %lruvec.0.i.i = phi ptr [ %5, %if.end2.i.i ], [ getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 26), %folio_pgdat.exit.i ]
  %pgdat4.i.i = getelementptr inbounds %struct.lruvec, ptr %lruvec.0.i.i, i32 0, i32 7
  %6 = ptrtoint ptr %pgdat4.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %pgdat4.i.i, align 4
  %cmp.not.i.i = icmp eq ptr %7, @contig_page_data
  br i1 %cmp.not.i.i, label %folio_lruvec.exit, label %if.then7.i.i, !prof !460

if.then7.i.i:                                     ; preds = %out.i.i
  %8 = ptrtoint ptr %pgdat4.i.i to i32
  call void @__asan_store4_noabort(i32 %8)
  store ptr @contig_page_data, ptr %pgdat4.i.i, align 4
  br label %folio_lruvec.exit

folio_lruvec.exit:                                ; preds = %if.then7.i.i, %out.i.i
  %lru_lock = getelementptr inbounds %struct.lruvec, ptr %lruvec.0.i.i, i32 0, i32 1
  tail call void @_raw_spin_lock(ptr noundef %lru_lock) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@folio_lruvec_lock, %lruvec_memcg_debug.exit)) #23
          to label %if.end.i [label %lruvec_memcg_debug.exit], !srcloc !461

if.end.i:                                         ; preds = %folio_lruvec.exit
  %call1.i = tail call fastcc ptr @folio_memcg(ptr noundef %folio) #23
  %tobool.not.i4 = icmp eq ptr %call1.i, null
  br i1 %tobool.not.i4, label %do.body.i, label %do.body14.i

do.body.i:                                        ; preds = %if.end.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@folio_lruvec_lock, %lruvec_memcg.exit.i)) #23
          to label %if.end.i.i5 [label %lruvec_memcg.exit.i], !srcloc !461

if.end.i.i5:                                      ; preds = %do.body.i
  %memcg.i.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %lruvec.0.i.i, i32 0, i32 9
  %9 = ptrtoint ptr %memcg.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %memcg.i.i, align 4
  br label %lruvec_memcg.exit.i

lruvec_memcg.exit.i:                              ; preds = %if.end.i.i5, %do.body.i
  %retval.0.i.i = phi ptr [ %10, %if.end.i.i5 ], [ null, %do.body.i ]
  %11 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.not.i = icmp eq ptr %retval.0.i.i, %11
  br i1 %cmp.not.i, label %lruvec_memcg_debug.exit, label %if.then6.i, !prof !460

if.then6.i:                                       ; preds = %lruvec_memcg.exit.i
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.3) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1176, 0\0A.popsection", ""() #23, !srcloc !481
  unreachable

do.body14.i:                                      ; preds = %if.end.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@folio_lruvec_lock, %lruvec_memcg.exit41.i)) #23
          to label %if.end.i39.i [label %lruvec_memcg.exit41.i], !srcloc !461

if.end.i39.i:                                     ; preds = %do.body14.i
  %memcg.i38.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %lruvec.0.i.i, i32 0, i32 9
  %12 = ptrtoint ptr %memcg.i38.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %memcg.i38.i, align 4
  br label %lruvec_memcg.exit41.i

lruvec_memcg.exit41.i:                            ; preds = %if.end.i39.i, %do.body14.i
  %retval.0.i40.i = phi ptr [ %13, %if.end.i39.i ], [ null, %do.body14.i ]
  %cmp16.not.i = icmp eq ptr %retval.0.i40.i, %call1.i
  br i1 %cmp16.not.i, label %lruvec_memcg_debug.exit, label %if.then23.i, !prof !460

if.then23.i:                                      ; preds = %lruvec_memcg.exit41.i
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.4) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1178, 0\0A.popsection", ""() #23, !srcloc !482
  unreachable

lruvec_memcg_debug.exit:                          ; preds = %lruvec_memcg.exit41.i, %lruvec_memcg.exit.i, %folio_lruvec.exit
  ret ptr %lruvec.0.i.i
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @folio_lruvec_lock_irq(ptr noundef %folio) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call.i = tail call fastcc ptr @folio_memcg(ptr noundef %folio) #23
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %land.rhs.i, label %if.end35.i

land.rhs.i:                                       ; preds = %entry
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@folio_lruvec_lock_irq, %if.end35.i)) #23
          to label %land.rhs5.i [label %if.end35.i], !srcloc !461

land.rhs5.i:                                      ; preds = %land.rhs.i
  %.b50.i = load i1, ptr @folio_lruvec.__warned, align 1
  br i1 %.b50.i, label %if.end35.i, label %if.then.i, !prof !460

if.then.i:                                        ; preds = %land.rhs5.i
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.61) #23
  store i1 true, ptr @folio_lruvec.__warned, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.62, i32 noundef 746, i32 noundef 9, ptr noundef null) #23
  br label %if.end35.i

if.end35.i:                                       ; preds = %if.then.i, %land.rhs5.i, %land.rhs.i, %entry
  %0 = ptrtoint ptr %folio to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile i32, ptr %folio, align 4
  %cmp.i.not.i.i.i.i = icmp eq i32 %1, -1
  br i1 %cmp.i.not.i.i.i.i, label %if.then.i.i.i.i, label %folio_pgdat.exit.i, !prof !466

if.then.i.i.i.i:                                  ; preds = %if.end35.i
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.170) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/mm.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1368, 0\0A.popsection", ""() #23, !srcloc !469
  unreachable

folio_pgdat.exit.i:                               ; preds = %if.end35.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@folio_lruvec_lock_irq, %out.i.i)) #23
          to label %if.end.i.i [label %out.i.i], !srcloc !461

if.end.i.i:                                       ; preds = %folio_pgdat.exit.i
  br i1 %tobool.not.i, label %if.then1.i.i, label %if.end2.i.i

if.then1.i.i:                                     ; preds = %if.end.i.i
  %2 = load ptr, ptr @root_mem_cgroup, align 4
  br label %if.end2.i.i

if.end2.i.i:                                      ; preds = %if.then1.i.i, %if.end.i.i
  %memcg.addr.0.i.i = phi ptr [ %call.i, %if.end.i.i ], [ %2, %if.then1.i.i ]
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 8) to i32))
  %3 = load i32, ptr getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 8), align 64
  %arrayidx.i.i = getelementptr %struct.mem_cgroup, ptr %memcg.addr.0.i.i, i32 0, i32 45, i32 %3
  %4 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %arrayidx.i.i, align 4
  br label %out.i.i

out.i.i:                                          ; preds = %if.end2.i.i, %folio_pgdat.exit.i
  %lruvec.0.i.i = phi ptr [ %5, %if.end2.i.i ], [ getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 26), %folio_pgdat.exit.i ]
  %pgdat4.i.i = getelementptr inbounds %struct.lruvec, ptr %lruvec.0.i.i, i32 0, i32 7
  %6 = ptrtoint ptr %pgdat4.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %pgdat4.i.i, align 4
  %cmp.not.i.i = icmp eq ptr %7, @contig_page_data
  br i1 %cmp.not.i.i, label %folio_lruvec.exit, label %if.then7.i.i, !prof !460

if.then7.i.i:                                     ; preds = %out.i.i
  %8 = ptrtoint ptr %pgdat4.i.i to i32
  call void @__asan_store4_noabort(i32 %8)
  store ptr @contig_page_data, ptr %pgdat4.i.i, align 4
  br label %folio_lruvec.exit

folio_lruvec.exit:                                ; preds = %if.then7.i.i, %out.i.i
  %lru_lock = getelementptr inbounds %struct.lruvec, ptr %lruvec.0.i.i, i32 0, i32 1
  tail call void @_raw_spin_lock_irq(ptr noundef %lru_lock) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@folio_lruvec_lock_irq, %lruvec_memcg_debug.exit)) #23
          to label %if.end.i [label %lruvec_memcg_debug.exit], !srcloc !461

if.end.i:                                         ; preds = %folio_lruvec.exit
  %call1.i = tail call fastcc ptr @folio_memcg(ptr noundef %folio) #23
  %tobool.not.i4 = icmp eq ptr %call1.i, null
  br i1 %tobool.not.i4, label %do.body.i, label %do.body14.i

do.body.i:                                        ; preds = %if.end.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@folio_lruvec_lock_irq, %lruvec_memcg.exit.i)) #23
          to label %if.end.i.i5 [label %lruvec_memcg.exit.i], !srcloc !461

if.end.i.i5:                                      ; preds = %do.body.i
  %memcg.i.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %lruvec.0.i.i, i32 0, i32 9
  %9 = ptrtoint ptr %memcg.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %memcg.i.i, align 4
  br label %lruvec_memcg.exit.i

lruvec_memcg.exit.i:                              ; preds = %if.end.i.i5, %do.body.i
  %retval.0.i.i = phi ptr [ %10, %if.end.i.i5 ], [ null, %do.body.i ]
  %11 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.not.i = icmp eq ptr %retval.0.i.i, %11
  br i1 %cmp.not.i, label %lruvec_memcg_debug.exit, label %if.then6.i, !prof !460

if.then6.i:                                       ; preds = %lruvec_memcg.exit.i
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.3) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1176, 0\0A.popsection", ""() #23, !srcloc !481
  unreachable

do.body14.i:                                      ; preds = %if.end.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@folio_lruvec_lock_irq, %lruvec_memcg.exit41.i)) #23
          to label %if.end.i39.i [label %lruvec_memcg.exit41.i], !srcloc !461

if.end.i39.i:                                     ; preds = %do.body14.i
  %memcg.i38.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %lruvec.0.i.i, i32 0, i32 9
  %12 = ptrtoint ptr %memcg.i38.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %memcg.i38.i, align 4
  br label %lruvec_memcg.exit41.i

lruvec_memcg.exit41.i:                            ; preds = %if.end.i39.i, %do.body14.i
  %retval.0.i40.i = phi ptr [ %13, %if.end.i39.i ], [ null, %do.body14.i ]
  %cmp16.not.i = icmp eq ptr %retval.0.i40.i, %call1.i
  br i1 %cmp16.not.i, label %lruvec_memcg_debug.exit, label %if.then23.i, !prof !460

if.then23.i:                                      ; preds = %lruvec_memcg.exit41.i
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.4) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1178, 0\0A.popsection", ""() #23, !srcloc !482
  unreachable

lruvec_memcg_debug.exit:                          ; preds = %lruvec_memcg.exit41.i, %lruvec_memcg.exit.i, %folio_lruvec.exit
  ret ptr %lruvec.0.i.i
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @folio_lruvec_lock_irqsave(ptr noundef %folio, ptr nocapture noundef writeonly %flags) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call.i = tail call fastcc ptr @folio_memcg(ptr noundef %folio) #23
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %land.rhs.i, label %if.end35.i

land.rhs.i:                                       ; preds = %entry
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@folio_lruvec_lock_irqsave, %if.end35.i)) #23
          to label %land.rhs5.i [label %if.end35.i], !srcloc !461

land.rhs5.i:                                      ; preds = %land.rhs.i
  %.b50.i = load i1, ptr @folio_lruvec.__warned, align 1
  br i1 %.b50.i, label %if.end35.i, label %if.then.i, !prof !460

if.then.i:                                        ; preds = %land.rhs5.i
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.61) #23
  store i1 true, ptr @folio_lruvec.__warned, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.62, i32 noundef 746, i32 noundef 9, ptr noundef null) #23
  br label %if.end35.i

if.end35.i:                                       ; preds = %if.then.i, %land.rhs5.i, %land.rhs.i, %entry
  %0 = ptrtoint ptr %folio to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile i32, ptr %folio, align 4
  %cmp.i.not.i.i.i.i = icmp eq i32 %1, -1
  br i1 %cmp.i.not.i.i.i.i, label %if.then.i.i.i.i, label %folio_pgdat.exit.i, !prof !466

if.then.i.i.i.i:                                  ; preds = %if.end35.i
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.170) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/mm.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1368, 0\0A.popsection", ""() #23, !srcloc !469
  unreachable

folio_pgdat.exit.i:                               ; preds = %if.end35.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@folio_lruvec_lock_irqsave, %out.i.i)) #23
          to label %if.end.i.i [label %out.i.i], !srcloc !461

if.end.i.i:                                       ; preds = %folio_pgdat.exit.i
  br i1 %tobool.not.i, label %if.then1.i.i, label %if.end2.i.i

if.then1.i.i:                                     ; preds = %if.end.i.i
  %2 = load ptr, ptr @root_mem_cgroup, align 4
  br label %if.end2.i.i

if.end2.i.i:                                      ; preds = %if.then1.i.i, %if.end.i.i
  %memcg.addr.0.i.i = phi ptr [ %call.i, %if.end.i.i ], [ %2, %if.then1.i.i ]
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 8) to i32))
  %3 = load i32, ptr getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 8), align 64
  %arrayidx.i.i = getelementptr %struct.mem_cgroup, ptr %memcg.addr.0.i.i, i32 0, i32 45, i32 %3
  %4 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %arrayidx.i.i, align 4
  br label %out.i.i

out.i.i:                                          ; preds = %if.end2.i.i, %folio_pgdat.exit.i
  %lruvec.0.i.i = phi ptr [ %5, %if.end2.i.i ], [ getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 26), %folio_pgdat.exit.i ]
  %pgdat4.i.i = getelementptr inbounds %struct.lruvec, ptr %lruvec.0.i.i, i32 0, i32 7
  %6 = ptrtoint ptr %pgdat4.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %pgdat4.i.i, align 4
  %cmp.not.i.i = icmp eq ptr %7, @contig_page_data
  br i1 %cmp.not.i.i, label %folio_lruvec.exit, label %if.then7.i.i, !prof !460

if.then7.i.i:                                     ; preds = %out.i.i
  %8 = ptrtoint ptr %pgdat4.i.i to i32
  call void @__asan_store4_noabort(i32 %8)
  store ptr @contig_page_data, ptr %pgdat4.i.i, align 4
  br label %folio_lruvec.exit

folio_lruvec.exit:                                ; preds = %if.then7.i.i, %out.i.i
  %lru_lock = getelementptr inbounds %struct.lruvec, ptr %lruvec.0.i.i, i32 0, i32 1
  %call3 = tail call i32 @_raw_spin_lock_irqsave(ptr noundef %lru_lock) #23
  %9 = ptrtoint ptr %flags to i32
  call void @__asan_store4_noabort(i32 %9)
  store i32 %call3, ptr %flags, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@folio_lruvec_lock_irqsave, %lruvec_memcg_debug.exit)) #23
          to label %if.end.i [label %lruvec_memcg_debug.exit], !srcloc !461

if.end.i:                                         ; preds = %folio_lruvec.exit
  %call1.i = tail call fastcc ptr @folio_memcg(ptr noundef %folio) #23
  %tobool.not.i9 = icmp eq ptr %call1.i, null
  br i1 %tobool.not.i9, label %do.body.i, label %do.body14.i

do.body.i:                                        ; preds = %if.end.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@folio_lruvec_lock_irqsave, %lruvec_memcg.exit.i)) #23
          to label %if.end.i.i10 [label %lruvec_memcg.exit.i], !srcloc !461

if.end.i.i10:                                     ; preds = %do.body.i
  %memcg.i.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %lruvec.0.i.i, i32 0, i32 9
  %10 = ptrtoint ptr %memcg.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %memcg.i.i, align 4
  br label %lruvec_memcg.exit.i

lruvec_memcg.exit.i:                              ; preds = %if.end.i.i10, %do.body.i
  %retval.0.i.i = phi ptr [ %11, %if.end.i.i10 ], [ null, %do.body.i ]
  %12 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.not.i = icmp eq ptr %retval.0.i.i, %12
  br i1 %cmp.not.i, label %lruvec_memcg_debug.exit, label %if.then6.i, !prof !460

if.then6.i:                                       ; preds = %lruvec_memcg.exit.i
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.3) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1176, 0\0A.popsection", ""() #23, !srcloc !481
  unreachable

do.body14.i:                                      ; preds = %if.end.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@folio_lruvec_lock_irqsave, %lruvec_memcg.exit41.i)) #23
          to label %if.end.i39.i [label %lruvec_memcg.exit41.i], !srcloc !461

if.end.i39.i:                                     ; preds = %do.body14.i
  %memcg.i38.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %lruvec.0.i.i, i32 0, i32 9
  %13 = ptrtoint ptr %memcg.i38.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %memcg.i38.i, align 4
  br label %lruvec_memcg.exit41.i

lruvec_memcg.exit41.i:                            ; preds = %if.end.i39.i, %do.body14.i
  %retval.0.i40.i = phi ptr [ %14, %if.end.i39.i ], [ null, %do.body14.i ]
  %cmp16.not.i = icmp eq ptr %retval.0.i40.i, %call1.i
  br i1 %cmp16.not.i, label %lruvec_memcg_debug.exit, label %if.then23.i, !prof !460

if.then23.i:                                      ; preds = %lruvec_memcg.exit41.i
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.4) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1178, 0\0A.popsection", ""() #23, !srcloc !482
  unreachable

lruvec_memcg_debug.exit:                          ; preds = %lruvec_memcg.exit41.i, %lruvec_memcg.exit.i, %folio_lruvec.exit
  ret ptr %lruvec.0.i.i
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @_raw_spin_lock_irqsave(ptr noundef) local_unnamed_addr #4 section ".spinlock.text"

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mem_cgroup_update_lru_size(ptr noundef %lruvec, i32 noundef %lru, i32 noundef %zid, i32 noundef %nr_pages) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_update_lru_size, %cleanup)) #23
          to label %if.end [label %cleanup], !srcloc !461

if.end:                                           ; preds = %entry
  %arrayidx1 = getelementptr %struct.mem_cgroup_per_node, ptr %lruvec, i32 0, i32 3, i32 %zid, i32 %lru
  %cmp = icmp slt i32 %nr_pages, 0
  %0 = ptrtoint ptr %arrayidx1 to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %arrayidx1, align 4
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %add = add i32 %1, %nr_pages
  %2 = ptrtoint ptr %arrayidx1 to i32
  call void @__asan_store4_noabort(i32 %2)
  store i32 %add, ptr %arrayidx1, align 4
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %3 = phi i32 [ %add, %if.then2 ], [ %1, %if.end ]
  %cmp4 = icmp slt i32 %3, 0
  br i1 %cmp4, label %land.rhs, label %if.end53

land.rhs:                                         ; preds = %if.end3
  %.b71 = load i1, ptr @mem_cgroup_update_lru_size.__already_done, align 1
  br i1 %.b71, label %do.body45, label %if.then11, !prof !460

if.then11:                                        ; preds = %land.rhs
  store i1 true, ptr @mem_cgroup_update_lru_size.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 1282, i32 noundef 9, ptr noundef nonnull @.str.5, ptr noundef nonnull @__func__.mem_cgroup_update_lru_size, ptr noundef %lruvec, i32 noundef %lru, i32 noundef %nr_pages, i32 noundef %3) #23
  br label %do.body45

do.body45:                                        ; preds = %if.then11, %land.rhs
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1283, 0\0A.popsection", ""() #23, !srcloc !487
  unreachable

if.end53:                                         ; preds = %if.end3
  %cmp54 = icmp sgt i32 %nr_pages, 0
  br i1 %cmp54, label %if.then55, label %cleanup

if.then55:                                        ; preds = %if.end53
  %add56 = add nuw i32 %3, %nr_pages
  %4 = ptrtoint ptr %arrayidx1 to i32
  call void @__asan_store4_noabort(i32 %4)
  store i32 %add56, ptr %arrayidx1, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.then55, %if.end53, %entry
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @warn_slowpath_fmt(ptr noundef, i32 noundef, i32 noundef, ptr noundef, ...) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mem_cgroup_print_oom_context(ptr noundef readonly %memcg, ptr noundef %p) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %3, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %entry
  %tobool.not = icmp eq ptr %memcg, null
  br i1 %tobool.not, label %do.end2, label %do.end

do.end:                                           ; preds = %rcu_read_lock.exit
  %call = tail call i32 (ptr, ...) @_printk(ptr noundef nonnull @.str.6) #25
  %4 = ptrtoint ptr %memcg to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %memcg, align 128
  %kn.i = getelementptr inbounds %struct.cgroup, ptr %5, i32 0, i32 11
  %6 = ptrtoint ptr %kn.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %kn.i, align 8
  tail call void @pr_cont_kernfs_path(ptr noundef %7) #23
  br label %if.end

do.end2:                                          ; preds = %rcu_read_lock.exit
  %call4 = tail call i32 (ptr, ...) @_printk(ptr noundef nonnull @.str.9) #25
  br label %if.end

if.end:                                           ; preds = %do.end2, %do.end
  %tobool5.not = icmp eq ptr %p, null
  br i1 %tobool5.not, label %if.end12, label %do.end8

do.end8:                                          ; preds = %if.end
  %call10 = tail call i32 (ptr, ...) @_printk(ptr noundef nonnull @.str.12) #25
  %cgroups.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 164
  %8 = ptrtoint ptr %cgroups.i.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load volatile ptr, ptr %cgroups.i.i, align 16
  %call.i.i.i = tail call i32 @lock_is_held_type(ptr noundef getelementptr inbounds (%struct.mutex, ptr @cgroup_mutex, i32 0, i32 5), i32 noundef -1) #23
  %tobool.not.i.i = icmp eq i32 %call.i.i.i, 0
  br i1 %tobool.not.i.i, label %lor.lhs.false.i.i, label %task_cgroup.exit

lor.lhs.false.i.i:                                ; preds = %do.end8
  %call.i2.i.i = tail call i32 @lock_is_held_type(ptr noundef getelementptr inbounds (%struct.spinlock, ptr @css_set_lock, i32 0, i32 0, i32 0, i32 4), i32 noundef -1) #23
  %tobool3.not.i.i = icmp eq i32 %call.i2.i.i, 0
  br i1 %tobool3.not.i.i, label %lor.lhs.false4.i.i, label %task_cgroup.exit

lor.lhs.false4.i.i:                               ; preds = %lor.lhs.false.i.i
  %flags.i.i = getelementptr inbounds %struct.task_struct, ptr %p, i32 0, i32 3
  %10 = ptrtoint ptr %flags.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %flags.i.i, align 4
  %and.i.i = and i32 %11, 4
  %tobool5.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool5.not.i.i, label %lor.lhs.false6.i.i, label %task_cgroup.exit

lor.lhs.false6.i.i:                               ; preds = %lor.lhs.false4.i.i
  %call7.i.i = tail call i32 @rcu_read_lock_held() #23
  %tobool8.not.i.i = icmp eq i32 %call7.i.i, 0
  br i1 %tobool8.not.i.i, label %land.lhs.true.i.i, label %task_cgroup.exit

land.lhs.true.i.i:                                ; preds = %lor.lhs.false6.i.i
  %call9.i.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool10.not.i.i = icmp eq i32 %call9.i.i, 0
  br i1 %tobool10.not.i.i, label %task_cgroup.exit, label %land.lhs.true11.i.i

land.lhs.true11.i.i:                              ; preds = %land.lhs.true.i.i
  %.b1.i.i = load i1, ptr @task_css.__warned, align 1
  br i1 %.b1.i.i, label %task_cgroup.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true11.i.i
  store i1 true, ptr @task_css.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.57, i32 noundef 494, ptr noundef nonnull @.str.2) #23
  br label %task_cgroup.exit

task_cgroup.exit:                                 ; preds = %if.then.i.i, %land.lhs.true11.i.i, %land.lhs.true.i.i, %lor.lhs.false6.i.i, %lor.lhs.false4.i.i, %lor.lhs.false.i.i, %do.end8
  %arrayidx.i.i = getelementptr [14 x ptr], ptr %9, i32 0, i32 4
  %12 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %arrayidx.i.i, align 4
  %14 = ptrtoint ptr %13 to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %13, align 8
  %kn.i15 = getelementptr inbounds %struct.cgroup, ptr %15, i32 0, i32 11
  %16 = ptrtoint ptr %kn.i15 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %kn.i15, align 8
  tail call void @pr_cont_kernfs_path(ptr noundef %17) #23
  br label %if.end12

if.end12:                                         ; preds = %task_cgroup.exit, %if.end
  %call.i16 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i16, label %rcu_read_unlock.exit, label %land.lhs.true.i19

land.lhs.true.i19:                                ; preds = %if.end12
  %call1.i17 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i18 = icmp eq i32 %call1.i17, 0
  br i1 %tobool.not.i18, label %rcu_read_unlock.exit, label %land.lhs.true2.i21

land.lhs.true2.i21:                               ; preds = %land.lhs.true.i19
  %.b4.i20 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i20, label %rcu_read_unlock.exit, label %if.then.i22

if.then.i22:                                      ; preds = %land.lhs.true2.i21
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i22, %land.lhs.true2.i21, %land.lhs.true.i19, %if.end12
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %18 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i23 = and i32 %18, -16384
  %19 = inttoptr i32 %and.i.i.i.i.i23 to ptr
  %preempt_count.i.i.i.i24 = getelementptr inbounds %struct.thread_info, ptr %19, i32 0, i32 1
  %20 = ptrtoint ptr %preempt_count.i.i.i.i24 to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load volatile i32, ptr %preempt_count.i.i.i.i24, align 4
  %sub.i.i.i = add i32 %21, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i24, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  ret void
}

; Function Attrs: cold null_pointer_is_valid
declare dso_local i32 @_printk(ptr noundef, ...) local_unnamed_addr #6

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mem_cgroup_print_oom_meminfo(ptr noundef %memcg) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %memory, i32 noundef 4) #23
  %0 = ptrtoint ptr %memory to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile i32, ptr %memory, align 4
  %conv = zext i32 %1 to i64
  %shl = shl nuw nsw i64 %conv, 2
  %max = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2, i32 4
  %2 = ptrtoint ptr %max to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %max, align 16
  %conv6 = zext i32 %3 to i64
  %shl7 = shl nuw nsw i64 %conv6, 2
  %failcnt = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2, i32 12
  %4 = ptrtoint ptr %failcnt to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %failcnt, align 16
  %call9 = tail call i32 (ptr, ...) @_printk(ptr noundef nonnull @.str.14, i64 noundef %shl, i64 noundef %shl7, i32 noundef %5) #25
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_print_oom_meminfo, %do.end33)) #23
          to label %do.end17 [label %do.end33], !srcloc !461

do.end17:                                         ; preds = %entry
  %6 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 3
  %call.i.i.i91 = tail call zeroext i1 @__kasan_check_read(ptr noundef %6, i32 noundef 4) #23
  %7 = ptrtoint ptr %6 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load volatile i32, ptr %6, align 4
  %conv20 = zext i32 %8 to i64
  %shl21 = shl nuw nsw i64 %conv20, 2
  %max26 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 3, i32 0, i32 4
  %9 = ptrtoint ptr %max26 to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load volatile i32, ptr %max26, align 8
  %conv27 = zext i32 %10 to i64
  %shl28 = shl nuw nsw i64 %conv27, 2
  %failcnt29 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 3, i32 0, i32 12
  %11 = ptrtoint ptr %failcnt29 to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %failcnt29, align 8
  %call30 = tail call i32 (ptr, ...) @_printk(ptr noundef nonnull @.str.17, i64 noundef %shl21, i64 noundef %shl28, i32 noundef %12) #25
  br label %do.end59

do.end33:                                         ; preds = %entry
  %13 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 3
  %call.i.i.i92 = tail call zeroext i1 @__kasan_check_read(ptr noundef %13, i32 noundef 4) #23
  %14 = ptrtoint ptr %13 to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %13, align 4
  %conv36 = zext i32 %15 to i64
  %shl37 = shl nuw nsw i64 %conv36, 2
  %max38 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 3, i32 0, i32 4
  %16 = ptrtoint ptr %max38 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %max38, align 8
  %conv39 = zext i32 %17 to i64
  %shl40 = shl nuw nsw i64 %conv39, 2
  %failcnt41 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 3, i32 0, i32 12
  %18 = ptrtoint ptr %failcnt41 to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %failcnt41, align 8
  %call42 = tail call i32 (ptr, ...) @_printk(ptr noundef nonnull @.str.20, i64 noundef %shl37, i64 noundef %shl40, i32 noundef %19) #25
  %kmem = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 4
  %call.i.i.i93 = tail call zeroext i1 @__kasan_check_read(ptr noundef %kmem, i32 noundef 4) #23
  %20 = ptrtoint ptr %kmem to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load volatile i32, ptr %kmem, align 4
  %conv48 = zext i32 %21 to i64
  %shl49 = shl nuw nsw i64 %conv48, 2
  %max51 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 4, i32 4
  %22 = ptrtoint ptr %max51 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load i32, ptr %max51, align 16
  %conv52 = zext i32 %23 to i64
  %shl53 = shl nuw nsw i64 %conv52, 2
  %failcnt55 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 4, i32 12
  %24 = ptrtoint ptr %failcnt55 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %failcnt55, align 16
  %call56 = tail call i32 (ptr, ...) @_printk(ptr noundef nonnull @.str.23, i64 noundef %shl49, i64 noundef %shl53, i32 noundef %25) #25
  br label %do.end59

do.end59:                                         ; preds = %do.end33, %do.end17
  %call61 = tail call i32 (ptr, ...) @_printk(ptr noundef nonnull @.str.26) #25
  %26 = ptrtoint ptr %memcg to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load ptr, ptr %memcg, align 128
  %kn.i = getelementptr inbounds %struct.cgroup, ptr %27, i32 0, i32 11
  %28 = ptrtoint ptr %kn.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load ptr, ptr %kn.i, align 8
  tail call void @pr_cont_kernfs_path(ptr noundef %29) #23
  %call66 = tail call i32 (ptr, ...) @_printk(ptr noundef nonnull @.str.29) #25
  %call67 = tail call fastcc ptr @memory_stat_format(ptr noundef %memcg)
  %tobool68.not = icmp eq ptr %call67, null
  br i1 %tobool68.not, label %cleanup, label %do.end73

do.end73:                                         ; preds = %do.end59
  %call75 = tail call i32 (ptr, ...) @_printk(ptr noundef nonnull @.str.32, ptr noundef nonnull %call67) #25
  tail call void @kfree(ptr noundef nonnull %call67) #23
  br label %cleanup

cleanup:                                          ; preds = %do.end73, %do.end59
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc ptr @memory_stat_format(ptr noundef %memcg) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %s = alloca %struct.seq_buf, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %s) #23
  %0 = getelementptr inbounds i8, ptr %s, i32 8
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_store8_noabort(i32 %1)
  store i64 -1, ptr %0, align 8
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 12) to i32))
  %2 = load ptr, ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 12), align 4
  %call7.i = tail call noalias align 8 ptr @kmem_cache_alloc_trace(ptr noundef %2, i32 noundef 3264, i32 noundef 4096) #26
  %3 = ptrtoint ptr %s to i32
  call void @__asan_store4_noabort(i32 %3)
  store ptr %call7.i, ptr %s, align 8
  %size1.i = getelementptr inbounds %struct.seq_buf, ptr %s, i32 0, i32 1
  %4 = ptrtoint ptr %size1.i to i32
  call void @__asan_store4_noabort(i32 %4)
  store i32 4096, ptr %size1.i, align 4
  %len.i.i = getelementptr inbounds %struct.seq_buf, ptr %s, i32 0, i32 2
  %5 = ptrtoint ptr %len.i.i to i32
  call void @__asan_store4_noabort(i32 %5)
  store i32 0, ptr %len.i.i, align 8
  %readpos.i.i = getelementptr inbounds %struct.seq_buf, ptr %s, i32 0, i32 3
  %6 = ptrtoint ptr %readpos.i.i to i32
  call void @__asan_store8_noabort(i32 %6)
  store i64 0, ptr %readpos.i.i, align 8
  %tobool.not = icmp eq ptr %call7.i, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @stats_flush_threshold, i32 noundef 4) #23
  %7 = load volatile i32, ptr @stats_flush_threshold, align 4
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @__num_online_cpus, i32 noundef 4) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__num_online_cpus to i32))
  %8 = load volatile i32, ptr @__num_online_cpus, align 4
  %cmp.i = icmp ugt i32 %7, %8
  br i1 %cmp.i, label %if.then.i, label %mem_cgroup_flush_stats.exit

if.then.i:                                        ; preds = %if.end
  tail call fastcc void @__mem_cgroup_flush_stats() #23
  br label %mem_cgroup_flush_stats.exit

mem_cgroup_flush_stats.exit:                      ; preds = %if.then.i, %if.end
  %vmstats.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 26
  %arrayidx.i.i114 = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 0, i32 5
  br label %for.body

for.body:                                         ; preds = %if.end14, %mem_cgroup_flush_stats.exit
  %i.0128 = phi i32 [ 0, %mem_cgroup_flush_stats.exit ], [ %inc, %if.end14 ]
  %arrayidx = getelementptr [26 x %struct.memory_stat], ptr @memory_stats, i32 0, i32 %i.0128
  %idx = getelementptr [26 x %struct.memory_stat], ptr @memory_stats, i32 0, i32 %i.0128, i32 1
  %9 = ptrtoint ptr %idx to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %idx, align 4
  %arrayidx.i.i = getelementptr [44 x i32], ptr %vmstats.i.i, i32 0, i32 %10
  %11 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %arrayidx.i.i, align 4
  switch i32 %10, label %sw.default.i.i [
    i32 42, label %memcg_page_state_output.exit
    i32 5, label %memcg_page_state_output.exit
    i32 6, label %memcg_page_state_output.exit
    i32 10, label %memcg_page_state_output.exit
    i32 11, label %memcg_page_state_output.exit
    i32 12, label %memcg_page_state_output.exit
    i32 13, label %memcg_page_state_output.exit
    i32 14, label %memcg_page_state_output.exit
    i32 15, label %memcg_page_state_output.exit
    i32 16, label %memcg_page_state_output.exit
    i32 37, label %sw.bb1.i.i
  ]

sw.bb1.i.i:                                       ; preds = %for.body
  br label %memcg_page_state_output.exit

sw.default.i.i:                                   ; preds = %for.body
  br label %memcg_page_state_output.exit

memcg_page_state_output.exit:                     ; preds = %sw.default.i.i, %sw.bb1.i.i, %for.body, %for.body, %for.body, %for.body, %for.body, %for.body, %for.body, %for.body, %for.body, %for.body
  %retval.0.i.i = phi i32 [ 4096, %sw.default.i.i ], [ 1024, %sw.bb1.i.i ], [ 1, %for.body ], [ 1, %for.body ], [ 1, %for.body ], [ 1, %for.body ], [ 1, %for.body ], [ 1, %for.body ], [ 1, %for.body ], [ 1, %for.body ], [ 1, %for.body ], [ 1, %for.body ]
  %mul.i = mul i32 %retval.0.i.i, %12
  %conv = zext i32 %mul.i to i64
  %13 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %arrayidx, align 4
  %call3 = call i32 (ptr, ptr, ...) @seq_buf_printf(ptr noundef nonnull %s, ptr noundef nonnull @.str.63, ptr noundef %14, i64 noundef %conv) #23
  %cmp6 = icmp eq i32 %i.0128, 18
  br i1 %cmp6, label %if.then10, label %if.end14, !prof !466

if.then10:                                        ; preds = %memcg_page_state_output.exit
  %15 = ptrtoint ptr %arrayidx.i.i114 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %arrayidx.i.i114, align 4
  %conv12 = zext i32 %16 to i64
  %add = add nuw nsw i64 %conv12, %conv
  %call13 = call i32 (ptr, ptr, ...) @seq_buf_printf(ptr noundef nonnull %s, ptr noundef nonnull @.str.64, i64 noundef %add) #23
  br label %if.end14

if.end14:                                         ; preds = %if.then10, %memcg_page_state_output.exit
  %inc = add nuw nsw i32 %i.0128, 1
  %exitcond.not = icmp eq i32 %inc, 26
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %if.end14
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 73) to i32))
  %17 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 73), align 4
  %arrayidx.i = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 1, i32 20
  %18 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load volatile i32, ptr %arrayidx.i, align 4
  %call17 = call i32 (ptr, ptr, ...) @seq_buf_printf(ptr noundef nonnull %s, ptr noundef nonnull @.str.65, ptr noundef %17, i32 noundef %19) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 74) to i32))
  %20 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 74), align 4
  %arrayidx.i117 = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 1, i32 21
  %21 = ptrtoint ptr %arrayidx.i117 to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load volatile i32, ptr %arrayidx.i117, align 4
  %call20 = call i32 (ptr, ptr, ...) @seq_buf_printf(ptr noundef nonnull %s, ptr noundef nonnull @.str.65, ptr noundef %20, i32 noundef %22) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 76) to i32))
  %23 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 76), align 4
  %arrayidx.i118 = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 1, i32 23
  %24 = ptrtoint ptr %arrayidx.i118 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load volatile i32, ptr %arrayidx.i118, align 4
  %call23 = call i32 (ptr, ptr, ...) @seq_buf_printf(ptr noundef nonnull %s, ptr noundef nonnull @.str.65, ptr noundef %23, i32 noundef %25) #23
  %arrayidx.i119 = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 1, i32 29
  %26 = ptrtoint ptr %arrayidx.i119 to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load volatile i32, ptr %arrayidx.i119, align 4
  %arrayidx.i120 = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 1, i32 30
  %28 = ptrtoint ptr %arrayidx.i120 to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %arrayidx.i120, align 4
  %add26 = add i32 %29, %27
  %call27 = call i32 (ptr, ptr, ...) @seq_buf_printf(ptr noundef nonnull %s, ptr noundef nonnull @.str.66, i32 noundef %add26) #23
  %arrayidx.i121 = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 1, i32 25
  %30 = ptrtoint ptr %arrayidx.i121 to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load volatile i32, ptr %arrayidx.i121, align 4
  %arrayidx.i122 = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 1, i32 26
  %32 = ptrtoint ptr %arrayidx.i122 to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load volatile i32, ptr %arrayidx.i122, align 4
  %add30 = add i32 %33, %31
  %call31 = call i32 (ptr, ptr, ...) @seq_buf_printf(ptr noundef nonnull %s, ptr noundef nonnull @.str.67, i32 noundef %add30) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 70) to i32))
  %34 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 70), align 4
  %arrayidx.i123 = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 1, i32 17
  %35 = ptrtoint ptr %arrayidx.i123 to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load volatile i32, ptr %arrayidx.i123, align 4
  %call34 = call i32 (ptr, ptr, ...) @seq_buf_printf(ptr noundef nonnull %s, ptr noundef nonnull @.str.65, ptr noundef %34, i32 noundef %36) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 71) to i32))
  %37 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 71), align 4
  %arrayidx.i124 = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 1, i32 18
  %38 = ptrtoint ptr %arrayidx.i124 to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load volatile i32, ptr %arrayidx.i124, align 4
  %call37 = call i32 (ptr, ptr, ...) @seq_buf_printf(ptr noundef nonnull %s, ptr noundef nonnull @.str.65, ptr noundef %37, i32 noundef %39) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 72) to i32))
  %40 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 72), align 4
  %arrayidx.i125 = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 1, i32 19
  %41 = ptrtoint ptr %arrayidx.i125 to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load volatile i32, ptr %arrayidx.i125, align 4
  %call40 = call i32 (ptr, ptr, ...) @seq_buf_printf(ptr noundef nonnull %s, ptr noundef nonnull @.str.65, ptr noundef %40, i32 noundef %42) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 75) to i32))
  %43 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 75), align 4
  %arrayidx.i126 = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 1, i32 22
  %44 = ptrtoint ptr %arrayidx.i126 to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load volatile i32, ptr %arrayidx.i126, align 4
  %call43 = call i32 (ptr, ptr, ...) @seq_buf_printf(ptr noundef nonnull %s, ptr noundef nonnull @.str.65, ptr noundef %43, i32 noundef %45) #23
  %46 = ptrtoint ptr %len.i.i to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load i32, ptr %len.i.i, align 8
  %48 = ptrtoint ptr %size1.i to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load i32, ptr %size1.i, align 4
  %cmp.i127 = icmp ugt i32 %47, %49
  br i1 %cmp.i127, label %land.rhs, label %if.end82

land.rhs:                                         ; preds = %for.end
  %.b112 = load i1, ptr @memory_stat_format.__already_done, align 1
  br i1 %.b112, label %if.end82, label %if.then60, !prof !460

if.then60:                                        ; preds = %land.rhs
  store i1 true, ptr @memory_stat_format.__already_done, align 1
  call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 1502, i32 noundef 9, ptr noundef null) #23
  br label %if.end82

if.end82:                                         ; preds = %if.then60, %land.rhs, %for.end
  %50 = ptrtoint ptr %s to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load ptr, ptr %s, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end82, %entry
  %retval.0 = phi ptr [ %51, %if.end82 ], [ null, %entry ]
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %s) #23
  ret ptr %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @kfree(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @mem_cgroup_get_max(ptr noundef %memcg) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %max1 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2, i32 4
  %0 = ptrtoint ptr %max1 to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile i32, ptr %max1, align 16
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_get_max, %if.else)) #23
          to label %if.then [label %if.else], !srcloc !461

if.then:                                          ; preds = %entry
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_get_max, %if.end.i)) #23
          to label %mem_cgroup_swappiness.exit [label %if.end.i], !srcloc !461

if.end.i:                                         ; preds = %if.then
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_get_max, %mem_cgroup_swappiness.exit)) #23
          to label %lor.lhs.false.i [label %mem_cgroup_swappiness.exit], !srcloc !461

lor.lhs.false.i:                                  ; preds = %if.end.i
  %2 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i = icmp eq ptr %2, %memcg
  %swappiness.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 12
  %spec.select.i = select i1 %cmp.i.i, ptr @vm_swappiness, ptr %swappiness.i
  br label %mem_cgroup_swappiness.exit

mem_cgroup_swappiness.exit:                       ; preds = %lor.lhs.false.i, %if.end.i, %if.then
  %retval.0.in.i = phi ptr [ %spec.select.i, %lor.lhs.false.i ], [ @vm_swappiness, %if.then ], [ @vm_swappiness, %if.end.i ]
  %3 = ptrtoint ptr %retval.0.in.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %retval.0.i45 = load i32, ptr %retval.0.in.i, align 4
  %tobool7.not = icmp eq i32 %retval.0.i45, 0
  br i1 %tobool7.not, label %if.end31, label %if.then8

if.then8:                                         ; preds = %mem_cgroup_swappiness.exit
  %max13 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 3, i32 0, i32 4
  %4 = ptrtoint ptr %max13 to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %max13, align 8
  br label %if.end31.sink.split

if.else:                                          ; preds = %entry
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_get_max, %if.end.i46)) #23
          to label %mem_cgroup_swappiness.exit53 [label %if.end.i46], !srcloc !461

if.end.i46:                                       ; preds = %if.else
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_get_max, %mem_cgroup_swappiness.exit53)) #23
          to label %lor.lhs.false.i50 [label %mem_cgroup_swappiness.exit53], !srcloc !461

lor.lhs.false.i50:                                ; preds = %if.end.i46
  %6 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i47 = icmp eq ptr %6, %memcg
  %swappiness.i48 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 12
  %spec.select.i49 = select i1 %cmp.i.i47, ptr @vm_swappiness, ptr %swappiness.i48
  br label %mem_cgroup_swappiness.exit53

mem_cgroup_swappiness.exit53:                     ; preds = %lor.lhs.false.i50, %if.end.i46, %if.else
  %retval.0.in.i51 = phi ptr [ %spec.select.i49, %lor.lhs.false.i50 ], [ @vm_swappiness, %if.else ], [ @vm_swappiness, %if.end.i46 ]
  %7 = ptrtoint ptr %retval.0.in.i51 to i32
  call void @__asan_load4_noabort(i32 %7)
  %retval.0.i52 = load i32, ptr %retval.0.in.i51, align 4
  %tobool16.not = icmp eq i32 %retval.0.i52, 0
  br i1 %tobool16.not, label %if.end31, label %if.then17

if.then17:                                        ; preds = %mem_cgroup_swappiness.exit53
  %max22 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 3, i32 0, i32 4
  %8 = ptrtoint ptr %max22 to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load volatile i32, ptr %max22, align 8
  %sub = sub i32 %9, %1
  br label %if.end31.sink.split

if.end31.sink.split:                              ; preds = %if.then17, %if.then8
  %sub.sink = phi i32 [ %sub, %if.then17 ], [ %5, %if.then8 ]
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @total_swap_pages to i32))
  %10 = load i32, ptr @total_swap_pages, align 4
  %11 = tail call i32 @llvm.umin.i32(i32 %sub.sink, i32 %10)
  %add29 = add i32 %11, %1
  br label %if.end31

if.end31:                                         ; preds = %if.end31.sink.split, %mem_cgroup_swappiness.exit53, %mem_cgroup_swappiness.exit
  %max.0 = phi i32 [ %1, %mem_cgroup_swappiness.exit ], [ %1, %mem_cgroup_swappiness.exit53 ], [ %add29, %if.end31.sink.split ]
  ret i32 %max.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @mem_cgroup_size(ptr noundef %memcg) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %memory, i32 noundef 4) #23
  %0 = ptrtoint ptr %memory to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile i32, ptr %memory, align 4
  ret i32 %1
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local zeroext i1 @mem_cgroup_oom_synchronize(i1 noundef zeroext %handle) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %owait = alloca %struct.oom_wait_info, align 4
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i to ptr
  %task = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 2
  %2 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %task, align 8
  %memcg_in_oom = getelementptr inbounds %struct.task_struct, ptr %3, i32 0, i32 202
  %4 = ptrtoint ptr %memcg_in_oom to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %memcg_in_oom, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %owait) #23
  %6 = getelementptr inbounds %struct.oom_wait_info, ptr %owait, i32 0, i32 1
  %7 = getelementptr inbounds %struct.oom_wait_info, ptr %owait, i32 0, i32 1, i32 1
  %8 = getelementptr inbounds %struct.oom_wait_info, ptr %owait, i32 0, i32 1, i32 2
  %9 = getelementptr inbounds %struct.oom_wait_info, ptr %owait, i32 0, i32 1, i32 3
  %10 = getelementptr inbounds %struct.oom_wait_info, ptr %owait, i32 0, i32 1, i32 3, i32 1
  %tobool.not = icmp eq ptr %5, null
  %11 = call ptr @memset(ptr %owait, i32 255, i32 24)
  br i1 %tobool.not, label %cleanup34, label %if.end

if.end:                                           ; preds = %entry
  br i1 %handle, label %if.end3, label %cleanup

if.end3:                                          ; preds = %if.end
  %12 = ptrtoint ptr %owait to i32
  call void @__asan_store4_noabort(i32 %12)
  store ptr %5, ptr %owait, align 4
  %13 = ptrtoint ptr %6 to i32
  call void @__asan_store4_noabort(i32 %13)
  store i32 0, ptr %6, align 4
  %14 = ptrtoint ptr %8 to i32
  call void @__asan_store4_noabort(i32 %14)
  store ptr @memcg_oom_wake_function, ptr %8, align 4
  %15 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %task, align 8
  %17 = ptrtoint ptr %7 to i32
  call void @__asan_store4_noabort(i32 %17)
  store ptr %16, ptr %7, align 4
  %18 = ptrtoint ptr %9 to i32
  call void @__asan_store4_noabort(i32 %18)
  store volatile ptr %9, ptr %9, align 4
  %19 = ptrtoint ptr %10 to i32
  call void @__asan_store4_noabort(i32 %19)
  store ptr %9, ptr %10, align 4
  call void @prepare_to_wait(ptr noundef nonnull @memcg_oom_waitq, ptr noundef %6, i32 noundef 258) #23
  call void @_raw_spin_lock(ptr noundef nonnull @memcg_oom_lock) #23
  %call.i = call ptr @mem_cgroup_iter(ptr noundef nonnull %5, ptr noundef null, ptr noundef null) #23
  %cmp.not5.i = icmp eq ptr %call.i, null
  br i1 %cmp.not5.i, label %mem_cgroup_mark_under_oom.exit, label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %if.end3
  %iter.06.i = phi ptr [ %call1.i, %for.body.i ], [ %call.i, %if.end3 ]
  %under_oom.i = getelementptr inbounds %struct.mem_cgroup, ptr %iter.06.i, i32 0, i32 11
  %20 = ptrtoint ptr %under_oom.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %under_oom.i, align 16
  %inc.i = add i32 %21, 1
  store i32 %inc.i, ptr %under_oom.i, align 16
  %call1.i = call ptr @mem_cgroup_iter(ptr noundef %5, ptr noundef nonnull %iter.06.i, ptr noundef null) #23
  %cmp.not.i = icmp eq ptr %call1.i, null
  br i1 %cmp.not.i, label %mem_cgroup_mark_under_oom.exit, label %for.body.i

mem_cgroup_mark_under_oom.exit:                   ; preds = %for.body.i, %if.end3
  call void @_raw_spin_unlock(ptr noundef nonnull @memcg_oom_lock) #23
  %call12 = call fastcc zeroext i1 @mem_cgroup_oom_trylock(ptr noundef nonnull %5)
  br i1 %call12, label %if.then15, label %cleanup.critedge

if.then15:                                        ; preds = %mem_cgroup_mark_under_oom.exit
  %call.i51 = call ptr @mem_cgroup_iter(ptr noundef %5, ptr noundef null, ptr noundef null) #23
  %cmp.not6.i = icmp eq ptr %call.i51, null
  br i1 %cmp.not6.i, label %mem_cgroup_oom_notify.exit, label %for.body.i52

for.body.i52:                                     ; preds = %mem_cgroup_oom_notify_cb.exit.i, %if.then15
  %iter.07.i = phi ptr [ %call2.i, %mem_cgroup_oom_notify_cb.exit.i ], [ %call.i51, %if.then15 ]
  call void @_raw_spin_lock(ptr noundef nonnull @memcg_oom_lock) #23
  %oom_notify.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %iter.07.i, i32 0, i32 20
  %22 = ptrtoint ptr %oom_notify.i.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %ev.01.i.i = load ptr, ptr %oom_notify.i.i, align 4
  %cmp.not2.i.i = icmp eq ptr %ev.01.i.i, %oom_notify.i.i
  br i1 %cmp.not2.i.i, label %mem_cgroup_oom_notify_cb.exit.i, label %for.body.i.i

for.body.i.i:                                     ; preds = %for.body.i.i, %for.body.i52
  %ev.03.i.i = phi ptr [ %ev.0.i.i, %for.body.i.i ], [ %ev.01.i.i, %for.body.i52 ]
  %eventfd.i.i = getelementptr inbounds %struct.mem_cgroup_eventfd_list, ptr %ev.03.i.i, i32 0, i32 1
  %23 = ptrtoint ptr %eventfd.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %eventfd.i.i, align 4
  %call.i.i = call i64 @eventfd_signal(ptr noundef %24, i64 noundef 1) #23
  %25 = ptrtoint ptr %ev.03.i.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %ev.0.i.i = load ptr, ptr %ev.03.i.i, align 4
  %cmp.not.i.i = icmp eq ptr %ev.0.i.i, %oom_notify.i.i
  br i1 %cmp.not.i.i, label %mem_cgroup_oom_notify_cb.exit.i, label %for.body.i.i

mem_cgroup_oom_notify_cb.exit.i:                  ; preds = %for.body.i.i, %for.body.i52
  call void @_raw_spin_unlock(ptr noundef nonnull @memcg_oom_lock) #23
  %call2.i = call ptr @mem_cgroup_iter(ptr noundef %5, ptr noundef nonnull %iter.07.i, ptr noundef null) #23
  %cmp.not.i53 = icmp eq ptr %call2.i, null
  br i1 %cmp.not.i53, label %mem_cgroup_oom_notify.exit, label %for.body.i52

mem_cgroup_oom_notify.exit:                       ; preds = %mem_cgroup_oom_notify_cb.exit.i, %if.then15
  %oom_kill_disable = getelementptr inbounds %struct.mem_cgroup, ptr %5, i32 0, i32 13
  %26 = ptrtoint ptr %oom_kill_disable to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %oom_kill_disable, align 8
  %tobool18.not = icmp eq i32 %27, 0
  br i1 %tobool18.not, label %if.then19, label %if.then29.critedge50

if.then19:                                        ; preds = %mem_cgroup_oom_notify.exit
  call void @_raw_spin_lock(ptr noundef nonnull @memcg_oom_lock) #23
  %call.i54 = call ptr @mem_cgroup_iter(ptr noundef %5, ptr noundef null, ptr noundef null) #23
  %cmp.not8.i = icmp eq ptr %call.i54, null
  br i1 %cmp.not8.i, label %mem_cgroup_unmark_under_oom.exit, label %for.body.i56

for.body.i56:                                     ; preds = %for.inc.i, %if.then19
  %iter.09.i = phi ptr [ %call3.i, %for.inc.i ], [ %call.i54, %if.then19 ]
  %under_oom.i55 = getelementptr inbounds %struct.mem_cgroup, ptr %iter.09.i, i32 0, i32 11
  %28 = ptrtoint ptr %under_oom.i55 to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %under_oom.i55, align 16
  %cmp1.i = icmp sgt i32 %29, 0
  br i1 %cmp1.i, label %if.then.i, label %for.inc.i

if.then.i:                                        ; preds = %for.body.i56
  %dec.i = add nsw i32 %29, -1
  %30 = ptrtoint ptr %under_oom.i55 to i32
  call void @__asan_store4_noabort(i32 %30)
  store i32 %dec.i, ptr %under_oom.i55, align 16
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then.i, %for.body.i56
  %call3.i = call ptr @mem_cgroup_iter(ptr noundef %5, ptr noundef nonnull %iter.09.i, ptr noundef null) #23
  %cmp.not.i57 = icmp eq ptr %call3.i, null
  br i1 %cmp.not.i57, label %mem_cgroup_unmark_under_oom.exit, label %for.body.i56

mem_cgroup_unmark_under_oom.exit:                 ; preds = %for.inc.i, %if.then19
  call void @_raw_spin_unlock(ptr noundef nonnull @memcg_oom_lock) #23
  call void @finish_wait(ptr noundef nonnull @memcg_oom_waitq, ptr noundef %6) #23
  %31 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %task, align 8
  %memcg_oom_gfp_mask = getelementptr inbounds %struct.task_struct, ptr %32, i32 0, i32 203
  %33 = ptrtoint ptr %memcg_oom_gfp_mask to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %memcg_oom_gfp_mask, align 4
  %memcg_oom_order = getelementptr inbounds %struct.task_struct, ptr %32, i32 0, i32 204
  %35 = ptrtoint ptr %memcg_oom_order to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %memcg_oom_order, align 32
  %call25 = call fastcc zeroext i1 @mem_cgroup_out_of_memory(ptr noundef nonnull %5, i32 noundef %34, i32 noundef %36)
  br label %if.then29

if.then29.critedge50:                             ; preds = %mem_cgroup_oom_notify.exit
  call void @schedule() #23
  call void @_raw_spin_lock(ptr noundef nonnull @memcg_oom_lock) #23
  %call.i58 = call ptr @mem_cgroup_iter(ptr noundef %5, ptr noundef null, ptr noundef null) #23
  %cmp.not8.i59 = icmp eq ptr %call.i58, null
  br i1 %cmp.not8.i59, label %mem_cgroup_unmark_under_oom.exit69, label %for.body.i63

for.body.i63:                                     ; preds = %for.inc.i68, %if.then29.critedge50
  %iter.09.i60 = phi ptr [ %call3.i66, %for.inc.i68 ], [ %call.i58, %if.then29.critedge50 ]
  %under_oom.i61 = getelementptr inbounds %struct.mem_cgroup, ptr %iter.09.i60, i32 0, i32 11
  %37 = ptrtoint ptr %under_oom.i61 to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %under_oom.i61, align 16
  %cmp1.i62 = icmp sgt i32 %38, 0
  br i1 %cmp1.i62, label %if.then.i65, label %for.inc.i68

if.then.i65:                                      ; preds = %for.body.i63
  %dec.i64 = add nsw i32 %38, -1
  %39 = ptrtoint ptr %under_oom.i61 to i32
  call void @__asan_store4_noabort(i32 %39)
  store i32 %dec.i64, ptr %under_oom.i61, align 16
  br label %for.inc.i68

for.inc.i68:                                      ; preds = %if.then.i65, %for.body.i63
  %call3.i66 = call ptr @mem_cgroup_iter(ptr noundef %5, ptr noundef nonnull %iter.09.i60, ptr noundef null) #23
  %cmp.not.i67 = icmp eq ptr %call3.i66, null
  br i1 %cmp.not.i67, label %mem_cgroup_unmark_under_oom.exit69, label %for.body.i63

mem_cgroup_unmark_under_oom.exit69:               ; preds = %for.inc.i68, %if.then29.critedge50
  call void @_raw_spin_unlock(ptr noundef nonnull @memcg_oom_lock) #23
  call void @finish_wait(ptr noundef nonnull @memcg_oom_waitq, ptr noundef %6) #23
  br label %if.then29

if.then29:                                        ; preds = %mem_cgroup_unmark_under_oom.exit69, %mem_cgroup_unmark_under_oom.exit
  call void @_raw_spin_lock(ptr noundef nonnull @memcg_oom_lock) #23
  %40 = call ptr @llvm.returnaddress(i32 0) #23
  %41 = ptrtoint ptr %40 to i32
  call void @lock_release(ptr noundef nonnull @memcg_oom_lock_dep_map, i32 noundef %41) #23
  %call.i70 = call ptr @mem_cgroup_iter(ptr noundef %5, ptr noundef null, ptr noundef null) #23
  %cmp.not5.i71 = icmp eq ptr %call.i70, null
  br i1 %cmp.not5.i71, label %land.lhs.true.i, label %for.body.i75

for.body.i75:                                     ; preds = %for.body.i75, %if.then29
  %iter.06.i72 = phi ptr [ %call1.i73, %for.body.i75 ], [ %call.i70, %if.then29 ]
  %oom_lock.i = getelementptr inbounds %struct.mem_cgroup, ptr %iter.06.i72, i32 0, i32 10
  %42 = ptrtoint ptr %oom_lock.i to i32
  call void @__asan_store1_noabort(i32 %42)
  store i8 0, ptr %oom_lock.i, align 1
  %call1.i73 = call ptr @mem_cgroup_iter(ptr noundef %5, ptr noundef nonnull %iter.06.i72, ptr noundef null) #23
  %cmp.not.i74 = icmp eq ptr %call1.i73, null
  br i1 %cmp.not.i74, label %land.lhs.true.i, label %for.body.i75

land.lhs.true.i:                                  ; preds = %for.body.i75, %if.then29
  call void @_raw_spin_unlock(ptr noundef nonnull @memcg_oom_lock) #23
  %under_oom.i76 = getelementptr inbounds %struct.mem_cgroup, ptr %5, i32 0, i32 11
  %43 = ptrtoint ptr %under_oom.i76 to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load i32, ptr %under_oom.i76, align 16
  %tobool1.not.i = icmp eq i32 %44, 0
  br i1 %tobool1.not.i, label %cleanup, label %if.then.i77

if.then.i77:                                      ; preds = %land.lhs.true.i
  call void @__wake_up(ptr noundef nonnull @memcg_oom_waitq, i32 noundef 3, i32 noundef 0, ptr noundef nonnull %5) #23
  br label %cleanup

cleanup.critedge:                                 ; preds = %mem_cgroup_mark_under_oom.exit
  call void @schedule() #23
  call void @_raw_spin_lock(ptr noundef nonnull @memcg_oom_lock) #23
  %call.i78 = call ptr @mem_cgroup_iter(ptr noundef %5, ptr noundef null, ptr noundef null) #23
  %cmp.not8.i79 = icmp eq ptr %call.i78, null
  br i1 %cmp.not8.i79, label %mem_cgroup_unmark_under_oom.exit89, label %for.body.i83

for.body.i83:                                     ; preds = %for.inc.i88, %cleanup.critedge
  %iter.09.i80 = phi ptr [ %call3.i86, %for.inc.i88 ], [ %call.i78, %cleanup.critedge ]
  %under_oom.i81 = getelementptr inbounds %struct.mem_cgroup, ptr %iter.09.i80, i32 0, i32 11
  %45 = ptrtoint ptr %under_oom.i81 to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load i32, ptr %under_oom.i81, align 16
  %cmp1.i82 = icmp sgt i32 %46, 0
  br i1 %cmp1.i82, label %if.then.i85, label %for.inc.i88

if.then.i85:                                      ; preds = %for.body.i83
  %dec.i84 = add nsw i32 %46, -1
  %47 = ptrtoint ptr %under_oom.i81 to i32
  call void @__asan_store4_noabort(i32 %47)
  store i32 %dec.i84, ptr %under_oom.i81, align 16
  br label %for.inc.i88

for.inc.i88:                                      ; preds = %if.then.i85, %for.body.i83
  %call3.i86 = call ptr @mem_cgroup_iter(ptr noundef %5, ptr noundef nonnull %iter.09.i80, ptr noundef null) #23
  %cmp.not.i87 = icmp eq ptr %call3.i86, null
  br i1 %cmp.not.i87, label %mem_cgroup_unmark_under_oom.exit89, label %for.body.i83

mem_cgroup_unmark_under_oom.exit89:               ; preds = %for.inc.i88, %cleanup.critedge
  call void @_raw_spin_unlock(ptr noundef nonnull @memcg_oom_lock) #23
  call void @finish_wait(ptr noundef nonnull @memcg_oom_waitq, ptr noundef %6) #23
  br label %cleanup

cleanup:                                          ; preds = %mem_cgroup_unmark_under_oom.exit89, %if.then.i77, %land.lhs.true.i, %if.end
  %48 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load ptr, ptr %task, align 8
  %memcg_in_oom33 = getelementptr inbounds %struct.task_struct, ptr %49, i32 0, i32 202
  %50 = ptrtoint ptr %memcg_in_oom33 to i32
  call void @__asan_store4_noabort(i32 %50)
  store ptr null, ptr %memcg_in_oom33, align 8
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %5, i32 0, i32 7
  %51 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load i32, ptr %flags.i, align 4
  %and.i90 = and i32 %52, 1
  %tobool.not.i91 = icmp eq i32 %and.i90, 0
  br i1 %tobool.not.i91, label %if.then.i92, label %cleanup34

if.then.i92:                                      ; preds = %cleanup
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %5, i32 0, i32 2
  call fastcc void @percpu_ref_put(ptr noundef %refcnt.i) #23
  br label %cleanup34

cleanup34:                                        ; preds = %if.then.i92, %cleanup, %entry
  %53 = xor i1 %tobool.not, true
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %owait) #23
  ret i1 %53
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memcg_oom_wake_function(ptr noundef %wait, i32 noundef %mode, i32 noundef %sync, ptr noundef %arg) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %wait, i32 -4
  %0 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %add.ptr, align 4
  %cmp.i = icmp eq ptr %1, %arg
  br i1 %cmp.i, label %if.end, label %if.end.i

if.end.i:                                         ; preds = %entry
  %2 = ptrtoint ptr %arg to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %arg, align 128
  %4 = ptrtoint ptr %1 to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %1, align 128
  %root.i.i = getelementptr inbounds %struct.cgroup, ptr %3, i32 0, i32 19
  %6 = ptrtoint ptr %root.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %root.i.i, align 4
  %root1.i.i = getelementptr inbounds %struct.cgroup, ptr %5, i32 0, i32 19
  %8 = ptrtoint ptr %root1.i.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %root1.i.i, align 4
  %cmp.not.i.i = icmp eq ptr %7, %9
  br i1 %cmp.not.i.i, label %lor.lhs.false.i.i, label %if.end.i13

lor.lhs.false.i.i:                                ; preds = %if.end.i
  %level.i.i = getelementptr inbounds %struct.cgroup, ptr %3, i32 0, i32 2
  %10 = ptrtoint ptr %level.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %level.i.i, align 4
  %level2.i.i = getelementptr inbounds %struct.cgroup, ptr %5, i32 0, i32 2
  %12 = ptrtoint ptr %level2.i.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %level2.i.i, align 4
  %cmp3.i.i = icmp slt i32 %11, %13
  br i1 %cmp3.i.i, label %if.end.i13, label %mem_cgroup_is_descendant.exit

mem_cgroup_is_descendant.exit:                    ; preds = %lor.lhs.false.i.i
  %arrayidx.i.i = getelementptr %struct.cgroup, ptr %3, i32 0, i32 37, i32 %13
  %14 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load8_noabort(i32 %14)
  %15 = load i64, ptr %arrayidx.i.i, align 8
  %kn.i.i.i = getelementptr inbounds %struct.cgroup, ptr %5, i32 0, i32 11
  %16 = ptrtoint ptr %kn.i.i.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %kn.i.i.i, align 8
  %id.i.i.i = getelementptr inbounds %struct.kernfs_node, ptr %17, i32 0, i32 10
  %18 = ptrtoint ptr %id.i.i.i to i32
  call void @__asan_load8_noabort(i32 %18)
  %19 = load i64, ptr %id.i.i.i, align 8
  %cmp5.i.i = icmp eq i64 %15, %19
  br i1 %cmp5.i.i, label %if.end, label %if.end.i13

if.end.i13:                                       ; preds = %mem_cgroup_is_descendant.exit, %lor.lhs.false.i.i, %if.end.i
  %20 = ptrtoint ptr %1 to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %1, align 128
  %22 = ptrtoint ptr %arg to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %arg, align 128
  %root.i.i10 = getelementptr inbounds %struct.cgroup, ptr %21, i32 0, i32 19
  %24 = ptrtoint ptr %root.i.i10 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %root.i.i10, align 4
  %root1.i.i11 = getelementptr inbounds %struct.cgroup, ptr %23, i32 0, i32 19
  %26 = ptrtoint ptr %root1.i.i11 to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load ptr, ptr %root1.i.i11, align 4
  %cmp.not.i.i12 = icmp eq ptr %25, %27
  br i1 %cmp.not.i.i12, label %lor.lhs.false.i.i17, label %cleanup

lor.lhs.false.i.i17:                              ; preds = %if.end.i13
  %level.i.i14 = getelementptr inbounds %struct.cgroup, ptr %21, i32 0, i32 2
  %28 = ptrtoint ptr %level.i.i14 to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %level.i.i14, align 4
  %level2.i.i15 = getelementptr inbounds %struct.cgroup, ptr %23, i32 0, i32 2
  %30 = ptrtoint ptr %level2.i.i15 to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load i32, ptr %level2.i.i15, align 4
  %cmp3.i.i16 = icmp slt i32 %29, %31
  br i1 %cmp3.i.i16, label %cleanup, label %mem_cgroup_is_descendant.exit24

mem_cgroup_is_descendant.exit24:                  ; preds = %lor.lhs.false.i.i17
  %arrayidx.i.i18 = getelementptr %struct.cgroup, ptr %21, i32 0, i32 37, i32 %31
  %32 = ptrtoint ptr %arrayidx.i.i18 to i32
  call void @__asan_load8_noabort(i32 %32)
  %33 = load i64, ptr %arrayidx.i.i18, align 8
  %kn.i.i.i19 = getelementptr inbounds %struct.cgroup, ptr %23, i32 0, i32 11
  %34 = ptrtoint ptr %kn.i.i.i19 to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load ptr, ptr %kn.i.i.i19, align 8
  %id.i.i.i20 = getelementptr inbounds %struct.kernfs_node, ptr %35, i32 0, i32 10
  %36 = ptrtoint ptr %id.i.i.i20 to i32
  call void @__asan_load8_noabort(i32 %36)
  %37 = load i64, ptr %id.i.i.i20, align 8
  %cmp5.i.i21 = icmp eq i64 %33, %37
  br i1 %cmp5.i.i21, label %if.end, label %cleanup

if.end:                                           ; preds = %mem_cgroup_is_descendant.exit24, %mem_cgroup_is_descendant.exit, %entry
  %call2 = tail call i32 @autoremove_wake_function(ptr noundef %wait, i32 noundef %mode, i32 noundef %sync, ptr noundef %arg) #23
  br label %cleanup

cleanup:                                          ; preds = %if.end, %mem_cgroup_is_descendant.exit24, %lor.lhs.false.i.i17, %if.end.i13
  %retval.0 = phi i32 [ %call2, %if.end ], [ 0, %mem_cgroup_is_descendant.exit24 ], [ 0, %lor.lhs.false.i.i17 ], [ 0, %if.end.i13 ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @prepare_to_wait(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc zeroext i1 @mem_cgroup_oom_trylock(ptr noundef %memcg) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call void @_raw_spin_lock(ptr noundef nonnull @memcg_oom_lock) #23
  %call = tail call ptr @mem_cgroup_iter(ptr noundef %memcg, ptr noundef null, ptr noundef null)
  %cmp.not59 = icmp eq ptr %call, null
  br i1 %cmp.not59, label %if.else16, label %for.body

for.body:                                         ; preds = %if.else, %entry
  %iter.060 = phi ptr [ %call2, %if.else ], [ %call, %entry ]
  %oom_lock = getelementptr inbounds %struct.mem_cgroup, ptr %iter.060, i32 0, i32 10
  %0 = ptrtoint ptr %oom_lock to i32
  call void @__asan_load1_noabort(i32 %0)
  %1 = load i8, ptr %oom_lock, align 1, !range !488
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %for.body
  %tobool.not.i = icmp eq ptr %memcg, null
  br i1 %tobool.not.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then
  %2 = load ptr, ptr @root_mem_cgroup, align 4
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.then
  %root.addr.0.i = phi ptr [ %memcg, %if.then ], [ %2, %if.then.i ]
  %cmp.not.i = icmp eq ptr %root.addr.0.i, %iter.060
  br i1 %cmp.not.i, label %if.then4, label %if.then2.i

if.then2.i:                                       ; preds = %if.end.i
  %flags.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %iter.060, i32 0, i32 7
  %3 = ptrtoint ptr %flags.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %flags.i.i, align 4
  %and.i.i = and i32 %4, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.then.i.i, label %if.then4

if.then.i.i:                                      ; preds = %if.then2.i
  %refcnt.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %iter.060, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i.i) #23
  br label %if.then4

if.else:                                          ; preds = %for.body
  %5 = ptrtoint ptr %oom_lock to i32
  call void @__asan_store1_noabort(i32 %5)
  store i8 1, ptr %oom_lock, align 1
  %call2 = tail call ptr @mem_cgroup_iter(ptr noundef %memcg, ptr noundef nonnull %iter.060, ptr noundef null)
  %cmp.not = icmp eq ptr %call2, null
  br i1 %cmp.not, label %if.else16, label %for.body

if.then4:                                         ; preds = %if.then.i.i, %if.then2.i, %if.end.i
  %call5 = tail call ptr @mem_cgroup_iter(ptr noundef %memcg, ptr noundef null, ptr noundef null)
  %cmp7.not62 = icmp eq ptr %call5, null
  br i1 %cmp7.not62, label %if.end17, label %for.body8

for.body8:                                        ; preds = %if.end11, %if.then4
  %iter.163 = phi ptr [ %call14, %if.end11 ], [ %call5, %if.then4 ]
  %cmp9 = icmp eq ptr %iter.163, %iter.060
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %for.body8
  br i1 %tobool.not.i, label %if.then.i37, label %if.end.i42

if.then.i37:                                      ; preds = %if.then10
  %6 = load ptr, ptr @root_mem_cgroup, align 4
  br label %if.end.i42

if.end.i42:                                       ; preds = %if.then.i37, %if.then10
  %root.addr.0.i38 = phi ptr [ %memcg, %if.then10 ], [ %6, %if.then.i37 ]
  %cmp.not.i40 = icmp eq ptr %root.addr.0.i38, %iter.060
  br i1 %cmp.not.i40, label %if.end17, label %if.then2.i46

if.then2.i46:                                     ; preds = %if.end.i42
  %flags.i.i43 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %iter.060, i32 0, i32 7
  %7 = ptrtoint ptr %flags.i.i43 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %flags.i.i43, align 4
  %and.i.i44 = and i32 %8, 1
  %tobool.not.i.i45 = icmp eq i32 %and.i.i44, 0
  br i1 %tobool.not.i.i45, label %if.then.i.i48, label %if.end17

if.then.i.i48:                                    ; preds = %if.then2.i46
  %refcnt.i.i47 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %iter.060, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i.i47) #23
  br label %if.end17

if.end11:                                         ; preds = %for.body8
  %oom_lock12 = getelementptr inbounds %struct.mem_cgroup, ptr %iter.163, i32 0, i32 10
  %9 = ptrtoint ptr %oom_lock12 to i32
  call void @__asan_store1_noabort(i32 %9)
  store i8 0, ptr %oom_lock12, align 1
  %call14 = tail call ptr @mem_cgroup_iter(ptr noundef %memcg, ptr noundef nonnull %iter.163, ptr noundef null)
  %cmp7.not = icmp eq ptr %call14, null
  br i1 %cmp7.not, label %if.end17, label %for.body8

if.else16:                                        ; preds = %if.else, %entry
  %10 = tail call ptr @llvm.returnaddress(i32 0)
  %11 = ptrtoint ptr %10 to i32
  tail call void @lock_acquire(ptr noundef nonnull @memcg_oom_lock_dep_map, i32 noundef 0, i32 noundef 1, i32 noundef 0, i32 noundef 1, ptr noundef null, i32 noundef %11) #23
  br label %if.end17

if.end17:                                         ; preds = %if.else16, %if.end11, %if.then.i.i48, %if.then2.i46, %if.end.i42, %if.then4
  %cmp.not57 = phi i1 [ false, %if.then.i.i48 ], [ false, %if.then2.i46 ], [ false, %if.end.i42 ], [ true, %if.else16 ], [ false, %if.then4 ], [ false, %if.end11 ]
  tail call void @_raw_spin_unlock(ptr noundef nonnull @memcg_oom_lock) #23
  ret i1 %cmp.not57
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @finish_wait(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc zeroext i1 @mem_cgroup_out_of_memory(ptr noundef %memcg, i32 noundef %gfp_mask, i32 noundef %order) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %oc = alloca %struct.oom_control, align 4
  call void @llvm.lifetime.start.p0(i64 36, ptr nonnull %oc) #23
  %0 = ptrtoint ptr %oc to i32
  call void @__asan_store4_noabort(i32 %0)
  store ptr null, ptr %oc, align 4
  %nodemask = getelementptr inbounds %struct.oom_control, ptr %oc, i32 0, i32 1
  %1 = ptrtoint ptr %nodemask to i32
  call void @__asan_store4_noabort(i32 %1)
  store ptr null, ptr %nodemask, align 4
  %memcg1 = getelementptr inbounds %struct.oom_control, ptr %oc, i32 0, i32 2
  %2 = ptrtoint ptr %memcg1 to i32
  call void @__asan_store4_noabort(i32 %2)
  store ptr %memcg, ptr %memcg1, align 4
  %gfp_mask2 = getelementptr inbounds %struct.oom_control, ptr %oc, i32 0, i32 3
  %3 = ptrtoint ptr %gfp_mask2 to i32
  call void @__asan_store4_noabort(i32 %3)
  store i32 %gfp_mask, ptr %gfp_mask2, align 4
  %order3 = getelementptr inbounds %struct.oom_control, ptr %oc, i32 0, i32 4
  %4 = ptrtoint ptr %order3 to i32
  call void @__asan_store4_noabort(i32 %4)
  store i32 %order, ptr %order3, align 4
  %totalpages = getelementptr inbounds %struct.oom_control, ptr %oc, i32 0, i32 5
  %5 = call ptr @memset(ptr %totalpages, i32 0, i32 16)
  %call = tail call i32 @mutex_lock_killable_nested(ptr noundef nonnull @oom_lock, i32 noundef 0) #23
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %memory.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %memory.i, i32 noundef 4) #23
  %6 = ptrtoint ptr %memory.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %memory.i, align 4
  %max.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2, i32 4
  %8 = ptrtoint ptr %max.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load volatile i32, ptr %max.i, align 16
  %10 = tail call i32 @llvm.usub.sat.i32(i32 %9, i32 %7) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_out_of_memory, %land.rhs.i.i)) #23
          to label %mem_cgroup_margin.exit [label %land.rhs.i.i], !srcloc !461

land.rhs.i.i:                                     ; preds = %if.end
  %11 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i = icmp eq i8 %11, 0
  br i1 %tobool4.not.i.i, label %if.then3.i, label %mem_cgroup_margin.exit

if.then3.i:                                       ; preds = %land.rhs.i.i
  %12 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 3
  %call.i.i.i30.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %12, i32 noundef 4) #23
  %13 = ptrtoint ptr %12 to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %12, align 4
  %max9.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 3, i32 0, i32 4
  %15 = ptrtoint ptr %max9.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %max9.i, align 8
  %cmp10.i = icmp ugt i32 %16, %14
  br i1 %cmp10.i, label %if.then11.i, label %mem_cgroup_margin.exit

if.then11.i:                                      ; preds = %if.then3.i
  %sub12.i = sub i32 %16, %14
  %17 = tail call i32 @llvm.umin.i32(i32 %10, i32 %sub12.i) #23
  br label %mem_cgroup_margin.exit

mem_cgroup_margin.exit:                           ; preds = %if.then11.i, %if.then3.i, %land.rhs.i.i, %if.end
  %margin.1.i = phi i32 [ %17, %if.then11.i ], [ 0, %if.then3.i ], [ %10, %land.rhs.i.i ], [ %10, %if.end ]
  %call4.highbits = lshr i32 %margin.1.i, %order
  %cmp.not = icmp eq i32 %call4.highbits, 0
  br i1 %cmp.not, label %if.end6, label %unlock

if.end6:                                          ; preds = %mem_cgroup_margin.exit
  %18 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i = and i32 %18, -16384
  %19 = inttoptr i32 %and.i.i to ptr
  %task.i = getelementptr inbounds %struct.thread_info, ptr %19, i32 0, i32 2
  %20 = ptrtoint ptr %task.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %task.i, align 8
  %signal.i.i = getelementptr inbounds %struct.task_struct, ptr %21, i32 0, i32 111
  %22 = ptrtoint ptr %signal.i.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %signal.i.i, align 16
  %oom_mm.i.i = getelementptr inbounds %struct.signal_struct, ptr %23, i32 0, i32 59
  %24 = ptrtoint ptr %oom_mm.i.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %oom_mm.i.i, align 4
  %tobool.i.not.i = icmp eq ptr %25, null
  br i1 %tobool.i.not.i, label %lor.lhs.false.i, label %unlock

lor.lhs.false.i:                                  ; preds = %if.end6
  %stack.i.i.i.i = getelementptr inbounds %struct.task_struct, ptr %21, i32 0, i32 1
  %26 = ptrtoint ptr %stack.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load ptr, ptr %stack.i.i.i.i, align 4
  %28 = ptrtoint ptr %27 to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %27, align 4
  %and1.i.i.i.i.i.i = and i32 %29, 1
  %tobool.not.i.i = icmp eq i32 %and1.i.i.i.i.i.i, 0
  br i1 %tobool.not.i.i, label %task_is_dying.exit, label %fatal_signal_pending.exit.i

fatal_signal_pending.exit.i:                      ; preds = %lor.lhs.false.i
  %signal.i.i.i = getelementptr inbounds %struct.task_struct, ptr %21, i32 0, i32 116, i32 1
  %30 = ptrtoint ptr %signal.i.i.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load i32, ptr %signal.i.i.i, align 4
  %32 = and i32 %31, 256
  %tobool.not.i = icmp eq i32 %32, 0
  br i1 %tobool.not.i, label %task_is_dying.exit, label %unlock

task_is_dying.exit:                               ; preds = %fatal_signal_pending.exit.i, %lor.lhs.false.i
  %flags.i = getelementptr inbounds %struct.task_struct, ptr %21, i32 0, i32 3
  %33 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %flags.i, align 4
  %and.i = and i32 %34, 4
  %tobool7.i.not = icmp eq i32 %and.i, 0
  br i1 %tobool7.i.not, label %lor.rhs, label %unlock

lor.rhs:                                          ; preds = %task_is_dying.exit
  %call8 = call zeroext i1 @out_of_memory(ptr noundef nonnull %oc) #23
  br label %unlock

unlock:                                           ; preds = %lor.rhs, %task_is_dying.exit, %fatal_signal_pending.exit.i, %if.end6, %mem_cgroup_margin.exit
  %ret.0.off0 = phi i1 [ true, %mem_cgroup_margin.exit ], [ true, %task_is_dying.exit ], [ %call8, %lor.rhs ], [ true, %fatal_signal_pending.exit.i ], [ true, %if.end6 ]
  call void @mutex_unlock(ptr noundef nonnull @oom_lock) #23
  br label %cleanup

cleanup:                                          ; preds = %unlock, %entry
  %retval.0 = phi i1 [ %ret.0.off0, %unlock ], [ true, %entry ]
  call void @llvm.lifetime.end.p0(i64 36, ptr nonnull %oc) #23
  ret i1 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @schedule() local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @mem_cgroup_get_oom_group(ptr noundef %victim, ptr noundef readonly %oom_domain) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_get_oom_group, %cleanup)) #23
          to label %if.end [label %cleanup], !srcloc !461

if.end:                                           ; preds = %entry
  %tobool4.not = icmp eq ptr %oom_domain, null
  br i1 %tobool4.not, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %0 = load ptr, ptr @root_mem_cgroup, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end
  %oom_domain.addr.0 = phi ptr [ %oom_domain, %if.end ], [ %0, %if.then5 ]
  %1 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %1, -16384
  %2 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %2, i32 0, i32 1
  %3 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %4, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end6
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %if.end6
  %call7 = tail call ptr @mem_cgroup_from_task(ptr noundef %victim)
  %5 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp = icmp eq ptr %call7, %5
  br i1 %cmp, label %out, label %if.end9

if.end9:                                          ; preds = %rcu_read_lock.exit
  %cmp.i = icmp eq ptr %oom_domain.addr.0, %call7
  br i1 %cmp.i, label %for.cond.preheader, label %if.end.i

if.end.i:                                         ; preds = %if.end9
  %6 = ptrtoint ptr %call7 to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %call7, align 128
  %8 = ptrtoint ptr %oom_domain.addr.0 to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %oom_domain.addr.0, align 128
  %root.i.i = getelementptr inbounds %struct.cgroup, ptr %7, i32 0, i32 19
  %10 = ptrtoint ptr %root.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %root.i.i, align 4
  %root1.i.i = getelementptr inbounds %struct.cgroup, ptr %9, i32 0, i32 19
  %12 = ptrtoint ptr %root1.i.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %root1.i.i, align 4
  %cmp.not.i.i = icmp eq ptr %11, %13
  br i1 %cmp.not.i.i, label %lor.lhs.false.i.i, label %out, !prof !489

lor.lhs.false.i.i:                                ; preds = %if.end.i
  %level.i.i = getelementptr inbounds %struct.cgroup, ptr %7, i32 0, i32 2
  %14 = ptrtoint ptr %level.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %level.i.i, align 4
  %level2.i.i = getelementptr inbounds %struct.cgroup, ptr %9, i32 0, i32 2
  %16 = ptrtoint ptr %level2.i.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %level2.i.i, align 4
  %cmp3.i.i = icmp slt i32 %15, %17
  br i1 %cmp3.i.i, label %out, label %if.end.i.i, !prof !490

if.end.i.i:                                       ; preds = %lor.lhs.false.i.i
  %arrayidx.i.i = getelementptr %struct.cgroup, ptr %7, i32 0, i32 37, i32 %17
  %18 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load8_noabort(i32 %18)
  %19 = load i64, ptr %arrayidx.i.i, align 8
  %kn.i.i.i = getelementptr inbounds %struct.cgroup, ptr %9, i32 0, i32 11
  %20 = ptrtoint ptr %kn.i.i.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %kn.i.i.i, align 8
  %id.i.i.i = getelementptr inbounds %struct.kernfs_node, ptr %21, i32 0, i32 10
  %22 = ptrtoint ptr %id.i.i.i to i32
  call void @__asan_load8_noabort(i32 %22)
  %23 = load i64, ptr %id.i.i.i, align 8
  %cmp5.i.i = icmp ne i64 %19, %23
  %tobool21.not62 = icmp eq ptr %call7, null
  %or.cond = select i1 %cmp5.i.i, i1 true, i1 %tobool21.not62
  br i1 %or.cond, label %out, label %for.body.preheader, !prof !491

for.cond.preheader:                               ; preds = %if.end9
  %tobool21.not62.old = icmp eq ptr %call7, null
  br i1 %tobool21.not62.old, label %out, label %for.body.preheader

for.body.preheader:                               ; preds = %for.cond.preheader, %if.end.i.i
  br label %for.body

for.body:                                         ; preds = %for.inc, %for.body.preheader
  %memcg.064 = phi ptr [ %add.ptr.i, %for.inc ], [ %call7, %for.body.preheader ]
  %oom_group.063 = phi ptr [ %spec.select, %for.inc ], [ null, %for.body.preheader ]
  %oom_group22 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.064, i32 0, i32 9
  %24 = ptrtoint ptr %oom_group22 to i32
  call void @__asan_load1_noabort(i32 %24)
  %25 = load i8, ptr %oom_group22, align 4, !range !488
  %tobool23.not = icmp eq i8 %25, 0
  %spec.select = select i1 %tobool23.not, ptr %oom_group.063, ptr %memcg.064
  %cmp26 = icmp eq ptr %memcg.064, %oom_domain.addr.0
  br i1 %cmp26, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.064, i32 0, i32 2, i32 13
  %26 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load ptr, ptr %parent.i, align 4
  %tobool.not.i45 = icmp eq ptr %27, null
  %add.ptr.i = getelementptr i8, ptr %27, i32 -176
  %tobool21.not68 = icmp eq ptr %add.ptr.i, null
  %tobool21.not = or i1 %tobool.not.i45, %tobool21.not68
  br i1 %tobool21.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %for.body
  %tobool30.not = icmp eq ptr %spec.select, null
  br i1 %tobool30.not, label %out, label %if.then31

if.then31:                                        ; preds = %for.end
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %spec.select, i32 0, i32 7
  %28 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %flags.i, align 4
  %and.i = and i32 %29, 1
  %tobool.not.i47 = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i47, label %if.then.i48, label %out

if.then.i48:                                      ; preds = %if.then31
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %spec.select, i32 0, i32 2
  tail call fastcc void @percpu_ref_get_many(ptr noundef %refcnt.i, i32 noundef 1) #23
  br label %out

out:                                              ; preds = %if.then.i48, %if.then31, %for.end, %for.cond.preheader, %if.end.i.i, %lor.lhs.false.i.i, %if.end.i, %rcu_read_lock.exit
  %oom_group.3 = phi ptr [ null, %rcu_read_lock.exit ], [ null, %for.end ], [ null, %if.end.i.i ], [ %spec.select, %if.then31 ], [ %spec.select, %if.then.i48 ], [ null, %lor.lhs.false.i.i ], [ null, %if.end.i ], [ null, %for.cond.preheader ]
  %call.i50 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i50, label %rcu_read_unlock.exit, label %land.lhs.true.i53

land.lhs.true.i53:                                ; preds = %out
  %call1.i51 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i52 = icmp eq i32 %call1.i51, 0
  br i1 %tobool.not.i52, label %rcu_read_unlock.exit, label %land.lhs.true2.i55

land.lhs.true2.i55:                               ; preds = %land.lhs.true.i53
  %.b4.i54 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i54, label %rcu_read_unlock.exit, label %if.then.i56

if.then.i56:                                      ; preds = %land.lhs.true2.i55
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i56, %land.lhs.true2.i55, %land.lhs.true.i53, %out
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %30 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i57 = and i32 %30, -16384
  %31 = inttoptr i32 %and.i.i.i.i.i57 to ptr
  %preempt_count.i.i.i.i58 = getelementptr inbounds %struct.thread_info, ptr %31, i32 0, i32 1
  %32 = ptrtoint ptr %preempt_count.i.i.i.i58 to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load volatile i32, ptr %preempt_count.i.i.i.i58, align 4
  %sub.i.i.i = add i32 %33, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i58, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  br label %cleanup

cleanup:                                          ; preds = %rcu_read_unlock.exit, %entry
  %retval.0 = phi ptr [ %oom_group.3, %rcu_read_unlock.exit ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mem_cgroup_print_oom_group(ptr nocapture noundef readonly %memcg) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call i32 (ptr, ...) @_printk(ptr noundef nonnull @.str.34) #25
  %0 = ptrtoint ptr %memcg to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %memcg, align 128
  %kn.i = getelementptr inbounds %struct.cgroup, ptr %1, i32 0, i32 11
  %2 = ptrtoint ptr %kn.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %kn.i, align 8
  tail call void @pr_cont_kernfs_path(ptr noundef %3) #23
  %call4 = tail call i32 (ptr, ...) @_printk(ptr noundef nonnull @.str.37) #25
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @folio_memcg_lock(ptr noundef %folio) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %3, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %entry
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@folio_memcg_lock, %cleanup)) #23
          to label %again [label %cleanup], !srcloc !461

again:                                            ; preds = %if.then92, %rcu_read_lock.exit
  %call1 = tail call fastcc ptr @folio_memcg(ptr noundef %folio)
  %tobool.not = icmp eq ptr %call1, null
  br i1 %tobool.not, label %cleanup, label %do.body7, !prof !466

do.body7:                                         ; preds = %again
  %4 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i = and i32 %4, 128
  %tobool16.not = icmp eq i32 %and.i, 0
  br i1 %tobool16.not, label %if.then17, label %do.body21

if.then17:                                        ; preds = %do.body7
  tail call void @trace_hardirqs_off() #23
  br label %do.body21

do.body21:                                        ; preds = %if.then17, %do.body7
  %move_lock = getelementptr inbounds %struct.mem_cgroup, ptr %call1, i32 0, i32 22
  %dep_map = getelementptr inbounds %struct.mem_cgroup, ptr %call1, i32 0, i32 22, i32 0, i32 0, i32 4
  br label %__here

__here:                                           ; preds = %do.body21
  tail call void @lock_acquire(ptr noundef %dep_map, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 1, ptr noundef null, i32 noundef ptrtoint (ptr blockaddress(@folio_memcg_lock, %__here) to i32)) #23
  br label %__here30

__here30:                                         ; preds = %__here
  tail call void @lock_release(ptr noundef %dep_map, i32 noundef ptrtoint (ptr blockaddress(@folio_memcg_lock, %__here30) to i32)) #23
  br i1 %tobool16.not, label %if.then43, label %do.body45

if.then43:                                        ; preds = %__here30
  tail call void @trace_hardirqs_on() #23
  br label %do.body45

do.body45:                                        ; preds = %if.then43, %__here30
  %5 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i = and i32 %5, 128
  %tobool53.not = icmp eq i32 %and.i.i, 0
  br i1 %tobool53.not, label %if.then62, label %do.end65, !prof !466

if.then62:                                        ; preds = %do.body45
  tail call void @warn_bogus_irq_restore() #23
  br label %do.end65

do.end65:                                         ; preds = %if.then62, %do.body45
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %4) #23, !srcloc !467
  %moving_account = getelementptr inbounds %struct.mem_cgroup, ptr %call1, i32 0, i32 37
  %call.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %moving_account, i32 noundef 4) #23
  %6 = ptrtoint ptr %moving_account to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %moving_account, align 4
  %cmp71 = icmp slt i32 %7, 1
  br i1 %cmp71, label %cleanup, label %do.body76

do.body76:                                        ; preds = %do.end65
  %call84 = tail call i32 @_raw_spin_lock_irqsave(ptr noundef %move_lock) #23
  %call89 = tail call fastcc ptr @folio_memcg(ptr noundef %folio)
  %cmp90.not = icmp eq ptr %call1, %call89
  br i1 %cmp90.not, label %if.end94, label %if.then92

if.then92:                                        ; preds = %do.body76
  tail call void @_raw_spin_unlock_irqrestore(ptr noundef %move_lock, i32 noundef %call84) #23
  br label %again

if.end94:                                         ; preds = %do.body76
  %8 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i111 = and i32 %8, -16384
  %9 = inttoptr i32 %and.i111 to ptr
  %task = getelementptr inbounds %struct.thread_info, ptr %9, i32 0, i32 2
  %10 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %task, align 8
  %move_lock_task = getelementptr inbounds %struct.mem_cgroup, ptr %call1, i32 0, i32 38
  %12 = ptrtoint ptr %move_lock_task to i32
  call void @__asan_store4_noabort(i32 %12)
  store ptr %11, ptr %move_lock_task, align 4
  %move_lock_flags = getelementptr inbounds %struct.mem_cgroup, ptr %call1, i32 0, i32 23
  %13 = ptrtoint ptr %move_lock_flags to i32
  call void @__asan_store4_noabort(i32 %13)
  store i32 %call84, ptr %move_lock_flags, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end94, %do.end65, %again, %rcu_read_lock.exit
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @trace_hardirqs_off() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @lock_acquire(ptr noundef, i32 noundef, i32 noundef, i32 noundef, i32 noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @lock_release(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @trace_hardirqs_on() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @warn_bogus_irq_restore() local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @lock_page_memcg(ptr noundef %page) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = getelementptr inbounds %struct.page, ptr %page, i32 0, i32 1
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %0, align 4
  %and.i = and i32 %2, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end.i, label %if.then.i, !prof !460

if.then.i:                                        ; preds = %entry
  %sub.i = add i32 %2, -1
  br label %_compound_head.exit

if.end.i:                                         ; preds = %entry
  %3 = ptrtoint ptr %page to i32
  br label %_compound_head.exit

_compound_head.exit:                              ; preds = %if.end.i, %if.then.i
  %retval.0.i = phi i32 [ %sub.i, %if.then.i ], [ %3, %if.end.i ]
  %4 = inttoptr i32 %retval.0.i to ptr
  tail call void @folio_memcg_lock(ptr noundef %4)
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @folio_memcg_unlock(ptr noundef %folio) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call fastcc ptr @folio_memcg(ptr noundef %folio)
  tail call fastcc void @__folio_memcg_unlock(ptr noundef %call)
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @__folio_memcg_unlock(ptr noundef %memcg) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tobool.not = icmp eq ptr %memcg, null
  br i1 %tobool.not, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %move_lock_task = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 38
  %0 = ptrtoint ptr %move_lock_task to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %move_lock_task, align 4
  %2 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i = and i32 %2, -16384
  %3 = inttoptr i32 %and.i to ptr
  %task = getelementptr inbounds %struct.thread_info, ptr %3, i32 0, i32 2
  %4 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %task, align 8
  %cmp = icmp eq ptr %1, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %move_lock_flags = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 23
  %6 = ptrtoint ptr %move_lock_flags to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %move_lock_flags, align 8
  %8 = ptrtoint ptr %move_lock_task to i32
  call void @__asan_store4_noabort(i32 %8)
  store ptr null, ptr %move_lock_task, align 4
  store i32 0, ptr %move_lock_flags, align 8
  %move_lock = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 22
  tail call void @_raw_spin_unlock_irqrestore(ptr noundef %move_lock, i32 noundef %7) #23
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_unlock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_unlock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_unlock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %if.end
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %9 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %9, -16384
  %10 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %10, i32 0, i32 1
  %11 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %sub.i.i.i = add i32 %12, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @unlock_page_memcg(ptr noundef %page) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = getelementptr inbounds %struct.page, ptr %page, i32 0, i32 1
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %0, align 4
  %and.i = and i32 %2, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end.i, label %if.then.i, !prof !460

if.then.i:                                        ; preds = %entry
  %sub.i = add i32 %2, -1
  br label %_compound_head.exit

if.end.i:                                         ; preds = %entry
  %3 = ptrtoint ptr %page to i32
  br label %_compound_head.exit

_compound_head.exit:                              ; preds = %if.end.i, %if.then.i
  %retval.0.i = phi i32 [ %sub.i, %if.then.i ], [ %3, %if.end.i ]
  %4 = inttoptr i32 %retval.0.i to ptr
  %call.i = tail call fastcc ptr @folio_memcg(ptr noundef %4) #23
  tail call fastcc void @__folio_memcg_unlock(ptr noundef %call.i) #23
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mem_cgroup_handle_over_high() local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i to ptr
  %task = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 2
  %2 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %task, align 8
  %memcg_nr_pages_over_high = getelementptr inbounds %struct.task_struct, ptr %3, i32 0, i32 205
  %4 = ptrtoint ptr %memcg_nr_pages_over_high to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %memcg_nr_pages_over_high, align 4
  %tobool.not = icmp eq i32 %5, 0
  br i1 %tobool.not, label %cleanup, label %if.end, !prof !460

if.end:                                           ; preds = %entry
  %mm = getelementptr inbounds %struct.task_struct, ptr %3, i32 0, i32 53
  %6 = ptrtoint ptr %mm to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %mm, align 8
  %call6 = tail call ptr @get_mem_cgroup_from_mm(ptr noundef %7)
  %8 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %task, align 8
  %memcg_nr_pages_over_high9 = getelementptr inbounds %struct.task_struct, ptr %9, i32 0, i32 205
  %10 = ptrtoint ptr %memcg_nr_pages_over_high9 to i32
  call void @__asan_store4_noabort(i32 %10)
  store i32 0, ptr %memcg_nr_pages_over_high9, align 4
  %call11 = tail call fastcc i32 @reclaim_high(ptr noundef %call6, i32 noundef %5)
  %call12 = tail call fastcc i64 @mem_find_max_overage(ptr noundef %call6)
  %call14 = tail call fastcc i64 @swap_find_max_overage(ptr noundef %call6)
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call6, i32 0, i32 7
  %11 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %flags.i, align 4
  %and.i47 = and i32 %12, 1
  %tobool.not.i = icmp eq i32 %and.i47, 0
  br i1 %tobool.not.i, label %if.then.i, label %cleanup

if.then.i:                                        ; preds = %if.end
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call6, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i) #23
  br label %cleanup

cleanup:                                          ; preds = %if.then.i, %if.end, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @reclaim_high(ptr noundef %memcg, i32 noundef %nr_pages) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %pflags = alloca i32, align 4
  br label %do.body

do.body:                                          ; preds = %land.rhs, %entry
  %nr_reclaimed.0 = phi i32 [ 0, %entry ], [ %nr_reclaimed.1, %land.rhs ]
  %memcg.addr.0 = phi ptr [ %memcg, %entry ], [ %add.ptr.i, %land.rhs ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %pflags) #23
  %0 = ptrtoint ptr %pflags to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %pflags, align 4, !annotation !492
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 2
  %call.i.i.i = call zeroext i1 @__kasan_check_read(ptr noundef %memory, i32 noundef 4) #23
  %1 = ptrtoint ptr %memory to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %memory, align 4
  %high = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 2, i32 3
  %3 = ptrtoint ptr %high to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load volatile i32, ptr %high, align 4
  %cmp.not = icmp ugt i32 %2, %4
  br i1 %cmp.not, label %if.end, label %cleanup

if.end:                                           ; preds = %do.body
  %arrayidx.i = getelementptr %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 28, i32 1
  %call.i.i.i1 = call zeroext i1 @__kasan_check_write(ptr noundef %arrayidx.i, i32 noundef 4) #23
  call void @llvm.prefetch.p0(ptr %arrayidx.i, i32 1, i32 3, i32 1) #23
  %5 = call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %arrayidx.i, ptr %arrayidx.i, i32 1, ptr elementtype(i32) %arrayidx.i) #23, !srcloc !468
  %events_local_file.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 15
  call void @cgroup_file_notify(ptr noundef %events_local_file.i) #23
  br label %do.body.i

do.body.i:                                        ; preds = %land.rhs.i, %if.end
  %memcg.addr.0.i = phi ptr [ %memcg.addr.0, %if.end ], [ %add.ptr.i.i, %land.rhs.i ]
  %arrayidx3.i = getelementptr %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 27, i32 1
  %call.i.i33.i = call zeroext i1 @__kasan_check_write(ptr noundef %arrayidx3.i, i32 noundef 4) #23
  call void @llvm.prefetch.p0(ptr %arrayidx3.i, i32 1, i32 3, i32 1) #23
  %6 = call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %arrayidx3.i, ptr %arrayidx3.i, i32 1, ptr elementtype(i32) %arrayidx3.i) #23, !srcloc !468
  %events_file.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 14
  call void @cgroup_file_notify(ptr noundef %events_file.i) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@reclaim_high, %memcg_memory_event.exit)) #23
          to label %if.end13.i [label %memcg_memory_event.exit], !srcloc !461

if.end13.i:                                       ; preds = %do.body.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7) to i32))
  %7 = load i32, ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7), align 4
  %and.i = and i32 %7, 32
  %tobool14.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool14.not.i, label %do.cond.i, label %memcg_memory_event.exit

do.cond.i:                                        ; preds = %if.end13.i
  %parent.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 2, i32 13
  %8 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i = icmp eq ptr %9, null
  %add.ptr.i.i = getelementptr i8, ptr %9, i32 -176
  %tobool18.not36.i = icmp eq ptr %add.ptr.i.i, null
  %tobool18.not.i = or i1 %tobool.not.i.i, %tobool18.not36.i
  br i1 %tobool18.not.i, label %memcg_memory_event.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %do.cond.i
  %10 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i = icmp eq ptr %10, %add.ptr.i.i
  br i1 %cmp.i.i, label %memcg_memory_event.exit, label %do.body.i

memcg_memory_event.exit:                          ; preds = %land.rhs.i, %do.cond.i, %if.end13.i, %do.body.i
  call void @psi_memstall_enter(ptr noundef nonnull %pflags) #23
  %call3 = call i32 @try_to_free_mem_cgroup_pages(ptr noundef %memcg.addr.0, i32 noundef %nr_pages, i32 noundef 3264, i1 noundef zeroext true) #23
  %add = add i32 %call3, %nr_reclaimed.0
  call void @psi_memstall_leave(ptr noundef nonnull %pflags) #23
  br label %cleanup

cleanup:                                          ; preds = %memcg_memory_event.exit, %do.body
  %nr_reclaimed.1 = phi i32 [ %add, %memcg_memory_event.exit ], [ %nr_reclaimed.0, %do.body ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %pflags) #23
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 2, i32 13
  %11 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %parent.i, align 4
  %tobool.not.i = icmp eq ptr %12, null
  %add.ptr.i = getelementptr i8, ptr %12, i32 -176
  %tobool.not2 = icmp eq ptr %add.ptr.i, null
  %tobool.not = or i1 %tobool.not.i, %tobool.not2
  br i1 %tobool.not, label %do.end7, label %land.rhs

land.rhs:                                         ; preds = %cleanup
  %13 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i = icmp eq ptr %13, %add.ptr.i
  br i1 %cmp.i, label %do.end7, label %do.body

do.end7:                                          ; preds = %land.rhs, %cleanup
  ret i32 %nr_reclaimed.1
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i64 @mem_find_max_overage(ptr noundef %memcg) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  br label %do.body

do.body:                                          ; preds = %land.rhs, %entry
  %max_overage.0 = phi i64 [ 0, %entry ], [ %5, %land.rhs ]
  %memcg.addr.0 = phi ptr [ %memcg, %entry ], [ %add.ptr.i, %land.rhs ]
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 2
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %memory, i32 noundef 4) #23
  %0 = ptrtoint ptr %memory to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile i32, ptr %memory, align 4
  %high = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 2, i32 3
  %2 = ptrtoint ptr %high to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %high, align 4
  %cmp.not.i = icmp ugt i32 %1, %3
  br i1 %cmp.not.i, label %if.end.i, label %calculate_overage.exit

if.end.i:                                         ; preds = %do.body
  %4 = tail call i32 @llvm.umax.i32(i32 %3, i32 1) #23
  %sub.i = sub i32 %1, %4
  %conv.i = zext i32 %sub.i to i64
  %shl.i = shl nuw nsw i64 %conv.i, 20
  %conv2.i = zext i32 %4 to i64
  %call.i = tail call i64 @div64_u64(i64 noundef %shl.i, i64 noundef %conv2.i) #23
  br label %calculate_overage.exit

calculate_overage.exit:                           ; preds = %if.end.i, %do.body
  %retval.0.i = phi i64 [ %call.i, %if.end.i ], [ 0, %do.body ]
  %5 = tail call i64 @llvm.umax.i64(i64 %retval.0.i, i64 %max_overage.0)
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 2, i32 13
  %6 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %parent.i, align 4
  %tobool.not.i = icmp eq ptr %7, null
  %add.ptr.i = getelementptr i8, ptr %7, i32 -176
  %tobool.not16 = icmp eq ptr %add.ptr.i, null
  %tobool.not = or i1 %tobool.not.i, %tobool.not16
  br i1 %tobool.not, label %do.end8, label %land.rhs

land.rhs:                                         ; preds = %calculate_overage.exit
  %8 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i = icmp eq ptr %8, %add.ptr.i
  br i1 %cmp.i, label %do.end8, label %do.body

do.end8:                                          ; preds = %land.rhs, %calculate_overage.exit
  ret i64 %5
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i64 @swap_find_max_overage(ptr noundef %memcg) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  br label %do.body

do.body:                                          ; preds = %land.rhs, %entry
  %max_overage.0 = phi i64 [ 0, %entry ], [ %12, %land.rhs ]
  %memcg.addr.0 = phi ptr [ %memcg, %entry ], [ %add.ptr.i, %land.rhs ]
  %0 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 3
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %0, i32 noundef 4) #23
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %0, align 4
  %high = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 3, i32 0, i32 3
  %3 = ptrtoint ptr %high to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load volatile i32, ptr %high, align 4
  %cmp.not.i = icmp ugt i32 %2, %4
  br i1 %cmp.not.i, label %calculate_overage.exit, label %if.end

calculate_overage.exit:                           ; preds = %do.body
  %5 = tail call i32 @llvm.umax.i32(i32 %4, i32 1) #23
  %sub.i = sub i32 %2, %5
  %conv.i = zext i32 %sub.i to i64
  %shl.i = shl nuw nsw i64 %conv.i, 20
  %conv2.i = zext i32 %5 to i64
  %call.i = tail call i64 @div64_u64(i64 noundef %shl.i, i64 noundef %conv2.i) #23
  %tobool.not = icmp eq i64 %call.i, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %calculate_overage.exit
  %arrayidx.i = getelementptr %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 28, i32 6
  %call.i.i.i17 = tail call zeroext i1 @__kasan_check_write(ptr noundef %arrayidx.i, i32 noundef 4) #23
  tail call void @llvm.prefetch.p0(ptr %arrayidx.i, i32 1, i32 3, i32 1) #23
  %6 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %arrayidx.i, ptr %arrayidx.i, i32 1, ptr elementtype(i32) %arrayidx.i) #23, !srcloc !468
  br label %do.body.i

do.body.i:                                        ; preds = %land.rhs.i, %if.then
  %memcg.addr.0.i = phi ptr [ %memcg.addr.0, %if.then ], [ %add.ptr.i.i, %land.rhs.i ]
  %arrayidx3.i = getelementptr %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 27, i32 6
  %call.i.i33.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %arrayidx3.i, i32 noundef 4) #23
  tail call void @llvm.prefetch.p0(ptr %arrayidx3.i, i32 1, i32 3, i32 1) #23
  %7 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %arrayidx3.i, ptr %arrayidx3.i, i32 1, ptr elementtype(i32) %arrayidx3.i) #23, !srcloc !468
  %swap_events_file.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 16
  tail call void @cgroup_file_notify(ptr noundef %swap_events_file.i) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@swap_find_max_overage, %if.end)) #23
          to label %if.end13.i [label %if.end], !srcloc !461

if.end13.i:                                       ; preds = %do.body.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7) to i32))
  %8 = load i32, ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7), align 4
  %and.i = and i32 %8, 32
  %tobool14.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool14.not.i, label %do.cond.i, label %if.end

do.cond.i:                                        ; preds = %if.end13.i
  %parent.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 2, i32 13
  %9 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i = icmp eq ptr %10, null
  %add.ptr.i.i = getelementptr i8, ptr %10, i32 -176
  %tobool18.not36.i = icmp eq ptr %add.ptr.i.i, null
  %tobool18.not.i = or i1 %tobool.not.i.i, %tobool18.not36.i
  br i1 %tobool18.not.i, label %if.end, label %land.rhs.i

land.rhs.i:                                       ; preds = %do.cond.i
  %11 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i = icmp eq ptr %11, %add.ptr.i.i
  br i1 %cmp.i.i, label %if.end, label %do.body.i

if.end:                                           ; preds = %land.rhs.i, %do.cond.i, %if.end13.i, %do.body.i, %calculate_overage.exit, %do.body
  %retval.0.i22 = phi i64 [ 0, %calculate_overage.exit ], [ %call.i, %do.body.i ], [ %call.i, %if.end13.i ], [ %call.i, %do.cond.i ], [ %call.i, %land.rhs.i ], [ 0, %do.body ]
  %12 = tail call i64 @llvm.umax.i64(i64 %retval.0.i22, i64 %max_overage.0)
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 2, i32 13
  %13 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %parent.i, align 4
  %tobool.not.i = icmp eq ptr %14, null
  %add.ptr.i = getelementptr i8, ptr %14, i32 -176
  %tobool6.not23 = icmp eq ptr %add.ptr.i, null
  %tobool6.not = or i1 %tobool.not.i, %tobool6.not23
  br i1 %tobool6.not, label %do.end8, label %land.rhs

land.rhs:                                         ; preds = %if.end
  %15 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i = icmp eq ptr %15, %add.ptr.i
  br i1 %cmp.i, label %do.end8, label %do.body

do.end8:                                          ; preds = %land.rhs, %if.end
  ret i64 %12
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @psi_memstall_enter(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @psi_memstall_leave(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @memcg_alloc_slab_cgroups(ptr noundef %slab, ptr nocapture noundef readnone %s, i32 noundef %gfp, i1 noundef zeroext %new_slab) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = getelementptr inbounds %struct.slab, ptr %slab, i32 0, i32 4
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %bf.load.i = load i32, ptr %0, align 4
  %2 = ptrtoint ptr %slab to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %slab, align 4
  %cmp.i.not.i.i.i = icmp eq i32 %3, -1
  br i1 %cmp.i.not.i.i.i, label %if.then.i.i.i, label %if.end7.i.i, !prof !466

if.then.i.i.i:                                    ; preds = %entry
  tail call void @dump_page(ptr noundef %slab, ptr noundef nonnull @.str.170) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/mm.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1368, 0\0A.popsection", ""() #23, !srcloc !469
  unreachable

if.end7.i.i:                                      ; preds = %entry
  %4 = shl i32 %bf.load.i, 1
  %5 = and i32 %4, 131068
  %and = and i32 %gfp, -4194578
  %or.i = or i32 %and, 256
  %call.i.i.i = tail call noalias align 128 ptr @__kmalloc(i32 noundef %5, i32 noundef %or.i) #27
  %tobool.not = icmp eq ptr %call.i.i.i, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %if.end7.i.i
  %6 = ptrtoint ptr %call.i.i.i to i32
  %or = or i32 %6, 1
  %memcg_data5 = getelementptr inbounds %struct.slab, ptr %slab, i32 0, i32 7
  br i1 %new_slab, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %7 = ptrtoint ptr %memcg_data5 to i32
  call void @__asan_store4_noabort(i32 %7)
  store i32 %or, ptr %memcg_data5, align 4
  br label %if.end25

if.else:                                          ; preds = %if.end
  %call.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %memcg_data5, i32 noundef 4) #23
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !493
  tail call void @llvm.prefetch.p0(ptr %memcg_data5, i32 1, i32 3, i32 1) #23
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %if.else
  %8 = tail call { i32, i32 } asm sideeffect "@ __cmpxchg4\0A\09ldrex\09$1, [$2]\0A\09mov\09$0, #0\0A\09teq\09$1, $3\0A\09strexeq $0, $4, [$2]\0A", "=&r,=&r,r,Ir,r,~{memory},~{cc}"(ptr %memcg_data5, i32 0, i32 %or) #23, !srcloc !476
  %asmresult.i = extractvalue { i32, i32 } %8, 0
  %tobool.not.i = icmp eq i32 %asmresult.i, 0
  br i1 %tobool.not.i, label %__cmpxchg.exit, label %do.body.i

__cmpxchg.exit:                                   ; preds = %do.body.i
  %asmresult1.i = extractvalue { i32, i32 } %8, 1
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !494
  %tobool22.not = icmp eq i32 %asmresult1.i, 0
  br i1 %tobool22.not, label %if.end25, label %if.then23

if.then23:                                        ; preds = %__cmpxchg.exit
  tail call void @kfree(ptr noundef nonnull %call.i.i.i) #23
  br label %cleanup

if.end25:                                         ; preds = %__cmpxchg.exit, %if.then4
  tail call void @kmemleak_not_leak(ptr noundef nonnull %call.i.i.i) #23
  br label %cleanup

cleanup:                                          ; preds = %if.end25, %if.then23, %if.end7.i.i
  %retval.0 = phi i32 [ 0, %if.end25 ], [ 0, %if.then23 ], [ -12, %if.end7.i.i ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @kmemleak_not_leak(ptr noundef) local_unnamed_addr #4 section ".ref.text"

; Function Attrs: alwaysinline nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @get_obj_cgroup_from_current() local_unnamed_addr #7 align 64 {
entry:
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i.i to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %and.i.i = and i32 %3, 15728640
  %4 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i27.i.i = and i32 %4, -16384
  %5 = inttoptr i32 %and.i.i27.i.i to ptr
  %preempt_count.i28.i.i = getelementptr inbounds %struct.thread_info, ptr %5, i32 0, i32 1
  %6 = ptrtoint ptr %preempt_count.i28.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %preempt_count.i28.i.i, align 4
  %and2.i.i = and i32 %7, 983040
  %or.i.i = or i32 %and2.i.i, %and.i.i
  %8 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i29.i.i = and i32 %8, -16384
  %9 = inttoptr i32 %and.i.i29.i.i to ptr
  %preempt_count.i30.i.i = getelementptr inbounds %struct.thread_info, ptr %9, i32 0, i32 1
  %10 = ptrtoint ptr %preempt_count.i30.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %preempt_count.i30.i.i, align 4
  %and5.i.i = and i32 %11, 256
  %or6.i.i = or i32 %or.i.i, %and5.i.i
  %tobool.not.i.i = icmp eq i32 %or6.i.i, 0
  %12 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i33.i.i = and i32 %12, -16384
  %13 = inttoptr i32 %and.i33.i.i to ptr
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 1
  %14 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %15, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !473
  %16 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i = and i32 %16, -16384
  %17 = inttoptr i32 %and.i.i.i to ptr
  %cpu.i.i = getelementptr inbounds %struct.thread_info, ptr %17, i32 0, i32 3
  %18 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %cpu.i.i, align 4
  %arrayidx.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %19
  %20 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %arrayidx.i.i, align 4
  %add.i.i = add i32 %21, ptrtoint (ptr @int_active_memcg to i32)
  %22 = inttoptr i32 %add.i.i to ptr
  %23 = ptrtoint ptr %22 to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load volatile ptr, ptr %22, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !474
  %25 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i31.i.i = and i32 %25, -16384
  %26 = inttoptr i32 %and.i.i.i31.i.i to ptr
  %preempt_count.i.i32.i.i = getelementptr inbounds %struct.thread_info, ptr %26, i32 0, i32 1
  %27 = ptrtoint ptr %preempt_count.i.i32.i.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load volatile i32, ptr %preempt_count.i.i32.i.i, align 4
  %sub.i.i.i = add i32 %28, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i32.i.i, align 4
  br label %active_memcg.exit.i

if.else.i.i:                                      ; preds = %entry
  %task.i.i = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 2
  %29 = ptrtoint ptr %task.i.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %task.i.i, align 8
  %active_memcg.i.i = getelementptr inbounds %struct.task_struct, ptr %30, i32 0, i32 206
  %31 = ptrtoint ptr %active_memcg.i.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %active_memcg.i.i, align 8
  br label %active_memcg.exit.i

active_memcg.exit.i:                              ; preds = %if.else.i.i, %if.then.i.i
  %retval.0.i.i = phi ptr [ %24, %if.then.i.i ], [ %32, %if.else.i.i ]
  %tobool.not.i = icmp eq ptr %retval.0.i.i, null
  br i1 %tobool.not.i, label %if.end.i, label %if.end, !prof !460

if.end.i:                                         ; preds = %active_memcg.exit.i
  %33 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i20.i = and i32 %33, -16384
  %34 = inttoptr i32 %and.i.i20.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %34, i32 0, i32 1
  %35 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load volatile i32, ptr %preempt_count.i.i, align 4
  %and.i = and i32 %36, 15728640
  %37 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i21.i = and i32 %37, -16384
  %38 = inttoptr i32 %and.i.i21.i to ptr
  %preempt_count.i22.i = getelementptr inbounds %struct.thread_info, ptr %38, i32 0, i32 1
  %39 = ptrtoint ptr %preempt_count.i22.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load volatile i32, ptr %preempt_count.i22.i, align 4
  %and5.i = and i32 %40, 983040
  %or.i = or i32 %and5.i, %and.i
  %41 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i23.i = and i32 %41, -16384
  %42 = inttoptr i32 %and.i.i23.i to ptr
  %preempt_count.i24.i = getelementptr inbounds %struct.thread_info, ptr %42, i32 0, i32 1
  %43 = ptrtoint ptr %preempt_count.i24.i to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load volatile i32, ptr %preempt_count.i24.i, align 4
  %and8.i = and i32 %44, 256
  %or9.i = or i32 %or.i, %and8.i
  %tobool10.not.i = icmp eq i32 %or9.i, 0
  br i1 %tobool10.not.i, label %lor.lhs.false.i, label %cleanup

lor.lhs.false.i:                                  ; preds = %if.end.i
  %45 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i25.i = and i32 %45, -16384
  %46 = inttoptr i32 %and.i25.i to ptr
  %task.i = getelementptr inbounds %struct.thread_info, ptr %46, i32 0, i32 2
  %47 = ptrtoint ptr %task.i to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load ptr, ptr %task.i, align 8
  %mm.i = getelementptr inbounds %struct.task_struct, ptr %48, i32 0, i32 53
  %49 = ptrtoint ptr %mm.i to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load ptr, ptr %mm.i, align 8
  %tobool12.not.i = icmp eq ptr %50, null
  br i1 %tobool12.not.i, label %cleanup, label %memcg_kmem_bypass.exit

memcg_kmem_bypass.exit:                           ; preds = %lor.lhs.false.i
  %flags.i = getelementptr inbounds %struct.task_struct, ptr %48, i32 0, i32 3
  %51 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load i32, ptr %flags.i, align 4
  %and16.i = and i32 %52, 2097152
  %tobool17.not.i.not = icmp eq i32 %and16.i, 0
  br i1 %tobool17.not.i.not, label %if.end, label %cleanup

if.end:                                           ; preds = %memcg_kmem_bypass.exit, %active_memcg.exit.i
  %53 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %53, -16384
  %54 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i34 = getelementptr inbounds %struct.thread_info, ptr %54, i32 0, i32 1
  %55 = ptrtoint ptr %preempt_count.i.i.i.i34 to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load volatile i32, ptr %preempt_count.i.i.i.i34, align 4
  %add.i.i.i35 = add i32 %56, 1
  store volatile i32 %add.i.i.i35, ptr %preempt_count.i.i.i.i34, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i36 = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i36, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %if.end
  %57 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i37 = and i32 %57, -16384
  %58 = inttoptr i32 %and.i.i.i37 to ptr
  %preempt_count.i.i38 = getelementptr inbounds %struct.thread_info, ptr %58, i32 0, i32 1
  %59 = ptrtoint ptr %preempt_count.i.i38 to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load volatile i32, ptr %preempt_count.i.i38, align 4
  %and.i39 = and i32 %60, 15728640
  %61 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i27.i = and i32 %61, -16384
  %62 = inttoptr i32 %and.i.i27.i to ptr
  %preempt_count.i28.i = getelementptr inbounds %struct.thread_info, ptr %62, i32 0, i32 1
  %63 = ptrtoint ptr %preempt_count.i28.i to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load volatile i32, ptr %preempt_count.i28.i, align 4
  %and2.i = and i32 %64, 983040
  %or.i40 = or i32 %and2.i, %and.i39
  %65 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i29.i = and i32 %65, -16384
  %66 = inttoptr i32 %and.i.i29.i to ptr
  %preempt_count.i30.i = getelementptr inbounds %struct.thread_info, ptr %66, i32 0, i32 1
  %67 = ptrtoint ptr %preempt_count.i30.i to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load volatile i32, ptr %preempt_count.i30.i, align 4
  %and5.i41 = and i32 %68, 256
  %or6.i = or i32 %or.i40, %and5.i41
  %tobool.not.i42 = icmp eq i32 %or6.i, 0
  %69 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i33.i = and i32 %69, -16384
  %70 = inttoptr i32 %and.i33.i to ptr
  br i1 %tobool.not.i42, label %if.else.i, label %if.then.i46

if.then.i46:                                      ; preds = %rcu_read_lock.exit
  %preempt_count.i.i.i43 = getelementptr inbounds %struct.thread_info, ptr %70, i32 0, i32 1
  %71 = ptrtoint ptr %preempt_count.i.i.i43 to i32
  call void @__asan_load4_noabort(i32 %71)
  %72 = load volatile i32, ptr %preempt_count.i.i.i43, align 4
  %add.i.i44 = add i32 %72, 1
  store volatile i32 %add.i.i44, ptr %preempt_count.i.i.i43, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !473
  %73 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i45 = and i32 %73, -16384
  %74 = inttoptr i32 %and.i.i45 to ptr
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %74, i32 0, i32 3
  %75 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %75)
  %76 = load i32, ptr %cpu.i, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %76
  %77 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %77)
  %78 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %78, ptrtoint (ptr @int_active_memcg to i32)
  %79 = inttoptr i32 %add.i to ptr
  %80 = ptrtoint ptr %79 to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load volatile ptr, ptr %79, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !474
  %82 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i31.i = and i32 %82, -16384
  %83 = inttoptr i32 %and.i.i.i31.i to ptr
  %preempt_count.i.i32.i = getelementptr inbounds %struct.thread_info, ptr %83, i32 0, i32 1
  %84 = ptrtoint ptr %preempt_count.i.i32.i to i32
  call void @__asan_load4_noabort(i32 %84)
  %85 = load volatile i32, ptr %preempt_count.i.i32.i, align 4
  %sub.i.i = add i32 %85, -1
  store volatile i32 %sub.i.i, ptr %preempt_count.i.i32.i, align 4
  br label %active_memcg.exit

if.else.i:                                        ; preds = %rcu_read_lock.exit
  %task.i47 = getelementptr inbounds %struct.thread_info, ptr %70, i32 0, i32 2
  %86 = ptrtoint ptr %task.i47 to i32
  call void @__asan_load4_noabort(i32 %86)
  %87 = load ptr, ptr %task.i47, align 8
  %active_memcg.i = getelementptr inbounds %struct.task_struct, ptr %87, i32 0, i32 206
  %88 = ptrtoint ptr %active_memcg.i to i32
  call void @__asan_load4_noabort(i32 %88)
  %89 = load ptr, ptr %active_memcg.i, align 8
  br label %active_memcg.exit

active_memcg.exit:                                ; preds = %if.else.i, %if.then.i46
  %retval.0.i48 = phi ptr [ %81, %if.then.i46 ], [ %89, %if.else.i ]
  %tobool.not = icmp eq ptr %retval.0.i48, null
  %90 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i77 = and i32 %90, -16384
  %91 = inttoptr i32 %and.i77 to ptr
  br i1 %tobool.not, label %if.else, label %if.then4, !prof !460

if.then4:                                         ; preds = %active_memcg.exit
  %preempt_count.i.i50 = getelementptr inbounds %struct.thread_info, ptr %91, i32 0, i32 1
  %92 = ptrtoint ptr %preempt_count.i.i50 to i32
  call void @__asan_load4_noabort(i32 %92)
  %93 = load volatile i32, ptr %preempt_count.i.i50, align 4
  %and.i51 = and i32 %93, 15728640
  %94 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i27.i52 = and i32 %94, -16384
  %95 = inttoptr i32 %and.i.i27.i52 to ptr
  %preempt_count.i28.i53 = getelementptr inbounds %struct.thread_info, ptr %95, i32 0, i32 1
  %96 = ptrtoint ptr %preempt_count.i28.i53 to i32
  call void @__asan_load4_noabort(i32 %96)
  %97 = load volatile i32, ptr %preempt_count.i28.i53, align 4
  %and2.i54 = and i32 %97, 983040
  %or.i55 = or i32 %and2.i54, %and.i51
  %98 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i29.i56 = and i32 %98, -16384
  %99 = inttoptr i32 %and.i.i29.i56 to ptr
  %preempt_count.i30.i57 = getelementptr inbounds %struct.thread_info, ptr %99, i32 0, i32 1
  %100 = ptrtoint ptr %preempt_count.i30.i57 to i32
  call void @__asan_load4_noabort(i32 %100)
  %101 = load volatile i32, ptr %preempt_count.i30.i57, align 4
  %and5.i58 = and i32 %101, 256
  %or6.i59 = or i32 %or.i55, %and5.i58
  %tobool.not.i60 = icmp eq i32 %or6.i59, 0
  %102 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i33.i61 = and i32 %102, -16384
  %103 = inttoptr i32 %and.i33.i61 to ptr
  br i1 %tobool.not.i60, label %if.else.i74, label %if.then.i71

if.then.i71:                                      ; preds = %if.then4
  %preempt_count.i.i.i62 = getelementptr inbounds %struct.thread_info, ptr %103, i32 0, i32 1
  %104 = ptrtoint ptr %preempt_count.i.i.i62 to i32
  call void @__asan_load4_noabort(i32 %104)
  %105 = load volatile i32, ptr %preempt_count.i.i.i62, align 4
  %add.i.i63 = add i32 %105, 1
  store volatile i32 %add.i.i63, ptr %preempt_count.i.i.i62, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !473
  %106 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i64 = and i32 %106, -16384
  %107 = inttoptr i32 %and.i.i64 to ptr
  %cpu.i65 = getelementptr inbounds %struct.thread_info, ptr %107, i32 0, i32 3
  %108 = ptrtoint ptr %cpu.i65 to i32
  call void @__asan_load4_noabort(i32 %108)
  %109 = load i32, ptr %cpu.i65, align 4
  %arrayidx.i66 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %109
  %110 = ptrtoint ptr %arrayidx.i66 to i32
  call void @__asan_load4_noabort(i32 %110)
  %111 = load i32, ptr %arrayidx.i66, align 4
  %add.i67 = add i32 %111, ptrtoint (ptr @int_active_memcg to i32)
  %112 = inttoptr i32 %add.i67 to ptr
  %113 = ptrtoint ptr %112 to i32
  call void @__asan_load4_noabort(i32 %113)
  %114 = load volatile ptr, ptr %112, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !474
  %115 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i31.i68 = and i32 %115, -16384
  %116 = inttoptr i32 %and.i.i.i31.i68 to ptr
  %preempt_count.i.i32.i69 = getelementptr inbounds %struct.thread_info, ptr %116, i32 0, i32 1
  %117 = ptrtoint ptr %preempt_count.i.i32.i69 to i32
  call void @__asan_load4_noabort(i32 %117)
  %118 = load volatile i32, ptr %preempt_count.i.i32.i69, align 4
  %sub.i.i70 = add i32 %118, -1
  store volatile i32 %sub.i.i70, ptr %preempt_count.i.i32.i69, align 4
  br label %if.end8

if.else.i74:                                      ; preds = %if.then4
  %task.i72 = getelementptr inbounds %struct.thread_info, ptr %103, i32 0, i32 2
  %119 = ptrtoint ptr %task.i72 to i32
  call void @__asan_load4_noabort(i32 %119)
  %120 = load ptr, ptr %task.i72, align 8
  %active_memcg.i73 = getelementptr inbounds %struct.task_struct, ptr %120, i32 0, i32 206
  %121 = ptrtoint ptr %active_memcg.i73 to i32
  call void @__asan_load4_noabort(i32 %121)
  %122 = load ptr, ptr %active_memcg.i73, align 8
  br label %if.end8

if.else:                                          ; preds = %active_memcg.exit
  %task = getelementptr inbounds %struct.thread_info, ptr %91, i32 0, i32 2
  %123 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %123)
  %124 = load ptr, ptr %task, align 8
  %call7 = tail call ptr @mem_cgroup_from_task(ptr noundef %124)
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.else.i74, %if.then.i71
  %memcg.0 = phi ptr [ %call7, %if.else ], [ %114, %if.then.i71 ], [ %122, %if.else.i74 ]
  %125 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.not94 = icmp eq ptr %memcg.0, %125
  br i1 %cmp.not94, label %for.end, label %for.body

for.body:                                         ; preds = %if.end26, %if.end8
  %memcg.195 = phi ptr [ %retval.0.i80, %if.end26 ], [ %memcg.0, %if.end8 ]
  %objcg9 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.195, i32 0, i32 33
  %126 = ptrtoint ptr %objcg9 to i32
  call void @__asan_load4_noabort(i32 %126)
  %127 = load volatile ptr, ptr %objcg9, align 8
  %call11 = tail call i32 @rcu_read_lock_held() #23
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %land.lhs.true, label %do.end20

land.lhs.true:                                    ; preds = %for.body
  %call13 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool14.not = icmp eq i32 %call13, 0
  br i1 %tobool14.not, label %do.end20, label %land.lhs.true15

land.lhs.true15:                                  ; preds = %land.lhs.true
  %.b33 = load i1, ptr @get_obj_cgroup_from_current.__warned, align 1
  br i1 %.b33, label %do.end20, label %if.then17

if.then17:                                        ; preds = %land.lhs.true15
  store i1 true, ptr @get_obj_cgroup_from_current.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 2929, ptr noundef nonnull @.str.2) #23
  br label %do.end20

do.end20:                                         ; preds = %if.then17, %land.lhs.true15, %land.lhs.true, %for.body
  %tobool22.not = icmp eq ptr %127, null
  br i1 %tobool22.not, label %if.end26, label %land.lhs.true23

land.lhs.true23:                                  ; preds = %do.end20
  %call.i78 = tail call fastcc zeroext i1 @percpu_ref_tryget(ptr noundef nonnull %127) #23
  br i1 %call.i78, label %for.end, label %if.end26

if.end26:                                         ; preds = %land.lhs.true23, %do.end20
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.195, i32 0, i32 2, i32 13
  %128 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %128)
  %129 = load ptr, ptr %parent.i, align 4
  %tobool.not.i79 = icmp eq ptr %129, null
  %add.ptr.i = getelementptr i8, ptr %129, i32 -176
  %retval.0.i80 = select i1 %tobool.not.i79, ptr null, ptr %add.ptr.i
  %130 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.not = icmp eq ptr %retval.0.i80, %130
  br i1 %cmp.not, label %for.end, label %for.body

for.end:                                          ; preds = %if.end26, %land.lhs.true23, %if.end8
  %objcg.1 = phi ptr [ null, %if.end8 ], [ %127, %land.lhs.true23 ], [ null, %if.end26 ]
  %call.i81 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i81, label %rcu_read_unlock.exit, label %land.lhs.true.i84

land.lhs.true.i84:                                ; preds = %for.end
  %call1.i82 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i83 = icmp eq i32 %call1.i82, 0
  br i1 %tobool.not.i83, label %rcu_read_unlock.exit, label %land.lhs.true2.i86

land.lhs.true2.i86:                               ; preds = %land.lhs.true.i84
  %.b4.i85 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i85, label %rcu_read_unlock.exit, label %if.then.i87

if.then.i87:                                      ; preds = %land.lhs.true2.i86
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i87, %land.lhs.true2.i86, %land.lhs.true.i84, %for.end
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %131 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i88 = and i32 %131, -16384
  %132 = inttoptr i32 %and.i.i.i.i.i88 to ptr
  %preempt_count.i.i.i.i89 = getelementptr inbounds %struct.thread_info, ptr %132, i32 0, i32 1
  %133 = ptrtoint ptr %preempt_count.i.i.i.i89 to i32
  call void @__asan_load4_noabort(i32 %133)
  %134 = load volatile i32, ptr %preempt_count.i.i.i.i89, align 4
  %sub.i.i.i90 = add i32 %134, -1
  store volatile i32 %sub.i.i.i90, ptr %preempt_count.i.i.i.i89, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  br label %cleanup

cleanup:                                          ; preds = %rcu_read_unlock.exit, %memcg_kmem_bypass.exit, %lor.lhs.false.i, %if.end.i
  %retval.0 = phi ptr [ %objcg.1, %rcu_read_unlock.exit ], [ null, %memcg_kmem_bypass.exit ], [ null, %lor.lhs.false.i ], [ null, %if.end.i ]
  ret ptr %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @__memcg_kmem_charge_page(ptr nocapture noundef writeonly %page, i32 noundef %gfp, i32 noundef %order) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %and.i.i.i = and i32 %3, 15728640
  %4 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i27.i.i.i = and i32 %4, -16384
  %5 = inttoptr i32 %and.i.i27.i.i.i to ptr
  %preempt_count.i28.i.i.i = getelementptr inbounds %struct.thread_info, ptr %5, i32 0, i32 1
  %6 = ptrtoint ptr %preempt_count.i28.i.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %preempt_count.i28.i.i.i, align 4
  %and2.i.i.i = and i32 %7, 983040
  %or.i.i.i = or i32 %and2.i.i.i, %and.i.i.i
  %8 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i29.i.i.i = and i32 %8, -16384
  %9 = inttoptr i32 %and.i.i29.i.i.i to ptr
  %preempt_count.i30.i.i.i = getelementptr inbounds %struct.thread_info, ptr %9, i32 0, i32 1
  %10 = ptrtoint ptr %preempt_count.i30.i.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %preempt_count.i30.i.i.i, align 4
  %and5.i.i.i = and i32 %11, 256
  %or6.i.i.i = or i32 %or.i.i.i, %and5.i.i.i
  %tobool.not.i.i.i = icmp eq i32 %or6.i.i.i, 0
  %12 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i33.i.i.i = and i32 %12, -16384
  %13 = inttoptr i32 %and.i33.i.i.i to ptr
  br i1 %tobool.not.i.i.i, label %if.else.i.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %entry
  %preempt_count.i.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 1
  %14 = ptrtoint ptr %preempt_count.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %preempt_count.i.i.i.i.i, align 4
  %add.i.i.i.i = add i32 %15, 1
  store volatile i32 %add.i.i.i.i, ptr %preempt_count.i.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !473
  %16 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i = and i32 %16, -16384
  %17 = inttoptr i32 %and.i.i.i.i to ptr
  %cpu.i.i.i = getelementptr inbounds %struct.thread_info, ptr %17, i32 0, i32 3
  %18 = ptrtoint ptr %cpu.i.i.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %cpu.i.i.i, align 4
  %arrayidx.i.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %19
  %20 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %arrayidx.i.i.i, align 4
  %add.i.i.i = add i32 %21, ptrtoint (ptr @int_active_memcg to i32)
  %22 = inttoptr i32 %add.i.i.i to ptr
  %23 = ptrtoint ptr %22 to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load volatile ptr, ptr %22, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !474
  %25 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i31.i.i.i = and i32 %25, -16384
  %26 = inttoptr i32 %and.i.i.i31.i.i.i to ptr
  %preempt_count.i.i32.i.i.i = getelementptr inbounds %struct.thread_info, ptr %26, i32 0, i32 1
  %27 = ptrtoint ptr %preempt_count.i.i32.i.i.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load volatile i32, ptr %preempt_count.i.i32.i.i.i, align 4
  %sub.i.i.i.i = add i32 %28, -1
  store volatile i32 %sub.i.i.i.i, ptr %preempt_count.i.i32.i.i.i, align 4
  br label %active_memcg.exit.i.i

if.else.i.i.i:                                    ; preds = %entry
  %task.i.i.i = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 2
  %29 = ptrtoint ptr %task.i.i.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %task.i.i.i, align 8
  %active_memcg.i.i.i = getelementptr inbounds %struct.task_struct, ptr %30, i32 0, i32 206
  %31 = ptrtoint ptr %active_memcg.i.i.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %active_memcg.i.i.i, align 8
  br label %active_memcg.exit.i.i

active_memcg.exit.i.i:                            ; preds = %if.else.i.i.i, %if.then.i.i.i
  %retval.0.i.i.i = phi ptr [ %24, %if.then.i.i.i ], [ %32, %if.else.i.i.i ]
  %tobool.not.i.i = icmp eq ptr %retval.0.i.i.i, null
  br i1 %tobool.not.i.i, label %if.end.i.i, label %if.end.i, !prof !460

if.end.i.i:                                       ; preds = %active_memcg.exit.i.i
  %33 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i20.i.i = and i32 %33, -16384
  %34 = inttoptr i32 %and.i.i20.i.i to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %34, i32 0, i32 1
  %35 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %and.i.i = and i32 %36, 15728640
  %37 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i21.i.i = and i32 %37, -16384
  %38 = inttoptr i32 %and.i.i21.i.i to ptr
  %preempt_count.i22.i.i = getelementptr inbounds %struct.thread_info, ptr %38, i32 0, i32 1
  %39 = ptrtoint ptr %preempt_count.i22.i.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load volatile i32, ptr %preempt_count.i22.i.i, align 4
  %and5.i.i = and i32 %40, 983040
  %or.i.i = or i32 %and5.i.i, %and.i.i
  %41 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i23.i.i = and i32 %41, -16384
  %42 = inttoptr i32 %and.i.i23.i.i to ptr
  %preempt_count.i24.i.i = getelementptr inbounds %struct.thread_info, ptr %42, i32 0, i32 1
  %43 = ptrtoint ptr %preempt_count.i24.i.i to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load volatile i32, ptr %preempt_count.i24.i.i, align 4
  %and8.i.i = and i32 %44, 256
  %or9.i.i = or i32 %or.i.i, %and8.i.i
  %tobool10.not.i.i = icmp eq i32 %or9.i.i, 0
  br i1 %tobool10.not.i.i, label %lor.lhs.false.i.i, label %cleanup

lor.lhs.false.i.i:                                ; preds = %if.end.i.i
  %45 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i25.i.i = and i32 %45, -16384
  %46 = inttoptr i32 %and.i25.i.i to ptr
  %task.i.i = getelementptr inbounds %struct.thread_info, ptr %46, i32 0, i32 2
  %47 = ptrtoint ptr %task.i.i to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load ptr, ptr %task.i.i, align 8
  %mm.i.i = getelementptr inbounds %struct.task_struct, ptr %48, i32 0, i32 53
  %49 = ptrtoint ptr %mm.i.i to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load ptr, ptr %mm.i.i, align 8
  %tobool12.not.i.i = icmp eq ptr %50, null
  br i1 %tobool12.not.i.i, label %cleanup, label %memcg_kmem_bypass.exit.i

memcg_kmem_bypass.exit.i:                         ; preds = %lor.lhs.false.i.i
  %flags.i.i = getelementptr inbounds %struct.task_struct, ptr %48, i32 0, i32 3
  %51 = ptrtoint ptr %flags.i.i to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load i32, ptr %flags.i.i, align 4
  %and16.i.i = and i32 %52, 2097152
  %tobool17.not.i.not.i = icmp eq i32 %and16.i.i, 0
  br i1 %tobool17.not.i.not.i, label %if.end.i, label %cleanup

if.end.i:                                         ; preds = %memcg_kmem_bypass.exit.i, %active_memcg.exit.i.i
  %53 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i.i = and i32 %53, -16384
  %54 = inttoptr i32 %and.i.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i34.i = getelementptr inbounds %struct.thread_info, ptr %54, i32 0, i32 1
  %55 = ptrtoint ptr %preempt_count.i.i.i.i34.i to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load volatile i32, ptr %preempt_count.i.i.i.i34.i, align 4
  %add.i.i.i35.i = add i32 %56, 1
  store volatile i32 %add.i.i.i35.i, ptr %preempt_count.i.i.i.i34.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i.i, label %rcu_read_lock.exit.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.end.i
  %call1.i.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i36.i = icmp eq i32 %call1.i.i, 0
  br i1 %tobool.not.i36.i, label %rcu_read_lock.exit.i, label %land.lhs.true2.i.i

land.lhs.true2.i.i:                               ; preds = %land.lhs.true.i.i
  %.b4.i.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i.i, label %rcu_read_lock.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true2.i.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit.i

rcu_read_lock.exit.i:                             ; preds = %if.then.i.i, %land.lhs.true2.i.i, %land.lhs.true.i.i, %if.end.i
  %57 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i37.i = and i32 %57, -16384
  %58 = inttoptr i32 %and.i.i.i37.i to ptr
  %preempt_count.i.i38.i = getelementptr inbounds %struct.thread_info, ptr %58, i32 0, i32 1
  %59 = ptrtoint ptr %preempt_count.i.i38.i to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load volatile i32, ptr %preempt_count.i.i38.i, align 4
  %and.i39.i = and i32 %60, 15728640
  %61 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i27.i.i = and i32 %61, -16384
  %62 = inttoptr i32 %and.i.i27.i.i to ptr
  %preempt_count.i28.i.i = getelementptr inbounds %struct.thread_info, ptr %62, i32 0, i32 1
  %63 = ptrtoint ptr %preempt_count.i28.i.i to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load volatile i32, ptr %preempt_count.i28.i.i, align 4
  %and2.i.i = and i32 %64, 983040
  %or.i40.i = or i32 %and2.i.i, %and.i39.i
  %65 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i29.i.i = and i32 %65, -16384
  %66 = inttoptr i32 %and.i.i29.i.i to ptr
  %preempt_count.i30.i.i = getelementptr inbounds %struct.thread_info, ptr %66, i32 0, i32 1
  %67 = ptrtoint ptr %preempt_count.i30.i.i to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load volatile i32, ptr %preempt_count.i30.i.i, align 4
  %and5.i41.i = and i32 %68, 256
  %or6.i.i = or i32 %or.i40.i, %and5.i41.i
  %tobool.not.i42.i = icmp eq i32 %or6.i.i, 0
  %69 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i33.i.i = and i32 %69, -16384
  %70 = inttoptr i32 %and.i33.i.i to ptr
  br i1 %tobool.not.i42.i, label %if.else.i.i, label %if.then.i46.i

if.then.i46.i:                                    ; preds = %rcu_read_lock.exit.i
  %preempt_count.i.i.i43.i = getelementptr inbounds %struct.thread_info, ptr %70, i32 0, i32 1
  %71 = ptrtoint ptr %preempt_count.i.i.i43.i to i32
  call void @__asan_load4_noabort(i32 %71)
  %72 = load volatile i32, ptr %preempt_count.i.i.i43.i, align 4
  %add.i.i44.i = add i32 %72, 1
  store volatile i32 %add.i.i44.i, ptr %preempt_count.i.i.i43.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !473
  %73 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i45.i = and i32 %73, -16384
  %74 = inttoptr i32 %and.i.i45.i to ptr
  %cpu.i.i = getelementptr inbounds %struct.thread_info, ptr %74, i32 0, i32 3
  %75 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %75)
  %76 = load i32, ptr %cpu.i.i, align 4
  %arrayidx.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %76
  %77 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %77)
  %78 = load i32, ptr %arrayidx.i.i, align 4
  %add.i.i = add i32 %78, ptrtoint (ptr @int_active_memcg to i32)
  %79 = inttoptr i32 %add.i.i to ptr
  %80 = ptrtoint ptr %79 to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load volatile ptr, ptr %79, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !474
  %82 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i31.i.i = and i32 %82, -16384
  %83 = inttoptr i32 %and.i.i.i31.i.i to ptr
  %preempt_count.i.i32.i.i = getelementptr inbounds %struct.thread_info, ptr %83, i32 0, i32 1
  %84 = ptrtoint ptr %preempt_count.i.i32.i.i to i32
  call void @__asan_load4_noabort(i32 %84)
  %85 = load volatile i32, ptr %preempt_count.i.i32.i.i, align 4
  %sub.i.i.i = add i32 %85, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i32.i.i, align 4
  br label %active_memcg.exit.i

if.else.i.i:                                      ; preds = %rcu_read_lock.exit.i
  %task.i47.i = getelementptr inbounds %struct.thread_info, ptr %70, i32 0, i32 2
  %86 = ptrtoint ptr %task.i47.i to i32
  call void @__asan_load4_noabort(i32 %86)
  %87 = load ptr, ptr %task.i47.i, align 8
  %active_memcg.i.i = getelementptr inbounds %struct.task_struct, ptr %87, i32 0, i32 206
  %88 = ptrtoint ptr %active_memcg.i.i to i32
  call void @__asan_load4_noabort(i32 %88)
  %89 = load ptr, ptr %active_memcg.i.i, align 8
  br label %active_memcg.exit.i

active_memcg.exit.i:                              ; preds = %if.else.i.i, %if.then.i46.i
  %retval.0.i48.i = phi ptr [ %81, %if.then.i46.i ], [ %89, %if.else.i.i ]
  %tobool.not.i = icmp eq ptr %retval.0.i48.i, null
  %90 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i77.i = and i32 %90, -16384
  %91 = inttoptr i32 %and.i77.i to ptr
  br i1 %tobool.not.i, label %if.else.i, label %if.then4.i, !prof !460

if.then4.i:                                       ; preds = %active_memcg.exit.i
  %preempt_count.i.i50.i = getelementptr inbounds %struct.thread_info, ptr %91, i32 0, i32 1
  %92 = ptrtoint ptr %preempt_count.i.i50.i to i32
  call void @__asan_load4_noabort(i32 %92)
  %93 = load volatile i32, ptr %preempt_count.i.i50.i, align 4
  %and.i51.i = and i32 %93, 15728640
  %94 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i27.i52.i = and i32 %94, -16384
  %95 = inttoptr i32 %and.i.i27.i52.i to ptr
  %preempt_count.i28.i53.i = getelementptr inbounds %struct.thread_info, ptr %95, i32 0, i32 1
  %96 = ptrtoint ptr %preempt_count.i28.i53.i to i32
  call void @__asan_load4_noabort(i32 %96)
  %97 = load volatile i32, ptr %preempt_count.i28.i53.i, align 4
  %and2.i54.i = and i32 %97, 983040
  %or.i55.i = or i32 %and2.i54.i, %and.i51.i
  %98 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i29.i56.i = and i32 %98, -16384
  %99 = inttoptr i32 %and.i.i29.i56.i to ptr
  %preempt_count.i30.i57.i = getelementptr inbounds %struct.thread_info, ptr %99, i32 0, i32 1
  %100 = ptrtoint ptr %preempt_count.i30.i57.i to i32
  call void @__asan_load4_noabort(i32 %100)
  %101 = load volatile i32, ptr %preempt_count.i30.i57.i, align 4
  %and5.i58.i = and i32 %101, 256
  %or6.i59.i = or i32 %or.i55.i, %and5.i58.i
  %tobool.not.i60.i = icmp eq i32 %or6.i59.i, 0
  %102 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i33.i61.i = and i32 %102, -16384
  %103 = inttoptr i32 %and.i33.i61.i to ptr
  br i1 %tobool.not.i60.i, label %if.else.i74.i, label %if.then.i71.i

if.then.i71.i:                                    ; preds = %if.then4.i
  %preempt_count.i.i.i62.i = getelementptr inbounds %struct.thread_info, ptr %103, i32 0, i32 1
  %104 = ptrtoint ptr %preempt_count.i.i.i62.i to i32
  call void @__asan_load4_noabort(i32 %104)
  %105 = load volatile i32, ptr %preempt_count.i.i.i62.i, align 4
  %add.i.i63.i = add i32 %105, 1
  store volatile i32 %add.i.i63.i, ptr %preempt_count.i.i.i62.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !473
  %106 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i64.i = and i32 %106, -16384
  %107 = inttoptr i32 %and.i.i64.i to ptr
  %cpu.i65.i = getelementptr inbounds %struct.thread_info, ptr %107, i32 0, i32 3
  %108 = ptrtoint ptr %cpu.i65.i to i32
  call void @__asan_load4_noabort(i32 %108)
  %109 = load i32, ptr %cpu.i65.i, align 4
  %arrayidx.i66.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %109
  %110 = ptrtoint ptr %arrayidx.i66.i to i32
  call void @__asan_load4_noabort(i32 %110)
  %111 = load i32, ptr %arrayidx.i66.i, align 4
  %add.i67.i = add i32 %111, ptrtoint (ptr @int_active_memcg to i32)
  %112 = inttoptr i32 %add.i67.i to ptr
  %113 = ptrtoint ptr %112 to i32
  call void @__asan_load4_noabort(i32 %113)
  %114 = load volatile ptr, ptr %112, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !474
  %115 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i31.i68.i = and i32 %115, -16384
  %116 = inttoptr i32 %and.i.i.i31.i68.i to ptr
  %preempt_count.i.i32.i69.i = getelementptr inbounds %struct.thread_info, ptr %116, i32 0, i32 1
  %117 = ptrtoint ptr %preempt_count.i.i32.i69.i to i32
  call void @__asan_load4_noabort(i32 %117)
  %118 = load volatile i32, ptr %preempt_count.i.i32.i69.i, align 4
  %sub.i.i70.i = add i32 %118, -1
  store volatile i32 %sub.i.i70.i, ptr %preempt_count.i.i32.i69.i, align 4
  br label %if.end8.i

if.else.i74.i:                                    ; preds = %if.then4.i
  %task.i72.i = getelementptr inbounds %struct.thread_info, ptr %103, i32 0, i32 2
  %119 = ptrtoint ptr %task.i72.i to i32
  call void @__asan_load4_noabort(i32 %119)
  %120 = load ptr, ptr %task.i72.i, align 8
  %active_memcg.i73.i = getelementptr inbounds %struct.task_struct, ptr %120, i32 0, i32 206
  %121 = ptrtoint ptr %active_memcg.i73.i to i32
  call void @__asan_load4_noabort(i32 %121)
  %122 = load ptr, ptr %active_memcg.i73.i, align 8
  br label %if.end8.i

if.else.i:                                        ; preds = %active_memcg.exit.i
  %task.i = getelementptr inbounds %struct.thread_info, ptr %91, i32 0, i32 2
  %123 = ptrtoint ptr %task.i to i32
  call void @__asan_load4_noabort(i32 %123)
  %124 = load ptr, ptr %task.i, align 8
  %call7.i = tail call ptr @mem_cgroup_from_task(ptr noundef %124) #23
  br label %if.end8.i

if.end8.i:                                        ; preds = %if.else.i, %if.else.i74.i, %if.then.i71.i
  %memcg.0.i = phi ptr [ %call7.i, %if.else.i ], [ %114, %if.then.i71.i ], [ %122, %if.else.i74.i ]
  %125 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.not94.i = icmp eq ptr %memcg.0.i, %125
  br i1 %cmp.not94.i, label %for.end.i, label %for.body.i

for.body.i:                                       ; preds = %if.end26.i, %if.end8.i
  %memcg.195.i = phi ptr [ %retval.0.i80.i, %if.end26.i ], [ %memcg.0.i, %if.end8.i ]
  %objcg9.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.195.i, i32 0, i32 33
  %126 = ptrtoint ptr %objcg9.i to i32
  call void @__asan_load4_noabort(i32 %126)
  %127 = load volatile ptr, ptr %objcg9.i, align 8
  %call11.i = tail call i32 @rcu_read_lock_held() #23
  %tobool12.not.i = icmp eq i32 %call11.i, 0
  br i1 %tobool12.not.i, label %land.lhs.true.i, label %do.end20.i

land.lhs.true.i:                                  ; preds = %for.body.i
  %call13.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool14.not.i = icmp eq i32 %call13.i, 0
  br i1 %tobool14.not.i, label %do.end20.i, label %land.lhs.true15.i

land.lhs.true15.i:                                ; preds = %land.lhs.true.i
  %.b33.i = load i1, ptr @get_obj_cgroup_from_current.__warned, align 1
  br i1 %.b33.i, label %do.end20.i, label %if.then17.i

if.then17.i:                                      ; preds = %land.lhs.true15.i
  store i1 true, ptr @get_obj_cgroup_from_current.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef 2929, ptr noundef nonnull @.str.2) #23
  br label %do.end20.i

do.end20.i:                                       ; preds = %if.then17.i, %land.lhs.true15.i, %land.lhs.true.i, %for.body.i
  %tobool22.not.i = icmp eq ptr %127, null
  br i1 %tobool22.not.i, label %if.end26.i, label %land.lhs.true23.i

land.lhs.true23.i:                                ; preds = %do.end20.i
  %call.i78.i = tail call fastcc zeroext i1 @percpu_ref_tryget(ptr noundef nonnull %127) #23
  br i1 %call.i78.i, label %for.end.i, label %if.end26.i

if.end26.i:                                       ; preds = %land.lhs.true23.i, %do.end20.i
  %parent.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.195.i, i32 0, i32 2, i32 13
  %128 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %128)
  %129 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i79.i = icmp eq ptr %129, null
  %add.ptr.i.i = getelementptr i8, ptr %129, i32 -176
  %retval.0.i80.i = select i1 %tobool.not.i79.i, ptr null, ptr %add.ptr.i.i
  %130 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.not.i = icmp eq ptr %retval.0.i80.i, %130
  br i1 %cmp.not.i, label %for.end.i, label %for.body.i

for.end.i:                                        ; preds = %if.end26.i, %land.lhs.true23.i, %if.end8.i
  %objcg.1.i = phi ptr [ null, %if.end8.i ], [ null, %if.end26.i ], [ %127, %land.lhs.true23.i ]
  %call.i81.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i81.i, label %get_obj_cgroup_from_current.exit, label %land.lhs.true.i84.i

land.lhs.true.i84.i:                              ; preds = %for.end.i
  %call1.i82.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i83.i = icmp eq i32 %call1.i82.i, 0
  br i1 %tobool.not.i83.i, label %get_obj_cgroup_from_current.exit, label %land.lhs.true2.i86.i

land.lhs.true2.i86.i:                             ; preds = %land.lhs.true.i84.i
  %.b4.i85.i = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i85.i, label %get_obj_cgroup_from_current.exit, label %if.then.i87.i

if.then.i87.i:                                    ; preds = %land.lhs.true2.i86.i
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %get_obj_cgroup_from_current.exit

get_obj_cgroup_from_current.exit:                 ; preds = %if.then.i87.i, %land.lhs.true2.i86.i, %land.lhs.true.i84.i, %for.end.i
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %131 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i88.i = and i32 %131, -16384
  %132 = inttoptr i32 %and.i.i.i.i.i88.i to ptr
  %preempt_count.i.i.i.i89.i = getelementptr inbounds %struct.thread_info, ptr %132, i32 0, i32 1
  %133 = ptrtoint ptr %preempt_count.i.i.i.i89.i to i32
  call void @__asan_load4_noabort(i32 %133)
  %134 = load volatile i32, ptr %preempt_count.i.i.i.i89.i, align 4
  %sub.i.i.i90.i = add i32 %134, -1
  store volatile i32 %sub.i.i.i90.i, ptr %preempt_count.i.i.i.i89.i, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  %tobool.not = icmp eq ptr %objcg.1.i, null
  br i1 %tobool.not, label %cleanup, label %if.then

if.then:                                          ; preds = %get_obj_cgroup_from_current.exit
  %shl = shl nuw i32 1, %order
  %call.i = tail call fastcc ptr @get_mem_cgroup_from_objcg(ptr noundef nonnull %objcg.1.i) #23
  %call1.i = tail call fastcc i32 @try_charge_memcg(ptr noundef %call.i, i32 noundef %gfp, i32 noundef %shl) #23
  %tobool.not.i10 = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i10, label %if.end.i11, label %out.i

if.end.i11:                                       ; preds = %if.then
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@__memcg_kmem_charge_page, %if.then7.i)) #23
          to label %out.i [label %if.then7.i], !srcloc !461

if.then7.i:                                       ; preds = %if.end.i11
  %kmem.i = getelementptr inbounds %struct.mem_cgroup, ptr %call.i, i32 0, i32 4
  tail call void @page_counter_charge(ptr noundef %kmem.i, i32 noundef %shl) #23
  br label %out.i

out.i:                                            ; preds = %if.then7.i, %if.end.i11, %if.then
  %flags.i.i12 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call.i, i32 0, i32 7
  %135 = ptrtoint ptr %flags.i.i12 to i32
  call void @__asan_load4_noabort(i32 %135)
  %136 = load i32, ptr %flags.i.i12, align 4
  %and.i.i13 = and i32 %136, 1
  %tobool.not.i.i14 = icmp eq i32 %and.i.i13, 0
  br i1 %tobool.not.i.i14, label %if.then.i.i15, label %obj_cgroup_charge_pages.exit

if.then.i.i15:                                    ; preds = %out.i
  %refcnt.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call.i, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i.i) #23
  br label %obj_cgroup_charge_pages.exit

obj_cgroup_charge_pages.exit:                     ; preds = %if.then.i.i15, %out.i
  br i1 %tobool.not.i10, label %if.then3, label %if.end

if.then3:                                         ; preds = %obj_cgroup_charge_pages.exit
  %137 = ptrtoint ptr %objcg.1.i to i32
  %or = or i32 %137, 2
  %memcg_data = getelementptr inbounds %struct.page, ptr %page, i32 0, i32 4
  %138 = ptrtoint ptr %memcg_data to i32
  call void @__asan_store4_noabort(i32 %138)
  store i32 %or, ptr %memcg_data, align 4
  br label %cleanup

if.end:                                           ; preds = %obj_cgroup_charge_pages.exit
  tail call fastcc void @percpu_ref_put(ptr noundef nonnull %objcg.1.i) #23
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then3, %get_obj_cgroup_from_current.exit, %memcg_kmem_bypass.exit.i, %lor.lhs.false.i.i, %if.end.i.i
  %retval.0 = phi i32 [ 0, %if.then3 ], [ %call1.i, %if.end ], [ 0, %get_obj_cgroup_from_current.exit ], [ 0, %memcg_kmem_bypass.exit.i ], [ 0, %lor.lhs.false.i.i ], [ 0, %if.end.i.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @__memcg_kmem_uncharge_page(ptr noundef %page, i32 noundef %order) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = getelementptr inbounds %struct.page, ptr %page, i32 0, i32 1
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %0, align 4
  %and.i = and i32 %2, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end.i, label %if.then.i, !prof !460

if.then.i:                                        ; preds = %entry
  %sub.i = add i32 %2, -1
  br label %_compound_head.exit

if.end.i:                                         ; preds = %entry
  %3 = ptrtoint ptr %page to i32
  br label %_compound_head.exit

_compound_head.exit:                              ; preds = %if.end.i, %if.then.i
  %retval.0.i = phi i32 [ %sub.i, %if.then.i ], [ %3, %if.end.i ]
  %4 = inttoptr i32 %retval.0.i to ptr
  %5 = getelementptr inbounds %struct.page, ptr %4, i32 0, i32 1
  %6 = ptrtoint ptr %5 to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %5, align 4
  %and.i.i = and i32 %7, 1
  %tobool.not.i8 = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i8, label %do.body7.i, label %if.then.i9, !prof !460

if.then.i9:                                       ; preds = %_compound_head.exit
  tail call void @dump_page(ptr noundef %4, ptr noundef nonnull @.str.104) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/memcontrol.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 537, 0\0A.popsection", ""() #23, !srcloc !483
  unreachable

do.body7.i:                                       ; preds = %_compound_head.exit
  %memcg_data.i = getelementptr inbounds %struct.anon.153, ptr %4, i32 0, i32 7
  %8 = ptrtoint ptr %memcg_data.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %memcg_data.i, align 4
  %and.i10 = and i32 %9, 1
  %tobool8.not.i = icmp eq i32 %and.i10, 0
  br i1 %tobool8.not.i, label %folio_memcg_kmem.exit, label %if.then15.i, !prof !460

if.then15.i:                                      ; preds = %do.body7.i
  tail call void @dump_page(ptr noundef %4, ptr noundef nonnull @.str.105) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/memcontrol.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 538, 0\0A.popsection", ""() #23, !srcloc !484
  unreachable

folio_memcg_kmem.exit:                            ; preds = %do.body7.i
  %and23.i = and i32 %9, 2
  %tobool24.i.not = icmp eq i32 %and23.i, 0
  br i1 %tobool24.i.not, label %cleanup, label %if.end

if.end:                                           ; preds = %folio_memcg_kmem.exit
  %shl = shl nuw i32 1, %order
  %10 = ptrtoint ptr %5 to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %5, align 4
  %and.i.i.i.i = and i32 %11, 1
  %tobool.not.i.i.i = icmp eq i32 %and.i.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %folio_test_slab.exit.i, label %if.then.i.i.i, !prof !460

if.then.i.i.i:                                    ; preds = %if.end
  tail call void @dump_page(ptr noundef %4, ptr noundef nonnull @.str.96) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #23, !srcloc !470
  unreachable

folio_test_slab.exit.i:                           ; preds = %if.end
  %12 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load volatile i32, ptr %4, align 4
  %14 = and i32 %13, 512
  %tobool.i.not.i = icmp eq i32 %14, 0
  br i1 %tobool.i.not.i, label %__folio_objcg.exit, label %if.then.i11, !prof !460

if.then.i11:                                      ; preds = %folio_test_slab.exit.i
  tail call void @dump_page(ptr noundef %4, ptr noundef nonnull @.str.58) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/memcontrol.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 417, 0\0A.popsection", ""() #23, !srcloc !485
  unreachable

__folio_objcg.exit:                               ; preds = %folio_test_slab.exit.i
  %and48.i = and i32 %9, -4
  %15 = inttoptr i32 %and48.i to ptr
  %call.i = tail call fastcc ptr @get_mem_cgroup_from_objcg(ptr noundef %15) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@__memcg_kmem_uncharge_page, %if.then.i13)) #23
          to label %if.end.i15 [label %if.then.i13], !srcloc !461

if.then.i13:                                      ; preds = %__folio_objcg.exit
  %kmem.i = getelementptr inbounds %struct.mem_cgroup, ptr %call.i, i32 0, i32 4
  tail call void @page_counter_uncharge(ptr noundef %kmem.i, i32 noundef %shl) #23
  br label %if.end.i15

if.end.i15:                                       ; preds = %if.then.i13, %__folio_objcg.exit
  tail call fastcc void @refill_stock(ptr noundef %call.i, i32 noundef %shl) #23
  %flags.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call.i, i32 0, i32 7
  %16 = ptrtoint ptr %flags.i.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %flags.i.i, align 4
  %and.i.i14 = and i32 %17, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i14, 0
  br i1 %tobool.not.i.i, label %if.then.i.i, label %obj_cgroup_uncharge_pages.exit

if.then.i.i:                                      ; preds = %if.end.i15
  %refcnt.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call.i, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i.i) #23
  br label %obj_cgroup_uncharge_pages.exit

obj_cgroup_uncharge_pages.exit:                   ; preds = %if.then.i.i, %if.end.i15
  %18 = ptrtoint ptr %memcg_data.i to i32
  call void @__asan_store4_noabort(i32 %18)
  store i32 0, ptr %memcg_data.i, align 4
  tail call fastcc void @percpu_ref_put(ptr noundef %15) #23
  br label %cleanup

cleanup:                                          ; preds = %obj_cgroup_uncharge_pages.exit, %folio_memcg_kmem.exit
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mod_objcg_state(ptr noundef %objcg, ptr noundef %pgdat, i32 noundef %idx, i32 noundef %nr) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i, align 4
  %and.i = and i32 %3, 15728640
  %4 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i47.i = and i32 %4, -16384
  %5 = inttoptr i32 %and.i.i47.i to ptr
  %preempt_count.i48.i = getelementptr inbounds %struct.thread_info, ptr %5, i32 0, i32 1
  %6 = ptrtoint ptr %preempt_count.i48.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %preempt_count.i48.i, align 4
  %and2.i = and i32 %7, 983040
  %or.i = or i32 %and2.i, %and.i
  %8 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i49.i = and i32 %8, -16384
  %9 = inttoptr i32 %and.i.i49.i to ptr
  %preempt_count.i50.i = getelementptr inbounds %struct.thread_info, ptr %9, i32 0, i32 1
  %10 = ptrtoint ptr %preempt_count.i50.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %preempt_count.i50.i, align 4
  %and5.i = and i32 %11, 256
  %or6.i = or i32 %or.i, %and5.i
  %tobool.not.i = icmp eq i32 %or6.i, 0
  br i1 %tobool.not.i, label %if.then.i, label %do.body16.i, !prof !460

if.then.i:                                        ; preds = %entry
  %12 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i = and i32 %12, -16384
  %13 = inttoptr i32 %and.i.i.i.i to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 1
  %14 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %add.i.i = add i32 %15, 1
  store volatile i32 %add.i.i, ptr %preempt_count.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !495
  %16 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i = and i32 %16, -16384
  %17 = inttoptr i32 %and.i.i to ptr
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %17, i32 0, i32 3
  %18 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %cpu.i, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %19
  %20 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %21, ptrtoint (ptr @memcg_stock to i32)
  %22 = inttoptr i32 %add.i to ptr
  %task_obj.i = getelementptr inbounds %struct.memcg_stock_pcp, ptr %22, i32 0, i32 2
  br label %get_obj_stock.exit

do.body16.i:                                      ; preds = %entry
  %23 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i51.i = and i32 %23, 128
  %tobool28.not.i = icmp eq i32 %and.i51.i, 0
  br i1 %tobool28.not.i, label %if.then29.i, label %do.body33.i

if.then29.i:                                      ; preds = %do.body16.i
  tail call void @trace_hardirqs_off() #23
  br label %do.body33.i

do.body33.i:                                      ; preds = %if.then29.i, %do.body16.i
  %24 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i52.i = and i32 %24, -16384
  %25 = inttoptr i32 %and.i52.i to ptr
  %cpu41.i = getelementptr inbounds %struct.thread_info, ptr %25, i32 0, i32 3
  %26 = ptrtoint ptr %cpu41.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %cpu41.i, align 4
  %arrayidx42.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %27
  %28 = ptrtoint ptr %arrayidx42.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %arrayidx42.i, align 4
  %add43.i = add i32 %29, ptrtoint (ptr @memcg_stock to i32)
  %30 = inttoptr i32 %add43.i to ptr
  %irq_obj.i = getelementptr inbounds %struct.memcg_stock_pcp, ptr %30, i32 0, i32 3
  br label %get_obj_stock.exit

get_obj_stock.exit:                               ; preds = %do.body33.i, %if.then.i
  %flags.0 = phi i32 [ 0, %if.then.i ], [ %23, %do.body33.i ]
  %retval.0.i = phi ptr [ %task_obj.i, %if.then.i ], [ %irq_obj.i, %do.body33.i ]
  %31 = ptrtoint ptr %retval.0.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %retval.0.i, align 4
  %cmp.not = icmp eq ptr %32, %objcg
  br i1 %cmp.not, label %if.else, label %if.then

if.then:                                          ; preds = %get_obj_stock.exit
  tail call fastcc void @drain_obj_stock(ptr noundef %retval.0.i)
  tail call fastcc void @percpu_ref_get_many(ptr noundef %objcg, i32 noundef 1) #23
  %nr_charged_bytes = getelementptr inbounds %struct.obj_cgroup, ptr %objcg, i32 0, i32 2
  %call.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %nr_charged_bytes, i32 noundef 4) #23
  %33 = ptrtoint ptr %nr_charged_bytes to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load volatile i32, ptr %nr_charged_bytes, align 4
  %tobool.not = icmp eq i32 %34, 0
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %if.then
  %call.i.i84 = tail call zeroext i1 @__kasan_check_write(ptr noundef %nr_charged_bytes, i32 noundef 4) #23
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !496
  tail call void @llvm.prefetch.p0(ptr %nr_charged_bytes, i32 1, i32 3, i32 1) #23
  %35 = tail call { i32, i32 } asm sideeffect "@\09__xchg4\0A1:\09ldrex\09$0, [$3]\0A\09strex\09$1, $2, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,r,r,~{memory},~{cc}"(i32 0, ptr %nr_charged_bytes) #23, !srcloc !497
  %asmresult.i.i = extractvalue { i32, i32 } %35, 0
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !498
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.then
  %cond = phi i32 [ %asmresult.i.i, %cond.true ], [ 0, %if.then ]
  %nr_bytes = getelementptr inbounds %struct.obj_stock, ptr %retval.0.i, i32 0, i32 2
  %36 = ptrtoint ptr %nr_bytes to i32
  call void @__asan_store4_noabort(i32 %36)
  store i32 %cond, ptr %nr_bytes, align 4
  %37 = ptrtoint ptr %retval.0.i to i32
  call void @__asan_store4_noabort(i32 %37)
  store ptr %objcg, ptr %retval.0.i, align 4
  %cached_pgdat = getelementptr inbounds %struct.obj_stock, ptr %retval.0.i, i32 0, i32 1
  br label %if.end20.sink.split

if.else:                                          ; preds = %get_obj_stock.exit
  %cached_pgdat5 = getelementptr inbounds %struct.obj_stock, ptr %retval.0.i, i32 0, i32 1
  %38 = ptrtoint ptr %cached_pgdat5 to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load ptr, ptr %cached_pgdat5, align 4
  %cmp6.not = icmp eq ptr %39, %pgdat
  br i1 %cmp6.not, label %if.end20, label %if.then7

if.then7:                                         ; preds = %if.else
  %nr_slab_reclaimable_b = getelementptr inbounds %struct.obj_stock, ptr %retval.0.i, i32 0, i32 3
  %40 = ptrtoint ptr %nr_slab_reclaimable_b to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %nr_slab_reclaimable_b, align 4
  %tobool9.not = icmp eq i32 %41, 0
  br i1 %tobool9.not, label %if.end, label %if.then10

if.then10:                                        ; preds = %if.then7
  tail call fastcc void @mod_objcg_mlstate(ptr noundef %objcg, ptr noundef %39, i32 noundef 5, i32 noundef %41)
  %42 = ptrtoint ptr %nr_slab_reclaimable_b to i32
  call void @__asan_store4_noabort(i32 %42)
  store i32 0, ptr %nr_slab_reclaimable_b, align 4
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.then7
  %nr_slab_unreclaimable_b = getelementptr inbounds %struct.obj_stock, ptr %retval.0.i, i32 0, i32 4
  %43 = ptrtoint ptr %nr_slab_unreclaimable_b to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load i32, ptr %nr_slab_unreclaimable_b, align 4
  %tobool13.not = icmp eq i32 %44, 0
  br i1 %tobool13.not, label %if.end20.sink.split, label %if.then14

if.then14:                                        ; preds = %if.end
  tail call fastcc void @mod_objcg_mlstate(ptr noundef %objcg, ptr noundef %39, i32 noundef 6, i32 noundef %44)
  %45 = ptrtoint ptr %nr_slab_unreclaimable_b to i32
  call void @__asan_store4_noabort(i32 %45)
  store i32 0, ptr %nr_slab_unreclaimable_b, align 4
  br label %if.end20.sink.split

if.end20.sink.split:                              ; preds = %if.then14, %if.end, %cond.end
  %cached_pgdat5.sink = phi ptr [ %cached_pgdat, %cond.end ], [ %cached_pgdat5, %if.then14 ], [ %cached_pgdat5, %if.end ]
  %46 = ptrtoint ptr %cached_pgdat5.sink to i32
  call void @__asan_store4_noabort(i32 %46)
  store ptr %pgdat, ptr %cached_pgdat5.sink, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.end20.sink.split, %if.else
  %cmp21 = icmp eq i32 %idx, 5
  %nr_slab_reclaimable_b23 = getelementptr inbounds %struct.obj_stock, ptr %retval.0.i, i32 0, i32 3
  %nr_slab_unreclaimable_b25 = getelementptr inbounds %struct.obj_stock, ptr %retval.0.i, i32 0, i32 4
  %cond27 = select i1 %cmp21, ptr %nr_slab_reclaimable_b23, ptr %nr_slab_unreclaimable_b25
  %47 = ptrtoint ptr %cond27 to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load i32, ptr %cond27, align 4
  %tobool28.not = icmp eq i32 %48, 0
  br i1 %tobool28.not, label %if.then29, label %if.else30

if.then29:                                        ; preds = %if.end20
  %49 = ptrtoint ptr %cond27 to i32
  call void @__asan_store4_noabort(i32 %49)
  store i32 %nr, ptr %cond27, align 4
  br label %if.end43

if.else30:                                        ; preds = %if.end20
  %add = add i32 %48, %nr
  %50 = ptrtoint ptr %cond27 to i32
  call void @__asan_store4_noabort(i32 %50)
  store i32 %add, ptr %cond27, align 4
  %51 = tail call i32 @llvm.abs.i32(i32 %add, i1 false)
  %cmp36 = icmp ugt i32 %51, 4096
  br i1 %cmp36, label %if.end40, label %if.end43

if.end40:                                         ; preds = %if.else30
  %52 = ptrtoint ptr %cond27 to i32
  call void @__asan_store4_noabort(i32 %52)
  store i32 0, ptr %cond27, align 4
  %tobool41.not = icmp eq i32 %add, 0
  br i1 %tobool41.not, label %if.end43, label %if.then42

if.then42:                                        ; preds = %if.end40
  tail call fastcc void @mod_objcg_mlstate(ptr noundef %objcg, ptr noundef %pgdat, i32 noundef %idx, i32 noundef %add)
  br label %if.end43

if.end43:                                         ; preds = %if.then42, %if.end40, %if.else30, %if.then29
  %53 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i85 = and i32 %53, -16384
  %54 = inttoptr i32 %and.i.i.i85 to ptr
  %preempt_count.i.i86 = getelementptr inbounds %struct.thread_info, ptr %54, i32 0, i32 1
  %55 = ptrtoint ptr %preempt_count.i.i86 to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load volatile i32, ptr %preempt_count.i.i86, align 4
  %and.i87 = and i32 %56, 15728640
  %57 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i39.i = and i32 %57, -16384
  %58 = inttoptr i32 %and.i.i39.i to ptr
  %preempt_count.i40.i = getelementptr inbounds %struct.thread_info, ptr %58, i32 0, i32 1
  %59 = ptrtoint ptr %preempt_count.i40.i to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load volatile i32, ptr %preempt_count.i40.i, align 4
  %and2.i88 = and i32 %60, 983040
  %or.i89 = or i32 %and2.i88, %and.i87
  %61 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i41.i = and i32 %61, -16384
  %62 = inttoptr i32 %and.i.i41.i to ptr
  %preempt_count.i42.i = getelementptr inbounds %struct.thread_info, ptr %62, i32 0, i32 1
  %63 = ptrtoint ptr %preempt_count.i42.i to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load volatile i32, ptr %preempt_count.i42.i, align 4
  %and5.i90 = and i32 %64, 256
  %or6.i91 = or i32 %or.i89, %and5.i90
  %tobool.not.i92 = icmp eq i32 %or6.i91, 0
  br i1 %tobool.not.i92, label %do.body.i, label %do.body10.i, !prof !460

do.body.i:                                        ; preds = %if.end43
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !499
  %65 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i93 = and i32 %65, -16384
  %66 = inttoptr i32 %and.i.i.i.i93 to ptr
  %preempt_count.i.i.i94 = getelementptr inbounds %struct.thread_info, ptr %66, i32 0, i32 1
  %67 = ptrtoint ptr %preempt_count.i.i.i94 to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load volatile i32, ptr %preempt_count.i.i.i94, align 4
  %sub.i.i = add i32 %68, -1
  store volatile i32 %sub.i.i, ptr %preempt_count.i.i.i94, align 4
  br label %put_obj_stock.exit

do.body10.i:                                      ; preds = %if.end43
  %and.i.i95 = and i32 %flags.0, 128
  %tobool13.not.i = icmp eq i32 %and.i.i95, 0
  br i1 %tobool13.not.i, label %if.then14.i, label %do.body15.i

if.then14.i:                                      ; preds = %do.body10.i
  tail call void @trace_hardirqs_on() #23
  br label %do.body15.i

do.body15.i:                                      ; preds = %if.then14.i, %do.body10.i
  %69 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i43.i = and i32 %69, 128
  %tobool23.not.i = icmp eq i32 %and.i.i43.i, 0
  br i1 %tobool23.not.i, label %if.then32.i, label %do.end34.i, !prof !466

if.then32.i:                                      ; preds = %do.body15.i
  tail call void @warn_bogus_irq_restore() #23
  br label %do.end34.i

do.end34.i:                                       ; preds = %if.then32.i, %do.body15.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %flags.0) #23, !srcloc !467
  br label %put_obj_stock.exit

put_obj_stock.exit:                               ; preds = %do.end34.i, %do.body.i
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @drain_obj_stock(ptr nocapture noundef %stock) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = ptrtoint ptr %stock to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %stock, align 4
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %nr_bytes = getelementptr inbounds %struct.obj_stock, ptr %stock, i32 0, i32 2
  %2 = ptrtoint ptr %nr_bytes to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %nr_bytes, align 4
  %tobool1.not = icmp eq i32 %3, 0
  br i1 %tobool1.not, label %if.end10, label %if.then2

if.then2:                                         ; preds = %if.end
  %and = and i32 %3, 4095
  %tobool6.not = icmp ult i32 %3, 4096
  br i1 %tobool6.not, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.then2
  %shr = lshr i32 %3, 12
  %call.i = tail call fastcc ptr @get_mem_cgroup_from_objcg(ptr noundef nonnull %1) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@drain_obj_stock, %if.then.i)) #23
          to label %if.end.i [label %if.then.i], !srcloc !461

if.then.i:                                        ; preds = %if.then7
  %kmem.i = getelementptr inbounds %struct.mem_cgroup, ptr %call.i, i32 0, i32 4
  tail call void @page_counter_uncharge(ptr noundef %kmem.i, i32 noundef %shr) #23
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.then7
  tail call fastcc void @refill_stock(ptr noundef %call.i, i32 noundef %shr) #23
  %flags.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call.i, i32 0, i32 7
  %4 = ptrtoint ptr %flags.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %flags.i.i, align 4
  %and.i.i = and i32 %5, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.then.i.i, label %if.end8

if.then.i.i:                                      ; preds = %if.end.i
  %refcnt.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call.i, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i.i) #23
  br label %if.end8

if.end8:                                          ; preds = %if.then.i.i, %if.end.i, %if.then2
  %nr_charged_bytes = getelementptr inbounds %struct.obj_cgroup, ptr %1, i32 0, i32 2
  %call.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %nr_charged_bytes, i32 noundef 4) #23
  tail call void @llvm.prefetch.p0(ptr %nr_charged_bytes, i32 1, i32 3, i32 1) #23
  %6 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %nr_charged_bytes, ptr %nr_charged_bytes, i32 %and, ptr elementtype(i32) %nr_charged_bytes) #23, !srcloc !468
  %7 = ptrtoint ptr %nr_bytes to i32
  call void @__asan_store4_noabort(i32 %7)
  store i32 0, ptr %nr_bytes, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.end8, %if.end
  %nr_slab_reclaimable_b = getelementptr inbounds %struct.obj_stock, ptr %stock, i32 0, i32 3
  %8 = ptrtoint ptr %nr_slab_reclaimable_b to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %nr_slab_reclaimable_b, align 4
  %tobool11.not = icmp eq i32 %9, 0
  br i1 %tobool11.not, label %lor.lhs.false, label %if.then16

lor.lhs.false:                                    ; preds = %if.end10
  %nr_slab_unreclaimable_b = getelementptr inbounds %struct.obj_stock, ptr %stock, i32 0, i32 4
  %10 = ptrtoint ptr %nr_slab_unreclaimable_b to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %nr_slab_unreclaimable_b, align 4
  %tobool12.not = icmp eq i32 %11, 0
  br i1 %tobool12.not, label %if.end28, label %if.end19

if.then16:                                        ; preds = %if.end10
  %cached_pgdat = getelementptr inbounds %struct.obj_stock, ptr %stock, i32 0, i32 1
  %12 = ptrtoint ptr %cached_pgdat to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %cached_pgdat, align 4
  tail call fastcc void @mod_objcg_mlstate(ptr noundef nonnull %1, ptr noundef %13, i32 noundef 5, i32 noundef %9)
  %14 = ptrtoint ptr %nr_slab_reclaimable_b to i32
  call void @__asan_store4_noabort(i32 %14)
  store i32 0, ptr %nr_slab_reclaimable_b, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %lor.lhs.false
  %nr_slab_unreclaimable_b20 = getelementptr inbounds %struct.obj_stock, ptr %stock, i32 0, i32 4
  %15 = ptrtoint ptr %nr_slab_unreclaimable_b20 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %nr_slab_unreclaimable_b20, align 4
  %tobool21.not = icmp eq i32 %16, 0
  br i1 %tobool21.not, label %if.end26, label %if.then22

if.then22:                                        ; preds = %if.end19
  %cached_pgdat23 = getelementptr inbounds %struct.obj_stock, ptr %stock, i32 0, i32 1
  %17 = ptrtoint ptr %cached_pgdat23 to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %cached_pgdat23, align 4
  tail call fastcc void @mod_objcg_mlstate(ptr noundef nonnull %1, ptr noundef %18, i32 noundef 6, i32 noundef %16)
  %19 = ptrtoint ptr %nr_slab_unreclaimable_b20 to i32
  call void @__asan_store4_noabort(i32 %19)
  store i32 0, ptr %nr_slab_unreclaimable_b20, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.then22, %if.end19
  %cached_pgdat27 = getelementptr inbounds %struct.obj_stock, ptr %stock, i32 0, i32 1
  %20 = ptrtoint ptr %cached_pgdat27 to i32
  call void @__asan_store4_noabort(i32 %20)
  store ptr null, ptr %cached_pgdat27, align 4
  br label %if.end28

if.end28:                                         ; preds = %if.end26, %lor.lhs.false
  tail call fastcc void @percpu_ref_put(ptr noundef nonnull %1) #23
  %21 = ptrtoint ptr %stock to i32
  call void @__asan_store4_noabort(i32 %21)
  store ptr null, ptr %stock, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end28, %entry
  ret void
}

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @mod_objcg_mlstate(ptr noundef %objcg, ptr noundef %pgdat, i32 noundef %idx, i32 noundef %nr) unnamed_addr #5 align 64 {
entry:
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %3, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %entry
  %memcg.i = getelementptr inbounds %struct.obj_cgroup, ptr %objcg, i32 0, i32 1
  %4 = ptrtoint ptr %memcg.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile ptr, ptr %memcg.i, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mod_objcg_mlstate, %if.then.i2)) #23
          to label %if.end.i [label %if.then.i2], !srcloc !461

if.then.i2:                                       ; preds = %rcu_read_lock.exit
  %__lruvec.i = getelementptr inbounds %struct.pglist_data, ptr %pgdat, i32 0, i32 26
  br label %out.i

if.end.i:                                         ; preds = %rcu_read_lock.exit
  %tobool.not.i3 = icmp eq ptr %5, null
  br i1 %tobool.not.i3, label %if.then1.i, label %if.end2.i

if.then1.i:                                       ; preds = %if.end.i
  %6 = load ptr, ptr @root_mem_cgroup, align 4
  br label %if.end2.i

if.end2.i:                                        ; preds = %if.then1.i, %if.end.i
  %memcg.addr.0.i = phi ptr [ %5, %if.end.i ], [ %6, %if.then1.i ]
  %node_id.i = getelementptr inbounds %struct.pglist_data, ptr %pgdat, i32 0, i32 8
  %7 = ptrtoint ptr %node_id.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %node_id.i, align 64
  %arrayidx.i = getelementptr %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 45, i32 %8
  %9 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %arrayidx.i, align 4
  br label %out.i

out.i:                                            ; preds = %if.end2.i, %if.then.i2
  %lruvec.0.i = phi ptr [ %__lruvec.i, %if.then.i2 ], [ %10, %if.end2.i ]
  %pgdat4.i = getelementptr inbounds %struct.lruvec, ptr %lruvec.0.i, i32 0, i32 7
  %11 = ptrtoint ptr %pgdat4.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %pgdat4.i, align 4
  %cmp.not.i = icmp eq ptr %12, %pgdat
  br i1 %cmp.not.i, label %mem_cgroup_lruvec.exit, label %if.then7.i, !prof !460

if.then7.i:                                       ; preds = %out.i
  %13 = ptrtoint ptr %pgdat4.i to i32
  call void @__asan_store4_noabort(i32 %13)
  store ptr %pgdat, ptr %pgdat4.i, align 4
  br label %mem_cgroup_lruvec.exit

mem_cgroup_lruvec.exit:                           ; preds = %if.then7.i, %out.i
  %14 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i.i = and i32 %14, 128
  %tobool.not.i4 = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i4, label %if.then21.i, label %do.end11.i

do.end11.i:                                       ; preds = %mem_cgroup_lruvec.exit
  tail call void @__mod_memcg_lruvec_state(ptr noundef %lruvec.0.i, i32 noundef %idx, i32 noundef %nr) #23
  br label %do.body23.i

if.then21.i:                                      ; preds = %mem_cgroup_lruvec.exit
  tail call void @trace_hardirqs_off() #23
  tail call void @__mod_memcg_lruvec_state(ptr noundef %lruvec.0.i, i32 noundef %idx, i32 noundef %nr) #23
  tail call void @trace_hardirqs_on() #23
  br label %do.body23.i

do.body23.i:                                      ; preds = %if.then21.i, %do.end11.i
  %15 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i.i = and i32 %15, 128
  %tobool32.not.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool32.not.i, label %if.then36.i, label %mod_memcg_lruvec_state.exit, !prof !466

if.then36.i:                                      ; preds = %do.body23.i
  tail call void @warn_bogus_irq_restore() #23
  br label %mod_memcg_lruvec_state.exit

mod_memcg_lruvec_state.exit:                      ; preds = %if.then36.i, %do.body23.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %14) #23, !srcloc !467
  %call.i5 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i5, label %rcu_read_unlock.exit, label %land.lhs.true.i8

land.lhs.true.i8:                                 ; preds = %mod_memcg_lruvec_state.exit
  %call1.i6 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i7 = icmp eq i32 %call1.i6, 0
  br i1 %tobool.not.i7, label %rcu_read_unlock.exit, label %land.lhs.true2.i10

land.lhs.true2.i10:                               ; preds = %land.lhs.true.i8
  %.b4.i9 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i9, label %rcu_read_unlock.exit, label %if.then.i11

if.then.i11:                                      ; preds = %land.lhs.true2.i10
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i11, %land.lhs.true2.i10, %land.lhs.true.i8, %mod_memcg_lruvec_state.exit
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %16 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i12 = and i32 %16, -16384
  %17 = inttoptr i32 %and.i.i.i.i.i12 to ptr
  %preempt_count.i.i.i.i13 = getelementptr inbounds %struct.thread_info, ptr %17, i32 0, i32 1
  %18 = ptrtoint ptr %preempt_count.i.i.i.i13 to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load volatile i32, ptr %preempt_count.i.i.i.i13, align 4
  %sub.i.i.i = add i32 %19, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i13, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @obj_cgroup_charge(ptr noundef %objcg, i32 noundef %gfp, i32 noundef %size) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i.i to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %and.i.i = and i32 %3, 15728640
  %4 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i47.i.i = and i32 %4, -16384
  %5 = inttoptr i32 %and.i.i47.i.i to ptr
  %preempt_count.i48.i.i = getelementptr inbounds %struct.thread_info, ptr %5, i32 0, i32 1
  %6 = ptrtoint ptr %preempt_count.i48.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %preempt_count.i48.i.i, align 4
  %and2.i.i = and i32 %7, 983040
  %or.i.i = or i32 %and2.i.i, %and.i.i
  %8 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i49.i.i = and i32 %8, -16384
  %9 = inttoptr i32 %and.i.i49.i.i to ptr
  %preempt_count.i50.i.i = getelementptr inbounds %struct.thread_info, ptr %9, i32 0, i32 1
  %10 = ptrtoint ptr %preempt_count.i50.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %preempt_count.i50.i.i, align 4
  %and5.i.i = and i32 %11, 256
  %or6.i.i = or i32 %or.i.i, %and5.i.i
  %tobool.not.i.i = icmp eq i32 %or6.i.i, 0
  br i1 %tobool.not.i.i, label %if.then.i.i, label %do.body16.i.i, !prof !460

if.then.i.i:                                      ; preds = %entry
  %12 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %12, -16384
  %13 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 1
  %14 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %15, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !495
  %16 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i = and i32 %16, -16384
  %17 = inttoptr i32 %and.i.i.i to ptr
  %cpu.i.i = getelementptr inbounds %struct.thread_info, ptr %17, i32 0, i32 3
  %18 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %cpu.i.i, align 4
  %arrayidx.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %19
  %20 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %arrayidx.i.i, align 4
  %add.i.i = add i32 %21, ptrtoint (ptr @memcg_stock to i32)
  %22 = inttoptr i32 %add.i.i to ptr
  %task_obj.i.i = getelementptr inbounds %struct.memcg_stock_pcp, ptr %22, i32 0, i32 2
  br label %get_obj_stock.exit.i

do.body16.i.i:                                    ; preds = %entry
  %23 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i51.i.i = and i32 %23, 128
  %tobool28.not.i.i = icmp eq i32 %and.i51.i.i, 0
  br i1 %tobool28.not.i.i, label %if.then29.i.i, label %do.body33.i.i

if.then29.i.i:                                    ; preds = %do.body16.i.i
  tail call void @trace_hardirqs_off() #23
  br label %do.body33.i.i

do.body33.i.i:                                    ; preds = %if.then29.i.i, %do.body16.i.i
  %24 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i52.i.i = and i32 %24, -16384
  %25 = inttoptr i32 %and.i52.i.i to ptr
  %cpu41.i.i = getelementptr inbounds %struct.thread_info, ptr %25, i32 0, i32 3
  %26 = ptrtoint ptr %cpu41.i.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %cpu41.i.i, align 4
  %arrayidx42.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %27
  %28 = ptrtoint ptr %arrayidx42.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %arrayidx42.i.i, align 4
  %add43.i.i = add i32 %29, ptrtoint (ptr @memcg_stock to i32)
  %30 = inttoptr i32 %add43.i.i to ptr
  %irq_obj.i.i = getelementptr inbounds %struct.memcg_stock_pcp, ptr %30, i32 0, i32 3
  br label %get_obj_stock.exit.i

get_obj_stock.exit.i:                             ; preds = %do.body33.i.i, %if.then.i.i
  %flags.0.i = phi i32 [ 0, %if.then.i.i ], [ %23, %do.body33.i.i ]
  %retval.0.i.i = phi ptr [ %task_obj.i.i, %if.then.i.i ], [ %irq_obj.i.i, %do.body33.i.i ]
  %31 = ptrtoint ptr %retval.0.i.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %retval.0.i.i, align 4
  %cmp.i = icmp eq ptr %32, %objcg
  br i1 %cmp.i, label %land.lhs.true.i, label %if.end.i

land.lhs.true.i:                                  ; preds = %get_obj_stock.exit.i
  %nr_bytes1.i = getelementptr inbounds %struct.obj_stock, ptr %retval.0.i.i, i32 0, i32 2
  %33 = ptrtoint ptr %nr_bytes1.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %nr_bytes1.i, align 4
  %cmp2.not.i = icmp ult i32 %34, %size
  br i1 %cmp2.not.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  %sub.i = sub i32 %34, %size
  %35 = ptrtoint ptr %nr_bytes1.i to i32
  call void @__asan_store4_noabort(i32 %35)
  store i32 %sub.i, ptr %nr_bytes1.i, align 4
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %land.lhs.true.i, %get_obj_stock.exit.i
  %ret.0.off0.i = phi i1 [ true, %if.then.i ], [ false, %land.lhs.true.i ], [ false, %get_obj_stock.exit.i ]
  %36 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i7.i = and i32 %36, -16384
  %37 = inttoptr i32 %and.i.i.i7.i to ptr
  %preempt_count.i.i8.i = getelementptr inbounds %struct.thread_info, ptr %37, i32 0, i32 1
  %38 = ptrtoint ptr %preempt_count.i.i8.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load volatile i32, ptr %preempt_count.i.i8.i, align 4
  %and.i9.i = and i32 %39, 15728640
  %40 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i39.i.i = and i32 %40, -16384
  %41 = inttoptr i32 %and.i.i39.i.i to ptr
  %preempt_count.i40.i.i = getelementptr inbounds %struct.thread_info, ptr %41, i32 0, i32 1
  %42 = ptrtoint ptr %preempt_count.i40.i.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load volatile i32, ptr %preempt_count.i40.i.i, align 4
  %and2.i10.i = and i32 %43, 983040
  %or.i11.i = or i32 %and2.i10.i, %and.i9.i
  %44 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i41.i.i = and i32 %44, -16384
  %45 = inttoptr i32 %and.i.i41.i.i to ptr
  %preempt_count.i42.i.i = getelementptr inbounds %struct.thread_info, ptr %45, i32 0, i32 1
  %46 = ptrtoint ptr %preempt_count.i42.i.i to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load volatile i32, ptr %preempt_count.i42.i.i, align 4
  %and5.i12.i = and i32 %47, 256
  %or6.i13.i = or i32 %or.i11.i, %and5.i12.i
  %tobool.not.i14.i = icmp eq i32 %or6.i13.i, 0
  br i1 %tobool.not.i14.i, label %do.body.i.i, label %do.body10.i.i, !prof !460

do.body.i.i:                                      ; preds = %if.end.i
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !499
  %48 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i15.i = and i32 %48, -16384
  %49 = inttoptr i32 %and.i.i.i.i15.i to ptr
  %preempt_count.i.i.i16.i = getelementptr inbounds %struct.thread_info, ptr %49, i32 0, i32 1
  %50 = ptrtoint ptr %preempt_count.i.i.i16.i to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load volatile i32, ptr %preempt_count.i.i.i16.i, align 4
  %sub.i.i.i = add i32 %51, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i16.i, align 4
  br label %consume_obj_stock.exit

do.body10.i.i:                                    ; preds = %if.end.i
  %and.i.i17.i = and i32 %flags.0.i, 128
  %tobool13.not.i.i = icmp eq i32 %and.i.i17.i, 0
  br i1 %tobool13.not.i.i, label %if.then14.i.i, label %do.body15.i.i

if.then14.i.i:                                    ; preds = %do.body10.i.i
  tail call void @trace_hardirqs_on() #23
  br label %do.body15.i.i

do.body15.i.i:                                    ; preds = %if.then14.i.i, %do.body10.i.i
  %52 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i43.i.i = and i32 %52, 128
  %tobool23.not.i.i = icmp eq i32 %and.i.i43.i.i, 0
  br i1 %tobool23.not.i.i, label %if.then32.i.i, label %do.end34.i.i, !prof !466

if.then32.i.i:                                    ; preds = %do.body15.i.i
  tail call void @warn_bogus_irq_restore() #23
  br label %do.end34.i.i

do.end34.i.i:                                     ; preds = %if.then32.i.i, %do.body15.i.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %flags.0.i) #23, !srcloc !467
  br label %consume_obj_stock.exit

consume_obj_stock.exit:                           ; preds = %do.end34.i.i, %do.body.i.i
  br i1 %ret.0.off0.i, label %cleanup, label %if.end

if.end:                                           ; preds = %consume_obj_stock.exit
  %shr = lshr i32 %size, 12
  %and = and i32 %size, 4095
  %tobool.not = icmp eq i32 %and, 0
  %not.tobool.not = xor i1 %tobool.not, true
  %add = zext i1 %not.tobool.not to i32
  %spec.select = add nuw nsw i32 %shr, %add
  %call.i = tail call fastcc ptr @get_mem_cgroup_from_objcg(ptr noundef %objcg) #23
  %call1.i = tail call fastcc i32 @try_charge_memcg(ptr noundef %call.i, i32 noundef %gfp, i32 noundef %spec.select) #23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %if.end.i18, label %out.i

if.end.i18:                                       ; preds = %if.end
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@obj_cgroup_charge, %if.then7.i)) #23
          to label %out.i [label %if.then7.i], !srcloc !461

if.then7.i:                                       ; preds = %if.end.i18
  %kmem.i = getelementptr inbounds %struct.mem_cgroup, ptr %call.i, i32 0, i32 4
  tail call void @page_counter_charge(ptr noundef %kmem.i, i32 noundef %spec.select) #23
  br label %out.i

out.i:                                            ; preds = %if.then7.i, %if.end.i18, %if.end
  %flags.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call.i, i32 0, i32 7
  %53 = ptrtoint ptr %flags.i.i to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load i32, ptr %flags.i.i, align 4
  %and.i.i19 = and i32 %54, 1
  %tobool.not.i.i20 = icmp eq i32 %and.i.i19, 0
  br i1 %tobool.not.i.i20, label %if.then.i.i21, label %obj_cgroup_charge_pages.exit

if.then.i.i21:                                    ; preds = %out.i
  %refcnt.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call.i, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i.i) #23
  br label %obj_cgroup_charge_pages.exit

obj_cgroup_charge_pages.exit:                     ; preds = %if.then.i.i21, %out.i
  %tobool4.not.not = xor i1 %tobool.not.i, true
  %brmerge = or i1 %tobool.not, %tobool4.not.not
  br i1 %brmerge, label %cleanup, label %if.then6

if.then6:                                         ; preds = %obj_cgroup_charge_pages.exit
  %sub = sub nuw nsw i32 4096, %and
  tail call fastcc void @refill_obj_stock(ptr noundef %objcg, i32 noundef %sub, i1 noundef zeroext false)
  br label %cleanup

cleanup:                                          ; preds = %if.then6, %obj_cgroup_charge_pages.exit, %consume_obj_stock.exit
  %retval.0 = phi i32 [ 0, %consume_obj_stock.exit ], [ %call1.i, %obj_cgroup_charge_pages.exit ], [ %call1.i, %if.then6 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @refill_obj_stock(ptr noundef %objcg, i32 noundef %nr_bytes, i1 noundef zeroext %allow_uncharge) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i, align 4
  %and.i = and i32 %3, 15728640
  %4 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i47.i = and i32 %4, -16384
  %5 = inttoptr i32 %and.i.i47.i to ptr
  %preempt_count.i48.i = getelementptr inbounds %struct.thread_info, ptr %5, i32 0, i32 1
  %6 = ptrtoint ptr %preempt_count.i48.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %preempt_count.i48.i, align 4
  %and2.i = and i32 %7, 983040
  %or.i = or i32 %and2.i, %and.i
  %8 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i49.i = and i32 %8, -16384
  %9 = inttoptr i32 %and.i.i49.i to ptr
  %preempt_count.i50.i = getelementptr inbounds %struct.thread_info, ptr %9, i32 0, i32 1
  %10 = ptrtoint ptr %preempt_count.i50.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %preempt_count.i50.i, align 4
  %and5.i = and i32 %11, 256
  %or6.i = or i32 %or.i, %and5.i
  %tobool.not.i = icmp eq i32 %or6.i, 0
  br i1 %tobool.not.i, label %if.then.i, label %do.body16.i, !prof !460

if.then.i:                                        ; preds = %entry
  %12 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i = and i32 %12, -16384
  %13 = inttoptr i32 %and.i.i.i.i to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 1
  %14 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %add.i.i = add i32 %15, 1
  store volatile i32 %add.i.i, ptr %preempt_count.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !495
  %16 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i = and i32 %16, -16384
  %17 = inttoptr i32 %and.i.i to ptr
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %17, i32 0, i32 3
  %18 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %cpu.i, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %19
  %20 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %21, ptrtoint (ptr @memcg_stock to i32)
  %22 = inttoptr i32 %add.i to ptr
  %task_obj.i = getelementptr inbounds %struct.memcg_stock_pcp, ptr %22, i32 0, i32 2
  br label %get_obj_stock.exit

do.body16.i:                                      ; preds = %entry
  %23 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i51.i = and i32 %23, 128
  %tobool28.not.i = icmp eq i32 %and.i51.i, 0
  br i1 %tobool28.not.i, label %if.then29.i, label %do.body33.i

if.then29.i:                                      ; preds = %do.body16.i
  tail call void @trace_hardirqs_off() #23
  br label %do.body33.i

do.body33.i:                                      ; preds = %if.then29.i, %do.body16.i
  %24 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i52.i = and i32 %24, -16384
  %25 = inttoptr i32 %and.i52.i to ptr
  %cpu41.i = getelementptr inbounds %struct.thread_info, ptr %25, i32 0, i32 3
  %26 = ptrtoint ptr %cpu41.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %cpu41.i, align 4
  %arrayidx42.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %27
  %28 = ptrtoint ptr %arrayidx42.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %arrayidx42.i, align 4
  %add43.i = add i32 %29, ptrtoint (ptr @memcg_stock to i32)
  %30 = inttoptr i32 %add43.i to ptr
  %irq_obj.i = getelementptr inbounds %struct.memcg_stock_pcp, ptr %30, i32 0, i32 3
  br label %get_obj_stock.exit

get_obj_stock.exit:                               ; preds = %do.body33.i, %if.then.i
  %flags.0 = phi i32 [ 0, %if.then.i ], [ %23, %do.body33.i ]
  %retval.0.i = phi ptr [ %task_obj.i, %if.then.i ], [ %irq_obj.i, %do.body33.i ]
  %31 = ptrtoint ptr %retval.0.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %retval.0.i, align 4
  %cmp.not = icmp eq ptr %32, %objcg
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %get_obj_stock.exit
  tail call fastcc void @drain_obj_stock(ptr noundef %retval.0.i)
  tail call fastcc void @percpu_ref_get_many(ptr noundef %objcg, i32 noundef 1) #23
  %33 = ptrtoint ptr %retval.0.i to i32
  call void @__asan_store4_noabort(i32 %33)
  store ptr %objcg, ptr %retval.0.i, align 4
  %nr_charged_bytes = getelementptr inbounds %struct.obj_cgroup, ptr %objcg, i32 0, i32 2
  %call.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %nr_charged_bytes, i32 noundef 4) #23
  %34 = ptrtoint ptr %nr_charged_bytes to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load volatile i32, ptr %nr_charged_bytes, align 4
  %tobool.not = icmp eq i32 %35, 0
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %if.then
  %call.i.i30 = tail call zeroext i1 @__kasan_check_write(ptr noundef %nr_charged_bytes, i32 noundef 4) #23
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !496
  tail call void @llvm.prefetch.p0(ptr %nr_charged_bytes, i32 1, i32 3, i32 1) #23
  %36 = tail call { i32, i32 } asm sideeffect "@\09__xchg4\0A1:\09ldrex\09$0, [$3]\0A\09strex\09$1, $2, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,r,r,~{memory},~{cc}"(i32 0, ptr %nr_charged_bytes) #23, !srcloc !497
  %asmresult.i.i = extractvalue { i32, i32 } %36, 0
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !498
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.then
  %cond = phi i32 [ %asmresult.i.i, %cond.true ], [ 0, %if.then ]
  %nr_bytes5 = getelementptr inbounds %struct.obj_stock, ptr %retval.0.i, i32 0, i32 2
  %37 = ptrtoint ptr %nr_bytes5 to i32
  call void @__asan_store4_noabort(i32 %37)
  store i32 %cond, ptr %nr_bytes5, align 4
  br label %if.end

if.end:                                           ; preds = %cond.end, %get_obj_stock.exit
  %allow_uncharge.addr.0.off0 = phi i1 [ true, %cond.end ], [ %allow_uncharge, %get_obj_stock.exit ]
  %nr_bytes6 = getelementptr inbounds %struct.obj_stock, ptr %retval.0.i, i32 0, i32 2
  %38 = ptrtoint ptr %nr_bytes6 to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load i32, ptr %nr_bytes6, align 4
  %add = add i32 %39, %nr_bytes
  %cmp9 = icmp ugt i32 %add, 4096
  %or.cond = select i1 %allow_uncharge.addr.0.off0, i1 %cmp9, i1 false
  %shr = lshr i32 %add, 12
  %and = and i32 %add, 4095
  %storemerge = select i1 %or.cond, i32 %and, i32 %add
  %nr_pages.0 = select i1 %or.cond, i32 %shr, i32 0
  store i32 %storemerge, ptr %nr_bytes6, align 4
  %40 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i31 = and i32 %40, -16384
  %41 = inttoptr i32 %and.i.i.i31 to ptr
  %preempt_count.i.i32 = getelementptr inbounds %struct.thread_info, ptr %41, i32 0, i32 1
  %42 = ptrtoint ptr %preempt_count.i.i32 to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load volatile i32, ptr %preempt_count.i.i32, align 4
  %and.i33 = and i32 %43, 15728640
  %44 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i39.i = and i32 %44, -16384
  %45 = inttoptr i32 %and.i.i39.i to ptr
  %preempt_count.i40.i = getelementptr inbounds %struct.thread_info, ptr %45, i32 0, i32 1
  %46 = ptrtoint ptr %preempt_count.i40.i to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load volatile i32, ptr %preempt_count.i40.i, align 4
  %and2.i34 = and i32 %47, 983040
  %or.i35 = or i32 %and2.i34, %and.i33
  %48 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i41.i = and i32 %48, -16384
  %49 = inttoptr i32 %and.i.i41.i to ptr
  %preempt_count.i42.i = getelementptr inbounds %struct.thread_info, ptr %49, i32 0, i32 1
  %50 = ptrtoint ptr %preempt_count.i42.i to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load volatile i32, ptr %preempt_count.i42.i, align 4
  %and5.i36 = and i32 %51, 256
  %or6.i37 = or i32 %or.i35, %and5.i36
  %tobool.not.i38 = icmp eq i32 %or6.i37, 0
  br i1 %tobool.not.i38, label %do.body.i, label %do.body10.i, !prof !460

do.body.i:                                        ; preds = %if.end
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !499
  %52 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i39 = and i32 %52, -16384
  %53 = inttoptr i32 %and.i.i.i.i39 to ptr
  %preempt_count.i.i.i40 = getelementptr inbounds %struct.thread_info, ptr %53, i32 0, i32 1
  %54 = ptrtoint ptr %preempt_count.i.i.i40 to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load volatile i32, ptr %preempt_count.i.i.i40, align 4
  %sub.i.i = add i32 %55, -1
  store volatile i32 %sub.i.i, ptr %preempt_count.i.i.i40, align 4
  br label %put_obj_stock.exit

do.body10.i:                                      ; preds = %if.end
  %and.i.i41 = and i32 %flags.0, 128
  %tobool13.not.i = icmp eq i32 %and.i.i41, 0
  br i1 %tobool13.not.i, label %if.then14.i, label %do.body15.i

if.then14.i:                                      ; preds = %do.body10.i
  tail call void @trace_hardirqs_on() #23
  br label %do.body15.i

do.body15.i:                                      ; preds = %if.then14.i, %do.body10.i
  %56 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i43.i = and i32 %56, 128
  %tobool23.not.i = icmp eq i32 %and.i.i43.i, 0
  br i1 %tobool23.not.i, label %if.then32.i, label %do.end34.i, !prof !466

if.then32.i:                                      ; preds = %do.body15.i
  tail call void @warn_bogus_irq_restore() #23
  br label %do.end34.i

do.end34.i:                                       ; preds = %if.then32.i, %do.body15.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %flags.0) #23, !srcloc !467
  br label %put_obj_stock.exit

put_obj_stock.exit:                               ; preds = %do.end34.i, %do.body.i
  %tobool14.not = icmp eq i32 %nr_pages.0, 0
  br i1 %tobool14.not, label %if.end16, label %if.then15

if.then15:                                        ; preds = %put_obj_stock.exit
  %call.i = tail call fastcc ptr @get_mem_cgroup_from_objcg(ptr noundef %objcg) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@refill_obj_stock, %if.then.i42)) #23
          to label %if.end.i [label %if.then.i42], !srcloc !461

if.then.i42:                                      ; preds = %if.then15
  %kmem.i = getelementptr inbounds %struct.mem_cgroup, ptr %call.i, i32 0, i32 4
  tail call void @page_counter_uncharge(ptr noundef %kmem.i, i32 noundef %nr_pages.0) #23
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i42, %if.then15
  tail call fastcc void @refill_stock(ptr noundef %call.i, i32 noundef %nr_pages.0) #23
  %flags.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call.i, i32 0, i32 7
  %57 = ptrtoint ptr %flags.i.i to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load i32, ptr %flags.i.i, align 4
  %and.i.i43 = and i32 %58, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i43, 0
  br i1 %tobool.not.i.i, label %if.then.i.i, label %if.end16

if.then.i.i:                                      ; preds = %if.end.i
  %refcnt.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call.i, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i.i) #23
  br label %if.end16

if.end16:                                         ; preds = %if.then.i.i, %if.end.i, %put_obj_stock.exit
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @obj_cgroup_uncharge(ptr noundef %objcg, i32 noundef %size) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call fastcc void @refill_obj_stock(ptr noundef %objcg, i32 noundef %size, i1 noundef zeroext true)
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @split_page_memcg(ptr noundef %head, i32 noundef %nr) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = getelementptr inbounds %struct.page, ptr %head, i32 0, i32 1
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %0, align 4
  %and.i = and i32 %2, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end.i, label %if.then.i, !prof !460

if.then.i:                                        ; preds = %entry
  %sub.i = add i32 %2, -1
  br label %_compound_head.exit

if.end.i:                                         ; preds = %entry
  %3 = ptrtoint ptr %head to i32
  br label %_compound_head.exit

_compound_head.exit:                              ; preds = %if.end.i, %if.then.i
  %retval.0.i = phi i32 [ %sub.i, %if.then.i ], [ %3, %if.end.i ]
  %4 = inttoptr i32 %retval.0.i to ptr
  %call1 = tail call fastcc ptr @folio_memcg(ptr noundef %4)
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@split_page_memcg, %cleanup)) #23
          to label %mem_cgroup_disabled.exit [label %cleanup], !srcloc !461

mem_cgroup_disabled.exit:                         ; preds = %_compound_head.exit
  %tobool.not = icmp eq ptr %call1, null
  br i1 %tobool.not, label %cleanup, label %for.cond.preheader

for.cond.preheader:                               ; preds = %mem_cgroup_disabled.exit
  %cmp32 = icmp ugt i32 %nr, 1
  br i1 %cmp32, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %memcg_data = getelementptr inbounds %struct.anon.153, ptr %4, i32 0, i32 7
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.lr.ph
  %i.033 = phi i32 [ 1, %for.body.lr.ph ], [ %inc, %for.body ]
  %5 = ptrtoint ptr %memcg_data to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %memcg_data, align 4
  %memcg_data3 = getelementptr %struct.page, ptr %4, i32 %i.033, i32 4
  %7 = ptrtoint ptr %memcg_data3 to i32
  call void @__asan_store4_noabort(i32 %7)
  store i32 %6, ptr %memcg_data3, align 4
  %inc = add nuw i32 %i.033, 1
  %exitcond.not = icmp eq i32 %inc, %nr
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %for.cond.preheader
  %8 = getelementptr inbounds %struct.page, ptr %4, i32 0, i32 1
  %9 = ptrtoint ptr %8 to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load volatile i32, ptr %8, align 4
  %and.i.i = and i32 %10, 1
  %tobool.not.i20 = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i20, label %do.body7.i, label %if.then.i21, !prof !460

if.then.i21:                                      ; preds = %for.end
  tail call void @dump_page(ptr noundef %4, ptr noundef nonnull @.str.104) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/memcontrol.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 537, 0\0A.popsection", ""() #23, !srcloc !483
  unreachable

do.body7.i:                                       ; preds = %for.end
  %memcg_data.i = getelementptr inbounds %struct.anon.153, ptr %4, i32 0, i32 7
  %11 = ptrtoint ptr %memcg_data.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %memcg_data.i, align 4
  %and.i22 = and i32 %12, 1
  %tobool8.not.i = icmp eq i32 %and.i22, 0
  br i1 %tobool8.not.i, label %folio_memcg_kmem.exit, label %if.then15.i, !prof !460

if.then15.i:                                      ; preds = %do.body7.i
  tail call void @dump_page(ptr noundef %4, ptr noundef nonnull @.str.105) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/memcontrol.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 538, 0\0A.popsection", ""() #23, !srcloc !484
  unreachable

folio_memcg_kmem.exit:                            ; preds = %do.body7.i
  %and23.i = and i32 %12, 2
  %tobool24.i.not = icmp eq i32 %and23.i, 0
  br i1 %tobool24.i.not, label %if.else, label %if.then5

if.then5:                                         ; preds = %folio_memcg_kmem.exit
  %13 = ptrtoint ptr %8 to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %8, align 4
  %and.i.i.i.i = and i32 %14, 1
  %tobool.not.i.i.i = icmp eq i32 %and.i.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %folio_test_slab.exit.i, label %if.then.i.i.i, !prof !460

if.then.i.i.i:                                    ; preds = %if.then5
  tail call void @dump_page(ptr noundef %4, ptr noundef nonnull @.str.96) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #23, !srcloc !470
  unreachable

folio_test_slab.exit.i:                           ; preds = %if.then5
  %15 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %4, align 4
  %17 = and i32 %16, 512
  %tobool.i.not.i = icmp eq i32 %17, 0
  br i1 %tobool.i.not.i, label %__folio_objcg.exit, label %if.then.i23, !prof !460

if.then.i23:                                      ; preds = %folio_test_slab.exit.i
  tail call void @dump_page(ptr noundef %4, ptr noundef nonnull @.str.58) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/memcontrol.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 417, 0\0A.popsection", ""() #23, !srcloc !485
  unreachable

__folio_objcg.exit:                               ; preds = %folio_test_slab.exit.i
  %and48.i = and i32 %12, -4
  %18 = inttoptr i32 %and48.i to ptr
  %sub = add i32 %nr, -1
  tail call fastcc void @percpu_ref_get_many(ptr noundef %18, i32 noundef %sub) #23
  br label %cleanup

if.else:                                          ; preds = %folio_memcg_kmem.exit
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call1, i32 0, i32 7
  %19 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %flags.i, align 4
  %and.i25 = and i32 %20, 1
  %tobool.not.i26 = icmp eq i32 %and.i25, 0
  br i1 %tobool.not.i26, label %if.then.i27, label %cleanup

if.then.i27:                                      ; preds = %if.else
  %sub7 = add i32 %nr, -1
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call1, i32 0, i32 2
  tail call fastcc void @percpu_ref_get_many(ptr noundef %refcnt.i, i32 noundef %sub7) #23
  br label %cleanup

cleanup:                                          ; preds = %if.then.i27, %if.else, %__folio_objcg.exit, %mem_cgroup_disabled.exit, %_compound_head.exit
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @mem_cgroup_soft_limit_reclaim(ptr noundef %pgdat, i32 noundef %order, i32 noundef %gfp_mask, ptr nocapture noundef %total_scanned) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %nr_scanned.i = alloca i32, align 4
  %reclaim.i = alloca %struct.mem_cgroup_reclaim_cookie, align 4
  %cmp = icmp sgt i32 %order, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %node_id = getelementptr inbounds %struct.pglist_data, ptr %pgdat, i32 0, i32 8
  %0 = ptrtoint ptr %node_id to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %node_id, align 64
  %arrayidx = getelementptr [1 x ptr], ptr @soft_limit_tree, i32 0, i32 %1
  %2 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %arrayidx, align 4
  %tobool.not = icmp eq ptr %3, null
  br i1 %tobool.not, label %cleanup, label %do.end

do.end:                                           ; preds = %if.end
  %4 = ptrtoint ptr %3 to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile ptr, ptr %3, align 4
  %cmp1 = icmp eq ptr %5, null
  br i1 %cmp1, label %cleanup, label %do.body4.preheader

do.body4.preheader:                               ; preds = %do.end
  %lock.i = getelementptr inbounds %struct.mem_cgroup_tree_per_node, ptr %3, i32 0, i32 2
  %6 = getelementptr inbounds %struct.mem_cgroup_reclaim_cookie, ptr %reclaim.i, i32 0, i32 1
  %rb_rightmost.i = getelementptr inbounds %struct.mem_cgroup_tree_per_node, ptr %3, i32 0, i32 1
  br label %do.body4

do.body4:                                         ; preds = %lor.lhs.false23, %do.body4.preheader
  %next_mz.0 = phi ptr [ %next_mz.1, %lor.lhs.false23 ], [ null, %do.body4.preheader ]
  %loop.0 = phi i32 [ %inc, %lor.lhs.false23 ], [ 0, %do.body4.preheader ]
  %tobool5.not = icmp eq ptr %next_mz.0, null
  br i1 %tobool5.not, label %if.end7, label %if.end10

if.end7:                                          ; preds = %do.body4
  call void @_raw_spin_lock_irq(ptr noundef %lock.i) #23
  %call.i = call fastcc ptr @__mem_cgroup_largest_soft_limit_node(ptr noundef nonnull %3) #23
  call void @_raw_spin_unlock_irq(ptr noundef %lock.i) #23
  %tobool8.not = icmp eq ptr %call.i, null
  br i1 %tobool8.not, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end7, %do.body4
  %mz.088 = phi ptr [ %call.i, %if.end7 ], [ %next_mz.0, %do.body4 ]
  %memcg = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %mz.088, i32 0, i32 9
  %7 = ptrtoint ptr %memcg to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %memcg, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %nr_scanned.i) #23
  %9 = ptrtoint ptr %nr_scanned.i to i32
  call void @__asan_store4_noabort(i32 %9)
  store i32 -1, ptr %nr_scanned.i, align 4, !annotation !492
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %reclaim.i) #23
  %10 = ptrtoint ptr %reclaim.i to i32
  call void @__asan_store4_noabort(i32 %10)
  store ptr %pgdat, ptr %reclaim.i, align 4
  %11 = ptrtoint ptr %6 to i32
  call void @__asan_store4_noabort(i32 %11)
  store i32 0, ptr %6, align 4
  %memory.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %8, i32 0, i32 2
  %call.i.i.i.i.i = call zeroext i1 @__kasan_check_read(ptr noundef %memory.i.i, i32 noundef 4) #23
  %12 = ptrtoint ptr %memory.i.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load volatile i32, ptr %memory.i.i, align 4
  %soft_limit1.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %8, i32 0, i32 7
  %14 = ptrtoint ptr %soft_limit1.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %soft_limit1.i.i, align 4
  %16 = call i32 @llvm.usub.sat.i32(i32 %13, i32 %15) #23
  %shr.i = lshr i32 %16, 2
  br label %while.cond.outer.i

while.cond.outer.i:                               ; preds = %if.end11.i, %if.end10
  %nr_scanned.0 = phi i32 [ 0, %if.end10 ], [ %add13.i, %if.end11.i ]
  %victim.0.ph.i = phi ptr [ null, %if.end10 ], [ %call2.lcssa.i, %if.end11.i ]
  %total.0.ph.i = phi i32 [ 0, %if.end10 ], [ %add.i, %if.end11.i ]
  %loop.0.ph.i = phi i32 [ 0, %if.end10 ], [ %loop.0.lcssa.i, %if.end11.i ]
  %call239.i = call ptr @mem_cgroup_iter(ptr noundef %8, ptr noundef %victim.0.ph.i, ptr noundef nonnull %reclaim.i) #23
  %tobool.not40.i = icmp eq ptr %call239.i, null
  br i1 %tobool.not40.i, label %if.then.lr.ph.i, label %if.end11.i

if.then.lr.ph.i:                                  ; preds = %while.cond.outer.i
  %tobool4.not.i = icmp eq i32 %total.0.ph.i, 0
  %cmp6.not.i = icmp uge i32 %total.0.ph.i, %shr.i
  br label %if.then.i

if.then.i:                                        ; preds = %if.end10.i, %if.then.lr.ph.i
  %loop.041.i = phi i32 [ %loop.0.ph.i, %if.then.lr.ph.i ], [ %inc.i, %if.end10.i ]
  %inc.i = add i32 %loop.041.i, 1
  %cmp.i = icmp sgt i32 %inc.i, 1
  br i1 %cmp.i, label %if.then3.i, label %if.end10.i

if.then3.i:                                       ; preds = %if.then.i
  br i1 %tobool4.not.i, label %while.end.i, label %if.end.i

if.end.i:                                         ; preds = %if.then3.i
  %cmp7.i = icmp ugt i32 %inc.i, 100
  %or.cond.i = select i1 %cmp6.not.i, i1 true, i1 %cmp7.i
  br i1 %or.cond.i, label %while.end.i, label %if.end10.i

if.end10.i:                                       ; preds = %if.end.i, %if.then.i
  %call2.i = call ptr @mem_cgroup_iter(ptr noundef %8, ptr noundef null, ptr noundef nonnull %reclaim.i) #23
  %tobool.not.i = icmp eq ptr %call2.i, null
  br i1 %tobool.not.i, label %if.then.i, label %if.end11.i

if.end11.i:                                       ; preds = %if.end10.i, %while.cond.outer.i
  %loop.0.lcssa.i = phi i32 [ %loop.0.ph.i, %while.cond.outer.i ], [ %inc.i, %if.end10.i ]
  %call2.lcssa.i = phi ptr [ %call239.i, %while.cond.outer.i ], [ %call2.i, %if.end10.i ]
  %call12.i = call i32 @mem_cgroup_shrink_node(ptr noundef nonnull %call2.lcssa.i, i32 noundef %gfp_mask, i1 noundef zeroext false, ptr noundef %pgdat, ptr noundef nonnull %nr_scanned.i) #23
  %add.i = add i32 %call12.i, %total.0.ph.i
  %17 = ptrtoint ptr %nr_scanned.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %nr_scanned.i, align 4
  %add13.i = add i32 %18, %nr_scanned.0
  %call.i.i.i.i31.i = call zeroext i1 @__kasan_check_read(ptr noundef %memory.i.i, i32 noundef 4) #23
  %19 = ptrtoint ptr %memory.i.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load volatile i32, ptr %memory.i.i, align 4
  %21 = ptrtoint ptr %soft_limit1.i.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load volatile i32, ptr %soft_limit1.i.i, align 4
  %tobool15.not.not.i = icmp ugt i32 %20, %22
  br i1 %tobool15.not.not.i, label %while.cond.outer.i, label %while.end.i

while.end.i:                                      ; preds = %if.end11.i, %if.end.i, %if.then3.i
  %nr_scanned.1 = phi i32 [ %nr_scanned.0, %if.then3.i ], [ %nr_scanned.0, %if.end.i ], [ %add13.i, %if.end11.i ]
  %call237.i = phi ptr [ null, %if.then3.i ], [ null, %if.end.i ], [ %call2.lcssa.i, %if.end11.i ]
  %tobool.not35.i = phi i1 [ true, %if.then3.i ], [ true, %if.end.i ], [ false, %if.end11.i ]
  %total.1.i = phi i32 [ %total.0.ph.i, %if.end.i ], [ 0, %if.then3.i ], [ %add.i, %if.end11.i ]
  %tobool.not.i.i = icmp eq ptr %8, null
  br i1 %tobool.not.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %while.end.i
  %23 = load ptr, ptr @root_mem_cgroup, align 4
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i.i, %while.end.i
  %root.addr.0.i.i = phi ptr [ %8, %while.end.i ], [ %23, %if.then.i.i ]
  %cmp.not.i.i = icmp eq ptr %root.addr.0.i.i, %call237.i
  %or.cond.i.i = select i1 %tobool.not35.i, i1 true, i1 %cmp.not.i.i
  br i1 %or.cond.i.i, label %mem_cgroup_soft_reclaim.exit, label %if.then2.i.i

if.then2.i.i:                                     ; preds = %if.end.i.i
  %flags.i.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call237.i, i32 0, i32 7
  %24 = ptrtoint ptr %flags.i.i.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %flags.i.i.i, align 4
  %and.i.i.i = and i32 %25, 1
  %tobool.not.i.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %if.then.i.i.i, label %mem_cgroup_soft_reclaim.exit

if.then.i.i.i:                                    ; preds = %if.then2.i.i
  %refcnt.i.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call237.i, i32 0, i32 2
  call fastcc void @percpu_ref_put(ptr noundef %refcnt.i.i.i) #23
  br label %mem_cgroup_soft_reclaim.exit

mem_cgroup_soft_reclaim.exit:                     ; preds = %if.then.i.i.i, %if.then2.i.i, %if.end.i.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %reclaim.i) #23
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %nr_scanned.i) #23
  %26 = ptrtoint ptr %total_scanned to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %total_scanned, align 4
  %add12 = add i32 %27, %nr_scanned.1
  store i32 %add12, ptr %total_scanned, align 4
  call void @_raw_spin_lock_irq(ptr noundef %lock.i) #23
  %on_tree.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %mz.088, i32 0, i32 8
  %28 = ptrtoint ptr %on_tree.i to i32
  call void @__asan_load1_noabort(i32 %28)
  %29 = load i8, ptr %on_tree.i, align 4, !range !488
  %tobool.not.i64 = icmp eq i8 %29, 0
  br i1 %tobool.not.i64, label %__mem_cgroup_remove_exceeded.exit, label %if.end.i66

if.end.i66:                                       ; preds = %mem_cgroup_soft_reclaim.exit
  %tree_node.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %mz.088, i32 0, i32 6
  %30 = ptrtoint ptr %rb_rightmost.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %rb_rightmost.i, align 4
  %cmp.i65 = icmp eq ptr %tree_node.i, %31
  br i1 %cmp.i65, label %if.then1.i, label %if.end4.i

if.then1.i:                                       ; preds = %if.end.i66
  %call.i67 = call ptr @rb_prev(ptr noundef %tree_node.i) #23
  %32 = ptrtoint ptr %rb_rightmost.i to i32
  call void @__asan_store4_noabort(i32 %32)
  store ptr %call.i67, ptr %rb_rightmost.i, align 4
  br label %if.end4.i

if.end4.i:                                        ; preds = %if.then1.i, %if.end.i66
  call void @rb_erase(ptr noundef %tree_node.i, ptr noundef nonnull %3) #23
  %33 = ptrtoint ptr %on_tree.i to i32
  call void @__asan_store1_noabort(i32 %33)
  store i8 0, ptr %on_tree.i, align 4
  br label %__mem_cgroup_remove_exceeded.exit

__mem_cgroup_remove_exceeded.exit:                ; preds = %if.end4.i, %mem_cgroup_soft_reclaim.exit
  %tobool13.not = icmp eq i32 %total.1.i, 0
  br i1 %tobool13.not, label %if.then14, label %if.end16

if.then14:                                        ; preds = %__mem_cgroup_remove_exceeded.exit
  %call15 = call fastcc ptr @__mem_cgroup_largest_soft_limit_node(ptr noundef nonnull %3)
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %__mem_cgroup_remove_exceeded.exit
  %next_mz.1 = phi ptr [ null, %__mem_cgroup_remove_exceeded.exit ], [ %call15, %if.then14 ]
  %34 = ptrtoint ptr %memcg to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load ptr, ptr %memcg, align 4
  %memory.i = getelementptr inbounds %struct.mem_cgroup, ptr %35, i32 0, i32 2
  %call.i.i.i.i = call zeroext i1 @__kasan_check_read(ptr noundef %memory.i, i32 noundef 4) #23
  %36 = ptrtoint ptr %memory.i to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load volatile i32, ptr %memory.i, align 4
  %soft_limit1.i = getelementptr inbounds %struct.mem_cgroup, ptr %35, i32 0, i32 7
  %38 = ptrtoint ptr %soft_limit1.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load volatile i32, ptr %soft_limit1.i, align 4
  %40 = call i32 @llvm.usub.sat.i32(i32 %37, i32 %39) #23
  %41 = ptrtoint ptr %on_tree.i to i32
  call void @__asan_load1_noabort(i32 %41)
  %42 = load i8, ptr %on_tree.i, align 4, !range !488
  %tobool.not.i69 = icmp eq i8 %42, 0
  br i1 %tobool.not.i69, label %if.end.i70, label %__mem_cgroup_insert_exceeded.exit

if.end.i70:                                       ; preds = %if.end16
  %usage_in_excess.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %mz.088, i32 0, i32 7
  %43 = ptrtoint ptr %usage_in_excess.i to i32
  call void @__asan_store4_noabort(i32 %43)
  store i32 %40, ptr %usage_in_excess.i, align 4
  %tobool2.not.i.not = icmp ugt i32 %37, %39
  br i1 %tobool2.not.i.not, label %while.cond.preheader.i, label %__mem_cgroup_insert_exceeded.exit

while.cond.preheader.i:                           ; preds = %if.end.i70
  %44 = ptrtoint ptr %3 to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load ptr, ptr %3, align 4
  %tobool5.not35.i = icmp eq ptr %45, null
  br i1 %tobool5.not35.i, label %if.then11.i, label %while.body.i

while.body.i:                                     ; preds = %while.body.i, %while.cond.preheader.i
  %46 = phi ptr [ %50, %while.body.i ], [ %45, %while.cond.preheader.i ]
  %rightmost.0.off036.i = phi i1 [ %rightmost.1.off0.i, %while.body.i ], [ true, %while.cond.preheader.i ]
  %usage_in_excess7.i = getelementptr i8, ptr %46, i32 12
  %47 = ptrtoint ptr %usage_in_excess7.i to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load i32, ptr %usage_in_excess7.i, align 4
  %cmp.i71 = icmp ugt i32 %48, %40
  %rb_left.i = getelementptr inbounds %struct.rb_node, ptr %46, i32 0, i32 2
  %rb_right.i = getelementptr inbounds %struct.rb_node, ptr %46, i32 0, i32 1
  %not.cmp.i = xor i1 %cmp.i71, true
  %rightmost.1.off0.i = select i1 %not.cmp.i, i1 %rightmost.0.off036.i, i1 false
  %p.1.i = select i1 %cmp.i71, ptr %rb_left.i, ptr %rb_right.i
  %49 = ptrtoint ptr %p.1.i to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load ptr, ptr %p.1.i, align 4
  %tobool5.not.i = icmp eq ptr %50, null
  br i1 %tobool5.not.i, label %while.end.i72, label %while.body.i

while.end.i72:                                    ; preds = %while.body.i
  %phi.cast.le.i = ptrtoint ptr %46 to i32
  br i1 %rightmost.1.off0.i, label %if.then11.i, label %if.end12.i

if.then11.i:                                      ; preds = %while.end.i72, %while.cond.preheader.i
  %p.0.lcssa45.i = phi ptr [ %p.1.i, %while.end.i72 ], [ %3, %while.cond.preheader.i ]
  %parent.0.lcssa43.i = phi i32 [ %phi.cast.le.i, %while.end.i72 ], [ 0, %while.cond.preheader.i ]
  %tree_node.i73 = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %mz.088, i32 0, i32 6
  %51 = ptrtoint ptr %rb_rightmost.i to i32
  call void @__asan_store4_noabort(i32 %51)
  store ptr %tree_node.i73, ptr %rb_rightmost.i, align 4
  br label %if.end12.i

if.end12.i:                                       ; preds = %if.then11.i, %while.end.i72
  %p.0.lcssa44.i = phi ptr [ %p.0.lcssa45.i, %if.then11.i ], [ %p.1.i, %while.end.i72 ]
  %parent.0.lcssa42.i = phi i32 [ %parent.0.lcssa43.i, %if.then11.i ], [ %phi.cast.le.i, %while.end.i72 ]
  %tree_node13.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %mz.088, i32 0, i32 6
  %52 = ptrtoint ptr %tree_node13.i to i32
  call void @__asan_store4_noabort(i32 %52)
  store i32 %parent.0.lcssa42.i, ptr %tree_node13.i, align 4
  %rb_right.i.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %mz.088, i32 0, i32 6, i32 1
  %53 = ptrtoint ptr %rb_right.i.i to i32
  call void @__asan_store4_noabort(i32 %53)
  store ptr null, ptr %rb_right.i.i, align 4
  %rb_left.i.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %mz.088, i32 0, i32 6, i32 2
  %54 = ptrtoint ptr %rb_left.i.i to i32
  call void @__asan_store4_noabort(i32 %54)
  store ptr null, ptr %rb_left.i.i, align 4
  %55 = ptrtoint ptr %p.0.lcssa44.i to i32
  call void @__asan_store4_noabort(i32 %55)
  store ptr %tree_node13.i, ptr %p.0.lcssa44.i, align 4
  call void @rb_insert_color(ptr noundef %tree_node13.i, ptr noundef nonnull %3) #23
  %56 = ptrtoint ptr %on_tree.i to i32
  call void @__asan_store1_noabort(i32 %56)
  store i8 1, ptr %on_tree.i, align 4
  br label %__mem_cgroup_insert_exceeded.exit

__mem_cgroup_insert_exceeded.exit:                ; preds = %if.end12.i, %if.end.i70, %if.end16
  call void @_raw_spin_unlock_irq(ptr noundef %lock.i) #23
  %57 = ptrtoint ptr %memcg to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load ptr, ptr %memcg, align 4
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %58, i32 0, i32 7
  %59 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %59)
  %60 = load i32, ptr %flags.i, align 4
  %and.i = and i32 %60, 1
  %tobool.not.i75 = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i75, label %if.then.i76, label %css_put.exit

if.then.i76:                                      ; preds = %__mem_cgroup_insert_exceeded.exit
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %58, i32 0, i32 2
  call fastcc void @percpu_ref_put(ptr noundef %refcnt.i) #23
  br label %css_put.exit

css_put.exit:                                     ; preds = %if.then.i76, %__mem_cgroup_insert_exceeded.exit
  %inc = add nuw nsw i32 %loop.0, 1
  %cmp22 = icmp eq ptr %next_mz.1, null
  br i1 %tobool13.not, label %land.lhs.true, label %do.end29

land.lhs.true:                                    ; preds = %css_put.exit
  br i1 %cmp22, label %cleanup, label %lor.lhs.false23

lor.lhs.false23:                                  ; preds = %land.lhs.true
  %exitcond = icmp eq i32 %inc, 3
  br i1 %exitcond, label %if.then31, label %do.body4

do.end29:                                         ; preds = %css_put.exit
  br i1 %cmp22, label %cleanup, label %if.then31

if.then31:                                        ; preds = %do.end29, %lor.lhs.false23
  %memcg32 = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %next_mz.1, i32 0, i32 9
  %61 = ptrtoint ptr %memcg32 to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load ptr, ptr %memcg32, align 4
  %flags.i78 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %62, i32 0, i32 7
  %63 = ptrtoint ptr %flags.i78 to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load i32, ptr %flags.i78, align 4
  %and.i79 = and i32 %64, 1
  %tobool.not.i80 = icmp eq i32 %and.i79, 0
  br i1 %tobool.not.i80, label %if.then.i82, label %cleanup

if.then.i82:                                      ; preds = %if.then31
  %refcnt.i81 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %62, i32 0, i32 2
  call fastcc void @percpu_ref_put(ptr noundef %refcnt.i81) #23
  br label %cleanup

cleanup:                                          ; preds = %if.then.i82, %if.then31, %do.end29, %land.lhs.true, %if.end7, %do.end, %if.end, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ 0, %do.end ], [ 0, %if.end ], [ %total.1.i, %do.end29 ], [ %total.1.i, %if.then31 ], [ %total.1.i, %if.then.i82 ], [ 0, %land.lhs.true ], [ 0, %if.end7 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc ptr @__mem_cgroup_largest_soft_limit_node(ptr noundef %mctz) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %rb_rightmost = getelementptr inbounds %struct.mem_cgroup_tree_per_node, ptr %mctz, i32 0, i32 1
  %0 = ptrtoint ptr %rb_rightmost to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %rb_rightmost, align 4
  %tobool.not21 = icmp eq ptr %1, null
  br i1 %tobool.not21, label %done, label %if.end

if.end:                                           ; preds = %if.then5, %entry
  %2 = phi ptr [ %18, %if.then5 ], [ %1, %entry ]
  %on_tree.i = getelementptr i8, ptr %2, i32 16
  %3 = ptrtoint ptr %on_tree.i to i32
  call void @__asan_load1_noabort(i32 %3)
  %4 = load i8, ptr %on_tree.i, align 4, !range !488
  %tobool.not.i = icmp eq i8 %4, 0
  br i1 %tobool.not.i, label %__mem_cgroup_remove_exceeded.exit, label %if.end4.i

if.end4.i:                                        ; preds = %if.end
  %call.i = tail call ptr @rb_prev(ptr noundef nonnull %2) #23
  %5 = ptrtoint ptr %rb_rightmost to i32
  call void @__asan_store4_noabort(i32 %5)
  store ptr %call.i, ptr %rb_rightmost, align 4
  tail call void @rb_erase(ptr noundef nonnull %2, ptr noundef %mctz) #23
  %6 = ptrtoint ptr %on_tree.i to i32
  call void @__asan_store1_noabort(i32 %6)
  store i8 0, ptr %on_tree.i, align 4
  br label %__mem_cgroup_remove_exceeded.exit

__mem_cgroup_remove_exceeded.exit:                ; preds = %if.end4.i, %if.end
  %memcg = getelementptr i8, ptr %2, i32 20
  %7 = ptrtoint ptr %memcg to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %memcg, align 4
  %memory.i = getelementptr inbounds %struct.mem_cgroup, ptr %8, i32 0, i32 2
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %memory.i, i32 noundef 4) #23
  %9 = ptrtoint ptr %memory.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load volatile i32, ptr %memory.i, align 4
  %soft_limit1.i = getelementptr inbounds %struct.mem_cgroup, ptr %8, i32 0, i32 7
  %11 = ptrtoint ptr %soft_limit1.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %soft_limit1.i, align 4
  %tobool2.not.not = icmp ugt i32 %10, %12
  br i1 %tobool2.not.not, label %lor.lhs.false, label %if.then5

lor.lhs.false:                                    ; preds = %__mem_cgroup_remove_exceeded.exit
  %13 = ptrtoint ptr %memcg to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %memcg, align 4
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %14, i32 0, i32 7
  %15 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %flags.i, align 4
  %and.i = and i32 %16, 1
  %tobool.not.i12 = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i12, label %css_tryget.exit, label %done.split.loop.exit

css_tryget.exit:                                  ; preds = %lor.lhs.false
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %14, i32 0, i32 2
  %call.i13 = tail call fastcc zeroext i1 @percpu_ref_tryget(ptr noundef %refcnt.i) #23
  br i1 %call.i13, label %done.split.loop.exit15, label %if.then5

if.then5:                                         ; preds = %css_tryget.exit, %__mem_cgroup_remove_exceeded.exit
  %17 = ptrtoint ptr %rb_rightmost to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %rb_rightmost, align 4
  %tobool.not = icmp eq ptr %18, null
  br i1 %tobool.not, label %done, label %if.end

done.split.loop.exit:                             ; preds = %lor.lhs.false
  %add.ptr.le19 = getelementptr i8, ptr %2, i32 -528
  br label %done

done.split.loop.exit15:                           ; preds = %css_tryget.exit
  %add.ptr.le = getelementptr i8, ptr %2, i32 -528
  br label %done

done:                                             ; preds = %done.split.loop.exit15, %done.split.loop.exit, %if.then5, %entry
  %mz.0 = phi ptr [ %add.ptr.le19, %done.split.loop.exit ], [ %add.ptr.le, %done.split.loop.exit15 ], [ null, %entry ], [ null, %if.then5 ]
  ret ptr %mz.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync)
define dso_local ptr @mem_cgroup_wb_domain(ptr nocapture noundef readonly %wb) local_unnamed_addr #0 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %memcg_css = getelementptr inbounds %struct.bdi_writeback, ptr %wb, i32 0, i32 29
  %0 = ptrtoint ptr %memcg_css to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %memcg_css, align 8
  %parent = getelementptr inbounds %struct.cgroup_subsys_state, ptr %1, i32 0, i32 12
  %2 = ptrtoint ptr %parent to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %parent, align 32
  %tobool.not = icmp eq ptr %3, null
  %cgwb_domain = getelementptr inbounds %struct.mem_cgroup, ptr %1, i32 0, i32 41
  %retval.0 = select i1 %tobool.not, ptr null, ptr %cgwb_domain
  ret ptr %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mem_cgroup_wb_stats(ptr nocapture noundef readonly %wb, ptr nocapture noundef writeonly %pfilepages, ptr nocapture noundef %pheadroom, ptr nocapture noundef writeonly %pdirty, ptr nocapture noundef writeonly %pwriteback) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %memcg_css = getelementptr inbounds %struct.bdi_writeback, ptr %wb, i32 0, i32 29
  %0 = ptrtoint ptr %memcg_css to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %memcg_css, align 8
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @stats_flush_threshold, i32 noundef 4) #23
  %2 = load volatile i32, ptr @stats_flush_threshold, align 4
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @__num_online_cpus, i32 noundef 4) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__num_online_cpus to i32))
  %3 = load volatile i32, ptr @__num_online_cpus, align 4
  %cmp.i = icmp ugt i32 %2, %3
  br i1 %cmp.i, label %if.then.i, label %mem_cgroup_flush_stats.exit

if.then.i:                                        ; preds = %entry
  tail call fastcc void @__mem_cgroup_flush_stats() #23
  br label %mem_cgroup_flush_stats.exit

mem_cgroup_flush_stats.exit:                      ; preds = %if.then.i, %entry
  %arrayidx.i = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 26, i32 0, i32 20
  %4 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %arrayidx.i, align 4
  %6 = ptrtoint ptr %pdirty to i32
  call void @__asan_store4_noabort(i32 %6)
  store i32 %5, ptr %pdirty, align 4
  %arrayidx.i45 = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 26, i32 0, i32 21
  %7 = ptrtoint ptr %arrayidx.i45 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load volatile i32, ptr %arrayidx.i45, align 4
  %9 = ptrtoint ptr %pwriteback to i32
  call void @__asan_store4_noabort(i32 %9)
  store i32 %8, ptr %pwriteback, align 4
  %arrayidx.i47 = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 26, i32 0, i32 2
  %10 = ptrtoint ptr %arrayidx.i47 to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %arrayidx.i47, align 4
  %arrayidx.i49 = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 26, i32 0, i32 3
  %12 = ptrtoint ptr %arrayidx.i49 to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load volatile i32, ptr %arrayidx.i49, align 4
  %add = add i32 %13, %11
  %14 = ptrtoint ptr %pfilepages to i32
  call void @__asan_store4_noabort(i32 %14)
  store i32 %add, ptr %pfilepages, align 4
  %15 = ptrtoint ptr %pheadroom to i32
  call void @__asan_store4_noabort(i32 %15)
  store i32 2147483647, ptr %pheadroom, align 4
  %parent.i52 = getelementptr inbounds %struct.mem_cgroup, ptr %1, i32 0, i32 2, i32 13
  %16 = ptrtoint ptr %parent.i52 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %parent.i52, align 4
  %tobool.not.i53 = icmp eq ptr %17, null
  %add.ptr.i54 = getelementptr i8, ptr %17, i32 -176
  %tobool.not5155 = icmp eq ptr %add.ptr.i54, null
  %tobool.not56 = or i1 %tobool.not.i53, %tobool.not5155
  br i1 %tobool.not56, label %while.end, label %while.body

while.body:                                       ; preds = %while.body, %mem_cgroup_flush_stats.exit
  %add.ptr.i58 = phi ptr [ %add.ptr.i, %while.body ], [ %add.ptr.i54, %mem_cgroup_flush_stats.exit ]
  %memcg.057 = phi ptr [ %add.ptr.i58, %while.body ], [ %1, %mem_cgroup_flush_stats.exit ]
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.057, i32 0, i32 2
  %max = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.057, i32 0, i32 2, i32 4
  %18 = ptrtoint ptr %max to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load volatile i32, ptr %max, align 16
  %high = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.057, i32 0, i32 2, i32 3
  %20 = ptrtoint ptr %high to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load volatile i32, ptr %high, align 4
  %22 = tail call i32 @llvm.umin.i32(i32 %19, i32 %21)
  %call.i.i.i50 = tail call zeroext i1 @__kasan_check_read(ptr noundef %memory, i32 noundef 4) #23
  %23 = ptrtoint ptr %memory to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load volatile i32, ptr %memory, align 4
  %25 = ptrtoint ptr %pheadroom to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %pheadroom, align 4
  %27 = tail call i32 @llvm.usub.sat.i32(i32 %22, i32 %24)
  %28 = tail call i32 @llvm.umin.i32(i32 %26, i32 %27)
  %29 = ptrtoint ptr %pheadroom to i32
  call void @__asan_store4_noabort(i32 %29)
  store i32 %28, ptr %pheadroom, align 4
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %add.ptr.i58, i32 0, i32 2, i32 13
  %30 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %parent.i, align 4
  %tobool.not.i = icmp eq ptr %31, null
  %add.ptr.i = getelementptr i8, ptr %31, i32 -176
  %tobool.not51 = icmp eq ptr %add.ptr.i, null
  %tobool.not = or i1 %tobool.not.i, %tobool.not51
  br i1 %tobool.not, label %while.end, label %while.body

while.end:                                        ; preds = %while.body, %mem_cgroup_flush_stats.exit
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mem_cgroup_track_foreign_dirty_slowpath(ptr noundef %folio, ptr noundef %wb) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call fastcc ptr @folio_memcg(ptr noundef %folio)
  %call1 = tail call i64 @get_jiffies_64() #23
  tail call fastcc void @trace_track_foreign_dirty(ptr noundef %folio, ptr noundef %wb)
  %memcg_css = getelementptr inbounds %struct.bdi_writeback, ptr %wb, i32 0, i32 29
  %arrayidx = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 0
  %0 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load8_noabort(i32 %0)
  %1 = load i64, ptr %arrayidx, align 8
  %2 = ptrtoint ptr %wb to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %wb, align 8
  %4 = ptrtoint ptr %3 to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %3, align 8
  %cmp2 = icmp eq i64 %1, %5
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %memcg_id = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 0, i32 1
  %6 = ptrtoint ptr %memcg_id to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %memcg_id, align 8
  %8 = ptrtoint ptr %memcg_css to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %memcg_css, align 8
  %id3 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %9, i32 0, i32 6
  %10 = ptrtoint ptr %id3 to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %id3, align 8
  %cmp4 = icmp eq i32 %7, %11
  br i1 %cmp4, label %if.else.i, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %at = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 0, i32 2
  %12 = ptrtoint ptr %at to i32
  call void @__asan_load8_noabort(i32 %12)
  %13 = load i64, ptr %at, align 8
  %sub = sub i64 %13, %call1
  %cmp5 = icmp slt i64 %sub, 0
  br i1 %cmp5, label %land.lhs.true6, label %for.inc

land.lhs.true6:                                   ; preds = %if.end
  %done = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 0, i32 3
  %call.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %done, i32 noundef 4) #23
  %14 = ptrtoint ptr %done to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %done, align 4
  %cmp8 = icmp eq i32 %15, 1
  br i1 %cmp8, label %if.then9, label %for.inc

if.then9:                                         ; preds = %land.lhs.true6
  %16 = ptrtoint ptr %at to i32
  call void @__asan_load8_noabort(i32 %16)
  %17 = load i64, ptr %at, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.then9, %land.lhs.true6, %if.end
  %oldest_at.1 = phi i64 [ %17, %if.then9 ], [ %call1, %land.lhs.true6 ], [ %call1, %if.end ]
  %oldest.1 = phi i32 [ 0, %if.then9 ], [ -1, %land.lhs.true6 ], [ -1, %if.end ]
  %arrayidx.1 = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 1
  %18 = ptrtoint ptr %arrayidx.1 to i32
  call void @__asan_load8_noabort(i32 %18)
  %19 = load i64, ptr %arrayidx.1, align 8
  %20 = ptrtoint ptr %wb to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %wb, align 8
  %22 = ptrtoint ptr %21 to i32
  call void @__asan_load8_noabort(i32 %22)
  %23 = load i64, ptr %21, align 8
  %cmp2.1 = icmp eq i64 %19, %23
  br i1 %cmp2.1, label %land.lhs.true.1, label %if.end.1

land.lhs.true.1:                                  ; preds = %for.inc
  %memcg_id.1 = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 1, i32 1
  %24 = ptrtoint ptr %memcg_id.1 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %memcg_id.1, align 8
  %26 = ptrtoint ptr %memcg_css to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load ptr, ptr %memcg_css, align 8
  %id3.1 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %27, i32 0, i32 6
  %28 = ptrtoint ptr %id3.1 to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %id3.1, align 8
  %cmp4.1 = icmp eq i32 %25, %29
  br i1 %cmp4.1, label %if.else.i, label %if.end.1

if.end.1:                                         ; preds = %land.lhs.true.1, %for.inc
  %at.1 = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 1, i32 2
  %30 = ptrtoint ptr %at.1 to i32
  call void @__asan_load8_noabort(i32 %30)
  %31 = load i64, ptr %at.1, align 8
  %sub.1 = sub i64 %31, %oldest_at.1
  %cmp5.1 = icmp slt i64 %sub.1, 0
  br i1 %cmp5.1, label %land.lhs.true6.1, label %for.inc.1

land.lhs.true6.1:                                 ; preds = %if.end.1
  %done.1 = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 1, i32 3
  %call.i.i.1 = tail call zeroext i1 @__kasan_check_read(ptr noundef %done.1, i32 noundef 4) #23
  %32 = ptrtoint ptr %done.1 to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load volatile i32, ptr %done.1, align 4
  %cmp8.1 = icmp eq i32 %33, 1
  br i1 %cmp8.1, label %if.then9.1, label %for.inc.1

if.then9.1:                                       ; preds = %land.lhs.true6.1
  %34 = ptrtoint ptr %at.1 to i32
  call void @__asan_load8_noabort(i32 %34)
  %35 = load i64, ptr %at.1, align 8
  br label %for.inc.1

for.inc.1:                                        ; preds = %if.then9.1, %land.lhs.true6.1, %if.end.1
  %oldest_at.1.1 = phi i64 [ %35, %if.then9.1 ], [ %oldest_at.1, %land.lhs.true6.1 ], [ %oldest_at.1, %if.end.1 ]
  %oldest.1.1 = phi i32 [ 1, %if.then9.1 ], [ %oldest.1, %land.lhs.true6.1 ], [ %oldest.1, %if.end.1 ]
  %arrayidx.2 = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 2
  %36 = ptrtoint ptr %arrayidx.2 to i32
  call void @__asan_load8_noabort(i32 %36)
  %37 = load i64, ptr %arrayidx.2, align 8
  %38 = ptrtoint ptr %wb to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load ptr, ptr %wb, align 8
  %40 = ptrtoint ptr %39 to i32
  call void @__asan_load8_noabort(i32 %40)
  %41 = load i64, ptr %39, align 8
  %cmp2.2 = icmp eq i64 %37, %41
  br i1 %cmp2.2, label %land.lhs.true.2, label %if.end.2

land.lhs.true.2:                                  ; preds = %for.inc.1
  %memcg_id.2 = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 2, i32 1
  %42 = ptrtoint ptr %memcg_id.2 to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load i32, ptr %memcg_id.2, align 8
  %44 = ptrtoint ptr %memcg_css to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load ptr, ptr %memcg_css, align 8
  %id3.2 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %45, i32 0, i32 6
  %46 = ptrtoint ptr %id3.2 to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load i32, ptr %id3.2, align 8
  %cmp4.2 = icmp eq i32 %43, %47
  br i1 %cmp4.2, label %if.else.i, label %if.end.2

if.end.2:                                         ; preds = %land.lhs.true.2, %for.inc.1
  %at.2 = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 2, i32 2
  %48 = ptrtoint ptr %at.2 to i32
  call void @__asan_load8_noabort(i32 %48)
  %49 = load i64, ptr %at.2, align 8
  %sub.2 = sub i64 %49, %oldest_at.1.1
  %cmp5.2 = icmp slt i64 %sub.2, 0
  br i1 %cmp5.2, label %land.lhs.true6.2, label %for.inc.2

land.lhs.true6.2:                                 ; preds = %if.end.2
  %done.2 = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 2, i32 3
  %call.i.i.2 = tail call zeroext i1 @__kasan_check_read(ptr noundef %done.2, i32 noundef 4) #23
  %50 = ptrtoint ptr %done.2 to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load volatile i32, ptr %done.2, align 4
  %cmp8.2 = icmp eq i32 %51, 1
  br i1 %cmp8.2, label %if.then9.2, label %for.inc.2

if.then9.2:                                       ; preds = %land.lhs.true6.2
  %52 = ptrtoint ptr %at.2 to i32
  call void @__asan_load8_noabort(i32 %52)
  %53 = load i64, ptr %at.2, align 8
  br label %for.inc.2

for.inc.2:                                        ; preds = %if.then9.2, %land.lhs.true6.2, %if.end.2
  %oldest_at.1.2 = phi i64 [ %53, %if.then9.2 ], [ %oldest_at.1.1, %land.lhs.true6.2 ], [ %oldest_at.1.1, %if.end.2 ]
  %oldest.1.2 = phi i32 [ 2, %if.then9.2 ], [ %oldest.1.1, %land.lhs.true6.2 ], [ %oldest.1.1, %if.end.2 ]
  %arrayidx.3 = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 3
  %54 = ptrtoint ptr %arrayidx.3 to i32
  call void @__asan_load8_noabort(i32 %54)
  %55 = load i64, ptr %arrayidx.3, align 8
  %56 = ptrtoint ptr %wb to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load ptr, ptr %wb, align 8
  %58 = ptrtoint ptr %57 to i32
  call void @__asan_load8_noabort(i32 %58)
  %59 = load i64, ptr %57, align 8
  %cmp2.3 = icmp eq i64 %55, %59
  br i1 %cmp2.3, label %land.lhs.true.3, label %if.end.3

land.lhs.true.3:                                  ; preds = %for.inc.2
  %memcg_id.3 = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 3, i32 1
  %60 = ptrtoint ptr %memcg_id.3 to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load i32, ptr %memcg_id.3, align 8
  %62 = ptrtoint ptr %memcg_css to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load ptr, ptr %memcg_css, align 8
  %id3.3 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %63, i32 0, i32 6
  %64 = ptrtoint ptr %id3.3 to i32
  call void @__asan_load4_noabort(i32 %64)
  %65 = load i32, ptr %id3.3, align 8
  %cmp4.3 = icmp eq i32 %61, %65
  br i1 %cmp4.3, label %if.else.i, label %if.end.3

if.end.3:                                         ; preds = %land.lhs.true.3, %for.inc.2
  %at.3 = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 3, i32 2
  %66 = ptrtoint ptr %at.3 to i32
  call void @__asan_load8_noabort(i32 %66)
  %67 = load i64, ptr %at.3, align 8
  %sub.3 = sub i64 %67, %oldest_at.1.2
  %cmp5.3 = icmp slt i64 %sub.3, 0
  br i1 %cmp5.3, label %land.lhs.true6.3, label %for.inc.3

land.lhs.true6.3:                                 ; preds = %if.end.3
  %done.3 = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 3, i32 3
  %call.i.i.3 = tail call zeroext i1 @__kasan_check_read(ptr noundef %done.3, i32 noundef 4) #23
  %68 = ptrtoint ptr %done.3 to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load volatile i32, ptr %done.3, align 4
  %cmp8.3 = icmp eq i32 %69, 1
  br i1 %cmp8.3, label %if.then26, label %for.inc.3

for.inc.3:                                        ; preds = %land.lhs.true6.3, %if.end.3
  %cmp24 = icmp sgt i32 %oldest.1.2, -1
  br i1 %cmp24, label %if.then26, label %if.end37

if.else.i:                                        ; preds = %land.lhs.true.3, %land.lhs.true.2, %land.lhs.true.1, %land.lhs.true
  %i.073.lcssa = phi i32 [ 0, %land.lhs.true ], [ 1, %land.lhs.true.1 ], [ 2, %land.lhs.true.2 ], [ 3, %land.lhs.true.3 ]
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @dirty_expire_interval to i32))
  %70 = load i32, ptr @dirty_expire_interval, align 4
  %mul = mul i32 %70, 10
  %call2.i = tail call i32 @__msecs_to_jiffies(i32 noundef %mul) #23
  %cmp15 = icmp ugt i32 %call2.i, 807
  %div63 = lshr i32 %call2.i, 3
  %71 = select i1 %cmp15, i32 100, i32 %div63
  %at16 = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 %i.073.lcssa, i32 2
  %72 = ptrtoint ptr %at16 to i32
  call void @__asan_load8_noabort(i32 %72)
  %73 = load i64, ptr %at16, align 8
  %conv = zext i32 %71 to i64
  %sub17.neg = sub i64 %conv, %call1
  %sub18 = add i64 %sub17.neg, %73
  %cmp19 = icmp slt i64 %sub18, 0
  br i1 %cmp19, label %if.end37.sink.split, label %if.end37

if.then26:                                        ; preds = %for.inc.3, %land.lhs.true6.3
  %oldest.1.379 = phi i32 [ %oldest.1.2, %for.inc.3 ], [ 3, %land.lhs.true6.3 ]
  %arrayidx28 = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 %oldest.1.379
  %74 = ptrtoint ptr %wb to i32
  call void @__asan_load4_noabort(i32 %74)
  %75 = load ptr, ptr %wb, align 8
  %76 = ptrtoint ptr %75 to i32
  call void @__asan_load8_noabort(i32 %76)
  %77 = load i64, ptr %75, align 8
  %78 = ptrtoint ptr %arrayidx28 to i32
  call void @__asan_store8_noabort(i32 %78)
  store i64 %77, ptr %arrayidx28, align 8
  %79 = ptrtoint ptr %memcg_css to i32
  call void @__asan_load4_noabort(i32 %79)
  %80 = load ptr, ptr %memcg_css, align 8
  %id33 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %80, i32 0, i32 6
  %81 = ptrtoint ptr %id33 to i32
  call void @__asan_load4_noabort(i32 %81)
  %82 = load i32, ptr %id33, align 8
  %memcg_id34 = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 %oldest.1.379, i32 1
  %83 = ptrtoint ptr %memcg_id34 to i32
  call void @__asan_store4_noabort(i32 %83)
  store i32 %82, ptr %memcg_id34, align 8
  %at35 = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 42, i32 %oldest.1.379, i32 2
  br label %if.end37.sink.split

if.end37.sink.split:                              ; preds = %if.then26, %if.else.i
  %at16.sink = phi ptr [ %at35, %if.then26 ], [ %at16, %if.else.i ]
  %84 = ptrtoint ptr %at16.sink to i32
  call void @__asan_store8_noabort(i32 %84)
  store i64 %call1, ptr %at16.sink, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.end37.sink.split, %if.else.i, %for.inc.3
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @get_jiffies_64() local_unnamed_addr #4

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @trace_track_foreign_dirty(ptr noundef %folio, ptr noundef %wb) unnamed_addr #5 align 64 {
entry:
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_track_foreign_dirty, i32 0, i32 1), ptr blockaddress(@trace_track_foreign_dirty, %do.body)) #23
          to label %if.end48 [label %do.body], !srcloc !461

do.body:                                          ; preds = %entry
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 3
  %2 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %4 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i = icmp ugt i32 %4, %3
  br i1 %cmp.not.i.i.i.i, label %cpu_online.exit, label %land.rhs.i.i.i.i

land.rhs.i.i.i.i:                                 ; preds = %do.body
  %.b37.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i, label %cpu_online.exit, label %if.then.i.i.i.i, !prof !460

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.108, i32 noundef 108, i32 noundef 9, ptr noundef null) #23
  br label %cpu_online.exit

cpu_online.exit:                                  ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i.i, %do.body
  %div3.i.i.i = lshr i32 %3, 5
  %arrayidx.i.i.i = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i
  %5 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %arrayidx.i.i.i, align 4
  %and.i.i.i75 = and i32 %3, 31
  %7 = shl nuw i32 1, %and.i.i.i75
  %8 = and i32 %6, %7
  %tobool.i.not = icmp eq i32 %8, 0
  br i1 %tobool.i.not, label %if.end69, label %cleanup.thread

cleanup.thread:                                   ; preds = %cpu_online.exit
  %9 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i = and i32 %9, -16384
  %10 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %10, i32 0, i32 1
  %11 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %preempt_count.i.i, align 4
  %add.i = add i32 %12, 1
  store volatile i32 %add.i, ptr %preempt_count.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !500
  %call42 = tail call i32 @__traceiter_track_foreign_dirty(ptr noundef null, ptr noundef %folio, ptr noundef %wb) #23
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !501
  %13 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i73 = and i32 %13, -16384
  %14 = inttoptr i32 %and.i.i.i73 to ptr
  %preempt_count.i.i74 = getelementptr inbounds %struct.thread_info, ptr %14, i32 0, i32 1
  %15 = ptrtoint ptr %preempt_count.i.i74 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %preempt_count.i.i74, align 4
  %sub.i = add i32 %16, -1
  store volatile i32 %sub.i, ptr %preempt_count.i.i74, align 4
  br label %if.end48

if.end48:                                         ; preds = %cleanup.thread, %entry
  %17 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i76 = and i32 %17, -16384
  %18 = inttoptr i32 %and.i76 to ptr
  %cpu50 = getelementptr inbounds %struct.thread_info, ptr %18, i32 0, i32 3
  %19 = ptrtoint ptr %cpu50 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %cpu50, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %21 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i77 = icmp ugt i32 %21, %20
  br i1 %cmp.not.i.i.i.i77, label %cpu_online.exit85, label %land.rhs.i.i.i.i79

land.rhs.i.i.i.i79:                               ; preds = %if.end48
  %.b37.i.i.i.i78 = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i78, label %cpu_online.exit85, label %if.then.i.i.i.i80, !prof !460

if.then.i.i.i.i80:                                ; preds = %land.rhs.i.i.i.i79
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.108, i32 noundef 108, i32 noundef 9, ptr noundef null) #23
  br label %cpu_online.exit85

cpu_online.exit85:                                ; preds = %if.then.i.i.i.i80, %land.rhs.i.i.i.i79, %if.end48
  %div3.i.i.i81 = lshr i32 %20, 5
  %arrayidx.i.i.i82 = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i81
  %22 = ptrtoint ptr %arrayidx.i.i.i82 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %arrayidx.i.i.i82, align 4
  %and.i.i.i83 = and i32 %20, 31
  %24 = shl nuw i32 1, %and.i.i.i83
  %25 = and i32 %23, %24
  %tobool.i84.not = icmp eq i32 %25, 0
  br i1 %tobool.i84.not, label %if.end69, label %if.then52

if.then52:                                        ; preds = %cpu_online.exit85
  %26 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i = and i32 %26, -16384
  %27 = inttoptr i32 %and.i.i.i.i to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %27, i32 0, i32 1
  %28 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %add.i.i = add i32 %29, 1
  store volatile i32 %add.i.i, ptr %preempt_count.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !502
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_track_foreign_dirty, i32 0, i32 7) to i32))
  %30 = load volatile ptr, ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_track_foreign_dirty, i32 0, i32 7), align 4
  %call58 = tail call i32 @rcu_read_lock_sched_held() #23
  %tobool59.not = icmp eq i32 %call58, 0
  br i1 %tobool59.not, label %land.lhs.true, label %do.end67

land.lhs.true:                                    ; preds = %if.then52
  %call60 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool61.not = icmp eq i32 %call60, 0
  br i1 %tobool61.not, label %do.end67, label %land.lhs.true62

land.lhs.true62:                                  ; preds = %land.lhs.true
  %.b72 = load i1, ptr @trace_track_foreign_dirty.__warned, align 1
  br i1 %.b72, label %do.end67, label %if.then64

if.then64:                                        ; preds = %land.lhs.true62
  store i1 true, ptr @trace_track_foreign_dirty.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.107, i32 noundef 272, ptr noundef nonnull @.str.2) #23
  br label %do.end67

do.end67:                                         ; preds = %if.then64, %land.lhs.true62, %land.lhs.true, %if.then52
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !503
  %31 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i86 = and i32 %31, -16384
  %32 = inttoptr i32 %and.i.i.i.i86 to ptr
  %preempt_count.i.i.i87 = getelementptr inbounds %struct.thread_info, ptr %32, i32 0, i32 1
  %33 = ptrtoint ptr %preempt_count.i.i.i87 to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load volatile i32, ptr %preempt_count.i.i.i87, align 4
  %sub.i.i = add i32 %34, -1
  store volatile i32 %sub.i.i, ptr %preempt_count.i.i.i87, align 4
  br label %if.end69

if.end69:                                         ; preds = %do.end67, %cpu_online.exit85, %cpu_online.exit
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mem_cgroup_flush_foreign(ptr noundef %wb) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %memcg_css = getelementptr inbounds %struct.bdi_writeback, ptr %wb, i32 0, i32 29
  %0 = ptrtoint ptr %memcg_css to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %memcg_css, align 8
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @dirty_expire_interval to i32))
  %2 = load i32, ptr @dirty_expire_interval, align 4
  %mul = mul i32 %2, 10
  %call2.i = tail call i32 @__msecs_to_jiffies(i32 noundef %mul) #23
  call void @__asan_load8_noabort(i32 ptrtoint (ptr @jiffies_64 to i32))
  %3 = load i64, ptr @jiffies_64, align 128
  %conv = zext i32 %call2.i to i64
  %arrayidx = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 42, i32 0
  %at = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 42, i32 0, i32 2
  %4 = ptrtoint ptr %at to i32
  call void @__asan_load8_noabort(i32 %4)
  %5 = load i64, ptr %at, align 8
  %6 = add i64 %5, %conv
  %sub2 = sub i64 %3, %6
  %cmp3 = icmp slt i64 %sub2, 0
  br i1 %cmp3, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %done = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 42, i32 0, i32 3
  %call.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %done, i32 noundef 4) #23
  %7 = ptrtoint ptr %done to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load volatile i32, ptr %done, align 4
  %cmp6 = icmp eq i32 %8, 1
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %9 = ptrtoint ptr %at to i32
  call void @__asan_store8_noabort(i32 %9)
  store i64 0, ptr %at, align 8
  %10 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load8_noabort(i32 %10)
  %11 = load i64, ptr %arrayidx, align 8
  %conv9 = trunc i64 %11 to i32
  %memcg_id = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 42, i32 0, i32 1
  %12 = ptrtoint ptr %memcg_id to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %memcg_id, align 8
  tail call fastcc void @trace_flush_foreign(ptr noundef %wb, i32 noundef %conv9, i32 noundef %13)
  %14 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load8_noabort(i32 %14)
  %15 = load i64, ptr %arrayidx, align 8
  %16 = ptrtoint ptr %memcg_id to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %memcg_id, align 8
  %call13 = tail call i32 @cgroup_writeback_by_id(i64 noundef %15, i32 noundef %17, i32 noundef 7, ptr noundef %done) #23
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %arrayidx.1 = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 42, i32 1
  %at.1 = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 42, i32 1, i32 2
  %18 = ptrtoint ptr %at.1 to i32
  call void @__asan_load8_noabort(i32 %18)
  %19 = load i64, ptr %at.1, align 8
  %20 = add i64 %19, %conv
  %sub2.1 = sub i64 %3, %20
  %cmp3.1 = icmp slt i64 %sub2.1, 0
  br i1 %cmp3.1, label %land.lhs.true.1, label %if.end.1

land.lhs.true.1:                                  ; preds = %if.end
  %done.1 = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 42, i32 1, i32 3
  %call.i.i.1 = tail call zeroext i1 @__kasan_check_read(ptr noundef %done.1, i32 noundef 4) #23
  %21 = ptrtoint ptr %done.1 to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load volatile i32, ptr %done.1, align 4
  %cmp6.1 = icmp eq i32 %22, 1
  br i1 %cmp6.1, label %if.then.1, label %if.end.1

if.then.1:                                        ; preds = %land.lhs.true.1
  %23 = ptrtoint ptr %at.1 to i32
  call void @__asan_store8_noabort(i32 %23)
  store i64 0, ptr %at.1, align 8
  %24 = ptrtoint ptr %arrayidx.1 to i32
  call void @__asan_load8_noabort(i32 %24)
  %25 = load i64, ptr %arrayidx.1, align 8
  %conv9.1 = trunc i64 %25 to i32
  %memcg_id.1 = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 42, i32 1, i32 1
  %26 = ptrtoint ptr %memcg_id.1 to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %memcg_id.1, align 8
  tail call fastcc void @trace_flush_foreign(ptr noundef %wb, i32 noundef %conv9.1, i32 noundef %27)
  %28 = ptrtoint ptr %arrayidx.1 to i32
  call void @__asan_load8_noabort(i32 %28)
  %29 = load i64, ptr %arrayidx.1, align 8
  %30 = ptrtoint ptr %memcg_id.1 to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load i32, ptr %memcg_id.1, align 8
  %call13.1 = tail call i32 @cgroup_writeback_by_id(i64 noundef %29, i32 noundef %31, i32 noundef 7, ptr noundef %done.1) #23
  br label %if.end.1

if.end.1:                                         ; preds = %if.then.1, %land.lhs.true.1, %if.end
  %arrayidx.2 = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 42, i32 2
  %at.2 = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 42, i32 2, i32 2
  %32 = ptrtoint ptr %at.2 to i32
  call void @__asan_load8_noabort(i32 %32)
  %33 = load i64, ptr %at.2, align 8
  %34 = add i64 %33, %conv
  %sub2.2 = sub i64 %3, %34
  %cmp3.2 = icmp slt i64 %sub2.2, 0
  br i1 %cmp3.2, label %land.lhs.true.2, label %if.end.2

land.lhs.true.2:                                  ; preds = %if.end.1
  %done.2 = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 42, i32 2, i32 3
  %call.i.i.2 = tail call zeroext i1 @__kasan_check_read(ptr noundef %done.2, i32 noundef 4) #23
  %35 = ptrtoint ptr %done.2 to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load volatile i32, ptr %done.2, align 4
  %cmp6.2 = icmp eq i32 %36, 1
  br i1 %cmp6.2, label %if.then.2, label %if.end.2

if.then.2:                                        ; preds = %land.lhs.true.2
  %37 = ptrtoint ptr %at.2 to i32
  call void @__asan_store8_noabort(i32 %37)
  store i64 0, ptr %at.2, align 8
  %38 = ptrtoint ptr %arrayidx.2 to i32
  call void @__asan_load8_noabort(i32 %38)
  %39 = load i64, ptr %arrayidx.2, align 8
  %conv9.2 = trunc i64 %39 to i32
  %memcg_id.2 = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 42, i32 2, i32 1
  %40 = ptrtoint ptr %memcg_id.2 to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load i32, ptr %memcg_id.2, align 8
  tail call fastcc void @trace_flush_foreign(ptr noundef %wb, i32 noundef %conv9.2, i32 noundef %41)
  %42 = ptrtoint ptr %arrayidx.2 to i32
  call void @__asan_load8_noabort(i32 %42)
  %43 = load i64, ptr %arrayidx.2, align 8
  %44 = ptrtoint ptr %memcg_id.2 to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load i32, ptr %memcg_id.2, align 8
  %call13.2 = tail call i32 @cgroup_writeback_by_id(i64 noundef %43, i32 noundef %45, i32 noundef 7, ptr noundef %done.2) #23
  br label %if.end.2

if.end.2:                                         ; preds = %if.then.2, %land.lhs.true.2, %if.end.1
  %arrayidx.3 = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 42, i32 3
  %at.3 = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 42, i32 3, i32 2
  %46 = ptrtoint ptr %at.3 to i32
  call void @__asan_load8_noabort(i32 %46)
  %47 = load i64, ptr %at.3, align 8
  %48 = add i64 %47, %conv
  %sub2.3 = sub i64 %3, %48
  %cmp3.3 = icmp slt i64 %sub2.3, 0
  br i1 %cmp3.3, label %land.lhs.true.3, label %if.end.3

land.lhs.true.3:                                  ; preds = %if.end.2
  %done.3 = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 42, i32 3, i32 3
  %call.i.i.3 = tail call zeroext i1 @__kasan_check_read(ptr noundef %done.3, i32 noundef 4) #23
  %49 = ptrtoint ptr %done.3 to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load volatile i32, ptr %done.3, align 4
  %cmp6.3 = icmp eq i32 %50, 1
  br i1 %cmp6.3, label %if.then.3, label %if.end.3

if.then.3:                                        ; preds = %land.lhs.true.3
  %51 = ptrtoint ptr %at.3 to i32
  call void @__asan_store8_noabort(i32 %51)
  store i64 0, ptr %at.3, align 8
  %52 = ptrtoint ptr %arrayidx.3 to i32
  call void @__asan_load8_noabort(i32 %52)
  %53 = load i64, ptr %arrayidx.3, align 8
  %conv9.3 = trunc i64 %53 to i32
  %memcg_id.3 = getelementptr %struct.mem_cgroup, ptr %1, i32 0, i32 42, i32 3, i32 1
  %54 = ptrtoint ptr %memcg_id.3 to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load i32, ptr %memcg_id.3, align 8
  tail call fastcc void @trace_flush_foreign(ptr noundef %wb, i32 noundef %conv9.3, i32 noundef %55)
  %56 = ptrtoint ptr %arrayidx.3 to i32
  call void @__asan_load8_noabort(i32 %56)
  %57 = load i64, ptr %arrayidx.3, align 8
  %58 = ptrtoint ptr %memcg_id.3 to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load i32, ptr %memcg_id.3, align 8
  %call13.3 = tail call i32 @cgroup_writeback_by_id(i64 noundef %57, i32 noundef %59, i32 noundef 7, ptr noundef %done.3) #23
  br label %if.end.3

if.end.3:                                         ; preds = %if.then.3, %land.lhs.true.3, %if.end.2
  ret void
}

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @trace_flush_foreign(ptr noundef %wb, i32 noundef %frn_bdi_id, i32 noundef %frn_memcg_id) unnamed_addr #5 align 64 {
entry:
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_flush_foreign, i32 0, i32 1), ptr blockaddress(@trace_flush_foreign, %do.body)) #23
          to label %if.end48 [label %do.body], !srcloc !461

do.body:                                          ; preds = %entry
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 3
  %2 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %cpu, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %4 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i = icmp ugt i32 %4, %3
  br i1 %cmp.not.i.i.i.i, label %cpu_online.exit, label %land.rhs.i.i.i.i

land.rhs.i.i.i.i:                                 ; preds = %do.body
  %.b37.i.i.i.i = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i, label %cpu_online.exit, label %if.then.i.i.i.i, !prof !460

if.then.i.i.i.i:                                  ; preds = %land.rhs.i.i.i.i
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.108, i32 noundef 108, i32 noundef 9, ptr noundef null) #23
  br label %cpu_online.exit

cpu_online.exit:                                  ; preds = %if.then.i.i.i.i, %land.rhs.i.i.i.i, %do.body
  %div3.i.i.i = lshr i32 %3, 5
  %arrayidx.i.i.i = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i
  %5 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %arrayidx.i.i.i, align 4
  %and.i.i.i75 = and i32 %3, 31
  %7 = shl nuw i32 1, %and.i.i.i75
  %8 = and i32 %6, %7
  %tobool.i.not = icmp eq i32 %8, 0
  br i1 %tobool.i.not, label %if.end69, label %cleanup.thread

cleanup.thread:                                   ; preds = %cpu_online.exit
  %9 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i = and i32 %9, -16384
  %10 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %10, i32 0, i32 1
  %11 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %preempt_count.i.i, align 4
  %add.i = add i32 %12, 1
  store volatile i32 %add.i, ptr %preempt_count.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !504
  %call42 = tail call i32 @__traceiter_flush_foreign(ptr noundef null, ptr noundef %wb, i32 noundef %frn_bdi_id, i32 noundef %frn_memcg_id) #23
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !505
  %13 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i73 = and i32 %13, -16384
  %14 = inttoptr i32 %and.i.i.i73 to ptr
  %preempt_count.i.i74 = getelementptr inbounds %struct.thread_info, ptr %14, i32 0, i32 1
  %15 = ptrtoint ptr %preempt_count.i.i74 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %preempt_count.i.i74, align 4
  %sub.i = add i32 %16, -1
  store volatile i32 %sub.i, ptr %preempt_count.i.i74, align 4
  br label %if.end48

if.end48:                                         ; preds = %cleanup.thread, %entry
  %17 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i76 = and i32 %17, -16384
  %18 = inttoptr i32 %and.i76 to ptr
  %cpu50 = getelementptr inbounds %struct.thread_info, ptr %18, i32 0, i32 3
  %19 = ptrtoint ptr %cpu50 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %cpu50, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %21 = load i32, ptr @nr_cpu_ids, align 4
  %cmp.not.i.i.i.i77 = icmp ugt i32 %21, %20
  br i1 %cmp.not.i.i.i.i77, label %cpu_online.exit85, label %land.rhs.i.i.i.i79

land.rhs.i.i.i.i79:                               ; preds = %if.end48
  %.b37.i.i.i.i78 = load i1, ptr @cpu_max_bits_warn.__already_done, align 1
  br i1 %.b37.i.i.i.i78, label %cpu_online.exit85, label %if.then.i.i.i.i80, !prof !460

if.then.i.i.i.i80:                                ; preds = %land.rhs.i.i.i.i79
  store i1 true, ptr @cpu_max_bits_warn.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.108, i32 noundef 108, i32 noundef 9, ptr noundef null) #23
  br label %cpu_online.exit85

cpu_online.exit85:                                ; preds = %if.then.i.i.i.i80, %land.rhs.i.i.i.i79, %if.end48
  %div3.i.i.i81 = lshr i32 %20, 5
  %arrayidx.i.i.i82 = getelementptr i32, ptr @__cpu_online_mask, i32 %div3.i.i.i81
  %22 = ptrtoint ptr %arrayidx.i.i.i82 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %arrayidx.i.i.i82, align 4
  %and.i.i.i83 = and i32 %20, 31
  %24 = shl nuw i32 1, %and.i.i.i83
  %25 = and i32 %23, %24
  %tobool.i84.not = icmp eq i32 %25, 0
  br i1 %tobool.i84.not, label %if.end69, label %if.then52

if.then52:                                        ; preds = %cpu_online.exit85
  %26 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i = and i32 %26, -16384
  %27 = inttoptr i32 %and.i.i.i.i to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %27, i32 0, i32 1
  %28 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %add.i.i = add i32 %29, 1
  store volatile i32 %add.i.i, ptr %preempt_count.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !502
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_flush_foreign, i32 0, i32 7) to i32))
  %30 = load volatile ptr, ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_flush_foreign, i32 0, i32 7), align 4
  %call58 = tail call i32 @rcu_read_lock_sched_held() #23
  %tobool59.not = icmp eq i32 %call58, 0
  br i1 %tobool59.not, label %land.lhs.true, label %do.end67

land.lhs.true:                                    ; preds = %if.then52
  %call60 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool61.not = icmp eq i32 %call60, 0
  br i1 %tobool61.not, label %do.end67, label %land.lhs.true62

land.lhs.true62:                                  ; preds = %land.lhs.true
  %.b72 = load i1, ptr @trace_flush_foreign.__warned, align 1
  br i1 %.b72, label %do.end67, label %if.then64

if.then64:                                        ; preds = %land.lhs.true62
  store i1 true, ptr @trace_flush_foreign.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.107, i32 noundef 301, ptr noundef nonnull @.str.2) #23
  br label %do.end67

do.end67:                                         ; preds = %if.then64, %land.lhs.true62, %land.lhs.true, %if.then52
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !503
  %31 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i86 = and i32 %31, -16384
  %32 = inttoptr i32 %and.i.i.i.i86 to ptr
  %preempt_count.i.i.i87 = getelementptr inbounds %struct.thread_info, ptr %32, i32 0, i32 1
  %33 = ptrtoint ptr %preempt_count.i.i.i87 to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load volatile i32, ptr %preempt_count.i.i.i87, align 4
  %sub.i.i = add i32 %34, -1
  store volatile i32 %sub.i.i, ptr %preempt_count.i.i.i87, align 4
  br label %if.end69

if.end69:                                         ; preds = %do.end67, %cpu_online.exit85, %cpu_online.exit
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @cgroup_writeback_by_id(i64 noundef, i32 noundef, i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local ptr @mem_cgroup_from_id(i16 noundef zeroext %id) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call i32 @rcu_read_lock_held() #23
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %land.rhs, label %if.end29

land.rhs:                                         ; preds = %entry
  %.b40 = load i1, ptr @mem_cgroup_from_id.__already_done, align 1
  br i1 %.b40, label %if.end29, label %if.then, !prof !460

if.then:                                          ; preds = %land.rhs
  store i1 true, ptr @mem_cgroup_from_id.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 5063, i32 noundef 9, ptr noundef null) #23
  br label %if.end29

if.end29:                                         ; preds = %if.then, %land.rhs, %entry
  %conv = zext i16 %id to i32
  %call37 = tail call ptr @idr_find(ptr noundef nonnull @mem_cgroup_idr, i32 noundef %conv) #23
  ret ptr %call37
}

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @idr_find(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: noinline nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal ptr @mem_cgroup_css_alloc(ptr noundef %parent_css) #8 section ".ref.text" align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i, align 4
  %and.i = and i32 %3, 15728640
  %4 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i78.i = and i32 %4, -16384
  %5 = inttoptr i32 %and.i.i78.i to ptr
  %preempt_count.i79.i = getelementptr inbounds %struct.thread_info, ptr %5, i32 0, i32 1
  %6 = ptrtoint ptr %preempt_count.i79.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %preempt_count.i79.i, align 4
  %and2.i = and i32 %7, 983040
  %or.i = or i32 %and2.i, %and.i
  %8 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i80.i = and i32 %8, -16384
  %9 = inttoptr i32 %and.i.i80.i to ptr
  %preempt_count.i81.i = getelementptr inbounds %struct.thread_info, ptr %9, i32 0, i32 1
  %10 = ptrtoint ptr %preempt_count.i81.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %preempt_count.i81.i, align 4
  %and5.i = and i32 %11, 256
  %or6.i = or i32 %or.i, %and5.i
  %tobool.not.i = icmp eq i32 %or6.i, 0
  %12 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i85.i = and i32 %12, -16384
  %13 = inttoptr i32 %and.i85.i to ptr
  br i1 %tobool.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 1
  %14 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %add.i.i = add i32 %15, 1
  store volatile i32 %add.i.i, ptr %preempt_count.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !506
  %16 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i = and i32 %16, -16384
  %17 = inttoptr i32 %and.i.i to ptr
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %17, i32 0, i32 3
  %18 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %cpu.i, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %19
  %20 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %21, ptrtoint (ptr @int_active_memcg to i32)
  %22 = inttoptr i32 %add.i to ptr
  %23 = ptrtoint ptr %22 to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load volatile ptr, ptr %22, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !507
  %25 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i82.i = and i32 %25, -16384
  %26 = inttoptr i32 %and.i.i.i82.i to ptr
  %preempt_count.i.i83.i = getelementptr inbounds %struct.thread_info, ptr %26, i32 0, i32 1
  %27 = ptrtoint ptr %preempt_count.i.i83.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load volatile i32, ptr %preempt_count.i.i83.i, align 4
  %sub.i.i = add i32 %28, -1
  store volatile i32 %sub.i.i, ptr %preempt_count.i.i83.i, align 4
  %29 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %30 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load i32, ptr %cpu.i, align 4
  %arrayidx47.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %31
  %32 = ptrtoint ptr %arrayidx47.i to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %arrayidx47.i, align 4
  %add48.i = add i32 %33, ptrtoint (ptr @int_active_memcg to i32)
  %34 = inttoptr i32 %add48.i to ptr
  %35 = ptrtoint ptr %34 to i32
  call void @__asan_store4_noabort(i32 %35)
  store ptr %parent_css, ptr %34, align 4
  %36 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i84.i = and i32 %36, 128
  %tobool59.not.i = icmp eq i32 %and.i.i84.i, 0
  br i1 %tobool59.not.i, label %if.then63.i, label %do.end65.i, !prof !466

if.then63.i:                                      ; preds = %if.then.i
  tail call void @warn_bogus_irq_restore() #23
  br label %do.end65.i

do.end65.i:                                       ; preds = %if.then63.i, %if.then.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %29) #23, !srcloc !467
  br label %set_active_memcg.exit

if.else.i:                                        ; preds = %entry
  %task.i = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 2
  %37 = ptrtoint ptr %task.i to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load ptr, ptr %task.i, align 8
  %active_memcg.i = getelementptr inbounds %struct.task_struct, ptr %38, i32 0, i32 206
  %39 = ptrtoint ptr %active_memcg.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load ptr, ptr %active_memcg.i, align 8
  store ptr %parent_css, ptr %active_memcg.i, align 8
  br label %set_active_memcg.exit

set_active_memcg.exit:                            ; preds = %if.else.i, %do.end65.i
  %old.0.i = phi ptr [ %24, %do.end65.i ], [ %40, %if.else.i ]
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 12) to i32))
  %41 = load ptr, ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 12), align 4
  %call7.i.i.i = tail call noalias align 8 ptr @kmem_cache_alloc_trace(ptr noundef %41, i32 noundef 3520, i32 noundef 2692) #26
  %tobool.not.i63 = icmp eq ptr %call7.i.i.i, null
  br i1 %tobool.not.i63, label %mem_cgroup_alloc.exit, label %if.end.i

if.end.i:                                         ; preds = %set_active_memcg.exit
  %call3.i = tail call i32 @idr_alloc(ptr noundef nonnull @mem_cgroup_idr, ptr noundef null, i32 noundef 1, i32 noundef 65535, i32 noundef 3264) #23
  %id.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 1
  %42 = ptrtoint ptr %id.i to i32
  call void @__asan_store4_noabort(i32 %42)
  store i32 %call3.i, ptr %id.i, align 8
  %cmp.i = icmp slt i32 %call3.i, 0
  br i1 %cmp.i, label %mem_cgroup_id_remove.exit.i, label %if.end10.i

if.end10.i:                                       ; preds = %if.end.i
  %call11.i = tail call noalias ptr @__alloc_percpu_gfp(i32 noundef 972, i32 noundef 4, i32 noundef 4197568) #27
  %vmstats_percpu.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 39
  %43 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_store4_noabort(i32 %43)
  store ptr %call11.i, ptr %vmstats_percpu.i, align 8
  %tobool13.not.i = icmp eq ptr %call11.i, null
  br i1 %tobool13.not.i, label %fail.i, label %for.body.i

for.body.i:                                       ; preds = %if.end10.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 10) to i32))
  %44 = load ptr, ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 10), align 4
  %call.i.i.i.i.i = tail call noalias align 8 ptr @kmem_cache_alloc_trace(ptr noundef %44, i32 noundef 3520, i32 noundef 552) #26
  %tobool2.not.i.i = icmp eq ptr %call.i.i.i.i.i, null
  br i1 %tobool2.not.i.i, label %fail.i, label %if.end4.i.i

if.end4.i.i:                                      ; preds = %for.body.i
  %call5.i.i = tail call noalias ptr @__alloc_percpu_gfp(i32 noundef 320, i32 noundef 4, i32 noundef 4197568) #27
  %lruvec_stats_percpu.i.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %call.i.i.i.i.i, i32 0, i32 1
  %45 = ptrtoint ptr %lruvec_stats_percpu.i.i to i32
  call void @__asan_store4_noabort(i32 %45)
  store ptr %call5.i.i, ptr %lruvec_stats_percpu.i.i, align 8
  %tobool7.not.i.i = icmp eq ptr %call5.i.i, null
  br i1 %tobool7.not.i.i, label %if.then8.i.i, label %for.end.i

if.then8.i.i:                                     ; preds = %if.end4.i.i
  tail call void @kfree(ptr noundef nonnull %call.i.i.i.i.i) #23
  br label %fail.i

for.end.i:                                        ; preds = %if.end4.i.i
  tail call void @lruvec_init(ptr noundef nonnull %call.i.i.i.i.i) #23
  %usage_in_excess.i.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %call.i.i.i.i.i, i32 0, i32 7
  %46 = ptrtoint ptr %usage_in_excess.i.i to i32
  call void @__asan_store4_noabort(i32 %46)
  store i32 0, ptr %usage_in_excess.i.i, align 4
  %on_tree.i.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %call.i.i.i.i.i, i32 0, i32 8
  %47 = ptrtoint ptr %on_tree.i.i to i32
  call void @__asan_store1_noabort(i32 %47)
  store i8 0, ptr %on_tree.i.i, align 8
  %memcg10.i.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %call.i.i.i.i.i, i32 0, i32 9
  %48 = ptrtoint ptr %memcg10.i.i to i32
  call void @__asan_store4_noabort(i32 %48)
  store ptr %call7.i.i.i, ptr %memcg10.i.i, align 4
  %nodeinfo.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 45
  %49 = ptrtoint ptr %nodeinfo.i.i to i32
  call void @__asan_store4_noabort(i32 %49)
  store ptr %call.i.i.i.i.i, ptr %nodeinfo.i.i, align 4
  %cgwb_domain.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 41
  %call.i.i = tail call i32 @wb_domain_init(ptr noundef %cgwb_domain.i.i, i32 noundef 3264) #23
  %tobool22.not.i = icmp eq i32 %call.i.i, 0
  br i1 %tobool22.not.i, label %do.body.i, label %fail.i

do.body.i:                                        ; preds = %for.end.i
  %high_work.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 6
  tail call void @__init_work(ptr noundef %high_work.i, i32 noundef 0) #23
  %50 = ptrtoint ptr %high_work.i to i32
  call void @__asan_store4_noabort(i32 %50)
  store i32 -64, ptr %high_work.i, align 16
  %lockdep_map.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 6, i32 3
  tail call void @lockdep_init_map_type(ptr noundef %lockdep_map.i, ptr noundef nonnull @.str.110, ptr noundef nonnull @mem_cgroup_alloc.__key, i32 noundef 0, i8 noundef zeroext 0, i8 noundef zeroext 0, i8 noundef zeroext 0) #23
  %entry28.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 6, i32 1
  %51 = ptrtoint ptr %entry28.i to i32
  call void @__asan_store4_noabort(i32 %51)
  store volatile ptr %entry28.i, ptr %entry28.i, align 4
  %prev.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 6, i32 1, i32 1
  %52 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_store4_noabort(i32 %52)
  store ptr %entry28.i, ptr %prev.i.i, align 8
  %func.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 6, i32 2
  %53 = ptrtoint ptr %func.i to i32
  call void @__asan_store4_noabort(i32 %53)
  store ptr @high_work_func, ptr %func.i, align 4
  %oom_notify.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 20
  %54 = ptrtoint ptr %oom_notify.i to i32
  call void @__asan_store4_noabort(i32 %54)
  store volatile ptr %oom_notify.i, ptr %oom_notify.i, align 8
  %prev.i87.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 20, i32 1
  %55 = ptrtoint ptr %prev.i87.i to i32
  call void @__asan_store4_noabort(i32 %55)
  store ptr %oom_notify.i, ptr %prev.i87.i, align 4
  %thresholds_lock.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 17
  tail call void @__mutex_init(ptr noundef %thresholds_lock.i, ptr noundef nonnull @.str.112, ptr noundef nonnull @mem_cgroup_alloc.__key.111) #23
  %move_lock.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 22
  tail call void @__raw_spin_lock_init(ptr noundef %move_lock.i, ptr noundef nonnull @.str.114, ptr noundef nonnull @mem_cgroup_alloc.__key.113, i16 noundef signext 3) #23
  %vmpressure.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 8
  tail call void @vmpressure_init(ptr noundef %vmpressure.i) #23
  %event_list.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 43
  %56 = ptrtoint ptr %event_list.i to i32
  call void @__asan_store4_noabort(i32 %56)
  store volatile ptr %event_list.i, ptr %event_list.i, align 8
  %prev.i88.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 43, i32 1
  %57 = ptrtoint ptr %prev.i88.i to i32
  call void @__asan_store4_noabort(i32 %57)
  store ptr %event_list.i, ptr %prev.i88.i, align 4
  %event_list_lock.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 44
  tail call void @__raw_spin_lock_init(ptr noundef %event_list_lock.i, ptr noundef nonnull @.str.116, ptr noundef nonnull @mem_cgroup_alloc.__key.115, i16 noundef signext 3) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %58 = load volatile i32, ptr @jiffies, align 128
  %socket_pressure.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 29
  %59 = ptrtoint ptr %socket_pressure.i to i32
  call void @__asan_store4_noabort(i32 %59)
  store i32 %58, ptr %socket_pressure.i, align 8
  %kmemcg_id.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 32
  %60 = ptrtoint ptr %kmemcg_id.i to i32
  call void @__asan_store4_noabort(i32 %60)
  store i32 -1, ptr %kmemcg_id.i, align 4
  %objcg_list.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 34
  %61 = ptrtoint ptr %objcg_list.i to i32
  call void @__asan_store4_noabort(i32 %61)
  store volatile ptr %objcg_list.i, ptr %objcg_list.i, align 4
  %prev.i89.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 34, i32 1
  %62 = ptrtoint ptr %prev.i89.i to i32
  call void @__asan_store4_noabort(i32 %62)
  store ptr %objcg_list.i, ptr %prev.i89.i, align 8
  %cgwb_list.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 40
  %63 = ptrtoint ptr %cgwb_list.i to i32
  call void @__asan_store4_noabort(i32 %63)
  store volatile ptr %cgwb_list.i, ptr %cgwb_list.i, align 4
  %prev.i90.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 40, i32 1
  %64 = ptrtoint ptr %prev.i90.i to i32
  call void @__asan_store4_noabort(i32 %64)
  store ptr %cgwb_list.i, ptr %prev.i90.i, align 8
  %done.i = getelementptr %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 42, i32 0, i32 3
  %65 = ptrtoint ptr %done.i to i32
  call void @__asan_store4_noabort(i32 %65)
  store i32 1, ptr %done.i, align 8
  %.compoundliteral44.sroa.2.0.done.sroa_idx.i = getelementptr %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 42, i32 0, i32 3, i32 1
  %66 = ptrtoint ptr %.compoundliteral44.sroa.2.0.done.sroa_idx.i to i32
  call void @__asan_store4_noabort(i32 %66)
  store ptr @memcg_cgwb_frn_waitq, ptr %.compoundliteral44.sroa.2.0.done.sroa_idx.i, align 4
  %done.1.i = getelementptr %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 42, i32 1, i32 3
  %67 = ptrtoint ptr %done.1.i to i32
  call void @__asan_store4_noabort(i32 %67)
  store i32 1, ptr %done.1.i, align 8
  %.compoundliteral44.sroa.2.0.done.sroa_idx.1.i = getelementptr %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 42, i32 1, i32 3, i32 1
  %68 = ptrtoint ptr %.compoundliteral44.sroa.2.0.done.sroa_idx.1.i to i32
  call void @__asan_store4_noabort(i32 %68)
  store ptr @memcg_cgwb_frn_waitq, ptr %.compoundliteral44.sroa.2.0.done.sroa_idx.1.i, align 4
  %done.2.i = getelementptr %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 42, i32 2, i32 3
  %69 = ptrtoint ptr %done.2.i to i32
  call void @__asan_store4_noabort(i32 %69)
  store i32 1, ptr %done.2.i, align 8
  %.compoundliteral44.sroa.2.0.done.sroa_idx.2.i = getelementptr %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 42, i32 2, i32 3, i32 1
  %70 = ptrtoint ptr %.compoundliteral44.sroa.2.0.done.sroa_idx.2.i to i32
  call void @__asan_store4_noabort(i32 %70)
  store ptr @memcg_cgwb_frn_waitq, ptr %.compoundliteral44.sroa.2.0.done.sroa_idx.2.i, align 4
  %done.3.i = getelementptr %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 42, i32 3, i32 3
  %71 = ptrtoint ptr %done.3.i to i32
  call void @__asan_store4_noabort(i32 %71)
  store i32 1, ptr %done.3.i, align 8
  %.compoundliteral44.sroa.2.0.done.sroa_idx.3.i = getelementptr %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 42, i32 3, i32 3, i32 1
  %72 = ptrtoint ptr %.compoundliteral44.sroa.2.0.done.sroa_idx.3.i to i32
  call void @__asan_store4_noabort(i32 %72)
  store ptr @memcg_cgwb_frn_waitq, ptr %.compoundliteral44.sroa.2.0.done.sroa_idx.3.i, align 4
  %73 = ptrtoint ptr %id.i to i32
  call void @__asan_load4_noabort(i32 %73)
  %74 = load i32, ptr %id.i, align 8
  %call50.i = tail call ptr @idr_replace(ptr noundef nonnull @mem_cgroup_idr, ptr noundef nonnull %call7.i.i.i, i32 noundef %74) #23
  br label %mem_cgroup_alloc.exit

fail.i:                                           ; preds = %for.end.i, %if.then8.i.i, %for.body.i, %if.end10.i
  %75 = ptrtoint ptr %id.i to i32
  call void @__asan_load4_noabort(i32 %75)
  %.pr.i = load i32, ptr %id.i, align 8
  %cmp.i.i = icmp sgt i32 %.pr.i, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %mem_cgroup_id_remove.exit.i

if.then.i.i:                                      ; preds = %fail.i
  %call.i91.i = tail call ptr @idr_remove(ptr noundef nonnull @mem_cgroup_idr, i32 noundef %.pr.i) #23
  %76 = ptrtoint ptr %id.i to i32
  call void @__asan_store4_noabort(i32 %76)
  store i32 0, ptr %id.i, align 8
  br label %mem_cgroup_id_remove.exit.i

mem_cgroup_id_remove.exit.i:                      ; preds = %if.then.i.i, %fail.i, %if.end.i
  %error.096.i = phi i32 [ -12, %fail.i ], [ -12, %if.then.i.i ], [ %call3.i, %if.end.i ]
  %nodeinfo.i.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 45
  %77 = ptrtoint ptr %nodeinfo.i.i.i to i32
  call void @__asan_load4_noabort(i32 %77)
  %78 = load ptr, ptr %nodeinfo.i.i.i, align 4
  %tobool.not.i.i.i = icmp eq ptr %78, null
  br i1 %tobool.not.i.i.i, label %__mem_cgroup_free.exit.i, label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %mem_cgroup_id_remove.exit.i
  %lruvec_stats_percpu.i.i.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %78, i32 0, i32 1
  %79 = ptrtoint ptr %lruvec_stats_percpu.i.i.i to i32
  call void @__asan_load4_noabort(i32 %79)
  %80 = load ptr, ptr %lruvec_stats_percpu.i.i.i, align 4
  tail call void @free_percpu(ptr noundef %80) #23
  tail call void @kfree(ptr noundef nonnull %78) #23
  br label %__mem_cgroup_free.exit.i

__mem_cgroup_free.exit.i:                         ; preds = %if.end.i.i.i, %mem_cgroup_id_remove.exit.i
  %vmstats_percpu.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %call7.i.i.i, i32 0, i32 39
  %81 = ptrtoint ptr %vmstats_percpu.i.i to i32
  call void @__asan_load4_noabort(i32 %81)
  %82 = load ptr, ptr %vmstats_percpu.i.i, align 8
  tail call void @free_percpu(ptr noundef %82) #23
  tail call void @kfree(ptr noundef nonnull %call7.i.i.i) #23
  %83 = inttoptr i32 %error.096.i to ptr
  br label %mem_cgroup_alloc.exit

mem_cgroup_alloc.exit:                            ; preds = %__mem_cgroup_free.exit.i, %do.body.i, %set_active_memcg.exit
  %retval.0.i64 = phi ptr [ %83, %__mem_cgroup_free.exit.i ], [ %call7.i.i.i, %do.body.i ], [ inttoptr (i32 -12 to ptr), %set_active_memcg.exit ]
  %84 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i65 = and i32 %84, -16384
  %85 = inttoptr i32 %and.i.i.i65 to ptr
  %preempt_count.i.i66 = getelementptr inbounds %struct.thread_info, ptr %85, i32 0, i32 1
  %86 = ptrtoint ptr %preempt_count.i.i66 to i32
  call void @__asan_load4_noabort(i32 %86)
  %87 = load volatile i32, ptr %preempt_count.i.i66, align 4
  %and.i67 = and i32 %87, 15728640
  %88 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i78.i68 = and i32 %88, -16384
  %89 = inttoptr i32 %and.i.i78.i68 to ptr
  %preempt_count.i79.i69 = getelementptr inbounds %struct.thread_info, ptr %89, i32 0, i32 1
  %90 = ptrtoint ptr %preempt_count.i79.i69 to i32
  call void @__asan_load4_noabort(i32 %90)
  %91 = load volatile i32, ptr %preempt_count.i79.i69, align 4
  %and2.i70 = and i32 %91, 983040
  %or.i71 = or i32 %and2.i70, %and.i67
  %92 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i80.i72 = and i32 %92, -16384
  %93 = inttoptr i32 %and.i.i80.i72 to ptr
  %preempt_count.i81.i73 = getelementptr inbounds %struct.thread_info, ptr %93, i32 0, i32 1
  %94 = ptrtoint ptr %preempt_count.i81.i73 to i32
  call void @__asan_load4_noabort(i32 %94)
  %95 = load volatile i32, ptr %preempt_count.i81.i73, align 4
  %and5.i74 = and i32 %95, 256
  %or6.i75 = or i32 %or.i71, %and5.i74
  %tobool.not.i76 = icmp eq i32 %or6.i75, 0
  %96 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i85.i77 = and i32 %96, -16384
  %97 = inttoptr i32 %and.i85.i77 to ptr
  br i1 %tobool.not.i76, label %if.else.i96, label %if.then.i91

if.then.i91:                                      ; preds = %mem_cgroup_alloc.exit
  %preempt_count.i.i.i78 = getelementptr inbounds %struct.thread_info, ptr %97, i32 0, i32 1
  %98 = ptrtoint ptr %preempt_count.i.i.i78 to i32
  call void @__asan_load4_noabort(i32 %98)
  %99 = load volatile i32, ptr %preempt_count.i.i.i78, align 4
  %add.i.i79 = add i32 %99, 1
  store volatile i32 %add.i.i79, ptr %preempt_count.i.i.i78, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !506
  %100 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i80 = and i32 %100, -16384
  %101 = inttoptr i32 %and.i.i80 to ptr
  %cpu.i81 = getelementptr inbounds %struct.thread_info, ptr %101, i32 0, i32 3
  %102 = ptrtoint ptr %cpu.i81 to i32
  call void @__asan_load4_noabort(i32 %102)
  %103 = load i32, ptr %cpu.i81, align 4
  %arrayidx.i82 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %103
  %104 = ptrtoint ptr %arrayidx.i82 to i32
  call void @__asan_load4_noabort(i32 %104)
  %105 = load i32, ptr %arrayidx.i82, align 4
  %add.i83 = add i32 %105, ptrtoint (ptr @int_active_memcg to i32)
  %106 = inttoptr i32 %add.i83 to ptr
  %107 = ptrtoint ptr %106 to i32
  call void @__asan_load4_noabort(i32 %107)
  %108 = load volatile ptr, ptr %106, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !507
  %109 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i82.i84 = and i32 %109, -16384
  %110 = inttoptr i32 %and.i.i.i82.i84 to ptr
  %preempt_count.i.i83.i85 = getelementptr inbounds %struct.thread_info, ptr %110, i32 0, i32 1
  %111 = ptrtoint ptr %preempt_count.i.i83.i85 to i32
  call void @__asan_load4_noabort(i32 %111)
  %112 = load volatile i32, ptr %preempt_count.i.i83.i85, align 4
  %sub.i.i86 = add i32 %112, -1
  store volatile i32 %sub.i.i86, ptr %preempt_count.i.i83.i85, align 4
  %113 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %114 = ptrtoint ptr %cpu.i81 to i32
  call void @__asan_load4_noabort(i32 %114)
  %115 = load i32, ptr %cpu.i81, align 4
  %arrayidx47.i87 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %115
  %116 = ptrtoint ptr %arrayidx47.i87 to i32
  call void @__asan_load4_noabort(i32 %116)
  %117 = load i32, ptr %arrayidx47.i87, align 4
  %add48.i88 = add i32 %117, ptrtoint (ptr @int_active_memcg to i32)
  %118 = inttoptr i32 %add48.i88 to ptr
  %119 = ptrtoint ptr %118 to i32
  call void @__asan_store4_noabort(i32 %119)
  store ptr %old.0.i, ptr %118, align 4
  %120 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i84.i89 = and i32 %120, 128
  %tobool59.not.i90 = icmp eq i32 %and.i.i84.i89, 0
  br i1 %tobool59.not.i90, label %if.then63.i92, label %do.end65.i93, !prof !466

if.then63.i92:                                    ; preds = %if.then.i91
  tail call void @warn_bogus_irq_restore() #23
  br label %do.end65.i93

do.end65.i93:                                     ; preds = %if.then63.i92, %if.then.i91
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %113) #23, !srcloc !467
  br label %set_active_memcg.exit98

if.else.i96:                                      ; preds = %mem_cgroup_alloc.exit
  %task.i94 = getelementptr inbounds %struct.thread_info, ptr %97, i32 0, i32 2
  %121 = ptrtoint ptr %task.i94 to i32
  call void @__asan_load4_noabort(i32 %121)
  %122 = load ptr, ptr %task.i94, align 8
  %active_memcg.i95 = getelementptr inbounds %struct.task_struct, ptr %122, i32 0, i32 206
  %123 = ptrtoint ptr %active_memcg.i95 to i32
  call void @__asan_store4_noabort(i32 %123)
  store ptr %old.0.i, ptr %active_memcg.i95, align 8
  br label %set_active_memcg.exit98

set_active_memcg.exit98:                          ; preds = %if.else.i96, %do.end65.i93
  %cmp.i99 = icmp ugt ptr %retval.0.i64, inttoptr (i32 -4096 to ptr)
  br i1 %cmp.i99, label %cleanup, label %if.end

if.end:                                           ; preds = %set_active_memcg.exit98
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 2
  %high.i = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 2, i32 3
  %124 = ptrtoint ptr %high.i to i32
  call void @__asan_store4_noabort(i32 %124)
  store volatile i32 2147483647, ptr %high.i, align 4
  %soft_limit = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 7
  %125 = ptrtoint ptr %soft_limit to i32
  call void @__asan_store4_noabort(i32 %125)
  store i32 2147483647, ptr %soft_limit, align 4
  %126 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 3
  %high.i100 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 3, i32 0, i32 3
  %127 = ptrtoint ptr %high.i100 to i32
  call void @__asan_store4_noabort(i32 %127)
  store volatile i32 2147483647, ptr %high.i100, align 4
  %tobool.not = icmp eq ptr %parent_css, null
  br i1 %tobool.not, label %if.else, label %if.then6

if.then6:                                         ; preds = %if.end
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_css_alloc, %if.end.i101)) #23
          to label %mem_cgroup_swappiness.exit [label %if.end.i101], !srcloc !461

if.end.i101:                                      ; preds = %if.then6
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_css_alloc, %mem_cgroup_swappiness.exit)) #23
          to label %lor.lhs.false.i [label %mem_cgroup_swappiness.exit], !srcloc !461

lor.lhs.false.i:                                  ; preds = %if.end.i101
  %128 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i102 = icmp eq ptr %128, %parent_css
  %swappiness.i = getelementptr inbounds %struct.mem_cgroup, ptr %parent_css, i32 0, i32 12
  %spec.select.i = select i1 %cmp.i.i102, ptr @vm_swappiness, ptr %swappiness.i
  br label %mem_cgroup_swappiness.exit

mem_cgroup_swappiness.exit:                       ; preds = %lor.lhs.false.i, %if.end.i101, %if.then6
  %retval.0.in.i = phi ptr [ %spec.select.i, %lor.lhs.false.i ], [ @vm_swappiness, %if.then6 ], [ @vm_swappiness, %if.end.i101 ]
  %129 = ptrtoint ptr %retval.0.in.i to i32
  call void @__asan_load4_noabort(i32 %129)
  %retval.0.i103 = load i32, ptr %retval.0.in.i, align 4
  %swappiness = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 12
  %130 = ptrtoint ptr %swappiness to i32
  call void @__asan_store4_noabort(i32 %130)
  store i32 %retval.0.i103, ptr %swappiness, align 4
  %oom_kill_disable = getelementptr inbounds %struct.mem_cgroup, ptr %parent_css, i32 0, i32 13
  %131 = ptrtoint ptr %oom_kill_disable to i32
  call void @__asan_load4_noabort(i32 %131)
  %132 = load i32, ptr %oom_kill_disable, align 8
  %oom_kill_disable8 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 13
  %133 = ptrtoint ptr %oom_kill_disable8 to i32
  call void @__asan_store4_noabort(i32 %133)
  store i32 %132, ptr %oom_kill_disable8, align 8
  %memory10 = getelementptr inbounds %struct.mem_cgroup, ptr %parent_css, i32 0, i32 2
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %memory, i32 noundef 4) #23
  %134 = ptrtoint ptr %memory to i32
  call void @__asan_store4_noabort(i32 %134)
  store volatile i32 0, ptr %memory, align 4
  %max.i = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 2, i32 4
  %135 = ptrtoint ptr %max.i to i32
  call void @__asan_store4_noabort(i32 %135)
  store i32 2147483647, ptr %max.i, align 4
  %parent1.i = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 2, i32 13
  %136 = ptrtoint ptr %parent1.i to i32
  call void @__asan_store4_noabort(i32 %136)
  store ptr %memory10, ptr %parent1.i, align 4
  %137 = getelementptr inbounds %struct.mem_cgroup, ptr %parent_css, i32 0, i32 3
  %call.i.i.i104 = tail call zeroext i1 @__kasan_check_write(ptr noundef %126, i32 noundef 4) #23
  %138 = ptrtoint ptr %126 to i32
  call void @__asan_store4_noabort(i32 %138)
  store volatile i32 0, ptr %126, align 4
  %max.i105 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 3, i32 0, i32 4
  %139 = ptrtoint ptr %max.i105 to i32
  call void @__asan_store4_noabort(i32 %139)
  store i32 2147483647, ptr %max.i105, align 4
  %parent1.i106 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 3, i32 0, i32 13
  %140 = ptrtoint ptr %parent1.i106 to i32
  call void @__asan_store4_noabort(i32 %140)
  store ptr %137, ptr %parent1.i106, align 4
  %kmem = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 4
  %kmem11 = getelementptr inbounds %struct.mem_cgroup, ptr %parent_css, i32 0, i32 4
  %call.i.i.i107 = tail call zeroext i1 @__kasan_check_write(ptr noundef %kmem, i32 noundef 4) #23
  %141 = ptrtoint ptr %kmem to i32
  call void @__asan_store4_noabort(i32 %141)
  store volatile i32 0, ptr %kmem, align 4
  %max.i108 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 4, i32 4
  %142 = ptrtoint ptr %max.i108 to i32
  call void @__asan_store4_noabort(i32 %142)
  store i32 2147483647, ptr %max.i108, align 4
  %parent1.i109 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 4, i32 13
  %143 = ptrtoint ptr %parent1.i109 to i32
  call void @__asan_store4_noabort(i32 %143)
  store ptr %kmem11, ptr %parent1.i109, align 4
  %tcpmem = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 5
  %tcpmem12 = getelementptr inbounds %struct.mem_cgroup, ptr %parent_css, i32 0, i32 5
  %call.i.i.i110 = tail call zeroext i1 @__kasan_check_write(ptr noundef %tcpmem, i32 noundef 4) #23
  %144 = ptrtoint ptr %tcpmem to i32
  call void @__asan_store4_noabort(i32 %144)
  store volatile i32 0, ptr %tcpmem, align 4
  %max.i111 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 5, i32 4
  %145 = ptrtoint ptr %max.i111 to i32
  call void @__asan_store4_noabort(i32 %145)
  store i32 2147483647, ptr %max.i111, align 4
  %parent1.i112 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 5, i32 13
  %146 = ptrtoint ptr %parent1.i112 to i32
  call void @__asan_store4_noabort(i32 %146)
  store ptr %tcpmem12, ptr %parent1.i112, align 4
  %.b67.i = load i1, ptr @cgroup_memory_nokmem, align 1
  br i1 %.b67.i, label %if.end20, label %do.body.i115

do.body.i115:                                     ; preds = %mem_cgroup_swappiness.exit
  %kmemcg_id.i113 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 32
  %147 = ptrtoint ptr %kmemcg_id.i113 to i32
  call void @__asan_load4_noabort(i32 %147)
  %148 = load i32, ptr %kmemcg_id.i113, align 4
  %cmp.i114 = icmp sgt i32 %148, -1
  br i1 %cmp.i114, label %do.body4.i, label %do.end10.i, !prof !466

do.body4.i:                                       ; preds = %do.body.i115
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 3633, 0\0A.popsection", ""() #23, !srcloc !508
  unreachable

do.end10.i:                                       ; preds = %do.body.i115
  %call.i.i116 = tail call i32 @ida_alloc_range(ptr noundef nonnull @memcg_cache_ida, i32 noundef 0, i32 noundef 65534, i32 noundef 3264) #23
  %cmp.i.i117 = icmp slt i32 %call.i.i116, 0
  br i1 %cmp.i.i117, label %fail, label %if.end.i.i

if.end.i.i:                                       ; preds = %do.end10.i
  %149 = load i32, ptr @memcg_nr_cache_ids, align 4
  %cmp1.i.i = icmp slt i32 %call.i.i116, %149
  br i1 %cmp1.i.i, label %if.end13.i, label %if.end3.i.i

if.end3.i.i:                                      ; preds = %if.end.i.i
  tail call void @down_write(ptr noundef nonnull @memcg_cache_ids_sem) #23
  %add.i.i118 = shl nuw i32 %call.i.i116, 1
  %mul.i.i = add i32 %add.i.i118, 2
  %150 = tail call i32 @llvm.smin.i32(i32 %mul.i.i, i32 65535) #23
  %151 = tail call i32 @llvm.smax.i32(i32 %150, i32 4) #23
  %call10.i.i = tail call i32 @memcg_update_all_list_lrus(i32 noundef %151) #23
  %tobool.not.i.i = icmp eq i32 %call10.i.i, 0
  br i1 %tobool.not.i.i, label %if.then11.i.i, label %memcg_alloc_cache_id.exit.i

if.then11.i.i:                                    ; preds = %if.end3.i.i
  store i32 %151, ptr @memcg_nr_cache_ids, align 4
  tail call void @up_write(ptr noundef nonnull @memcg_cache_ids_sem) #23
  br label %if.end13.i

memcg_alloc_cache_id.exit.i:                      ; preds = %if.end3.i.i
  tail call void @up_write(ptr noundef nonnull @memcg_cache_ids_sem) #23
  tail call void @ida_free(ptr noundef nonnull @memcg_cache_ida, i32 noundef %call.i.i116) #23
  %cmp11.i = icmp slt i32 %call10.i.i, 0
  br i1 %cmp11.i, label %fail, label %if.end13.i

if.end13.i:                                       ; preds = %memcg_alloc_cache_id.exit.i, %if.then11.i.i, %if.end.i.i
  %retval.0.i73.i = phi i32 [ %call10.i.i, %memcg_alloc_cache_id.exit.i ], [ %call.i.i116, %if.then11.i.i ], [ %call.i.i116, %if.end.i.i ]
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 7) to i32))
  %152 = load ptr, ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 7), align 4
  %call7.i.i.i.i = tail call noalias align 8 ptr @kmem_cache_alloc_trace(ptr noundef %152, i32 noundef 3520, i32 noundef 24) #26
  %tobool.not.i68.i = icmp eq ptr %call7.i.i.i.i, null
  br i1 %tobool.not.i68.i, label %if.then16.i, label %if.end.i69.i

if.end.i69.i:                                     ; preds = %if.end13.i
  %call1.i.i = tail call i32 @percpu_ref_init(ptr noundef nonnull %call7.i.i.i.i, ptr noundef nonnull @obj_cgroup_release, i32 noundef 0, i32 noundef 3264) #23
  %tobool2.not.i.i119 = icmp eq i32 %call1.i.i, 0
  br i1 %tobool2.not.i.i119, label %if.end17.i, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.end.i69.i
  tail call void @kfree(ptr noundef nonnull %call7.i.i.i.i) #23
  br label %if.then16.i

if.then16.i:                                      ; preds = %if.then3.i.i, %if.end13.i
  tail call void @ida_free(ptr noundef nonnull @memcg_cache_ida, i32 noundef %retval.0.i73.i) #23
  br label %fail

if.end17.i:                                       ; preds = %if.end.i69.i
  %153 = getelementptr inbounds %struct.obj_cgroup, ptr %call7.i.i.i.i, i32 0, i32 3
  %154 = ptrtoint ptr %153 to i32
  call void @__asan_store4_noabort(i32 %154)
  store volatile ptr %153, ptr %153, align 8
  %prev.i.i.i = getelementptr inbounds %struct.obj_cgroup, ptr %call7.i.i.i.i, i32 0, i32 3, i32 0, i32 1
  %155 = ptrtoint ptr %prev.i.i.i to i32
  call void @__asan_store4_noabort(i32 %155)
  store ptr %153, ptr %prev.i.i.i, align 4
  %memcg18.i = getelementptr inbounds %struct.obj_cgroup, ptr %call7.i.i.i.i, i32 0, i32 1
  %156 = ptrtoint ptr %memcg18.i to i32
  call void @__asan_store4_noabort(i32 %156)
  store ptr %retval.0.i64, ptr %memcg18.i, align 8
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !509
  %objcg45.i = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 33
  %157 = ptrtoint ptr %objcg45.i to i32
  call void @__asan_store4_noabort(i32 %157)
  store volatile ptr %call7.i.i.i.i, ptr %objcg45.i, align 8
  tail call void @static_key_enable(ptr noundef nonnull @memcg_kmem_enabled_key) #23
  %158 = ptrtoint ptr %kmemcg_id.i113 to i32
  call void @__asan_store4_noabort(i32 %158)
  store i32 %retval.0.i73.i, ptr %kmemcg_id.i113, align 4
  br label %if.end20

if.else:                                          ; preds = %if.end
  %call.i.i.i121 = tail call zeroext i1 @__kasan_check_write(ptr noundef %memory, i32 noundef 4) #23
  %159 = ptrtoint ptr %memory to i32
  call void @__asan_store4_noabort(i32 %159)
  store volatile i32 0, ptr %memory, align 4
  %max.i122 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 2, i32 4
  %160 = ptrtoint ptr %max.i122 to i32
  call void @__asan_store4_noabort(i32 %160)
  store i32 2147483647, ptr %max.i122, align 4
  %parent1.i123 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 2, i32 13
  %161 = ptrtoint ptr %parent1.i123 to i32
  call void @__asan_store4_noabort(i32 %161)
  store ptr null, ptr %parent1.i123, align 4
  %call.i.i.i124 = tail call zeroext i1 @__kasan_check_write(ptr noundef %126, i32 noundef 4) #23
  %162 = ptrtoint ptr %126 to i32
  call void @__asan_store4_noabort(i32 %162)
  store volatile i32 0, ptr %126, align 4
  %max.i125 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 3, i32 0, i32 4
  %163 = ptrtoint ptr %max.i125 to i32
  call void @__asan_store4_noabort(i32 %163)
  store i32 2147483647, ptr %max.i125, align 4
  %parent1.i126 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 3, i32 0, i32 13
  %164 = ptrtoint ptr %parent1.i126 to i32
  call void @__asan_store4_noabort(i32 %164)
  store ptr null, ptr %parent1.i126, align 4
  %kmem14 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 4
  %call.i.i.i127 = tail call zeroext i1 @__kasan_check_write(ptr noundef %kmem14, i32 noundef 4) #23
  %165 = ptrtoint ptr %kmem14 to i32
  call void @__asan_store4_noabort(i32 %165)
  store volatile i32 0, ptr %kmem14, align 4
  %max.i128 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 4, i32 4
  %166 = ptrtoint ptr %max.i128 to i32
  call void @__asan_store4_noabort(i32 %166)
  store i32 2147483647, ptr %max.i128, align 4
  %parent1.i129 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 4, i32 13
  %167 = ptrtoint ptr %parent1.i129 to i32
  call void @__asan_store4_noabort(i32 %167)
  store ptr null, ptr %parent1.i129, align 4
  %tcpmem15 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 5
  %call.i.i.i130 = tail call zeroext i1 @__kasan_check_write(ptr noundef %tcpmem15, i32 noundef 4) #23
  %168 = ptrtoint ptr %tcpmem15 to i32
  call void @__asan_store4_noabort(i32 %168)
  store volatile i32 0, ptr %tcpmem15, align 4
  %max.i131 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 5, i32 4
  %169 = ptrtoint ptr %max.i131 to i32
  call void @__asan_store4_noabort(i32 %169)
  store i32 2147483647, ptr %max.i131, align 4
  %parent1.i132 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 5, i32 13
  %170 = ptrtoint ptr %parent1.i132 to i32
  call void @__asan_store4_noabort(i32 %170)
  store ptr null, ptr %parent1.i132, align 4
  store ptr %retval.0.i64, ptr @root_mem_cgroup, align 4
  br label %cleanup

if.end20:                                         ; preds = %if.end17.i, %mem_cgroup_swappiness.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_css_alloc, %cleanup)) #23
          to label %land.lhs.true [label %cleanup], !srcloc !461

land.lhs.true:                                    ; preds = %if.end20
  %.b62 = load i1, ptr @cgroup_memory_nosocket, align 1
  br i1 %.b62, label %cleanup, label %if.then27

if.then27:                                        ; preds = %land.lhs.true
  tail call void @static_key_slow_inc(ptr noundef nonnull @memcg_sockets_enabled_key) #23
  br label %cleanup

fail:                                             ; preds = %if.then16.i, %memcg_alloc_cache_id.exit.i, %do.end10.i
  %retval.0.i120.ph = phi i32 [ %call.i.i116, %do.end10.i ], [ %call10.i.i, %memcg_alloc_cache_id.exit.i ], [ -12, %if.then16.i ]
  %id.i133 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 1
  %171 = ptrtoint ptr %id.i133 to i32
  call void @__asan_load4_noabort(i32 %171)
  %172 = load i32, ptr %id.i133, align 8
  %cmp.i134 = icmp sgt i32 %172, 0
  br i1 %cmp.i134, label %if.then.i135, label %mem_cgroup_id_remove.exit

if.then.i135:                                     ; preds = %fail
  %call.i = tail call ptr @idr_remove(ptr noundef nonnull @mem_cgroup_idr, i32 noundef %172) #23
  %173 = ptrtoint ptr %id.i133 to i32
  call void @__asan_store4_noabort(i32 %173)
  store i32 0, ptr %id.i133, align 8
  br label %mem_cgroup_id_remove.exit

mem_cgroup_id_remove.exit:                        ; preds = %if.then.i135, %fail
  %cgwb_domain.i.i137 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 41
  tail call void @wb_domain_exit(ptr noundef %cgwb_domain.i.i137) #23
  %nodeinfo.i.i.i138 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 45
  %174 = ptrtoint ptr %nodeinfo.i.i.i138 to i32
  call void @__asan_load4_noabort(i32 %174)
  %175 = load ptr, ptr %nodeinfo.i.i.i138, align 4
  %tobool.not.i.i.i139 = icmp eq ptr %175, null
  br i1 %tobool.not.i.i.i139, label %mem_cgroup_free.exit, label %if.end.i.i.i141

if.end.i.i.i141:                                  ; preds = %mem_cgroup_id_remove.exit
  %lruvec_stats_percpu.i.i.i140 = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %175, i32 0, i32 1
  %176 = ptrtoint ptr %lruvec_stats_percpu.i.i.i140 to i32
  call void @__asan_load4_noabort(i32 %176)
  %177 = load ptr, ptr %lruvec_stats_percpu.i.i.i140, align 4
  tail call void @free_percpu(ptr noundef %177) #23
  tail call void @kfree(ptr noundef nonnull %175) #23
  br label %mem_cgroup_free.exit

mem_cgroup_free.exit:                             ; preds = %if.end.i.i.i141, %mem_cgroup_id_remove.exit
  %vmstats_percpu.i.i142 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i64, i32 0, i32 39
  %178 = ptrtoint ptr %vmstats_percpu.i.i142 to i32
  call void @__asan_load4_noabort(i32 %178)
  %179 = load ptr, ptr %vmstats_percpu.i.i142, align 8
  tail call void @free_percpu(ptr noundef %179) #23
  tail call void @kfree(ptr noundef %retval.0.i64) #23
  %180 = inttoptr i32 %retval.0.i120.ph to ptr
  br label %cleanup

cleanup:                                          ; preds = %mem_cgroup_free.exit, %if.then27, %land.lhs.true, %if.end20, %if.else, %set_active_memcg.exit98
  %retval.0 = phi ptr [ %180, %mem_cgroup_free.exit ], [ %retval.0.i64, %if.else ], [ %retval.0.i64, %if.then27 ], [ %retval.0.i64, %land.lhs.true ], [ %retval.0.i64, %set_active_memcg.exit98 ], [ %retval.0.i64, %if.end20 ]
  ret ptr %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @mem_cgroup_css_online(ptr noundef %css) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call1 = tail call i32 @alloc_shrinker_info(ptr noundef %css) #23
  %tobool.not = icmp eq i32 %call1, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %id.i = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 1
  %0 = ptrtoint ptr %id.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %id.i, align 8
  %cmp.i = icmp sgt i32 %1, 0
  br i1 %cmp.i, label %if.then.i, label %cleanup

if.then.i:                                        ; preds = %if.then
  %call.i = tail call ptr @idr_remove(ptr noundef nonnull @mem_cgroup_idr, i32 noundef %1) #23
  %2 = ptrtoint ptr %id.i to i32
  call void @__asan_store4_noabort(i32 %2)
  store i32 0, ptr %id.i, align 8
  br label %cleanup

if.end:                                           ; preds = %entry
  %ref = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 1, i32 1
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %ref, i32 noundef 4) #23
  %3 = ptrtoint ptr %ref to i32
  call void @__asan_store4_noabort(i32 %3)
  store volatile i32 1, ptr %ref, align 4
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %css, i32 0, i32 7
  %4 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %flags.i, align 4
  %and.i = and i32 %5, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.then.i12, label %css_get.exit

if.then.i12:                                      ; preds = %if.end
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %css, i32 0, i32 2
  tail call fastcc void @percpu_ref_get_many(ptr noundef %refcnt.i, i32 noundef 1) #23
  br label %css_get.exit

css_get.exit:                                     ; preds = %if.then.i12, %if.end
  %6 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i13 = icmp eq ptr %6, %css
  br i1 %cmp.i13, label %if.then5, label %cleanup, !prof !466

if.then5:                                         ; preds = %css_get.exit
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @system_unbound_wq to i32))
  %7 = load ptr, ptr @system_unbound_wq, align 4
  %call.i14 = tail call zeroext i1 @queue_delayed_work_on(i32 noundef 4, ptr noundef %7, ptr noundef nonnull @stats_flush_dwork, i32 noundef 200) #23
  br label %cleanup

cleanup:                                          ; preds = %if.then5, %css_get.exit, %if.then.i, %if.then
  %retval.0 = phi i32 [ 0, %if.then5 ], [ 0, %css_get.exit ], [ -12, %if.then ], [ -12, %if.then.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @mem_cgroup_css_offline(ptr noundef %css) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %event_list_lock = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 44
  tail call void @_raw_spin_lock_irq(ptr noundef %event_list_lock) #23
  %event_list = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 43
  %0 = ptrtoint ptr %event_list to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %event_list, align 8
  %cmp.not33 = icmp eq ptr %1, %event_list
  br i1 %cmp.not33, label %for.end, label %for.body

for.body:                                         ; preds = %list_del_init.exit, %entry
  %.pn.in34 = phi ptr [ %.pn, %list_del_init.exit ], [ %1, %entry ]
  %2 = ptrtoint ptr %.pn.in34 to i32
  call void @__asan_load4_noabort(i32 %2)
  %.pn = load ptr, ptr %.pn.in34, align 4
  %call.i.i = tail call zeroext i1 @__list_del_entry_valid(ptr noundef %.pn.in34) #23
  br i1 %call.i.i, label %if.end.i.i, label %list_del_init.exit

if.end.i.i:                                       ; preds = %for.body
  %prev.i.i = getelementptr inbounds %struct.list_head, ptr %.pn.in34, i32 0, i32 1
  %3 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %prev.i.i, align 4
  %5 = ptrtoint ptr %.pn.in34 to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %.pn.in34, align 4
  %prev1.i.i.i = getelementptr inbounds %struct.list_head, ptr %6, i32 0, i32 1
  %7 = ptrtoint ptr %prev1.i.i.i to i32
  call void @__asan_store4_noabort(i32 %7)
  store ptr %4, ptr %prev1.i.i.i, align 4
  %8 = ptrtoint ptr %4 to i32
  call void @__asan_store4_noabort(i32 %8)
  store volatile ptr %6, ptr %4, align 4
  br label %list_del_init.exit

list_del_init.exit:                               ; preds = %if.end.i.i, %for.body
  %9 = ptrtoint ptr %.pn.in34 to i32
  call void @__asan_store4_noabort(i32 %9)
  store volatile ptr %.pn.in34, ptr %.pn.in34, align 4
  %prev.i3.i = getelementptr inbounds %struct.list_head, ptr %.pn.in34, i32 0, i32 1
  %10 = ptrtoint ptr %prev.i3.i to i32
  call void @__asan_store4_noabort(i32 %10)
  store ptr %.pn.in34, ptr %prev.i3.i, align 4
  %remove = getelementptr i8, ptr %.pn.in34, i32 48
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @system_wq to i32))
  %11 = load ptr, ptr @system_wq, align 4
  %call.i.i32 = tail call zeroext i1 @queue_work_on(i32 noundef 4, ptr noundef %11, ptr noundef %remove) #23
  %cmp.not = icmp eq ptr %.pn, %event_list
  br i1 %cmp.not, label %for.end, label %for.body

for.end:                                          ; preds = %list_del_init.exit, %entry
  tail call void @_raw_spin_unlock_irq(ptr noundef %event_list_lock) #23
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 2
  tail call void @page_counter_set_min(ptr noundef %memory, i32 noundef 0) #23
  tail call void @page_counter_set_low(ptr noundef %memory, i32 noundef 0) #23
  tail call fastcc void @memcg_offline_kmem(ptr noundef %css)
  tail call void @reparent_shrinker_deferred(ptr noundef %css) #23
  tail call void @wb_memcg_offline(ptr noundef %css) #23
  tail call fastcc void @drain_all_stock(ptr noundef %css)
  tail call fastcc void @mem_cgroup_id_put_many(ptr noundef %css, i32 noundef 1) #23
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @mem_cgroup_css_released(ptr noundef %css) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = ptrtoint ptr %css to i32
  br label %do.body.i

do.body.i:                                        ; preds = %__invalidate_reclaim_iterators.exit.i, %entry
  %memcg.0.i = phi ptr [ %css, %entry ], [ %add.ptr.i.i, %__invalidate_reclaim_iterators.exit.i ]
  %nodeinfo.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.0.i, i32 0, i32 45
  %1 = ptrtoint ptr %nodeinfo.i.i to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %nodeinfo.i.i, align 4
  %iter1.i.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %2, i32 0, i32 4
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %iter1.i.i, i32 noundef 4) #23
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !510
  tail call void @llvm.prefetch.p0(ptr %iter1.i.i, i32 1, i32 3, i32 1) #23
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %do.body.i.i.i, %do.body.i
  %3 = tail call { i32, i32 } asm sideeffect "@ __cmpxchg4\0A\09ldrex\09$1, [$2]\0A\09mov\09$0, #0\0A\09teq\09$1, $3\0A\09strexeq $0, $4, [$2]\0A", "=&r,=&r,r,Ir,r,~{memory},~{cc}"(ptr %iter1.i.i, i32 %0, i32 0) #23, !srcloc !476
  %asmresult.i.i.i = extractvalue { i32, i32 } %3, 0
  %tobool.not.i.i.i = icmp eq i32 %asmresult.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %__invalidate_reclaim_iterators.exit.i, label %do.body.i.i.i

__invalidate_reclaim_iterators.exit.i:            ; preds = %do.body.i.i.i
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !511
  %parent.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.0.i, i32 0, i32 2, i32 13
  %4 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i = icmp eq ptr %5, null
  %add.ptr.i.i = getelementptr i8, ptr %5, i32 -176
  %tobool.not12.i = icmp eq ptr %add.ptr.i.i, null
  %tobool.not.i = or i1 %tobool.not.i.i, %tobool.not12.i
  br i1 %tobool.not.i, label %do.end.i, label %do.body.i

do.end.i:                                         ; preds = %__invalidate_reclaim_iterators.exit.i
  %6 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.not.i = icmp eq ptr %memcg.0.i, %6
  br i1 %cmp.not.i, label %invalidate_reclaim_iterators.exit, label %if.then.i

if.then.i:                                        ; preds = %do.end.i
  %nodeinfo.i5.i = getelementptr inbounds %struct.mem_cgroup, ptr %6, i32 0, i32 45
  %7 = ptrtoint ptr %nodeinfo.i5.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %nodeinfo.i5.i, align 4
  %iter1.i6.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %8, i32 0, i32 4
  %call.i.i7.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %iter1.i6.i, i32 noundef 4) #23
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !510
  tail call void @llvm.prefetch.p0(ptr %iter1.i6.i, i32 1, i32 3, i32 1) #23
  br label %do.body.i.i10.i

do.body.i.i10.i:                                  ; preds = %do.body.i.i10.i, %if.then.i
  %9 = tail call { i32, i32 } asm sideeffect "@ __cmpxchg4\0A\09ldrex\09$1, [$2]\0A\09mov\09$0, #0\0A\09teq\09$1, $3\0A\09strexeq $0, $4, [$2]\0A", "=&r,=&r,r,Ir,r,~{memory},~{cc}"(ptr %iter1.i6.i, i32 %0, i32 0) #23, !srcloc !476
  %asmresult.i.i8.i = extractvalue { i32, i32 } %9, 0
  %tobool.not.i.i9.i = icmp eq i32 %asmresult.i.i8.i, 0
  br i1 %tobool.not.i.i9.i, label %__invalidate_reclaim_iterators.exit11.i, label %do.body.i.i10.i

__invalidate_reclaim_iterators.exit11.i:          ; preds = %do.body.i.i10.i
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !511
  br label %invalidate_reclaim_iterators.exit

invalidate_reclaim_iterators.exit:                ; preds = %__invalidate_reclaim_iterators.exit11.i, %do.end.i
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @mem_cgroup_css_free(ptr noundef %css) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %done = getelementptr %struct.mem_cgroup, ptr %css, i32 0, i32 42, i32 0, i32 3
  tail call void @wb_wait_for_completion(ptr noundef %done) #23
  %done.1 = getelementptr %struct.mem_cgroup, ptr %css, i32 0, i32 42, i32 1, i32 3
  tail call void @wb_wait_for_completion(ptr noundef %done.1) #23
  %done.2 = getelementptr %struct.mem_cgroup, ptr %css, i32 0, i32 42, i32 2, i32 3
  tail call void @wb_wait_for_completion(ptr noundef %done.2) #23
  %done.3 = getelementptr %struct.mem_cgroup, ptr %css, i32 0, i32 42, i32 3, i32 3
  tail call void @wb_wait_for_completion(ptr noundef %done.3) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_css_free, %if.end)) #23
          to label %land.lhs.true [label %if.end], !srcloc !461

land.lhs.true:                                    ; preds = %entry
  %.b33 = load i1, ptr @cgroup_memory_nosocket, align 1
  br i1 %.b33, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  tail call void @static_key_slow_dec(ptr noundef nonnull @memcg_sockets_enabled_key) #23
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_css_free, %land.lhs.true19)) #23
          to label %if.end22 [label %land.lhs.true19], !srcloc !461

land.lhs.true19:                                  ; preds = %if.end
  %tcpmem_active = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 30
  %0 = ptrtoint ptr %tcpmem_active to i32
  call void @__asan_load1_noabort(i32 %0)
  %1 = load i8, ptr %tcpmem_active, align 4, !range !488
  %tobool20.not = icmp eq i8 %1, 0
  br i1 %tobool20.not, label %if.end22, label %if.then21

if.then21:                                        ; preds = %land.lhs.true19
  tail call void @static_key_slow_dec(ptr noundef nonnull @memcg_sockets_enabled_key) #23
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %land.lhs.true19, %if.end
  %vmpressure = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 8
  tail call void @vmpressure_cleanup(ptr noundef %vmpressure) #23
  %high_work = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 6
  %call23 = tail call zeroext i1 @cancel_work_sync(ptr noundef %high_work) #23
  %2 = load ptr, ptr @soft_limit_tree, align 4
  %tobool.not.i = icmp eq ptr %2, null
  br i1 %tobool.not.i, label %mem_cgroup_remove_from_trees.exit, label %if.then.i

if.then.i:                                        ; preds = %if.end22
  %nodeinfo.i = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 45
  %3 = ptrtoint ptr %nodeinfo.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %nodeinfo.i, align 4
  %lock.i.i = getelementptr inbounds %struct.mem_cgroup_tree_per_node, ptr %2, i32 0, i32 2
  %call2.i.i = tail call i32 @_raw_spin_lock_irqsave(ptr noundef %lock.i.i) #23
  %on_tree.i.i.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %4, i32 0, i32 8
  %5 = ptrtoint ptr %on_tree.i.i.i to i32
  call void @__asan_load1_noabort(i32 %5)
  %6 = load i8, ptr %on_tree.i.i.i, align 4, !range !488
  %tobool.not.i.i.i = icmp eq i8 %6, 0
  br i1 %tobool.not.i.i.i, label %mem_cgroup_remove_exceeded.exit.i, label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %if.then.i
  %tree_node.i.i.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %4, i32 0, i32 6
  %rb_rightmost.i.i.i = getelementptr inbounds %struct.mem_cgroup_tree_per_node, ptr %2, i32 0, i32 1
  %7 = ptrtoint ptr %rb_rightmost.i.i.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %rb_rightmost.i.i.i, align 4
  %cmp.i.i.i = icmp eq ptr %tree_node.i.i.i, %8
  br i1 %cmp.i.i.i, label %if.then1.i.i.i, label %if.end4.i.i.i

if.then1.i.i.i:                                   ; preds = %if.end.i.i.i
  %call.i.i.i = tail call ptr @rb_prev(ptr noundef %tree_node.i.i.i) #23
  %9 = ptrtoint ptr %rb_rightmost.i.i.i to i32
  call void @__asan_store4_noabort(i32 %9)
  store ptr %call.i.i.i, ptr %rb_rightmost.i.i.i, align 4
  br label %if.end4.i.i.i

if.end4.i.i.i:                                    ; preds = %if.then1.i.i.i, %if.end.i.i.i
  tail call void @rb_erase(ptr noundef %tree_node.i.i.i, ptr noundef nonnull %2) #23
  %10 = ptrtoint ptr %on_tree.i.i.i to i32
  call void @__asan_store1_noabort(i32 %10)
  store i8 0, ptr %on_tree.i.i.i, align 4
  br label %mem_cgroup_remove_exceeded.exit.i

mem_cgroup_remove_exceeded.exit.i:                ; preds = %if.end4.i.i.i, %if.then.i
  tail call void @_raw_spin_unlock_irqrestore(ptr noundef %lock.i.i, i32 noundef %call2.i.i) #23
  br label %mem_cgroup_remove_from_trees.exit

mem_cgroup_remove_from_trees.exit:                ; preds = %mem_cgroup_remove_exceeded.exit.i, %if.end22
  tail call void @free_shrinker_info(ptr noundef %css) #23
  tail call fastcc void @memcg_offline_kmem(ptr noundef %css)
  %cgwb_domain.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 41
  tail call void @wb_domain_exit(ptr noundef %cgwb_domain.i.i) #23
  %nodeinfo.i.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 45
  %11 = ptrtoint ptr %nodeinfo.i.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %nodeinfo.i.i.i, align 4
  %tobool.not.i.i.i37 = icmp eq ptr %12, null
  br i1 %tobool.not.i.i.i37, label %mem_cgroup_free.exit, label %if.end.i.i.i38

if.end.i.i.i38:                                   ; preds = %mem_cgroup_remove_from_trees.exit
  %lruvec_stats_percpu.i.i.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %12, i32 0, i32 1
  %13 = ptrtoint ptr %lruvec_stats_percpu.i.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %lruvec_stats_percpu.i.i.i, align 4
  tail call void @free_percpu(ptr noundef %14) #23
  tail call void @kfree(ptr noundef nonnull %12) #23
  br label %mem_cgroup_free.exit

mem_cgroup_free.exit:                             ; preds = %if.end.i.i.i38, %mem_cgroup_remove_from_trees.exit
  %vmstats_percpu.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 39
  %15 = ptrtoint ptr %vmstats_percpu.i.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %vmstats_percpu.i.i, align 8
  tail call void @free_percpu(ptr noundef %16) #23
  tail call void @kfree(ptr noundef %css) #23
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @mem_cgroup_css_reset(ptr noundef %css) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 2
  %call1 = tail call i32 @page_counter_set_max(ptr noundef %memory, i32 noundef 2147483647) #23
  %0 = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 3
  %call2 = tail call i32 @page_counter_set_max(ptr noundef %0, i32 noundef 2147483647) #23
  %kmem = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 4
  %call3 = tail call i32 @page_counter_set_max(ptr noundef %kmem, i32 noundef 2147483647) #23
  %tcpmem = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 5
  %call4 = tail call i32 @page_counter_set_max(ptr noundef %tcpmem, i32 noundef 2147483647) #23
  tail call void @page_counter_set_min(ptr noundef %memory, i32 noundef 0) #23
  tail call void @page_counter_set_low(ptr noundef %memory, i32 noundef 0) #23
  %high.i = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 2, i32 3
  %1 = ptrtoint ptr %high.i to i32
  call void @__asan_store4_noabort(i32 %1)
  store volatile i32 2147483647, ptr %high.i, align 4
  %soft_limit = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 7
  %2 = ptrtoint ptr %soft_limit to i32
  call void @__asan_store4_noabort(i32 %2)
  store i32 2147483647, ptr %soft_limit, align 4
  %high.i17 = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 3, i32 0, i32 3
  %3 = ptrtoint ptr %high.i17 to i32
  call void @__asan_store4_noabort(i32 %3)
  store volatile i32 2147483647, ptr %high.i17, align 4
  %cgwb_domain.i = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 41
  tail call void @_raw_spin_lock(ptr noundef %cgwb_domain.i) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %4 = load volatile i32, ptr @jiffies, align 128
  %dirty_limit_tstamp.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 41, i32 4
  %5 = ptrtoint ptr %dirty_limit_tstamp.i.i to i32
  call void @__asan_store4_noabort(i32 %5)
  store i32 %4, ptr %dirty_limit_tstamp.i.i, align 4
  %dirty_limit.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 41, i32 5
  %6 = ptrtoint ptr %dirty_limit.i.i to i32
  call void @__asan_store4_noabort(i32 %6)
  store i32 0, ptr %dirty_limit.i.i, align 8
  tail call void @_raw_spin_unlock(ptr noundef %cgwb_domain.i) #23
  ret void
}

; Function Attrs: nofree norecurse nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @mem_cgroup_css_rstat_flush(ptr nocapture noundef %css, i32 noundef %cpu) #9 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 2, i32 13
  %0 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %parent.i, align 4
  %tobool.not.i = icmp eq ptr %1, null
  %add.ptr.i = getelementptr i8, ptr %1, i32 -176
  %retval.0.i = select i1 %tobool.not.i, ptr null, ptr %add.ptr.i
  %vmstats_percpu = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 39
  %2 = ptrtoint ptr %vmstats_percpu to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %vmstats_percpu, align 8
  %4 = ptrtoint ptr %3 to i32
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %cpu
  %5 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %arrayidx, align 4
  %add = add i32 %6, %4
  %7 = inttoptr i32 %add to ptr
  %vmstats = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 26
  %tobool28.not = icmp eq ptr %retval.0.i, null
  br label %for.body

for.body:                                         ; preds = %for.inc, %entry
  %i.0231 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %arrayidx3 = getelementptr %struct.mem_cgroup, ptr %css, i32 0, i32 26, i32 2, i32 %i.0231
  %8 = ptrtoint ptr %arrayidx3 to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %arrayidx3, align 4
  %tobool.not = icmp eq i32 %9, 0
  br i1 %tobool.not, label %do.end9, label %if.then

if.then:                                          ; preds = %for.body
  %10 = ptrtoint ptr %arrayidx3 to i32
  call void @__asan_store4_noabort(i32 %10)
  store i32 0, ptr %arrayidx3, align 4
  br label %do.end9

do.end9:                                          ; preds = %if.then, %for.body
  %arrayidx11 = getelementptr [44 x i32], ptr %7, i32 0, i32 %i.0231
  %11 = ptrtoint ptr %arrayidx11 to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %arrayidx11, align 4
  %arrayidx12 = getelementptr %struct.memcg_vmstats_percpu, ptr %7, i32 0, i32 2, i32 %i.0231
  %13 = ptrtoint ptr %arrayidx12 to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %arrayidx12, align 4
  %cmp13.not = icmp eq i32 %12, %14
  br i1 %cmp13.not, label %if.end20, label %if.then14

if.then14:                                        ; preds = %do.end9
  %sub = add i32 %12, %9
  %add17 = sub i32 %sub, %14
  %15 = ptrtoint ptr %arrayidx12 to i32
  call void @__asan_store4_noabort(i32 %15)
  store i32 %12, ptr %arrayidx12, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.then14, %do.end9
  %delta.0 = phi i32 [ %add17, %if.then14 ], [ %9, %do.end9 ]
  %tobool21.not = icmp eq i32 %delta.0, 0
  br i1 %tobool21.not, label %for.inc, label %if.end23

if.end23:                                         ; preds = %if.end20
  %arrayidx26 = getelementptr [44 x i32], ptr %vmstats, i32 0, i32 %i.0231
  %16 = ptrtoint ptr %arrayidx26 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %arrayidx26, align 4
  %add27 = add i32 %17, %delta.0
  store i32 %add27, ptr %arrayidx26, align 4
  br i1 %tobool28.not, label %for.inc, label %if.then29

if.then29:                                        ; preds = %if.end23
  %arrayidx32 = getelementptr %struct.mem_cgroup, ptr %retval.0.i, i32 0, i32 26, i32 2, i32 %i.0231
  %18 = ptrtoint ptr %arrayidx32 to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %arrayidx32, align 4
  %add33 = add i32 %19, %delta.0
  store i32 %add33, ptr %arrayidx32, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.then29, %if.end23, %if.end20
  %inc = add nuw nsw i32 %i.0231, 1
  %exitcond.not = icmp eq i32 %inc, 44
  br i1 %exitcond.not, label %for.body37, label %for.body

for.body37:                                       ; preds = %for.body37.backedge, %for.inc
  %i.1233 = phi i32 [ %i.1233.be, %for.body37.backedge ], [ 0, %for.inc ]
  %arrayidx39 = getelementptr %struct.mem_cgroup, ptr %css, i32 0, i32 26, i32 3, i32 %i.1233
  %20 = ptrtoint ptr %arrayidx39 to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %arrayidx39, align 4
  %tobool40.not = icmp eq i32 %21, 0
  br i1 %tobool40.not, label %do.end48, label %if.then41

if.then41:                                        ; preds = %for.body37
  %22 = ptrtoint ptr %arrayidx39 to i32
  call void @__asan_store4_noabort(i32 %22)
  store i32 0, ptr %arrayidx39, align 4
  br label %do.end48

do.end48:                                         ; preds = %if.then41, %for.body37
  %arrayidx50 = getelementptr %struct.memcg_vmstats_percpu, ptr %7, i32 0, i32 1, i32 %i.1233
  %23 = ptrtoint ptr %arrayidx50 to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load volatile i32, ptr %arrayidx50, align 4
  %arrayidx51 = getelementptr %struct.memcg_vmstats_percpu, ptr %7, i32 0, i32 3, i32 %i.1233
  %25 = ptrtoint ptr %arrayidx51 to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %arrayidx51, align 4
  %cmp52.not = icmp eq i32 %24, %26
  br i1 %cmp52.not, label %if.end60, label %if.then53

if.then53:                                        ; preds = %do.end48
  %sub56 = add i32 %24, %21
  %add57 = sub i32 %sub56, %26
  %27 = ptrtoint ptr %arrayidx51 to i32
  call void @__asan_store4_noabort(i32 %27)
  store i32 %24, ptr %arrayidx51, align 4
  br label %if.end60

if.end60:                                         ; preds = %if.then53, %do.end48
  %delta.1 = phi i32 [ %add57, %if.then53 ], [ %21, %do.end48 ]
  %tobool61.not = icmp eq i32 %delta.1, 0
  br i1 %tobool61.not, label %for.inc75, label %if.end63

if.end63:                                         ; preds = %if.end60
  %arrayidx66 = getelementptr %struct.mem_cgroup, ptr %css, i32 0, i32 26, i32 1, i32 %i.1233
  %28 = ptrtoint ptr %arrayidx66 to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %arrayidx66, align 4
  %add67 = add i32 %29, %delta.1
  store i32 %add67, ptr %arrayidx66, align 4
  br i1 %tobool28.not, label %for.inc75.thread242, label %for.inc75.thread

for.inc75:                                        ; preds = %if.end60
  %inc76 = add nuw nsw i32 %i.1233, 1
  %exitcond237.not = icmp eq i32 %inc76, 76
  br i1 %exitcond237.not, label %for.body80, label %for.body37.backedge

for.body37.backedge:                              ; preds = %for.inc75.thread, %for.inc75.thread242, %for.inc75
  %i.1233.be = phi i32 [ %inc76, %for.inc75 ], [ %inc76239, %for.inc75.thread ], [ %inc76243, %for.inc75.thread242 ]
  br label %for.body37

for.inc75.thread242:                              ; preds = %if.end63
  %inc76243 = add nuw nsw i32 %i.1233, 1
  %exitcond237.not244 = icmp eq i32 %inc76243, 76
  br i1 %exitcond237.not244, label %for.body80.thread245, label %for.body37.backedge

for.body80.thread245:                             ; preds = %for.inc75.thread242
  %nodeinfo246 = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 45
  %30 = ptrtoint ptr %nodeinfo246 to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %nodeinfo246, align 4
  br label %do.body87

for.inc75.thread:                                 ; preds = %if.end63
  %arrayidx72 = getelementptr %struct.mem_cgroup, ptr %retval.0.i, i32 0, i32 26, i32 3, i32 %i.1233
  %32 = ptrtoint ptr %arrayidx72 to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %arrayidx72, align 4
  %add73 = add i32 %33, %delta.1
  store i32 %add73, ptr %arrayidx72, align 4
  %inc76239 = add nuw nsw i32 %i.1233, 1
  %exitcond237.not240 = icmp eq i32 %inc76239, 76
  br i1 %exitcond237.not240, label %for.body80.thread, label %for.body37.backedge

for.body80.thread:                                ; preds = %for.inc75.thread
  %nodeinfo241 = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 45
  %34 = ptrtoint ptr %nodeinfo241 to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load ptr, ptr %nodeinfo241, align 4
  br label %if.then83

for.body80:                                       ; preds = %for.inc75
  %nodeinfo = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 45
  %36 = ptrtoint ptr %nodeinfo to i32
  call void @__asan_load4_noabort(i32 %36)
  %37 = load ptr, ptr %nodeinfo, align 4
  br i1 %tobool28.not, label %do.body87, label %if.then83

if.then83:                                        ; preds = %for.body80, %for.body80.thread
  %38 = phi ptr [ %35, %for.body80.thread ], [ %37, %for.body80 ]
  %nodeinfo84 = getelementptr inbounds %struct.mem_cgroup, ptr %retval.0.i, i32 0, i32 45
  %39 = ptrtoint ptr %nodeinfo84 to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load ptr, ptr %nodeinfo84, align 4
  br label %do.body87

do.body87:                                        ; preds = %if.then83, %for.body80, %for.body80.thread245
  %41 = phi ptr [ %38, %if.then83 ], [ %37, %for.body80 ], [ %31, %for.body80.thread245 ]
  %ppn.0 = phi ptr [ %40, %if.then83 ], [ null, %for.body80 ], [ null, %for.body80.thread245 ]
  %lruvec_stats_percpu = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %41, i32 0, i32 1
  %42 = ptrtoint ptr %lruvec_stats_percpu to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load ptr, ptr %lruvec_stats_percpu, align 4
  %44 = ptrtoint ptr %43 to i32
  %45 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load i32, ptr %arrayidx, align 4
  %add95 = add i32 %46, %44
  %47 = inttoptr i32 %add95 to ptr
  %lruvec_stats = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %41, i32 0, i32 2
  %tobool131.not = icmp eq ptr %ppn.0, null
  br label %for.body98

for.body98:                                       ; preds = %for.inc138, %do.body87
  %i.2235 = phi i32 [ 0, %do.body87 ], [ %inc139, %for.inc138 ]
  %arrayidx100 = getelementptr %struct.mem_cgroup_per_node, ptr %41, i32 0, i32 2, i32 1, i32 %i.2235
  %48 = ptrtoint ptr %arrayidx100 to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load i32, ptr %arrayidx100, align 4
  %tobool101.not = icmp eq i32 %49, 0
  br i1 %tobool101.not, label %do.end109, label %if.then102

if.then102:                                       ; preds = %for.body98
  %50 = ptrtoint ptr %arrayidx100 to i32
  call void @__asan_store4_noabort(i32 %50)
  store i32 0, ptr %arrayidx100, align 4
  br label %do.end109

do.end109:                                        ; preds = %if.then102, %for.body98
  %arrayidx112 = getelementptr [40 x i32], ptr %47, i32 0, i32 %i.2235
  %51 = ptrtoint ptr %arrayidx112 to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load volatile i32, ptr %arrayidx112, align 4
  %arrayidx114 = getelementptr %struct.lruvec_stats_percpu, ptr %47, i32 0, i32 1, i32 %i.2235
  %53 = ptrtoint ptr %arrayidx114 to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load i32, ptr %arrayidx114, align 4
  %cmp115.not = icmp eq i32 %52, %54
  br i1 %cmp115.not, label %if.end123, label %if.then116

if.then116:                                       ; preds = %do.end109
  %sub119 = add i32 %52, %49
  %add120 = sub i32 %sub119, %54
  %55 = ptrtoint ptr %arrayidx114 to i32
  call void @__asan_store4_noabort(i32 %55)
  store i32 %52, ptr %arrayidx114, align 4
  br label %if.end123

if.end123:                                        ; preds = %if.then116, %do.end109
  %delta.2 = phi i32 [ %add120, %if.then116 ], [ %49, %do.end109 ]
  %tobool124.not = icmp eq i32 %delta.2, 0
  br i1 %tobool124.not, label %for.inc138, label %if.end126

if.end126:                                        ; preds = %if.end123
  %arrayidx129 = getelementptr [40 x i32], ptr %lruvec_stats, i32 0, i32 %i.2235
  %56 = ptrtoint ptr %arrayidx129 to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load i32, ptr %arrayidx129, align 4
  %add130 = add i32 %57, %delta.2
  store i32 %add130, ptr %arrayidx129, align 4
  br i1 %tobool131.not, label %for.inc138, label %if.then132

if.then132:                                       ; preds = %if.end126
  %arrayidx135 = getelementptr %struct.mem_cgroup_per_node, ptr %ppn.0, i32 0, i32 2, i32 1, i32 %i.2235
  %58 = ptrtoint ptr %arrayidx135 to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load i32, ptr %arrayidx135, align 4
  %add136 = add i32 %59, %delta.2
  store i32 %add136, ptr %arrayidx135, align 4
  br label %for.inc138

for.inc138:                                       ; preds = %if.then132, %if.end126, %if.end123
  %inc139 = add nuw nsw i32 %i.2235, 1
  %exitcond238.not = icmp eq i32 %inc139, 40
  br i1 %exitcond238.not, label %for.end142, label %for.body98

for.end142:                                       ; preds = %for.inc138
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @mem_cgroup_can_attach(ptr noundef %tset) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %css = alloca ptr, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %css) #23
  %0 = ptrtoint ptr %css to i32
  call void @__asan_store4_noabort(i32 %0)
  store ptr inttoptr (i32 -1 to ptr), ptr %css, align 4, !annotation !492
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_can_attach, %if.end)) #23
          to label %cleanup [label %if.end], !srcloc !461

if.end:                                           ; preds = %entry
  %call4 = call ptr @cgroup_taskset_first(ptr noundef %tset, ptr noundef nonnull %css) #23
  %tobool5.not216 = icmp eq ptr %call4, null
  br i1 %tobool5.not216, label %cleanup, label %for.body

for.body:                                         ; preds = %for.inc, %if.end
  %memcg.0219 = phi ptr [ %memcg.1, %for.inc ], [ null, %if.end ]
  %leader.0218 = phi ptr [ %call56, %for.inc ], [ %call4, %if.end ]
  %p.0217 = phi ptr [ %p.1, %for.inc ], [ null, %if.end ]
  %group_leader = getelementptr inbounds %struct.task_struct, ptr %leader.0218, i32 0, i32 75
  %1 = ptrtoint ptr %group_leader to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %group_leader, align 4
  %cmp.not = icmp eq ptr %leader.0218, %2
  br i1 %cmp.not, label %if.else, label %for.inc

if.else:                                          ; preds = %for.body
  %tobool7.not = icmp eq ptr %p.0217, null
  br i1 %tobool7.not, label %if.end46, label %land.rhs

land.rhs:                                         ; preds = %if.else
  %.b214 = load i1, ptr @mem_cgroup_can_attach.__already_done, align 1
  br i1 %.b214, label %if.end46, label %if.then23, !prof !460

if.then23:                                        ; preds = %land.rhs
  store i1 true, ptr @mem_cgroup_can_attach.__already_done, align 1
  call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 5930, i32 noundef 9, ptr noundef null) #23
  br label %if.end46

if.end46:                                         ; preds = %if.then23, %land.rhs, %if.else
  %3 = ptrtoint ptr %css to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %css, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end46, %for.body
  %p.1 = phi ptr [ %p.0217, %for.body ], [ %leader.0218, %if.end46 ]
  %memcg.1 = phi ptr [ %memcg.0219, %for.body ], [ %4, %if.end46 ]
  %call56 = call ptr @cgroup_taskset_next(ptr noundef %tset, ptr noundef nonnull %css) #23
  %tobool5.not = icmp eq ptr %call56, null
  br i1 %tobool5.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc
  %tobool57.not = icmp eq ptr %p.1, null
  br i1 %tobool57.not, label %cleanup, label %do.end62

do.end62:                                         ; preds = %for.end
  %move_charge_at_immigrate = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.1, i32 0, i32 21
  %5 = ptrtoint ptr %move_charge_at_immigrate to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %move_charge_at_immigrate, align 8
  %tobool64.not = icmp eq i32 %6, 0
  br i1 %tobool64.not, label %cleanup, label %if.end66

if.end66:                                         ; preds = %do.end62
  %call67 = call ptr @mem_cgroup_from_task(ptr noundef nonnull %p.1)
  %cmp69 = icmp eq ptr %call67, %memcg.1
  br i1 %cmp69, label %do.body77, label %do.end85, !prof !466

do.body77:                                        ; preds = %if.end66
  call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 5948, 0\0A.popsection", ""() #23, !srcloc !512
  unreachable

do.end85:                                         ; preds = %if.end66
  %call86 = call ptr @get_task_mm(ptr noundef nonnull %p.1) #23
  %tobool87.not = icmp eq ptr %call86, null
  br i1 %tobool87.not, label %cleanup, label %if.end89

if.end89:                                         ; preds = %do.end85
  %owner = getelementptr inbounds %struct.anon.28, ptr %call86, i32 0, i32 46
  %7 = ptrtoint ptr %owner to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %owner, align 4
  %cmp90 = icmp eq ptr %8, %p.1
  br i1 %cmp90, label %do.body92, label %if.else186

do.body92:                                        ; preds = %if.end89
  %9 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 2), align 4
  %tobool93.not = icmp eq ptr %9, null
  br i1 %tobool93.not, label %do.body110, label %do.body101, !prof !460

do.body101:                                       ; preds = %do.body92
  call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 5955, 0\0A.popsection", ""() #23, !srcloc !513
  unreachable

do.body110:                                       ; preds = %do.body92
  %10 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 3), align 4
  %tobool111.not = icmp eq ptr %10, null
  br i1 %tobool111.not, label %do.body128, label %do.body119, !prof !460

do.body119:                                       ; preds = %do.body110
  call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 5956, 0\0A.popsection", ""() #23, !srcloc !514
  unreachable

do.body128:                                       ; preds = %do.body110
  %11 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 5), align 4
  %tobool129.not = icmp eq i32 %11, 0
  br i1 %tobool129.not, label %do.body146, label %do.body137, !prof !460

do.body137:                                       ; preds = %do.body128
  call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 5957, 0\0A.popsection", ""() #23, !srcloc !515
  unreachable

do.body146:                                       ; preds = %do.body128
  %12 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 6), align 4
  %tobool147.not = icmp eq i32 %12, 0
  br i1 %tobool147.not, label %do.body164, label %do.body155, !prof !460

do.body155:                                       ; preds = %do.body146
  call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 5958, 0\0A.popsection", ""() #23, !srcloc !516
  unreachable

do.body164:                                       ; preds = %do.body146
  %13 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 7), align 4
  %tobool165.not = icmp eq i32 %13, 0
  br i1 %tobool165.not, label %do.end181, label %do.body173, !prof !460

do.body173:                                       ; preds = %do.body164
  call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 5959, 0\0A.popsection", ""() #23, !srcloc !517
  unreachable

do.end181:                                        ; preds = %do.body164
  call void @_raw_spin_lock(ptr noundef nonnull @mc) #23
  store ptr %call86, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 1), align 4
  store ptr %call67, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 2), align 4
  store ptr %memcg.1, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 3), align 4
  store i32 %6, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 4), align 4
  call void @_raw_spin_unlock(ptr noundef nonnull @mc) #23
  %call.i = call fastcc i32 @mem_cgroup_count_precharge(ptr noundef nonnull %call86) #23
  %14 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 8), align 4
  %tobool.not.i = icmp eq ptr %14, null
  br i1 %tobool.not.i, label %mem_cgroup_precharge_mc.exit, label %do.body3.i, !prof !460

do.body3.i:                                       ; preds = %do.end181
  call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 5843, 0\0A.popsection", ""() #23, !srcloc !518
  unreachable

mem_cgroup_precharge_mc.exit:                     ; preds = %do.end181
  %15 = call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i = and i32 %15, -16384
  %16 = inttoptr i32 %and.i.i to ptr
  %task.i = getelementptr inbounds %struct.thread_info, ptr %16, i32 0, i32 2
  %17 = ptrtoint ptr %task.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %task.i, align 8
  store ptr %18, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 8), align 4
  %call10.i = call fastcc i32 @mem_cgroup_do_precharge(i32 noundef %call.i) #23
  %tobool183.not = icmp eq i32 %call10.i, 0
  br i1 %tobool183.not, label %cleanup, label %if.then184

if.then184:                                       ; preds = %mem_cgroup_precharge_mc.exit
  %19 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 1), align 4
  store ptr null, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 8), align 4
  call fastcc void @__mem_cgroup_clear_mc() #23
  call void @_raw_spin_lock(ptr noundef nonnull @mc) #23
  store ptr null, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 2), align 4
  store ptr null, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 3), align 4
  store ptr null, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 1), align 4
  call void @_raw_spin_unlock(ptr noundef nonnull @mc) #23
  call void @mmput(ptr noundef %19) #23
  br label %cleanup

if.else186:                                       ; preds = %if.end89
  call void @mmput(ptr noundef nonnull %call86) #23
  br label %cleanup

cleanup:                                          ; preds = %if.else186, %if.then184, %mem_cgroup_precharge_mc.exit, %do.end85, %do.end62, %for.end, %if.end, %entry
  %retval.0 = phi i32 [ 0, %for.end ], [ 0, %do.end62 ], [ 0, %do.end85 ], [ %call10.i, %if.then184 ], [ 0, %mem_cgroup_precharge_mc.exit ], [ 0, %if.else186 ], [ 0, %entry ], [ 0, %if.end ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %css) #23
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @mem_cgroup_cancel_attach(ptr nocapture noundef readnone %tset) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 3), align 4
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 1), align 4
  store ptr null, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 8), align 4
  tail call fastcc void @__mem_cgroup_clear_mc() #23
  tail call void @_raw_spin_lock(ptr noundef nonnull @mc) #23
  store ptr null, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 2), align 4
  store ptr null, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 3), align 4
  store ptr null, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 1), align 4
  tail call void @_raw_spin_unlock(ptr noundef nonnull @mc) #23
  tail call void @mmput(ptr noundef %1) #23
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @mem_cgroup_move_task() #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 3), align 4
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call fastcc void @mem_cgroup_move_charge()
  %1 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 1), align 4
  store ptr null, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 8), align 4
  tail call fastcc void @__mem_cgroup_clear_mc() #23
  tail call void @_raw_spin_lock(ptr noundef nonnull @mc) #23
  store ptr null, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 2), align 4
  store ptr null, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 3), align 4
  store ptr null, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 1), align 4
  tail call void @_raw_spin_unlock(ptr noundef nonnull @mc) #23
  tail call void @mmput(ptr noundef %1) #23
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mem_cgroup_calculate_protection(ptr noundef readnone %root, ptr noundef %memcg) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_calculate_protection, %cleanup)) #23
          to label %if.end [label %cleanup], !srcloc !461

if.end:                                           ; preds = %entry
  %tobool.not = icmp eq ptr %root, null
  br i1 %tobool.not, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  %0 = load ptr, ptr @root_mem_cgroup, align 4
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %if.end
  %root.addr.0 = phi ptr [ %root, %if.end ], [ %0, %if.then1 ]
  %cmp = icmp eq ptr %root.addr.0, %memcg
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end2
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %memory, i32 noundef 4) #23
  %1 = ptrtoint ptr %memory to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %memory, align 4
  %tobool6.not = icmp eq i32 %2, 0
  br i1 %tobool6.not, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end4
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2, i32 13
  %3 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %parent.i, align 4
  %tobool.not.i = icmp eq ptr %4, null
  %add.ptr.i = getelementptr i8, ptr %4, i32 -176
  %tobool10.not128 = icmp eq ptr %add.ptr.i, null
  %tobool10.not = or i1 %tobool.not.i, %tobool10.not128
  br i1 %tobool10.not, label %cleanup, label %if.end12

if.end12:                                         ; preds = %if.end8
  %cmp13 = icmp eq ptr %add.ptr.i, %root.addr.0
  br i1 %cmp13, label %do.end, label %if.end23

do.end:                                           ; preds = %if.end12
  %min = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2, i32 1
  %5 = ptrtoint ptr %min to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %min, align 4
  %emin = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2, i32 5
  %7 = ptrtoint ptr %emin to i32
  call void @__asan_store4_noabort(i32 %7)
  store i32 %6, ptr %emin, align 4
  %low = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2, i32 2
  %8 = ptrtoint ptr %low to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load volatile i32, ptr %low, align 8
  %elow = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2, i32 8
  %10 = ptrtoint ptr %elow to i32
  call void @__asan_store4_noabort(i32 %10)
  store i32 %9, ptr %elow, align 16
  br label %cleanup

if.end23:                                         ; preds = %if.end12
  %call.i.i.i102 = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull %4, i32 noundef 4) #23
  %11 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %4, align 4
  %min36 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2, i32 1
  %13 = ptrtoint ptr %min36 to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %min36, align 4
  %emin42 = getelementptr i8, ptr %4, i32 20
  %15 = ptrtoint ptr %emin42 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %emin42, align 4
  %children_min_usage = getelementptr i8, ptr %4, i32 28
  %call.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %children_min_usage, i32 noundef 4) #23
  %17 = ptrtoint ptr %children_min_usage to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load volatile i32, ptr %children_min_usage, align 4
  %19 = tail call i32 @llvm.umin.i32(i32 %2, i32 %14) #23
  %cmp1.i = icmp ult i32 %16, %18
  br i1 %cmp1.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end23
  %mul.i = mul i32 %19, %16
  %div.i = udiv i32 %mul.i, %18
  br label %effective_protection.exit

if.end.i:                                         ; preds = %if.end23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7) to i32))
  %20 = load i32, ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7), align 4
  %and.i = and i32 %20, 64
  %tobool.not.i103 = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i103, label %effective_protection.exit, label %if.end3.i

if.end3.i:                                        ; preds = %if.end.i
  %cmp4.i = icmp ugt i32 %16, %18
  %cmp5.i = icmp ugt i32 %12, %18
  %or.cond.i = and i1 %cmp4.i, %cmp5.i
  %cmp7.i = icmp ugt i32 %2, %14
  %or.cond35.i = and i1 %cmp7.i, %or.cond.i
  br i1 %or.cond35.i, label %if.then8.i, label %effective_protection.exit

if.then8.i:                                       ; preds = %if.end3.i
  %sub.i = sub i32 %16, %18
  %sub9.i = sub i32 %2, %19
  %mul10.i = mul i32 %sub.i, %sub9.i
  %sub11.i = sub i32 %12, %18
  %div12.i = udiv i32 %mul10.i, %sub11.i
  %add.i = add i32 %div12.i, %19
  br label %effective_protection.exit

effective_protection.exit:                        ; preds = %if.then8.i, %if.end3.i, %if.end.i, %if.then.i
  %retval.0.i104 = phi i32 [ %div.i, %if.then.i ], [ %19, %if.end.i ], [ %add.i, %if.then8.i ], [ %19, %if.end3.i ]
  %emin47 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2, i32 5
  %21 = ptrtoint ptr %emin47 to i32
  call void @__asan_store4_noabort(i32 %21)
  store volatile i32 %retval.0.i104, ptr %emin47, align 4
  %low62 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2, i32 2
  %22 = ptrtoint ptr %low62 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %low62, align 8
  %elow68 = getelementptr i8, ptr %4, i32 32
  %24 = ptrtoint ptr %elow68 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load volatile i32, ptr %elow68, align 16
  %children_low_usage = getelementptr i8, ptr %4, i32 40
  %call.i.i101 = tail call zeroext i1 @__kasan_check_read(ptr noundef %children_low_usage, i32 noundef 4) #23
  %26 = ptrtoint ptr %children_low_usage to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load volatile i32, ptr %children_low_usage, align 4
  %28 = tail call i32 @llvm.umin.i32(i32 %2, i32 %23) #23
  %cmp1.i105 = icmp ult i32 %25, %27
  br i1 %cmp1.i105, label %if.then.i108, label %if.end.i111

if.then.i108:                                     ; preds = %effective_protection.exit
  %mul.i106 = mul i32 %28, %25
  %div.i107 = udiv i32 %mul.i106, %27
  br label %effective_protection.exit126

if.end.i111:                                      ; preds = %effective_protection.exit
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7) to i32))
  %29 = load i32, ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7), align 4
  %and.i109 = and i32 %29, 64
  %tobool.not.i110 = icmp eq i32 %and.i109, 0
  br i1 %tobool.not.i110, label %effective_protection.exit126, label %if.end3.i117

if.end3.i117:                                     ; preds = %if.end.i111
  %cmp4.i112 = icmp ugt i32 %25, %27
  %cmp5.i113 = icmp ugt i32 %12, %27
  %or.cond.i114 = and i1 %cmp4.i112, %cmp5.i113
  %cmp7.i115 = icmp ugt i32 %2, %23
  %or.cond35.i116 = and i1 %cmp7.i115, %or.cond.i114
  br i1 %or.cond35.i116, label %if.then8.i124, label %effective_protection.exit126

if.then8.i124:                                    ; preds = %if.end3.i117
  %sub.i118 = sub i32 %25, %27
  %sub9.i119 = sub i32 %2, %28
  %mul10.i120 = mul i32 %sub.i118, %sub9.i119
  %sub11.i121 = sub i32 %12, %27
  %div12.i122 = udiv i32 %mul10.i120, %sub11.i121
  %add.i123 = add i32 %div12.i122, %28
  br label %effective_protection.exit126

effective_protection.exit126:                     ; preds = %if.then8.i124, %if.end3.i117, %if.end.i111, %if.then.i108
  %retval.0.i125 = phi i32 [ %div.i107, %if.then.i108 ], [ %28, %if.end.i111 ], [ %add.i123, %if.then8.i124 ], [ %28, %if.end3.i117 ]
  %elow73 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2, i32 8
  %30 = ptrtoint ptr %elow73 to i32
  call void @__asan_store4_noabort(i32 %30)
  store volatile i32 %retval.0.i125, ptr %elow73, align 16
  br label %cleanup

cleanup:                                          ; preds = %effective_protection.exit126, %do.end, %if.end8, %if.end4, %if.end2, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @__mem_cgroup_charge(ptr noundef %folio, ptr noundef %mm, i32 noundef %gfp) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call ptr @get_mem_cgroup_from_mm(ptr noundef %mm)
  %call1 = tail call fastcc i32 @charge_memcg(ptr noundef %folio, ptr noundef %call, i32 noundef %gfp)
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call, i32 0, i32 7
  %0 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %flags.i, align 4
  %and.i = and i32 %1, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.then.i, label %css_put.exit

if.then.i:                                        ; preds = %entry
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i) #23
  br label %css_put.exit

css_put.exit:                                     ; preds = %if.then.i, %entry
  ret i32 %call1
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @charge_memcg(ptr noundef %folio, ptr noundef %memcg, i32 noundef %gfp) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = ptrtoint ptr %folio to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile i32, ptr %folio, align 4
  %cmp.i.not.i.i.i = icmp eq i32 %1, -1
  br i1 %cmp.i.not.i.i.i, label %if.then.i.i.i, label %PageHead.exit.i.i, !prof !466

if.then.i.i.i:                                    ; preds = %entry
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.159) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 698, 0\0A.popsection", ""() #23, !srcloc !519
  unreachable

PageHead.exit.i.i:                                ; preds = %entry
  %2 = ptrtoint ptr %folio to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %folio, align 4
  %4 = and i32 %3, 65536
  %tobool.not.i.i = icmp eq i32 %4, 0
  br i1 %tobool.not.i.i, label %folio_nr_pages.exit, label %if.end.i.i

if.end.i.i:                                       ; preds = %PageHead.exit.i.i
  %compound_nr.i.i = getelementptr %struct.page, ptr %folio, i32 1, i32 1, i32 0, i32 2
  %5 = ptrtoint ptr %compound_nr.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %compound_nr.i.i, align 4
  br label %folio_nr_pages.exit

folio_nr_pages.exit:                              ; preds = %if.end.i.i, %PageHead.exit.i.i
  %retval.0.i.i = phi i32 [ %6, %if.end.i.i ], [ 1, %PageHead.exit.i.i ]
  %7 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i = icmp eq ptr %7, %memcg
  br i1 %cmp.i.i, label %if.end, label %try_charge.exit

try_charge.exit:                                  ; preds = %folio_nr_pages.exit
  %call1.i = tail call fastcc i32 @try_charge_memcg(ptr noundef %memcg, i32 noundef %gfp, i32 noundef %retval.0.i.i) #23
  %tobool.not = icmp eq i32 %call1.i, 0
  br i1 %tobool.not, label %if.end, label %out

if.end:                                           ; preds = %try_charge.exit, %folio_nr_pages.exit
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %memcg, i32 0, i32 7
  %8 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %flags.i, align 4
  %and.i = and i32 %9, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.then.i, label %css_get.exit

if.then.i:                                        ; preds = %if.end
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %memcg, i32 0, i32 2
  tail call fastcc void @percpu_ref_get_many(ptr noundef %refcnt.i, i32 noundef 1) #23
  br label %css_get.exit

css_get.exit:                                     ; preds = %if.then.i, %if.end
  %call.i = tail call fastcc ptr @folio_memcg(ptr noundef %folio) #23
  %tobool.not.i20 = icmp eq ptr %call.i, null
  br i1 %tobool.not.i20, label %commit_charge.exit, label %if.then.i21, !prof !460

if.then.i21:                                      ; preds = %css_get.exit
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.160) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 2739, 0\0A.popsection", ""() #23, !srcloc !520
  unreachable

commit_charge.exit:                               ; preds = %css_get.exit
  %10 = ptrtoint ptr %memcg to i32
  %memcg_data.i = getelementptr inbounds %struct.anon.153, ptr %folio, i32 0, i32 7
  %11 = ptrtoint ptr %memcg_data.i to i32
  call void @__asan_store4_noabort(i32 %11)
  store i32 %10, ptr %memcg_data.i, align 4
  %12 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i = and i32 %12, 128
  %tobool3.not = icmp eq i32 %and.i.i, 0
  tail call void asm sideeffect "\09cpsid i\09\09\09@ arch_local_irq_disable", "~{memory},~{cc}"() #23, !srcloc !521
  br i1 %tobool3.not, label %if.then5, label %if.end6

if.then5:                                         ; preds = %commit_charge.exit
  tail call void @trace_hardirqs_off() #23
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %commit_charge.exit
  %cmp.i = icmp sgt i32 %retval.0.i.i, 0
  br i1 %cmp.i, label %if.then.i22, label %if.else.i

if.then.i22:                                      ; preds = %if.end6
  tail call void @__count_memcg_events(ptr noundef %memcg, i32 noundef 0, i32 noundef 1) #23
  br label %mem_cgroup_charge_statistics.exit

if.else.i:                                        ; preds = %if.end6
  tail call void @__count_memcg_events(ptr noundef %memcg, i32 noundef 1, i32 noundef 1) #23
  %sub.i = sub i32 0, %retval.0.i.i
  br label %mem_cgroup_charge_statistics.exit

mem_cgroup_charge_statistics.exit:                ; preds = %if.else.i, %if.then.i22
  %nr_pages.addr.0.i = phi i32 [ %retval.0.i.i, %if.then.i22 ], [ %sub.i, %if.else.i ]
  %vmstats_percpu.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 39
  %13 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %vmstats_percpu.i, align 8
  %nr_page_events.i = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %14, i32 0, i32 4
  %15 = ptrtoint ptr %nr_page_events.i to i32
  %16 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i23 = and i32 %16, -16384
  %17 = inttoptr i32 %and.i.i23 to ptr
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %17, i32 0, i32 3
  %18 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %cpu.i, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %19
  %20 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %21, %15
  %22 = inttoptr i32 %add.i to ptr
  %23 = ptrtoint ptr %22 to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %22, align 4
  %add7.i = add i32 %24, %nr_pages.addr.0.i
  store i32 %add7.i, ptr %22, align 4
  %25 = ptrtoint ptr %folio to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load volatile i32, ptr %folio, align 4
  %cmp.i.not.i.i = icmp eq i32 %26, -1
  br i1 %cmp.i.not.i.i, label %if.then.i.i, label %folio_nid.exit, !prof !466

if.then.i.i:                                      ; preds = %mem_cgroup_charge_statistics.exit
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.170) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/mm.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1368, 0\0A.popsection", ""() #23, !srcloc !469
  unreachable

folio_nid.exit:                                   ; preds = %mem_cgroup_charge_statistics.exit
  %27 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %vmstats_percpu.i, align 8
  %nr_page_events.i.i = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %28, i32 0, i32 4
  %29 = ptrtoint ptr %nr_page_events.i.i to i32
  %30 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i = and i32 %30, -16384
  %31 = inttoptr i32 %and.i.i.i to ptr
  %cpu.i.i = getelementptr inbounds %struct.thread_info, ptr %31, i32 0, i32 3
  %32 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %cpu.i.i, align 4
  %arrayidx.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %33
  %34 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load i32, ptr %arrayidx.i.i, align 4
  %add.i.i = add i32 %35, %29
  %36 = inttoptr i32 %add.i.i to ptr
  %37 = ptrtoint ptr %36 to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %36, align 4
  %arrayidx23.i.i = getelementptr %struct.memcg_vmstats_percpu, ptr %28, i32 0, i32 5, i32 0
  %39 = ptrtoint ptr %arrayidx23.i.i to i32
  %add28.i.i = add i32 %35, %39
  %40 = inttoptr i32 %add28.i.i to ptr
  %41 = ptrtoint ptr %40 to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load i32, ptr %40, align 4
  %sub.i.i = sub i32 %42, %38
  %cmp.i.i25 = icmp slt i32 %sub.i.i, 0
  br i1 %cmp.i.i25, label %if.then.i26, label %memcg_check_events.exit

if.then.i26:                                      ; preds = %folio_nid.exit
  %add30.i.i = add i32 %38, 128
  %43 = ptrtoint ptr %40 to i32
  call void @__asan_store4_noabort(i32 %43)
  store i32 %add30.i.i, ptr %40, align 4
  %44 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load ptr, ptr %vmstats_percpu.i, align 8
  %nr_page_events.i16.i = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %45, i32 0, i32 4
  %46 = ptrtoint ptr %nr_page_events.i16.i to i32
  %47 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i17.i = and i32 %47, -16384
  %48 = inttoptr i32 %and.i.i17.i to ptr
  %cpu.i18.i = getelementptr inbounds %struct.thread_info, ptr %48, i32 0, i32 3
  %49 = ptrtoint ptr %cpu.i18.i to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load i32, ptr %cpu.i18.i, align 4
  %arrayidx.i19.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %50
  %51 = ptrtoint ptr %arrayidx.i19.i to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load i32, ptr %arrayidx.i19.i, align 4
  %add.i20.i = add i32 %52, %46
  %53 = inttoptr i32 %add.i20.i to ptr
  %54 = ptrtoint ptr %53 to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load i32, ptr %53, align 4
  %arrayidx23.i21.i = getelementptr %struct.memcg_vmstats_percpu, ptr %45, i32 0, i32 5, i32 1
  %56 = ptrtoint ptr %arrayidx23.i21.i to i32
  %add28.i22.i = add i32 %52, %56
  %57 = inttoptr i32 %add28.i22.i to ptr
  %58 = ptrtoint ptr %57 to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load i32, ptr %57, align 4
  %sub.i23.i = sub i32 %59, %55
  %cmp.i24.i = icmp slt i32 %sub.i23.i, 0
  br i1 %cmp.i24.i, label %if.then10.i, label %mem_cgroup_event_ratelimit.exit26.i

mem_cgroup_event_ratelimit.exit26.i:              ; preds = %if.then.i26
  %tobool.not5.i31 = icmp eq ptr %memcg, null
  br i1 %tobool.not5.i31, label %memcg_check_events.exit, label %while.body.i33

while.body.i33:                                   ; preds = %if.end.i42, %mem_cgroup_event_ratelimit.exit26.i
  %memcg.addr.06.i32 = phi ptr [ %add.ptr.i.i39, %if.end.i42 ], [ %memcg, %mem_cgroup_event_ratelimit.exit26.i ]
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i32, i1 noundef zeroext false) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@charge_memcg, %land.rhs.i.i35)) #23
          to label %if.end.i42 [label %land.rhs.i.i35], !srcloc !461

land.rhs.i.i35:                                   ; preds = %while.body.i33
  %60 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i34 = icmp eq i8 %60, 0
  br i1 %tobool4.not.i.i34, label %if.then.i36, label %if.end.i42

if.then.i36:                                      ; preds = %land.rhs.i.i35
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i32, i1 noundef zeroext true) #23
  br label %if.end.i42

if.end.i42:                                       ; preds = %if.then.i36, %land.rhs.i.i35, %while.body.i33
  %parent.i.i37 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.06.i32, i32 0, i32 2, i32 13
  %61 = ptrtoint ptr %parent.i.i37 to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load ptr, ptr %parent.i.i37, align 4
  %tobool.not.i.i38 = icmp eq ptr %62, null
  %add.ptr.i.i39 = getelementptr i8, ptr %62, i32 -176
  %tobool.not7.i40 = icmp eq ptr %add.ptr.i.i39, null
  %tobool.not.i41 = or i1 %tobool.not.i.i38, %tobool.not7.i40
  br i1 %tobool.not.i41, label %memcg_check_events.exit, label %while.body.i33

if.then10.i:                                      ; preds = %if.then.i26
  %add32.i.i = add i32 %55, 1024
  %63 = ptrtoint ptr %57 to i32
  call void @__asan_store4_noabort(i32 %63)
  store i32 %add32.i.i, ptr %57, align 4
  %tobool.not5.i = icmp eq ptr %memcg, null
  br i1 %tobool.not5.i, label %mem_cgroup_threshold.exit, label %while.body.i

while.body.i:                                     ; preds = %if.end.i30, %if.then10.i
  %memcg.addr.06.i = phi ptr [ %add.ptr.i.i, %if.end.i30 ], [ %memcg, %if.then10.i ]
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i, i1 noundef zeroext false) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@charge_memcg, %land.rhs.i.i)) #23
          to label %if.end.i30 [label %land.rhs.i.i], !srcloc !461

land.rhs.i.i:                                     ; preds = %while.body.i
  %64 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i = icmp eq i8 %64, 0
  br i1 %tobool4.not.i.i, label %if.then.i27, label %if.end.i30

if.then.i27:                                      ; preds = %land.rhs.i.i
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i, i1 noundef zeroext true) #23
  br label %if.end.i30

if.end.i30:                                       ; preds = %if.then.i27, %land.rhs.i.i, %while.body.i
  %parent.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.06.i, i32 0, i32 2, i32 13
  %65 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %65)
  %66 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i28 = icmp eq ptr %66, null
  %add.ptr.i.i = getelementptr i8, ptr %66, i32 -176
  %tobool.not7.i = icmp eq ptr %add.ptr.i.i, null
  %tobool.not.i29 = or i1 %tobool.not.i.i28, %tobool.not7.i
  br i1 %tobool.not.i29, label %mem_cgroup_threshold.exit, label %while.body.i

mem_cgroup_threshold.exit:                        ; preds = %if.end.i30, %if.then10.i
  tail call fastcc void @mem_cgroup_update_tree(ptr noundef %memcg, i32 noundef 0) #23
  br label %memcg_check_events.exit

memcg_check_events.exit:                          ; preds = %mem_cgroup_threshold.exit, %if.end.i42, %mem_cgroup_event_ratelimit.exit26.i, %folio_nid.exit
  tail call void @trace_hardirqs_on() #23
  tail call void asm sideeffect "\09cpsie i\09\09\09@ arch_local_irq_enable", "~{memory},~{cc}"() #23, !srcloc !522
  br label %out

out:                                              ; preds = %memcg_check_events.exit, %try_charge.exit
  %retval.0.i46 = phi i32 [ %call1.i, %try_charge.exit ], [ 0, %memcg_check_events.exit ]
  ret i32 %retval.0.i46
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @mem_cgroup_swapin_charge_page(ptr noundef %page, ptr noundef %mm, i32 noundef %gfp, [1 x i32] %entry.coerce) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = getelementptr inbounds %struct.page, ptr %page, i32 0, i32 1
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %0, align 4
  %and.i = and i32 %2, 1
  %tobool.not.i19 = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i19, label %if.end.i, label %if.then.i20, !prof !460

if.then.i20:                                      ; preds = %entry
  %sub.i = add i32 %2, -1
  br label %_compound_head.exit

if.end.i:                                         ; preds = %entry
  %3 = ptrtoint ptr %page to i32
  br label %_compound_head.exit

_compound_head.exit:                              ; preds = %if.end.i, %if.then.i20
  %retval.0.i = phi i32 [ %sub.i, %if.then.i20 ], [ %3, %if.end.i ]
  %4 = inttoptr i32 %retval.0.i to ptr
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_swapin_charge_page, %cleanup)) #23
          to label %if.end [label %cleanup], !srcloc !461

if.end:                                           ; preds = %_compound_head.exit
  %call5 = tail call zeroext i16 @lookup_swap_cgroup_id([1 x i32] %entry.coerce) #23
  %5 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %5, -16384
  %6 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %6, i32 0, i32 1
  %7 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %8, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %if.end
  %call.i21 = tail call i32 @rcu_read_lock_held() #23
  %tobool.not.i22 = icmp eq i32 %call.i21, 0
  br i1 %tobool.not.i22, label %land.rhs.i, label %mem_cgroup_from_id.exit

land.rhs.i:                                       ; preds = %rcu_read_lock.exit
  %.b40.i = load i1, ptr @mem_cgroup_from_id.__already_done, align 1
  br i1 %.b40.i, label %mem_cgroup_from_id.exit, label %if.then.i23, !prof !460

if.then.i23:                                      ; preds = %land.rhs.i
  store i1 true, ptr @mem_cgroup_from_id.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 5063, i32 noundef 9, ptr noundef null) #23
  br label %mem_cgroup_from_id.exit

mem_cgroup_from_id.exit:                          ; preds = %if.then.i23, %land.rhs.i, %rcu_read_lock.exit
  %conv.i = zext i16 %call5 to i32
  %call37.i = tail call ptr @idr_find(ptr noundef nonnull @mem_cgroup_idr, i32 noundef %conv.i) #23
  %tobool.not = icmp eq ptr %call37.i, null
  br i1 %tobool.not, label %if.then8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %mem_cgroup_from_id.exit
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call37.i, i32 0, i32 7
  %9 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %flags.i, align 4
  %and.i24 = and i32 %10, 1
  %tobool.not.i25 = icmp eq i32 %and.i24, 0
  br i1 %tobool.not.i25, label %if.then.i26, label %if.end10

if.then.i26:                                      ; preds = %lor.lhs.false
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call37.i, i32 0, i32 2
  %11 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i.i.i = and i32 %11, -16384
  %12 = inttoptr i32 %and.i.i.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %12, i32 0, i32 1
  %13 = ptrtoint ptr %preempt_count.i.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %preempt_count.i.i.i.i.i.i, align 4
  %add.i.i.i.i.i = add i32 %14, 1
  store volatile i32 %add.i.i.i.i.i, ptr %preempt_count.i.i.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i.i.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i.i.i, label %rcu_read_lock.exit.i.i, label %land.lhs.true.i.i.i

land.lhs.true.i.i.i:                              ; preds = %if.then.i26
  %call1.i.i.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i.i.i = icmp eq i32 %call1.i.i.i, 0
  br i1 %tobool.not.i.i.i, label %rcu_read_lock.exit.i.i, label %land.lhs.true2.i.i.i

land.lhs.true2.i.i.i:                             ; preds = %land.lhs.true.i.i.i
  %.b4.i.i.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i.i.i, label %rcu_read_lock.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %land.lhs.true2.i.i.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit.i.i

rcu_read_lock.exit.i.i:                           ; preds = %if.then.i.i.i, %land.lhs.true2.i.i.i, %land.lhs.true.i.i.i, %if.then.i26
  %call.i1.i.i = tail call i32 @rcu_read_lock_held() #23
  %tobool.not.i2.i.i = icmp eq i32 %call.i1.i.i, 0
  br i1 %tobool.not.i2.i.i, label %land.rhs.i.i.i, label %if.end29.i.i.i

land.rhs.i.i.i:                                   ; preds = %rcu_read_lock.exit.i.i
  %.b104.i.i.i = load i1, ptr @percpu_ref_tryget_live_rcu.__already_done, align 1
  br i1 %.b104.i.i.i, label %if.end29.i.i.i, label %if.then.i3.i.i, !prof !460

if.then.i3.i.i:                                   ; preds = %land.rhs.i.i.i
  store i1 true, ptr @percpu_ref_tryget_live_rcu.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.158, i32 noundef 280, i32 noundef 9, ptr noundef null) #23
  br label %if.end29.i.i.i

if.end29.i.i.i:                                   ; preds = %if.then.i3.i.i, %land.rhs.i.i.i, %rcu_read_lock.exit.i.i
  %15 = ptrtoint ptr %refcnt.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %refcnt.i, align 4
  %and.i.i.i.i = and i32 %16, 3
  %tobool.not.i.i.i.i = icmp eq i32 %and.i.i.i.i, 0
  br i1 %tobool.not.i.i.i.i, label %do.body46.i.i.i, label %if.else.i.i.i, !prof !460

do.body46.i.i.i:                                  ; preds = %if.end29.i.i.i
  %17 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %18 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i105.i.i.i = and i32 %18, -16384
  %19 = inttoptr i32 %and.i105.i.i.i to ptr
  %cpu.i.i.i = getelementptr inbounds %struct.thread_info, ptr %19, i32 0, i32 3
  %20 = ptrtoint ptr %cpu.i.i.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %cpu.i.i.i, align 4
  %arrayidx.i.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %21
  %22 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load i32, ptr %arrayidx.i.i.i, align 4
  %add.i.i.i27 = add i32 %23, %16
  %24 = inttoptr i32 %add.i.i.i27 to ptr
  %25 = ptrtoint ptr %24 to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %24, align 4
  %add63.i.i.i = add i32 %26, 1
  store i32 %add63.i.i.i, ptr %24, align 4
  %27 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i.i.i.i28 = and i32 %27, 128
  %tobool74.not.i.i.i = icmp eq i32 %and.i.i.i.i.i28, 0
  br i1 %tobool74.not.i.i.i, label %if.then83.i.i.i, label %do.end86.i.i.i, !prof !466

if.then83.i.i.i:                                  ; preds = %do.body46.i.i.i
  tail call void @warn_bogus_irq_restore() #23
  br label %do.end86.i.i.i

do.end86.i.i.i:                                   ; preds = %if.then83.i.i.i, %do.body46.i.i.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %17) #23, !srcloc !467
  br label %percpu_ref_tryget_live_rcu.exit.i.i

if.else.i.i.i:                                    ; preds = %if.end29.i.i.i
  %and.i.i.i = and i32 %16, 2
  %tobool93.not.i.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool93.not.i.i.i, label %if.then94.i.i.i, label %percpu_ref_tryget_live_rcu.exit.i.i

if.then94.i.i.i:                                  ; preds = %if.else.i.i.i
  %data.i.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call37.i, i32 0, i32 2, i32 1
  %28 = ptrtoint ptr %data.i.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load ptr, ptr %data.i.i.i, align 4
  %call.i.i.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %29, i32 noundef 4) #23
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !523
  tail call void @llvm.prefetch.p0(ptr %29, i32 1, i32 3, i32 1) #23
  %30 = tail call { i32, i32, i32 } asm sideeffect "@ atomic_add_unless\0A1:\09ldrex\09$0, [$4]\0A\09teq\09$0, $5\0A\09beq\092f\0A\09add\09$1, $0, $6\0A\09strex\09$2, $1, [$4]\0A\09teq\09$2, #0\0A\09bne\091b\0A2:", "=&r,=&r,=&r,=*Qo,r,r,r,*Qo,~{cc}"(ptr elementtype(i32) %29, ptr %29, i32 0, i32 1, ptr elementtype(i32) %29) #23, !srcloc !524
  %asmresult.i.i.i.i.i.i.i.i = extractvalue { i32, i32, i32 } %30, 0
  %cmp.not.i.i.i.i.i.i.i.i = icmp eq i32 %asmresult.i.i.i.i.i.i.i.i, 0
  br i1 %cmp.not.i.i.i.i.i.i.i.i, label %atomic_long_inc_not_zero.exit.i.i.i, label %do.end11.i.i.i.i.i.i.i.i

do.end11.i.i.i.i.i.i.i.i:                         ; preds = %if.then94.i.i.i
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !525
  br label %atomic_long_inc_not_zero.exit.i.i.i

atomic_long_inc_not_zero.exit.i.i.i:              ; preds = %do.end11.i.i.i.i.i.i.i.i, %if.then94.i.i.i
  %cmp.i.i.i.i.i.i.i = icmp ne i32 %asmresult.i.i.i.i.i.i.i.i, 0
  br label %percpu_ref_tryget_live_rcu.exit.i.i

percpu_ref_tryget_live_rcu.exit.i.i:              ; preds = %atomic_long_inc_not_zero.exit.i.i.i, %if.else.i.i.i, %do.end86.i.i.i
  %ret.0.off0.i.i.i = phi i1 [ true, %do.end86.i.i.i ], [ false, %if.else.i.i.i ], [ %cmp.i.i.i.i.i.i.i, %atomic_long_inc_not_zero.exit.i.i.i ]
  %call.i4.i.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i4.i.i, label %css_tryget_online.exit, label %land.lhs.true.i7.i.i

land.lhs.true.i7.i.i:                             ; preds = %percpu_ref_tryget_live_rcu.exit.i.i
  %call1.i5.i.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i6.i.i = icmp eq i32 %call1.i5.i.i, 0
  br i1 %tobool.not.i6.i.i, label %css_tryget_online.exit, label %land.lhs.true2.i9.i.i

land.lhs.true2.i9.i.i:                            ; preds = %land.lhs.true.i7.i.i
  %.b4.i8.i.i = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i8.i.i, label %css_tryget_online.exit, label %if.then.i10.i.i

if.then.i10.i.i:                                  ; preds = %land.lhs.true2.i9.i.i
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %css_tryget_online.exit

css_tryget_online.exit:                           ; preds = %if.then.i10.i.i, %land.lhs.true2.i9.i.i, %land.lhs.true.i7.i.i, %percpu_ref_tryget_live_rcu.exit.i.i
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %31 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i11.i.i = and i32 %31, -16384
  %32 = inttoptr i32 %and.i.i.i.i.i11.i.i to ptr
  %preempt_count.i.i.i.i12.i.i = getelementptr inbounds %struct.thread_info, ptr %32, i32 0, i32 1
  %33 = ptrtoint ptr %preempt_count.i.i.i.i12.i.i to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load volatile i32, ptr %preempt_count.i.i.i.i12.i.i, align 4
  %sub.i.i.i.i.i = add i32 %34, -1
  store volatile i32 %sub.i.i.i.i.i, ptr %preempt_count.i.i.i.i12.i.i, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  br i1 %ret.0.off0.i.i.i, label %if.end10, label %if.then8

if.then8:                                         ; preds = %css_tryget_online.exit, %mem_cgroup_from_id.exit
  %call9 = tail call ptr @get_mem_cgroup_from_mm(ptr noundef %mm)
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %css_tryget_online.exit, %lor.lhs.false
  %memcg.0 = phi ptr [ %call37.i, %css_tryget_online.exit ], [ %call9, %if.then8 ], [ %call37.i, %lor.lhs.false ]
  %call.i30 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i30, label %rcu_read_unlock.exit, label %land.lhs.true.i33

land.lhs.true.i33:                                ; preds = %if.end10
  %call1.i31 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i32 = icmp eq i32 %call1.i31, 0
  br i1 %tobool.not.i32, label %rcu_read_unlock.exit, label %land.lhs.true2.i35

land.lhs.true2.i35:                               ; preds = %land.lhs.true.i33
  %.b4.i34 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i34, label %rcu_read_unlock.exit, label %if.then.i36

if.then.i36:                                      ; preds = %land.lhs.true2.i35
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i36, %land.lhs.true2.i35, %land.lhs.true.i33, %if.end10
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %35 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i37 = and i32 %35, -16384
  %36 = inttoptr i32 %and.i.i.i.i.i37 to ptr
  %preempt_count.i.i.i.i38 = getelementptr inbounds %struct.thread_info, ptr %36, i32 0, i32 1
  %37 = ptrtoint ptr %preempt_count.i.i.i.i38 to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load volatile i32, ptr %preempt_count.i.i.i.i38, align 4
  %sub.i.i.i = add i32 %38, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i38, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  %call11 = tail call fastcc i32 @charge_memcg(ptr noundef %4, ptr noundef %memcg.0, i32 noundef %gfp)
  %flags.i39 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %memcg.0, i32 0, i32 7
  %39 = ptrtoint ptr %flags.i39 to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load i32, ptr %flags.i39, align 4
  %and.i40 = and i32 %40, 1
  %tobool.not.i41 = icmp eq i32 %and.i40, 0
  br i1 %tobool.not.i41, label %if.then.i43, label %cleanup

if.then.i43:                                      ; preds = %rcu_read_unlock.exit
  %refcnt.i42 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %memcg.0, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i42) #23
  br label %cleanup

cleanup:                                          ; preds = %if.then.i43, %rcu_read_unlock.exit, %_compound_head.exit
  %retval.0 = phi i32 [ %call11, %rcu_read_unlock.exit ], [ %call11, %if.then.i43 ], [ 0, %_compound_head.exit ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i16 @lookup_swap_cgroup_id([1 x i32]) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mem_cgroup_swapin_uncharge_swap([1 x i32] %entry.coerce) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_swapin_uncharge_swap, %if.end)) #23
          to label %land.lhs.true [label %if.end], !srcloc !461

land.lhs.true:                                    ; preds = %entry
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_swapin_uncharge_swap, %land.rhs.i)) #23
          to label %if.end [label %land.rhs.i], !srcloc !461

land.rhs.i:                                       ; preds = %land.lhs.true
  %0 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i = icmp eq i8 %0, 0
  br i1 %tobool4.not.i, label %if.then, label %if.end

if.then:                                          ; preds = %land.rhs.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_swapin_uncharge_swap, %if.end)) #23
          to label %if.end.i [label %if.end], !srcloc !461

if.end.i:                                         ; preds = %if.then
  tail call void @__mem_cgroup_uncharge_swap([1 x i32] %entry.coerce, i32 noundef 1) #23
  br label %if.end

if.end:                                           ; preds = %if.end.i, %if.then, %land.rhs.i, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @__mem_cgroup_uncharge(ptr noundef %folio) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %ug = alloca %struct.uncharge_gather, align 4
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %ug) #23
  %call = tail call fastcc ptr @folio_memcg(ptr noundef %folio)
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %0 = call ptr @memset(ptr %ug, i32 0, i32 20)
  call fastcc void @uncharge_folio(ptr noundef %folio, ptr noundef nonnull %ug)
  call fastcc void @uncharge_batch(ptr noundef nonnull %ug)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %ug) #23
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @uncharge_folio(ptr noundef %folio, ptr nocapture noundef %ug) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = getelementptr inbounds %struct.page, ptr %folio, i32 0, i32 1
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %0, align 4
  %and.i.i = and i32 %2, 1
  %tobool.not.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i, label %do.body7.i, label %if.then.i, !prof !460

if.then.i:                                        ; preds = %entry
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.104) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/memcontrol.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 537, 0\0A.popsection", ""() #23, !srcloc !483
  unreachable

do.body7.i:                                       ; preds = %entry
  %memcg_data.i = getelementptr inbounds %struct.anon.153, ptr %folio, i32 0, i32 7
  %3 = ptrtoint ptr %memcg_data.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %memcg_data.i, align 4
  %and.i = and i32 %4, 1
  %tobool8.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool8.not.i, label %folio_memcg_kmem.exit, label %if.then15.i, !prof !460

if.then15.i:                                      ; preds = %do.body7.i
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.105) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/memcontrol.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 538, 0\0A.popsection", ""() #23, !srcloc !484
  unreachable

folio_memcg_kmem.exit:                            ; preds = %do.body7.i
  %and23.i = and i32 %4, 2
  %tobool24.i.not = icmp eq i32 %and23.i, 0
  %5 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %0, align 4
  %and.i.i.i = and i32 %6, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i.i, label %folio_test_lru.exit, label %if.then.i.i, !prof !460

if.then.i.i:                                      ; preds = %folio_memcg_kmem.exit
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.96) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #23, !srcloc !470
  unreachable

folio_test_lru.exit:                              ; preds = %folio_memcg_kmem.exit
  %7 = ptrtoint ptr %folio to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load volatile i32, ptr %folio, align 4
  %9 = and i32 %8, 16
  %tobool.i.not = icmp eq i32 %9, 0
  br i1 %tobool.i.not, label %do.end8, label %if.then, !prof !460

if.then:                                          ; preds = %folio_test_lru.exit
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.123) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 6826, 0\0A.popsection", ""() #23, !srcloc !526
  unreachable

do.end8:                                          ; preds = %folio_test_lru.exit
  %10 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %0, align 4
  %and.i.i.i.i72 = and i32 %11, 1
  %tobool.not.i.i.i73 = icmp eq i32 %and.i.i.i.i72, 0
  br i1 %tobool24.i.not, label %if.else, label %if.then10

if.then10:                                        ; preds = %do.end8
  br i1 %tobool.not.i.i.i73, label %folio_test_slab.exit.i, label %if.then.i.i.i, !prof !460

if.then.i.i.i:                                    ; preds = %if.then10
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.96) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #23, !srcloc !470
  unreachable

folio_test_slab.exit.i:                           ; preds = %if.then10
  %12 = ptrtoint ptr %folio to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load volatile i32, ptr %folio, align 4
  %14 = and i32 %13, 512
  %tobool.i.not.i = icmp eq i32 %14, 0
  br i1 %tobool.i.not.i, label %__folio_objcg.exit, label %if.then.i69, !prof !460

if.then.i69:                                      ; preds = %folio_test_slab.exit.i
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.58) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/memcontrol.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 417, 0\0A.popsection", ""() #23, !srcloc !485
  unreachable

__folio_objcg.exit:                               ; preds = %folio_test_slab.exit.i
  %and48.i = and i32 %4, -4
  %15 = inttoptr i32 %and48.i to ptr
  %call12 = tail call fastcc ptr @get_mem_cgroup_from_objcg(ptr noundef %15)
  br label %if.end14

if.else:                                          ; preds = %do.end8
  br i1 %tobool.not.i.i.i73, label %folio_test_slab.exit.i76, label %if.then.i.i.i74, !prof !460

if.then.i.i.i74:                                  ; preds = %if.else
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.96) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #23, !srcloc !470
  unreachable

folio_test_slab.exit.i76:                         ; preds = %if.else
  %16 = ptrtoint ptr %folio to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load volatile i32, ptr %folio, align 4
  %18 = and i32 %17, 512
  %tobool.i.not.i75 = icmp eq i32 %18, 0
  br i1 %tobool.i.not.i75, label %__folio_memcg.exit, label %if.then.i77, !prof !460

if.then.i77:                                      ; preds = %folio_test_slab.exit.i76
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.58) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/memcontrol.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 396, 0\0A.popsection", ""() #23, !srcloc !486
  unreachable

__folio_memcg.exit:                               ; preds = %folio_test_slab.exit.i76
  %and46.i = and i32 %4, -4
  %19 = inttoptr i32 %and46.i to ptr
  br label %if.end14

if.end14:                                         ; preds = %__folio_memcg.exit, %__folio_objcg.exit
  %memcg.0 = phi ptr [ %call12, %__folio_objcg.exit ], [ %19, %__folio_memcg.exit ]
  %objcg.0 = phi ptr [ %15, %__folio_objcg.exit ], [ inttoptr (i32 -1 to ptr), %__folio_memcg.exit ]
  %tobool15.not = icmp eq ptr %memcg.0, null
  br i1 %tobool15.not, label %cleanup, label %if.end17

if.end17:                                         ; preds = %if.end14
  %20 = ptrtoint ptr %ug to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %ug, align 4
  %cmp.not = icmp eq ptr %21, %memcg.0
  br i1 %cmp.not, label %if.end26, label %if.then19

if.then19:                                        ; preds = %if.end17
  %tobool21.not = icmp eq ptr %21, null
  br i1 %tobool21.not, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.then19
  tail call fastcc void @uncharge_batch(ptr noundef %ug)
  %22 = getelementptr inbounds i8, ptr %ug, i32 4
  %23 = call ptr @memset(ptr %22, i32 0, i32 16)
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.then19
  %24 = ptrtoint ptr %ug to i32
  call void @__asan_store4_noabort(i32 %24)
  store ptr %memcg.0, ptr %ug, align 4
  %25 = ptrtoint ptr %folio to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load volatile i32, ptr %folio, align 4
  %cmp.i.not.i.i = icmp eq i32 %26, -1
  br i1 %cmp.i.not.i.i, label %if.then.i.i85, label %folio_nid.exit, !prof !466

if.then.i.i85:                                    ; preds = %if.end23
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.170) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/mm.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1368, 0\0A.popsection", ""() #23, !srcloc !469
  unreachable

folio_nid.exit:                                   ; preds = %if.end23
  %nid = getelementptr inbounds %struct.uncharge_gather, ptr %ug, i32 0, i32 4
  %27 = ptrtoint ptr %nid to i32
  call void @__asan_store4_noabort(i32 %27)
  store i32 0, ptr %nid, align 4
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %memcg.0, i32 0, i32 7
  %28 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %flags.i, align 4
  %and.i86 = and i32 %29, 1
  %tobool.not.i87 = icmp eq i32 %and.i86, 0
  br i1 %tobool.not.i87, label %if.then.i88, label %if.end26

if.then.i88:                                      ; preds = %folio_nid.exit
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %memcg.0, i32 0, i32 2
  tail call fastcc void @percpu_ref_get_many(ptr noundef %refcnt.i, i32 noundef 1) #23
  br label %if.end26

if.end26:                                         ; preds = %if.then.i88, %folio_nid.exit, %if.end17
  %30 = ptrtoint ptr %folio to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load volatile i32, ptr %folio, align 4
  %cmp.i.not.i.i.i = icmp eq i32 %31, -1
  br i1 %cmp.i.not.i.i.i, label %if.then.i.i.i89, label %PageHead.exit.i.i, !prof !466

if.then.i.i.i89:                                  ; preds = %if.end26
  tail call void @dump_page(ptr noundef %folio, ptr noundef nonnull @.str.159) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 698, 0\0A.popsection", ""() #23, !srcloc !519
  unreachable

PageHead.exit.i.i:                                ; preds = %if.end26
  %32 = ptrtoint ptr %folio to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load volatile i32, ptr %folio, align 4
  %34 = and i32 %33, 65536
  %tobool.not.i.i90 = icmp eq i32 %34, 0
  br i1 %tobool.not.i.i90, label %folio_nr_pages.exit, label %if.end.i.i

if.end.i.i:                                       ; preds = %PageHead.exit.i.i
  %compound_nr.i.i = getelementptr %struct.page, ptr %folio, i32 1, i32 1, i32 0, i32 2
  %35 = ptrtoint ptr %compound_nr.i.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %compound_nr.i.i, align 4
  br label %folio_nr_pages.exit

folio_nr_pages.exit:                              ; preds = %if.end.i.i, %PageHead.exit.i.i
  %retval.0.i.i = phi i32 [ %36, %if.end.i.i ], [ 1, %PageHead.exit.i.i ]
  br i1 %tobool24.i.not, label %if.else31, label %if.then29

if.then29:                                        ; preds = %folio_nr_pages.exit
  %nr_memory = getelementptr inbounds %struct.uncharge_gather, ptr %ug, i32 0, i32 1
  %37 = ptrtoint ptr %nr_memory to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %nr_memory, align 4
  %add = add i32 %38, %retval.0.i.i
  store i32 %add, ptr %nr_memory, align 4
  %nr_kmem = getelementptr inbounds %struct.uncharge_gather, ptr %ug, i32 0, i32 3
  %39 = ptrtoint ptr %nr_kmem to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load i32, ptr %nr_kmem, align 4
  %add30 = add i32 %40, %retval.0.i.i
  store i32 %add30, ptr %nr_kmem, align 4
  %41 = ptrtoint ptr %memcg_data.i to i32
  call void @__asan_store4_noabort(i32 %41)
  store i32 0, ptr %memcg_data.i, align 4
  tail call fastcc void @percpu_ref_put(ptr noundef %objcg.0) #23
  br label %if.end38

if.else31:                                        ; preds = %folio_nr_pages.exit
  %42 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i = icmp eq ptr %42, %memcg.0
  br i1 %cmp.i, label %if.end36, label %if.then33

if.then33:                                        ; preds = %if.else31
  %nr_memory34 = getelementptr inbounds %struct.uncharge_gather, ptr %ug, i32 0, i32 1
  %43 = ptrtoint ptr %nr_memory34 to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load i32, ptr %nr_memory34, align 4
  %add35 = add i32 %44, %retval.0.i.i
  store i32 %add35, ptr %nr_memory34, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then33, %if.else31
  %pgpgout = getelementptr inbounds %struct.uncharge_gather, ptr %ug, i32 0, i32 2
  %45 = ptrtoint ptr %pgpgout to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load i32, ptr %pgpgout, align 4
  %inc = add i32 %46, 1
  store i32 %inc, ptr %pgpgout, align 4
  %47 = ptrtoint ptr %memcg_data.i to i32
  call void @__asan_store4_noabort(i32 %47)
  store i32 0, ptr %memcg_data.i, align 4
  br label %if.end38

if.end38:                                         ; preds = %if.end36, %if.then29
  %flags.i91 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %memcg.0, i32 0, i32 7
  %48 = ptrtoint ptr %flags.i91 to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load i32, ptr %flags.i91, align 4
  %and.i92 = and i32 %49, 1
  %tobool.not.i93 = icmp eq i32 %and.i92, 0
  br i1 %tobool.not.i93, label %if.then.i95, label %cleanup

if.then.i95:                                      ; preds = %if.end38
  %refcnt.i94 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %memcg.0, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i94) #23
  br label %cleanup

cleanup:                                          ; preds = %if.then.i95, %if.end38, %if.end14
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @uncharge_batch(ptr nocapture noundef readonly %ug) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %nr_memory = getelementptr inbounds %struct.uncharge_gather, ptr %ug, i32 0, i32 1
  %0 = ptrtoint ptr %nr_memory to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %nr_memory, align 4
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %do.body17, label %if.then

if.then:                                          ; preds = %entry
  %2 = ptrtoint ptr %ug to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %ug, align 4
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %3, i32 0, i32 2
  tail call void @page_counter_uncharge(ptr noundef %memory, i32 noundef %1) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@uncharge_batch, %land.rhs.i)) #23
          to label %if.end [label %land.rhs.i], !srcloc !461

land.rhs.i:                                       ; preds = %if.then
  %4 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i = icmp eq i8 %4, 0
  br i1 %tobool4.not.i, label %if.then2, label %if.end

if.then2:                                         ; preds = %land.rhs.i
  %5 = ptrtoint ptr %ug to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %ug, align 4
  %7 = getelementptr inbounds %struct.mem_cgroup, ptr %6, i32 0, i32 3
  %8 = ptrtoint ptr %nr_memory to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %nr_memory, align 4
  tail call void @page_counter_uncharge(ptr noundef %7, i32 noundef %9) #23
  br label %if.end

if.end:                                           ; preds = %if.then2, %land.rhs.i, %if.then
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@uncharge_batch, %land.lhs.true)) #23
          to label %if.end14 [label %land.lhs.true], !srcloc !461

land.lhs.true:                                    ; preds = %if.end
  %nr_kmem = getelementptr inbounds %struct.uncharge_gather, ptr %ug, i32 0, i32 3
  %10 = ptrtoint ptr %nr_kmem to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %nr_kmem, align 4
  %tobool10.not = icmp eq i32 %11, 0
  br i1 %tobool10.not, label %if.end14, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %12 = ptrtoint ptr %ug to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %ug, align 4
  %kmem = getelementptr inbounds %struct.mem_cgroup, ptr %13, i32 0, i32 4
  tail call void @page_counter_uncharge(ptr noundef %kmem, i32 noundef %11) #23
  br label %if.end14

if.end14:                                         ; preds = %if.then11, %land.lhs.true, %if.end
  %14 = ptrtoint ptr %ug to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %ug, align 4
  %tobool.not.i = icmp eq ptr %15, null
  br i1 %tobool.not.i, label %do.body17, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end14
  %under_oom.i = getelementptr inbounds %struct.mem_cgroup, ptr %15, i32 0, i32 11
  %16 = ptrtoint ptr %under_oom.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %under_oom.i, align 16
  %tobool1.not.i = icmp eq i32 %17, 0
  br i1 %tobool1.not.i, label %do.body17, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  tail call void @__wake_up(ptr noundef nonnull @memcg_oom_waitq, i32 noundef 3, i32 noundef 0, ptr noundef nonnull %15) #23
  br label %do.body17

do.body17:                                        ; preds = %if.then.i, %land.lhs.true.i, %if.end14, %entry
  %18 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i = and i32 %18, 128
  %tobool27.not = icmp eq i32 %and.i, 0
  br i1 %tobool27.not, label %if.then28, label %do.end31

if.then28:                                        ; preds = %do.body17
  tail call void @trace_hardirqs_off() #23
  br label %do.end31

do.end31:                                         ; preds = %if.then28, %do.body17
  %19 = ptrtoint ptr %ug to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %ug, align 4
  %pgpgout = getelementptr inbounds %struct.uncharge_gather, ptr %ug, i32 0, i32 2
  %21 = ptrtoint ptr %pgpgout to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load i32, ptr %pgpgout, align 4
  tail call void @__count_memcg_events(ptr noundef %20, i32 noundef 1, i32 noundef %22)
  %23 = ptrtoint ptr %nr_memory to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %nr_memory, align 4
  %25 = ptrtoint ptr %ug to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load ptr, ptr %ug, align 4
  %vmstats_percpu = getelementptr inbounds %struct.mem_cgroup, ptr %26, i32 0, i32 39
  %27 = ptrtoint ptr %vmstats_percpu to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %vmstats_percpu, align 8
  %nr_page_events = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %28, i32 0, i32 4
  %29 = ptrtoint ptr %nr_page_events to i32
  %30 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i108 = and i32 %30, -16384
  %31 = inttoptr i32 %and.i108 to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %31, i32 0, i32 3
  %32 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %cpu, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %33
  %34 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load i32, ptr %arrayidx, align 4
  %add = add i32 %35, %29
  %36 = inttoptr i32 %add to ptr
  %37 = ptrtoint ptr %36 to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %36, align 4
  %add47 = add i32 %38, %24
  store i32 %add47, ptr %36, align 4
  %39 = ptrtoint ptr %ug to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load ptr, ptr %ug, align 4
  %nid = getelementptr inbounds %struct.uncharge_gather, ptr %ug, i32 0, i32 4
  %41 = ptrtoint ptr %nid to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load i32, ptr %nid, align 4
  %vmstats_percpu.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %40, i32 0, i32 39
  %43 = ptrtoint ptr %vmstats_percpu.i.i to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load ptr, ptr %vmstats_percpu.i.i, align 8
  %nr_page_events.i.i = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %44, i32 0, i32 4
  %45 = ptrtoint ptr %nr_page_events.i.i to i32
  %46 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i = and i32 %46, -16384
  %47 = inttoptr i32 %and.i.i.i to ptr
  %cpu.i.i = getelementptr inbounds %struct.thread_info, ptr %47, i32 0, i32 3
  %48 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load i32, ptr %cpu.i.i, align 4
  %arrayidx.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %49
  %50 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load i32, ptr %arrayidx.i.i, align 4
  %add.i.i = add i32 %51, %45
  %52 = inttoptr i32 %add.i.i to ptr
  %53 = ptrtoint ptr %52 to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load i32, ptr %52, align 4
  %arrayidx23.i.i = getelementptr %struct.memcg_vmstats_percpu, ptr %44, i32 0, i32 5, i32 0
  %55 = ptrtoint ptr %arrayidx23.i.i to i32
  %add28.i.i = add i32 %51, %55
  %56 = inttoptr i32 %add28.i.i to ptr
  %57 = ptrtoint ptr %56 to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load i32, ptr %56, align 4
  %sub.i.i = sub i32 %58, %54
  %cmp.i.i = icmp slt i32 %sub.i.i, 0
  br i1 %cmp.i.i, label %if.then.i109, label %memcg_check_events.exit

if.then.i109:                                     ; preds = %do.end31
  %add30.i.i = add i32 %54, 128
  %59 = ptrtoint ptr %56 to i32
  call void @__asan_store4_noabort(i32 %59)
  store i32 %add30.i.i, ptr %56, align 4
  %60 = ptrtoint ptr %vmstats_percpu.i.i to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load ptr, ptr %vmstats_percpu.i.i, align 8
  %nr_page_events.i16.i = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %61, i32 0, i32 4
  %62 = ptrtoint ptr %nr_page_events.i16.i to i32
  %63 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i17.i = and i32 %63, -16384
  %64 = inttoptr i32 %and.i.i17.i to ptr
  %cpu.i18.i = getelementptr inbounds %struct.thread_info, ptr %64, i32 0, i32 3
  %65 = ptrtoint ptr %cpu.i18.i to i32
  call void @__asan_load4_noabort(i32 %65)
  %66 = load i32, ptr %cpu.i18.i, align 4
  %arrayidx.i19.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %66
  %67 = ptrtoint ptr %arrayidx.i19.i to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load i32, ptr %arrayidx.i19.i, align 4
  %add.i20.i = add i32 %68, %62
  %69 = inttoptr i32 %add.i20.i to ptr
  %70 = ptrtoint ptr %69 to i32
  call void @__asan_load4_noabort(i32 %70)
  %71 = load i32, ptr %69, align 4
  %arrayidx23.i21.i = getelementptr %struct.memcg_vmstats_percpu, ptr %61, i32 0, i32 5, i32 1
  %72 = ptrtoint ptr %arrayidx23.i21.i to i32
  %add28.i22.i = add i32 %68, %72
  %73 = inttoptr i32 %add28.i22.i to ptr
  %74 = ptrtoint ptr %73 to i32
  call void @__asan_load4_noabort(i32 %74)
  %75 = load i32, ptr %73, align 4
  %sub.i23.i = sub i32 %75, %71
  %cmp.i24.i = icmp slt i32 %sub.i23.i, 0
  br i1 %cmp.i24.i, label %if.then10.i, label %mem_cgroup_event_ratelimit.exit26.i

mem_cgroup_event_ratelimit.exit26.i:              ; preds = %if.then.i109
  %tobool.not5.i116 = icmp eq ptr %40, null
  br i1 %tobool.not5.i116, label %memcg_check_events.exit, label %while.body.i118

while.body.i118:                                  ; preds = %if.end.i127, %mem_cgroup_event_ratelimit.exit26.i
  %memcg.addr.06.i117 = phi ptr [ %add.ptr.i.i124, %if.end.i127 ], [ %40, %mem_cgroup_event_ratelimit.exit26.i ]
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i117, i1 noundef zeroext false) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@uncharge_batch, %land.rhs.i.i120)) #23
          to label %if.end.i127 [label %land.rhs.i.i120], !srcloc !461

land.rhs.i.i120:                                  ; preds = %while.body.i118
  %76 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i119 = icmp eq i8 %76, 0
  br i1 %tobool4.not.i.i119, label %if.then.i121, label %if.end.i127

if.then.i121:                                     ; preds = %land.rhs.i.i120
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i117, i1 noundef zeroext true) #23
  br label %if.end.i127

if.end.i127:                                      ; preds = %if.then.i121, %land.rhs.i.i120, %while.body.i118
  %parent.i.i122 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.06.i117, i32 0, i32 2, i32 13
  %77 = ptrtoint ptr %parent.i.i122 to i32
  call void @__asan_load4_noabort(i32 %77)
  %78 = load ptr, ptr %parent.i.i122, align 4
  %tobool.not.i.i123 = icmp eq ptr %78, null
  %add.ptr.i.i124 = getelementptr i8, ptr %78, i32 -176
  %tobool.not7.i125 = icmp eq ptr %add.ptr.i.i124, null
  %tobool.not.i126 = or i1 %tobool.not.i.i123, %tobool.not7.i125
  br i1 %tobool.not.i126, label %memcg_check_events.exit, label %while.body.i118

if.then10.i:                                      ; preds = %if.then.i109
  %add32.i.i = add i32 %71, 1024
  %79 = ptrtoint ptr %73 to i32
  call void @__asan_store4_noabort(i32 %79)
  store i32 %add32.i.i, ptr %73, align 4
  %tobool.not5.i = icmp eq ptr %40, null
  br i1 %tobool.not5.i, label %mem_cgroup_threshold.exit, label %while.body.i

while.body.i:                                     ; preds = %if.end.i, %if.then10.i
  %memcg.addr.06.i = phi ptr [ %add.ptr.i.i, %if.end.i ], [ %40, %if.then10.i ]
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i, i1 noundef zeroext false) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@uncharge_batch, %land.rhs.i.i)) #23
          to label %if.end.i [label %land.rhs.i.i], !srcloc !461

land.rhs.i.i:                                     ; preds = %while.body.i
  %80 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i = icmp eq i8 %80, 0
  br i1 %tobool4.not.i.i, label %if.then.i114, label %if.end.i

if.then.i114:                                     ; preds = %land.rhs.i.i
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i, i1 noundef zeroext true) #23
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i114, %land.rhs.i.i, %while.body.i
  %parent.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.06.i, i32 0, i32 2, i32 13
  %81 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %81)
  %82 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i = icmp eq ptr %82, null
  %add.ptr.i.i = getelementptr i8, ptr %82, i32 -176
  %tobool.not7.i = icmp eq ptr %add.ptr.i.i, null
  %tobool.not.i115 = or i1 %tobool.not.i.i, %tobool.not7.i
  br i1 %tobool.not.i115, label %mem_cgroup_threshold.exit, label %while.body.i

mem_cgroup_threshold.exit:                        ; preds = %if.end.i, %if.then10.i
  tail call fastcc void @mem_cgroup_update_tree(ptr noundef %40, i32 noundef %42) #23
  br label %memcg_check_events.exit

memcg_check_events.exit:                          ; preds = %mem_cgroup_threshold.exit, %if.end.i127, %mem_cgroup_event_ratelimit.exit26.i, %do.end31
  br i1 %tobool27.not, label %if.then62, label %do.body64

if.then62:                                        ; preds = %memcg_check_events.exit
  tail call void @trace_hardirqs_on() #23
  br label %do.body64

do.body64:                                        ; preds = %if.then62, %memcg_check_events.exit
  %83 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i = and i32 %83, 128
  %tobool72.not = icmp eq i32 %and.i.i, 0
  br i1 %tobool72.not, label %if.then81, label %do.end84, !prof !466

if.then81:                                        ; preds = %do.body64
  tail call void @warn_bogus_irq_restore() #23
  br label %do.end84

do.end84:                                         ; preds = %if.then81, %do.body64
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %18) #23, !srcloc !467
  %84 = ptrtoint ptr %ug to i32
  call void @__asan_load4_noabort(i32 %84)
  %85 = load ptr, ptr %ug, align 4
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %85, i32 0, i32 7
  %86 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %86)
  %87 = load i32, ptr %flags.i, align 4
  %and.i111 = and i32 %87, 1
  %tobool.not.i112 = icmp eq i32 %and.i111, 0
  br i1 %tobool.not.i112, label %if.then.i113, label %css_put.exit

if.then.i113:                                     ; preds = %do.end84
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %85, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i) #23
  br label %css_put.exit

css_put.exit:                                     ; preds = %if.then.i113, %do.end84
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @__mem_cgroup_uncharge_list(ptr noundef readonly %page_list) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %ug = alloca %struct.uncharge_gather, align 4
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %ug) #23
  %0 = call ptr @memset(ptr %ug, i32 0, i32 20)
  %1 = ptrtoint ptr %page_list to i32
  call void @__asan_load4_noabort(i32 %1)
  %.pn9 = load ptr, ptr %page_list, align 4
  %cmp.not10 = icmp eq ptr %.pn9, %page_list
  br i1 %cmp.not10, label %for.end, label %for.body

for.body:                                         ; preds = %for.body, %entry
  %.pn11 = phi ptr [ %.pn, %for.body ], [ %.pn9, %entry ]
  %folio.0 = getelementptr i8, ptr %.pn11, i32 -4
  call fastcc void @uncharge_folio(ptr noundef %folio.0, ptr noundef nonnull %ug)
  %2 = ptrtoint ptr %.pn11 to i32
  call void @__asan_load4_noabort(i32 %2)
  %.pn = load ptr, ptr %.pn11, align 4
  %cmp.not = icmp eq ptr %.pn, %page_list
  br i1 %cmp.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  %3 = ptrtoint ptr %ug to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %ug, align 4
  %tobool.not = icmp eq ptr %4, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %for.end
  call fastcc void @uncharge_batch(ptr noundef nonnull %ug)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %ug) #23
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mem_cgroup_migrate(ptr noundef %old, ptr noundef %new) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = ptrtoint ptr %new to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile i32, ptr %new, align 4
  %cmp.i.not.i.i.i = icmp eq i32 %1, -1
  br i1 %cmp.i.not.i.i.i, label %if.then.i.i.i, label %PageHead.exit.i.i, !prof !466

if.then.i.i.i:                                    ; preds = %entry
  tail call void @dump_page(ptr noundef %new, ptr noundef nonnull @.str.159) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 698, 0\0A.popsection", ""() #23, !srcloc !519
  unreachable

PageHead.exit.i.i:                                ; preds = %entry
  %2 = ptrtoint ptr %new to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %new, align 4
  %4 = and i32 %3, 65536
  %tobool.not.i.i236 = icmp eq i32 %4, 0
  br i1 %tobool.not.i.i236, label %folio_nr_pages.exit, label %if.end.i.i

if.end.i.i:                                       ; preds = %PageHead.exit.i.i
  %compound_nr.i.i = getelementptr %struct.page, ptr %new, i32 1, i32 1, i32 0, i32 2
  %5 = ptrtoint ptr %compound_nr.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %compound_nr.i.i, align 4
  br label %folio_nr_pages.exit

folio_nr_pages.exit:                              ; preds = %if.end.i.i, %PageHead.exit.i.i
  %retval.0.i.i = phi i32 [ %6, %if.end.i.i ], [ 1, %PageHead.exit.i.i ]
  %7 = getelementptr inbounds %struct.page, ptr %old, i32 0, i32 1
  %8 = ptrtoint ptr %7 to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load volatile i32, ptr %7, align 4
  %and.i.i.i = and i32 %9, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i.i, label %folio_test_locked.exit, label %if.then.i.i, !prof !460

if.then.i.i:                                      ; preds = %folio_nr_pages.exit
  tail call void @dump_page(ptr noundef %old, ptr noundef nonnull @.str.96) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #23, !srcloc !470
  unreachable

folio_test_locked.exit:                           ; preds = %folio_nr_pages.exit
  %10 = ptrtoint ptr %old to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %old, align 4
  %and1.i.i = and i32 %11, 1
  %tobool.i.not = icmp eq i32 %and1.i.i, 0
  br i1 %tobool.i.not, label %if.then, label %do.body10, !prof !466

if.then:                                          ; preds = %folio_test_locked.exit
  tail call void @dump_page(ptr noundef %old, ptr noundef nonnull @.str.39) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 6927, 0\0A.popsection", ""() #23, !srcloc !527
  unreachable

do.body10:                                        ; preds = %folio_test_locked.exit
  %12 = getelementptr inbounds %struct.page, ptr %new, i32 0, i32 1
  %13 = ptrtoint ptr %12 to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %12, align 4
  %and.i.i.i227 = and i32 %14, 1
  %tobool.not.i.i228 = icmp eq i32 %and.i.i.i227, 0
  br i1 %tobool.not.i.i228, label %folio_test_locked.exit232, label %if.then.i.i229, !prof !460

if.then.i.i229:                                   ; preds = %do.body10
  tail call void @dump_page(ptr noundef %new, ptr noundef nonnull @.str.96) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #23, !srcloc !470
  unreachable

folio_test_locked.exit232:                        ; preds = %do.body10
  %15 = ptrtoint ptr %new to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %new, align 4
  %and1.i.i230 = and i32 %16, 1
  %tobool.i231.not = icmp eq i32 %and1.i.i230, 0
  br i1 %tobool.i231.not, label %if.then20, label %do.body30, !prof !466

if.then20:                                        ; preds = %folio_test_locked.exit232
  tail call void @dump_page(ptr noundef %new, ptr noundef nonnull @.str.40) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 6928, 0\0A.popsection", ""() #23, !srcloc !528
  unreachable

do.body30:                                        ; preds = %folio_test_locked.exit232
  %mapping.i = getelementptr inbounds %struct.anon.153, ptr %old, i32 0, i32 2
  %17 = ptrtoint ptr %mapping.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %mapping.i, align 4
  %19 = ptrtoint ptr %18 to i32
  %and.i = and i32 %19, 1
  %cmp.i = icmp ne i32 %and.i, 0
  %mapping.i233 = getelementptr inbounds %struct.anon.153, ptr %new, i32 0, i32 2
  %20 = ptrtoint ptr %mapping.i233 to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %mapping.i233, align 4
  %22 = ptrtoint ptr %21 to i32
  %and.i234 = and i32 %22, 1
  %cmp.i235 = icmp ne i32 %and.i234, 0
  %23 = xor i1 %cmp.i, %cmp.i235
  br i1 %23, label %if.then41, label %do.body51, !prof !466

if.then41:                                        ; preds = %do.body30
  tail call void @dump_page(ptr noundef %new, ptr noundef nonnull @.str.41) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 6929, 0\0A.popsection", ""() #23, !srcloc !529
  unreachable

do.body51:                                        ; preds = %do.body30
  %24 = ptrtoint ptr %old to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load volatile i32, ptr %old, align 4
  %cmp.i.not.i.i.i237 = icmp eq i32 %25, -1
  br i1 %cmp.i.not.i.i.i237, label %if.then.i.i.i238, label %PageHead.exit.i.i240, !prof !466

if.then.i.i.i238:                                 ; preds = %do.body51
  tail call void @dump_page(ptr noundef %old, ptr noundef nonnull @.str.159) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 698, 0\0A.popsection", ""() #23, !srcloc !519
  unreachable

PageHead.exit.i.i240:                             ; preds = %do.body51
  %26 = ptrtoint ptr %old to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load volatile i32, ptr %old, align 4
  %28 = and i32 %27, 65536
  %tobool.not.i.i239 = icmp eq i32 %28, 0
  br i1 %tobool.not.i.i239, label %folio_nr_pages.exit244, label %if.end.i.i242

if.end.i.i242:                                    ; preds = %PageHead.exit.i.i240
  %compound_nr.i.i241 = getelementptr %struct.page, ptr %old, i32 1, i32 1, i32 0, i32 2
  %29 = ptrtoint ptr %compound_nr.i.i241 to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %compound_nr.i.i241, align 4
  br label %folio_nr_pages.exit244

folio_nr_pages.exit244:                           ; preds = %if.end.i.i242, %PageHead.exit.i.i240
  %retval.0.i.i243 = phi i32 [ %30, %if.end.i.i242 ], [ 1, %PageHead.exit.i.i240 ]
  %cmp53.not = icmp eq i32 %retval.0.i.i243, %retval.0.i.i
  br i1 %cmp53.not, label %do.end70, label %if.then61, !prof !460

if.then61:                                        ; preds = %folio_nr_pages.exit244
  tail call void @dump_page(ptr noundef %new, ptr noundef nonnull @.str.42) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 6930, 0\0A.popsection", ""() #23, !srcloc !530
  unreachable

do.end70:                                         ; preds = %folio_nr_pages.exit244
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_migrate, %cleanup)) #23
          to label %if.end73 [label %cleanup], !srcloc !461

if.end73:                                         ; preds = %do.end70
  %call74 = tail call fastcc ptr @folio_memcg(ptr noundef %new)
  %tobool75.not = icmp eq ptr %call74, null
  br i1 %tobool75.not, label %if.end77, label %cleanup

if.end77:                                         ; preds = %if.end73
  %call78 = tail call fastcc ptr @folio_memcg(ptr noundef %old)
  %tobool79.not = icmp eq ptr %call78, null
  br i1 %tobool79.not, label %land.rhs, label %if.end131

land.rhs:                                         ; preds = %if.end77
  %.b225 = load i1, ptr @mem_cgroup_migrate.__warned, align 1
  br i1 %.b225, label %cleanup, label %if.then96, !prof !460

if.then96:                                        ; preds = %land.rhs
  tail call void @dump_page(ptr noundef %old, ptr noundef nonnull @.str.43) #23
  store i1 true, ptr @mem_cgroup_migrate.__warned, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 6940, i32 noundef 9, ptr noundef null) #23
  br label %cleanup

if.end131:                                        ; preds = %if.end77
  %31 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i246 = icmp eq ptr %31, %call78
  br i1 %cmp.i246, label %if.end137, label %if.then133

if.then133:                                       ; preds = %if.end131
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %call78, i32 0, i32 2
  tail call void @page_counter_charge(ptr noundef %memory, i32 noundef %retval.0.i.i) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_migrate, %land.rhs.i)) #23
          to label %if.end137 [label %land.rhs.i], !srcloc !461

land.rhs.i:                                       ; preds = %if.then133
  %32 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i = icmp eq i8 %32, 0
  br i1 %tobool4.not.i, label %if.then135, label %if.end137

if.then135:                                       ; preds = %land.rhs.i
  %33 = getelementptr inbounds %struct.mem_cgroup, ptr %call78, i32 0, i32 3
  tail call void @page_counter_charge(ptr noundef %33, i32 noundef %retval.0.i.i) #23
  br label %if.end137

if.end137:                                        ; preds = %if.then135, %land.rhs.i, %if.then133, %if.end131
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call78, i32 0, i32 7
  %34 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load i32, ptr %flags.i, align 4
  %and.i247 = and i32 %35, 1
  %tobool.not.i = icmp eq i32 %and.i247, 0
  br i1 %tobool.not.i, label %if.then.i, label %css_get.exit

if.then.i:                                        ; preds = %if.end137
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call78, i32 0, i32 2
  tail call fastcc void @percpu_ref_get_many(ptr noundef %refcnt.i, i32 noundef 1) #23
  br label %css_get.exit

css_get.exit:                                     ; preds = %if.then.i, %if.end137
  %call.i = tail call fastcc ptr @folio_memcg(ptr noundef %new) #23
  %tobool.not.i248 = icmp eq ptr %call.i, null
  br i1 %tobool.not.i248, label %commit_charge.exit, label %if.then.i249, !prof !460

if.then.i249:                                     ; preds = %css_get.exit
  tail call void @dump_page(ptr noundef %new, ptr noundef nonnull @.str.160) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 2739, 0\0A.popsection", ""() #23, !srcloc !520
  unreachable

commit_charge.exit:                               ; preds = %css_get.exit
  %36 = ptrtoint ptr %call78 to i32
  %memcg_data.i = getelementptr inbounds %struct.anon.153, ptr %new, i32 0, i32 7
  %37 = ptrtoint ptr %memcg_data.i to i32
  call void @__asan_store4_noabort(i32 %37)
  store i32 %36, ptr %memcg_data.i, align 4
  %38 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i250 = and i32 %38, 128
  %tobool153.not = icmp eq i32 %and.i250, 0
  br i1 %tobool153.not, label %if.then154, label %do.end157

if.then154:                                       ; preds = %commit_charge.exit
  tail call void @trace_hardirqs_off() #23
  br label %do.end157

do.end157:                                        ; preds = %if.then154, %commit_charge.exit
  %cmp.i251 = icmp sgt i32 %retval.0.i.i, 0
  br i1 %cmp.i251, label %if.then.i252, label %if.else.i

if.then.i252:                                     ; preds = %do.end157
  tail call void @__count_memcg_events(ptr noundef nonnull %call78, i32 noundef 0, i32 noundef 1) #23
  br label %mem_cgroup_charge_statistics.exit

if.else.i:                                        ; preds = %do.end157
  tail call void @__count_memcg_events(ptr noundef nonnull %call78, i32 noundef 1, i32 noundef 1) #23
  %sub.i = sub i32 0, %retval.0.i.i
  br label %mem_cgroup_charge_statistics.exit

mem_cgroup_charge_statistics.exit:                ; preds = %if.else.i, %if.then.i252
  %nr_pages.addr.0.i = phi i32 [ %retval.0.i.i, %if.then.i252 ], [ %sub.i, %if.else.i ]
  %vmstats_percpu.i = getelementptr inbounds %struct.mem_cgroup, ptr %call78, i32 0, i32 39
  %39 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load ptr, ptr %vmstats_percpu.i, align 8
  %nr_page_events.i = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %40, i32 0, i32 4
  %41 = ptrtoint ptr %nr_page_events.i to i32
  %42 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i = and i32 %42, -16384
  %43 = inttoptr i32 %and.i.i to ptr
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %43, i32 0, i32 3
  %44 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load i32, ptr %cpu.i, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %45
  %46 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %47, %41
  %48 = inttoptr i32 %add.i to ptr
  %49 = ptrtoint ptr %48 to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load i32, ptr %48, align 4
  %add7.i = add i32 %50, %nr_pages.addr.0.i
  store i32 %add7.i, ptr %48, align 4
  %51 = ptrtoint ptr %new to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load volatile i32, ptr %new, align 4
  %cmp.i.not.i.i = icmp eq i32 %52, -1
  br i1 %cmp.i.not.i.i, label %if.then.i.i253, label %folio_nid.exit, !prof !466

if.then.i.i253:                                   ; preds = %mem_cgroup_charge_statistics.exit
  tail call void @dump_page(ptr noundef %new, ptr noundef nonnull @.str.170) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/mm.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1368, 0\0A.popsection", ""() #23, !srcloc !469
  unreachable

folio_nid.exit:                                   ; preds = %mem_cgroup_charge_statistics.exit
  %53 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load ptr, ptr %vmstats_percpu.i, align 8
  %nr_page_events.i.i = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %54, i32 0, i32 4
  %55 = ptrtoint ptr %nr_page_events.i.i to i32
  %56 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i254 = and i32 %56, -16384
  %57 = inttoptr i32 %and.i.i.i254 to ptr
  %cpu.i.i = getelementptr inbounds %struct.thread_info, ptr %57, i32 0, i32 3
  %58 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load i32, ptr %cpu.i.i, align 4
  %arrayidx.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %59
  %60 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load i32, ptr %arrayidx.i.i, align 4
  %add.i.i = add i32 %61, %55
  %62 = inttoptr i32 %add.i.i to ptr
  %63 = ptrtoint ptr %62 to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load i32, ptr %62, align 4
  %arrayidx23.i.i = getelementptr %struct.memcg_vmstats_percpu, ptr %54, i32 0, i32 5, i32 0
  %65 = ptrtoint ptr %arrayidx23.i.i to i32
  %add28.i.i = add i32 %61, %65
  %66 = inttoptr i32 %add28.i.i to ptr
  %67 = ptrtoint ptr %66 to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load i32, ptr %66, align 4
  %sub.i.i = sub i32 %68, %64
  %cmp.i.i = icmp slt i32 %sub.i.i, 0
  br i1 %cmp.i.i, label %if.then.i255, label %memcg_check_events.exit

if.then.i255:                                     ; preds = %folio_nid.exit
  %add30.i.i = add i32 %64, 128
  %69 = ptrtoint ptr %66 to i32
  call void @__asan_store4_noabort(i32 %69)
  store i32 %add30.i.i, ptr %66, align 4
  %70 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %70)
  %71 = load ptr, ptr %vmstats_percpu.i, align 8
  %nr_page_events.i16.i = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %71, i32 0, i32 4
  %72 = ptrtoint ptr %nr_page_events.i16.i to i32
  %73 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i17.i = and i32 %73, -16384
  %74 = inttoptr i32 %and.i.i17.i to ptr
  %cpu.i18.i = getelementptr inbounds %struct.thread_info, ptr %74, i32 0, i32 3
  %75 = ptrtoint ptr %cpu.i18.i to i32
  call void @__asan_load4_noabort(i32 %75)
  %76 = load i32, ptr %cpu.i18.i, align 4
  %arrayidx.i19.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %76
  %77 = ptrtoint ptr %arrayidx.i19.i to i32
  call void @__asan_load4_noabort(i32 %77)
  %78 = load i32, ptr %arrayidx.i19.i, align 4
  %add.i20.i = add i32 %78, %72
  %79 = inttoptr i32 %add.i20.i to ptr
  %80 = ptrtoint ptr %79 to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load i32, ptr %79, align 4
  %arrayidx23.i21.i = getelementptr %struct.memcg_vmstats_percpu, ptr %71, i32 0, i32 5, i32 1
  %82 = ptrtoint ptr %arrayidx23.i21.i to i32
  %add28.i22.i = add i32 %78, %82
  %83 = inttoptr i32 %add28.i22.i to ptr
  %84 = ptrtoint ptr %83 to i32
  call void @__asan_load4_noabort(i32 %84)
  %85 = load i32, ptr %83, align 4
  %sub.i23.i = sub i32 %85, %81
  %cmp.i24.i = icmp slt i32 %sub.i23.i, 0
  br i1 %cmp.i24.i, label %if.then10.i, label %while.body.i

while.body.i:                                     ; preds = %if.end.i, %if.then.i255
  %memcg.addr.06.i = phi ptr [ %add.ptr.i.i, %if.end.i ], [ %call78, %if.then.i255 ]
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i, i1 noundef zeroext false) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_migrate, %land.rhs.i.i)) #23
          to label %if.end.i [label %land.rhs.i.i], !srcloc !461

land.rhs.i.i:                                     ; preds = %while.body.i
  %86 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i = icmp eq i8 %86, 0
  br i1 %tobool4.not.i.i, label %if.then.i258, label %if.end.i

if.then.i258:                                     ; preds = %land.rhs.i.i
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i, i1 noundef zeroext true) #23
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i258, %land.rhs.i.i, %while.body.i
  %parent.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.06.i, i32 0, i32 2, i32 13
  %87 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %87)
  %88 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i259 = icmp eq ptr %88, null
  %add.ptr.i.i = getelementptr i8, ptr %88, i32 -176
  %tobool.not7.i = icmp eq ptr %add.ptr.i.i, null
  %tobool.not.i260 = or i1 %tobool.not.i.i259, %tobool.not7.i
  br i1 %tobool.not.i260, label %memcg_check_events.exit, label %while.body.i

if.then10.i:                                      ; preds = %if.then.i255
  %add32.i.i = add i32 %81, 1024
  %89 = ptrtoint ptr %83 to i32
  call void @__asan_store4_noabort(i32 %89)
  store i32 %add32.i.i, ptr %83, align 4
  tail call fastcc void @mem_cgroup_threshold(ptr noundef nonnull %call78) #23
  tail call fastcc void @mem_cgroup_update_tree(ptr noundef nonnull %call78, i32 noundef 0) #23
  br label %memcg_check_events.exit

memcg_check_events.exit:                          ; preds = %if.then10.i, %if.end.i, %folio_nid.exit
  br i1 %tobool153.not, label %if.then168, label %do.body170

if.then168:                                       ; preds = %memcg_check_events.exit
  tail call void @trace_hardirqs_on() #23
  br label %do.body170

do.body170:                                       ; preds = %if.then168, %memcg_check_events.exit
  %90 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i257 = and i32 %90, 128
  %tobool178.not = icmp eq i32 %and.i.i257, 0
  br i1 %tobool178.not, label %if.then187, label %do.end190, !prof !466

if.then187:                                       ; preds = %do.body170
  tail call void @warn_bogus_irq_restore() #23
  br label %do.end190

do.end190:                                        ; preds = %if.then187, %do.body170
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %38) #23, !srcloc !467
  br label %cleanup

cleanup:                                          ; preds = %do.end190, %if.then96, %land.rhs, %if.end73, %do.end70
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @page_counter_charge(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mem_cgroup_sk_alloc(ptr nocapture noundef writeonly %sk) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr nonnull @memcg_sockets_enabled_key, ptr blockaddress(@mem_cgroup_sk_alloc, %if.end)) #23
          to label %cleanup [label %if.end], !srcloc !461

if.end:                                           ; preds = %entry
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i to ptr
  %preempt_count.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i, align 4
  %and = and i32 %3, 15728640
  %4 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i38 = and i32 %4, -16384
  %5 = inttoptr i32 %and.i.i38 to ptr
  %preempt_count.i39 = getelementptr inbounds %struct.thread_info, ptr %5, i32 0, i32 1
  %6 = ptrtoint ptr %preempt_count.i39 to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %preempt_count.i39, align 4
  %and5 = and i32 %7, 983040
  %or = or i32 %and5, %and
  %8 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i40 = and i32 %8, -16384
  %9 = inttoptr i32 %and.i.i40 to ptr
  %preempt_count.i41 = getelementptr inbounds %struct.thread_info, ptr %9, i32 0, i32 1
  %10 = ptrtoint ptr %preempt_count.i41 to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %preempt_count.i41, align 4
  %and7 = and i32 %11, 65280
  %or8 = or i32 %or, %and7
  %tobool9.not = icmp eq i32 %or8, 0
  br i1 %tobool9.not, label %if.end11, label %cleanup

if.end11:                                         ; preds = %if.end
  %12 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %12, -16384
  %13 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 1
  %14 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %15, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end11
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %if.end11
  %16 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i = and i32 %16, -16384
  %17 = inttoptr i32 %and.i to ptr
  %task = getelementptr inbounds %struct.thread_info, ptr %17, i32 0, i32 2
  %18 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load ptr, ptr %task, align 8
  %call13 = tail call ptr @mem_cgroup_from_task(ptr noundef %19)
  %20 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp = icmp eq ptr %call13, %20
  br i1 %cmp, label %out, label %if.end15

if.end15:                                         ; preds = %rcu_read_lock.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_sk_alloc, %land.lhs.true)) #23
          to label %if.end31 [label %land.lhs.true], !srcloc !461

land.lhs.true:                                    ; preds = %if.end15
  %tcpmem_active = getelementptr inbounds %struct.mem_cgroup, ptr %call13, i32 0, i32 30
  %21 = ptrtoint ptr %tcpmem_active to i32
  call void @__asan_load1_noabort(i32 %21)
  %22 = load i8, ptr %tcpmem_active, align 4, !range !488
  %tobool29.not = icmp eq i8 %22, 0
  br i1 %tobool29.not, label %out, label %if.end31

if.end31:                                         ; preds = %land.lhs.true, %if.end15
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call13, i32 0, i32 7
  %23 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %flags.i, align 4
  %and.i45 = and i32 %24, 1
  %tobool.not.i46 = icmp eq i32 %and.i45, 0
  br i1 %tobool.not.i46, label %css_tryget.exit, label %if.then33

css_tryget.exit:                                  ; preds = %if.end31
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call13, i32 0, i32 2
  %call.i47 = tail call fastcc zeroext i1 @percpu_ref_tryget(ptr noundef %refcnt.i) #23
  br i1 %call.i47, label %if.then33, label %out

if.then33:                                        ; preds = %css_tryget.exit, %if.end31
  %sk_memcg = getelementptr inbounds %struct.sock, ptr %sk, i32 0, i32 75
  %25 = ptrtoint ptr %sk_memcg to i32
  call void @__asan_store4_noabort(i32 %25)
  store ptr %call13, ptr %sk_memcg, align 8
  br label %out

out:                                              ; preds = %if.then33, %css_tryget.exit, %land.lhs.true, %rcu_read_lock.exit
  %call.i50 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i50, label %rcu_read_unlock.exit, label %land.lhs.true.i53

land.lhs.true.i53:                                ; preds = %out
  %call1.i51 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i52 = icmp eq i32 %call1.i51, 0
  br i1 %tobool.not.i52, label %rcu_read_unlock.exit, label %land.lhs.true2.i55

land.lhs.true2.i55:                               ; preds = %land.lhs.true.i53
  %.b4.i54 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i54, label %rcu_read_unlock.exit, label %if.then.i56

if.then.i56:                                      ; preds = %land.lhs.true2.i55
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i56, %land.lhs.true2.i55, %land.lhs.true.i53, %out
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %26 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i57 = and i32 %26, -16384
  %27 = inttoptr i32 %and.i.i.i.i.i57 to ptr
  %preempt_count.i.i.i.i58 = getelementptr inbounds %struct.thread_info, ptr %27, i32 0, i32 1
  %28 = ptrtoint ptr %preempt_count.i.i.i.i58 to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %preempt_count.i.i.i.i58, align 4
  %sub.i.i.i = add i32 %29, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i58, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  br label %cleanup

cleanup:                                          ; preds = %rcu_read_unlock.exit, %if.end, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mem_cgroup_sk_free(ptr nocapture noundef readonly %sk) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %sk_memcg = getelementptr inbounds %struct.sock, ptr %sk, i32 0, i32 75
  %0 = ptrtoint ptr %sk_memcg to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %sk_memcg, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %1, i32 0, i32 7
  %2 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %flags.i, align 4
  %and.i = and i32 %3, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.then.i, label %if.end

if.then.i:                                        ; preds = %if.then
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %1, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i) #23
  br label %if.end

if.end:                                           ; preds = %if.then.i, %if.then, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local zeroext i1 @mem_cgroup_charge_skmem(ptr noundef %memcg, i32 noundef %nr_pages, i32 noundef %gfp_mask) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %fail = alloca ptr, align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_charge_skmem, %if.then)) #23
          to label %if.end11 [label %if.then], !srcloc !461

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %fail) #23
  %0 = ptrtoint ptr %fail to i32
  call void @__asan_store4_noabort(i32 %0)
  store ptr inttoptr (i32 -1 to ptr), ptr %fail, align 4, !annotation !492
  %tcpmem = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 5
  %call4 = call zeroext i1 @page_counter_try_charge(ptr noundef %tcpmem, i32 noundef %nr_pages, ptr noundef nonnull %fail) #23
  %tcpmem_pressure = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 31
  br i1 %call4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  %1 = ptrtoint ptr %tcpmem_pressure to i32
  call void @__asan_store4_noabort(i32 %1)
  store i32 0, ptr %tcpmem_pressure, align 16
  br label %cleanup

if.end:                                           ; preds = %if.then
  %2 = ptrtoint ptr %tcpmem_pressure to i32
  call void @__asan_store4_noabort(i32 %2)
  store i32 1, ptr %tcpmem_pressure, align 16
  %and = and i32 %gfp_mask, 32768
  %tobool7.not = icmp eq i32 %and, 0
  br i1 %tobool7.not, label %cleanup, label %if.then8

if.then8:                                         ; preds = %if.end
  call void @page_counter_charge(ptr noundef %tcpmem, i32 noundef %nr_pages) #23
  br label %cleanup

cleanup:                                          ; preds = %if.then8, %if.end, %if.then5
  %retval.0 = phi i1 [ true, %if.then5 ], [ true, %if.then8 ], [ false, %if.end ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %fail) #23
  br label %return

if.end11:                                         ; preds = %entry
  %3 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i = icmp eq ptr %3, %memcg
  br i1 %cmp.i.i, label %if.then13, label %try_charge.exit

try_charge.exit:                                  ; preds = %if.end11
  %call1.i = tail call fastcc i32 @try_charge_memcg(ptr noundef %memcg, i32 noundef %gfp_mask, i32 noundef %nr_pages) #23
  %cmp = icmp eq i32 %call1.i, 0
  br i1 %cmp, label %if.then13, label %return

if.then13:                                        ; preds = %try_charge.exit, %if.end11
  %4 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i.i = and i32 %4, 128
  %tobool.not.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i, label %if.then21.i, label %do.end11.i

do.end11.i:                                       ; preds = %if.then13
  tail call void @__mod_memcg_state(ptr noundef %memcg, i32 noundef 41, i32 noundef %nr_pages) #23
  br label %do.body23.i

if.then21.i:                                      ; preds = %if.then13
  tail call void @trace_hardirqs_off() #23
  tail call void @__mod_memcg_state(ptr noundef %memcg, i32 noundef 41, i32 noundef %nr_pages) #23
  tail call void @trace_hardirqs_on() #23
  br label %do.body23.i

do.body23.i:                                      ; preds = %if.then21.i, %do.end11.i
  %5 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i.i = and i32 %5, 128
  %tobool32.not.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool32.not.i, label %if.then36.i, label %mod_memcg_state.exit, !prof !466

if.then36.i:                                      ; preds = %do.body23.i
  tail call void @warn_bogus_irq_restore() #23
  br label %mod_memcg_state.exit

mod_memcg_state.exit:                             ; preds = %if.then36.i, %do.body23.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %4) #23, !srcloc !467
  br label %return

return:                                           ; preds = %mod_memcg_state.exit, %try_charge.exit, %cleanup
  %retval.1 = phi i1 [ true, %mod_memcg_state.exit ], [ %retval.0, %cleanup ], [ false, %try_charge.exit ]
  ret i1 %retval.1
}

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @page_counter_try_charge(ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mem_cgroup_uncharge_skmem(ptr noundef %memcg, i32 noundef %nr_pages) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_uncharge_skmem, %if.then)) #23
          to label %if.end [label %if.then], !srcloc !461

if.then:                                          ; preds = %entry
  %tcpmem = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 5
  tail call void @page_counter_uncharge(ptr noundef %tcpmem, i32 noundef %nr_pages) #23
  br label %return

if.end:                                           ; preds = %entry
  %sub = sub i32 0, %nr_pages
  %0 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i.i = and i32 %0, 128
  %tobool.not.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i, label %if.then21.i, label %do.end11.i

do.end11.i:                                       ; preds = %if.end
  tail call void @__mod_memcg_state(ptr noundef %memcg, i32 noundef 41, i32 noundef %sub) #23
  br label %do.body23.i

if.then21.i:                                      ; preds = %if.end
  tail call void @trace_hardirqs_off() #23
  tail call void @__mod_memcg_state(ptr noundef %memcg, i32 noundef 41, i32 noundef %sub) #23
  tail call void @trace_hardirqs_on() #23
  br label %do.body23.i

do.body23.i:                                      ; preds = %if.then21.i, %do.end11.i
  %1 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i.i = and i32 %1, 128
  %tobool32.not.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool32.not.i, label %if.then36.i, label %mod_memcg_state.exit, !prof !466

if.then36.i:                                      ; preds = %do.body23.i
  tail call void @warn_bogus_irq_restore() #23
  br label %mod_memcg_state.exit

mod_memcg_state.exit:                             ; preds = %if.then36.i, %do.body23.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %0) #23, !srcloc !467
  tail call fastcc void @refill_stock(ptr noundef %memcg, i32 noundef %nr_pages)
  br label %return

return:                                           ; preds = %mod_memcg_state.exit, %if.then
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @page_counter_uncharge(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @refill_stock(ptr noundef %memcg, i32 noundef %nr_pages) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i = and i32 %0, 128
  %tobool.not = icmp eq i32 %and.i, 0
  br i1 %tobool.not, label %if.then, label %do.body12

if.then:                                          ; preds = %entry
  tail call void @trace_hardirqs_off() #23
  br label %do.body12

do.body12:                                        ; preds = %if.then, %entry
  %1 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i70 = and i32 %1, -16384
  %2 = inttoptr i32 %and.i70 to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %2, i32 0, i32 3
  %3 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %cpu, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %4
  %5 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %arrayidx, align 4
  %add = add i32 %6, ptrtoint (ptr @memcg_stock to i32)
  %7 = inttoptr i32 %add to ptr
  %8 = ptrtoint ptr %7 to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %7, align 4
  %cmp18.not = icmp eq ptr %9, %memcg
  br i1 %cmp18.not, label %if.end22, label %if.then20

if.then20:                                        ; preds = %do.body12
  %tobool.not.i = icmp eq ptr %9, null
  br i1 %tobool.not.i, label %drain_stock.exit, label %if.end.i

if.end.i:                                         ; preds = %if.then20
  %nr_pages.i = getelementptr inbounds %struct.memcg_stock_pcp, ptr %7, i32 0, i32 1
  %10 = ptrtoint ptr %nr_pages.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %nr_pages.i, align 4
  %tobool1.not.i = icmp eq i32 %11, 0
  br i1 %tobool1.not.i, label %if.end8.i, label %if.then2.i

if.then2.i:                                       ; preds = %if.end.i
  %memory.i = getelementptr inbounds %struct.mem_cgroup, ptr %9, i32 0, i32 2
  tail call void @page_counter_uncharge(ptr noundef %memory.i, i32 noundef %11) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@refill_stock, %land.rhs.i.i)) #23
          to label %if.end6.i [label %land.rhs.i.i], !srcloc !461

land.rhs.i.i:                                     ; preds = %if.then2.i
  %12 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i = icmp eq i8 %12, 0
  br i1 %tobool4.not.i.i, label %if.then4.i, label %if.end6.i

if.then4.i:                                       ; preds = %land.rhs.i.i
  %13 = getelementptr inbounds %struct.mem_cgroup, ptr %9, i32 0, i32 3
  %14 = ptrtoint ptr %nr_pages.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %nr_pages.i, align 4
  tail call void @page_counter_uncharge(ptr noundef %13, i32 noundef %15) #23
  br label %if.end6.i

if.end6.i:                                        ; preds = %if.then4.i, %land.rhs.i.i, %if.then2.i
  %16 = ptrtoint ptr %nr_pages.i to i32
  call void @__asan_store4_noabort(i32 %16)
  store i32 0, ptr %nr_pages.i, align 4
  br label %if.end8.i

if.end8.i:                                        ; preds = %if.end6.i, %if.end.i
  %flags.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %9, i32 0, i32 7
  %17 = ptrtoint ptr %flags.i.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %flags.i.i, align 4
  %and.i.i = and i32 %18, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.then.i.i, label %css_put.exit.i

if.then.i.i:                                      ; preds = %if.end8.i
  %refcnt.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %9, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i.i) #23
  br label %css_put.exit.i

css_put.exit.i:                                   ; preds = %if.then.i.i, %if.end8.i
  %19 = ptrtoint ptr %7 to i32
  call void @__asan_store4_noabort(i32 %19)
  store ptr null, ptr %7, align 4
  br label %drain_stock.exit

drain_stock.exit:                                 ; preds = %css_put.exit.i, %if.then20
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %memcg, i32 0, i32 7
  %20 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %flags.i, align 4
  %and.i71 = and i32 %21, 1
  %tobool.not.i72 = icmp eq i32 %and.i71, 0
  br i1 %tobool.not.i72, label %if.then.i, label %css_get.exit

if.then.i:                                        ; preds = %drain_stock.exit
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %memcg, i32 0, i32 2
  tail call fastcc void @percpu_ref_get_many(ptr noundef %refcnt.i, i32 noundef 1) #23
  br label %css_get.exit

css_get.exit:                                     ; preds = %if.then.i, %drain_stock.exit
  %22 = ptrtoint ptr %7 to i32
  call void @__asan_store4_noabort(i32 %22)
  store ptr %memcg, ptr %7, align 4
  br label %if.end22

if.end22:                                         ; preds = %css_get.exit, %do.body12
  %nr_pages23 = getelementptr inbounds %struct.memcg_stock_pcp, ptr %7, i32 0, i32 1
  %23 = ptrtoint ptr %nr_pages23 to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %nr_pages23, align 4
  %add24 = add i32 %24, %nr_pages
  store i32 %add24, ptr %nr_pages23, align 4
  %cmp26 = icmp ugt i32 %add24, 32
  br i1 %cmp26, label %if.then28, label %do.body30

if.then28:                                        ; preds = %if.end22
  %25 = ptrtoint ptr %7 to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load ptr, ptr %7, align 4
  %tobool.not.i74 = icmp eq ptr %26, null
  br i1 %tobool.not.i74, label %do.body30, label %if.then2.i79

if.then2.i79:                                     ; preds = %if.then28
  %memory.i78 = getelementptr inbounds %struct.mem_cgroup, ptr %26, i32 0, i32 2
  tail call void @page_counter_uncharge(ptr noundef %memory.i78, i32 noundef %add24) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@refill_stock, %land.rhs.i.i81)) #23
          to label %if.end8.i87 [label %land.rhs.i.i81], !srcloc !461

land.rhs.i.i81:                                   ; preds = %if.then2.i79
  %27 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i80 = icmp eq i8 %27, 0
  br i1 %tobool4.not.i.i80, label %if.then4.i82, label %if.end8.i87

if.then4.i82:                                     ; preds = %land.rhs.i.i81
  %28 = getelementptr inbounds %struct.mem_cgroup, ptr %26, i32 0, i32 3
  %29 = ptrtoint ptr %nr_pages23 to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %nr_pages23, align 4
  tail call void @page_counter_uncharge(ptr noundef %28, i32 noundef %30) #23
  br label %if.end8.i87

if.end8.i87:                                      ; preds = %if.then4.i82, %land.rhs.i.i81, %if.then2.i79
  %31 = ptrtoint ptr %nr_pages23 to i32
  call void @__asan_store4_noabort(i32 %31)
  store i32 0, ptr %nr_pages23, align 4
  %flags.i.i84 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %26, i32 0, i32 7
  %32 = ptrtoint ptr %flags.i.i84 to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %flags.i.i84, align 4
  %and.i.i85 = and i32 %33, 1
  %tobool.not.i.i86 = icmp eq i32 %and.i.i85, 0
  br i1 %tobool.not.i.i86, label %if.then.i.i89, label %css_put.exit.i90

if.then.i.i89:                                    ; preds = %if.end8.i87
  %refcnt.i.i88 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %26, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i.i88) #23
  br label %css_put.exit.i90

css_put.exit.i90:                                 ; preds = %if.then.i.i89, %if.end8.i87
  %34 = ptrtoint ptr %7 to i32
  call void @__asan_store4_noabort(i32 %34)
  store ptr null, ptr %7, align 4
  br label %do.body30

do.body30:                                        ; preds = %css_put.exit.i90, %if.then28, %if.end22
  br i1 %tobool.not, label %if.then39, label %do.body41

if.then39:                                        ; preds = %do.body30
  tail call void @trace_hardirqs_on() #23
  br label %do.body41

do.body41:                                        ; preds = %if.then39, %do.body30
  %35 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i93 = and i32 %35, 128
  %tobool49.not = icmp eq i32 %and.i.i93, 0
  br i1 %tobool49.not, label %if.then53, label %do.end56, !prof !466

if.then53:                                        ; preds = %do.body41
  tail call void @warn_bogus_irq_restore() #23
  br label %do.end56

do.end56:                                         ; preds = %if.then53, %do.body41
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %0) #23, !srcloc !467
  ret void
}

; Function Attrs: cold nounwind null_pointer_is_valid optsize sanitize_address sspstrong uwtable(sync)
define internal i32 @cgroup_memory(ptr noundef %s) #10 section ".init.text" align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %s.addr = alloca ptr, align 4
  %0 = ptrtoint ptr %s.addr to i32
  call void @__asan_store4_noabort(i32 %0)
  store ptr %s, ptr %s.addr, align 4
  %call11 = call ptr @strsep(ptr noundef nonnull %s.addr, ptr noundef nonnull @.str.162) #23
  %cmp.not12 = icmp eq ptr %call11, null
  br i1 %cmp.not12, label %while.end, label %while.body

while.body:                                       ; preds = %while.cond.backedge, %entry
  %call13 = phi ptr [ %call, %while.cond.backedge ], [ %call11, %entry ]
  %1 = ptrtoint ptr %call13 to i32
  call void @__asan_load1_noabort(i32 %1)
  %2 = load i8, ptr %call13, align 1
  %tobool.not = icmp eq i8 %2, 0
  br i1 %tobool.not, label %while.cond.backedge, label %if.end

if.end:                                           ; preds = %while.body
  %call1 = call i32 @strcmp(ptr noundef nonnull %call13, ptr noundef nonnull dereferenceable(9) @.str.163) #28
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i1 true, ptr @cgroup_memory_nosocket, align 1
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %call5 = call i32 @strcmp(ptr noundef nonnull %call13, ptr noundef nonnull dereferenceable(7) @.str.164) #28
  %tobool6.not = icmp eq i32 %call5, 0
  br i1 %tobool6.not, label %if.then7, label %while.cond.backedge

if.then7:                                         ; preds = %if.end4
  store i1 true, ptr @cgroup_memory_nokmem, align 1
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %if.then7, %if.end4, %while.body
  %call = call ptr @strsep(ptr noundef nonnull %s.addr, ptr noundef nonnull @.str.162) #23
  %cmp.not = icmp eq ptr %call, null
  br i1 %cmp.not, label %while.end, label %while.body

while.end:                                        ; preds = %while.cond.backedge, %entry
  ret i32 0
}

; Function Attrs: cold nounwind null_pointer_is_valid optsize sanitize_address sspstrong uwtable(sync)
define internal i32 @mem_cgroup_init() #10 section ".init.text" align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call.i = tail call i32 @__cpuhp_setup_state(i32 noundef 29, ptr noundef nonnull @.str.165, i1 noundef zeroext false, ptr noundef null, ptr noundef nonnull @memcg_hotplug_cpu_dead, i1 noundef zeroext false) #23
  %call174 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_possible_mask) #29
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %0 = load i32, ptr @nr_cpu_ids, align 4
  %cmp75 = icmp ult i32 %call174, %0
  br i1 %cmp75, label %do.body3, label %for.body52

do.body3:                                         ; preds = %do.body3, %entry
  %call176 = phi i32 [ %call1, %do.body3 ], [ %call174, %entry ]
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call176
  %1 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %arrayidx, align 4
  %add = add i32 %2, ptrtoint (ptr @memcg_stock to i32)
  %3 = inttoptr i32 %add to ptr
  %work = getelementptr inbounds %struct.memcg_stock_pcp, ptr %3, i32 0, i32 4
  tail call void @__init_work(ptr noundef %work, i32 noundef 0) #23
  %4 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %arrayidx, align 4
  %add15 = add i32 %5, ptrtoint (ptr @memcg_stock to i32)
  %6 = inttoptr i32 %add15 to ptr
  %work16 = getelementptr inbounds %struct.memcg_stock_pcp, ptr %6, i32 0, i32 4
  %7 = ptrtoint ptr %work16 to i32
  call void @__asan_store4_noabort(i32 %7)
  store i32 -64, ptr %work16, align 4
  %8 = load i32, ptr %arrayidx, align 4
  %add25 = add i32 %8, ptrtoint (ptr @memcg_stock to i32)
  %9 = inttoptr i32 %add25 to ptr
  %lockdep_map = getelementptr inbounds %struct.memcg_stock_pcp, ptr %9, i32 0, i32 4, i32 3
  tail call void @lockdep_init_map_type(ptr noundef %lockdep_map, ptr noundef nonnull @.str.166, ptr noundef nonnull @mem_cgroup_init.__key, i32 noundef 0, i8 noundef zeroext 0, i8 noundef zeroext 0, i8 noundef zeroext 0) #23
  %10 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %arrayidx, align 4
  %add35 = add i32 %11, ptrtoint (ptr @memcg_stock to i32)
  %12 = inttoptr i32 %add35 to ptr
  %entry37 = getelementptr inbounds %struct.memcg_stock_pcp, ptr %12, i32 0, i32 4, i32 1
  %13 = ptrtoint ptr %entry37 to i32
  call void @__asan_store4_noabort(i32 %13)
  store volatile ptr %entry37, ptr %entry37, align 4
  %prev.i = getelementptr inbounds %struct.memcg_stock_pcp, ptr %12, i32 0, i32 4, i32 1, i32 1
  %14 = ptrtoint ptr %prev.i to i32
  call void @__asan_store4_noabort(i32 %14)
  store ptr %entry37, ptr %prev.i, align 4
  %15 = load i32, ptr %arrayidx, align 4
  %add46 = add i32 %15, ptrtoint (ptr @memcg_stock to i32)
  %16 = inttoptr i32 %add46 to ptr
  %func = getelementptr inbounds %struct.memcg_stock_pcp, ptr %16, i32 0, i32 4, i32 2
  %17 = ptrtoint ptr %func to i32
  call void @__asan_store4_noabort(i32 %17)
  store ptr @drain_local_stock, ptr %func, align 4
  %call1 = tail call i32 @cpumask_next(i32 noundef %call176, ptr noundef nonnull @__cpu_possible_mask) #29
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %18 = load i32, ptr @nr_cpu_ids, align 4
  %cmp = icmp ult i32 %call1, %18
  br i1 %cmp, label %do.body3, label %for.body52

for.body52:                                       ; preds = %do.body3, %entry
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 7) to i32))
  %19 = load ptr, ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 7), align 4
  %call.i.i.i = tail call noalias align 8 ptr @kmem_cache_alloc_trace(ptr noundef %19, i32 noundef 3520, i32 noundef 52) #26
  %20 = ptrtoint ptr %call.i.i.i to i32
  call void @__asan_store4_noabort(i32 %20)
  store ptr null, ptr %call.i.i.i, align 8
  %rb_rightmost = getelementptr inbounds %struct.mem_cgroup_tree_per_node, ptr %call.i.i.i, i32 0, i32 1
  %21 = ptrtoint ptr %rb_rightmost to i32
  call void @__asan_store4_noabort(i32 %21)
  store ptr null, ptr %rb_rightmost, align 4
  %lock = getelementptr inbounds %struct.mem_cgroup_tree_per_node, ptr %call.i.i.i, i32 0, i32 2
  tail call void @__raw_spin_lock_init(ptr noundef %lock, ptr noundef nonnull @.str.168, ptr noundef nonnull @mem_cgroup_init.__key.167, i16 noundef signext 3) #23
  store ptr %call.i.i.i, ptr @soft_limit_tree, align 4
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @mem_cgroup_swapout(ptr noundef %page, [1 x i32] %entry.coerce) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = getelementptr inbounds %struct.page, ptr %page, i32 0, i32 1
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %0, align 4
  %and.i.i = and i32 %2, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.end.i.i, label %if.then.i.i, !prof !460

if.then.i.i:                                      ; preds = %entry
  %sub.i.i = add i32 %2, -1
  br label %_compound_head.exit.i

if.end.i.i:                                       ; preds = %entry
  %3 = ptrtoint ptr %page to i32
  br label %_compound_head.exit.i

_compound_head.exit.i:                            ; preds = %if.end.i.i, %if.then.i.i
  %retval.0.i.i = phi i32 [ %sub.i.i, %if.then.i.i ], [ %3, %if.end.i.i ]
  %4 = inttoptr i32 %retval.0.i.i to ptr
  %5 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %4, align 4
  %cmp.i.not.i = icmp eq i32 %6, -1
  %7 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load volatile i32, ptr %0, align 4
  %and.i13.i = and i32 %8, 1
  %tobool.not.i14.i = icmp eq i32 %and.i13.i, 0
  br i1 %cmp.i.not.i, label %if.then.i, label %do.end8.i, !prof !466

if.then.i:                                        ; preds = %_compound_head.exit.i
  br i1 %tobool.not.i14.i, label %if.end.i17.i, label %if.then.i16.i, !prof !460

if.then.i16.i:                                    ; preds = %if.then.i
  %sub.i15.i = add i32 %8, -1
  br label %_compound_head.exit19.i

if.end.i17.i:                                     ; preds = %if.then.i
  %9 = ptrtoint ptr %page to i32
  br label %_compound_head.exit19.i

_compound_head.exit19.i:                          ; preds = %if.end.i17.i, %if.then.i16.i
  %retval.0.i18.i = phi i32 [ %sub.i15.i, %if.then.i16.i ], [ %9, %if.end.i17.i ]
  %10 = inttoptr i32 %retval.0.i18.i to ptr
  tail call void @dump_page(ptr noundef %10, ptr noundef nonnull @.str.169) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 422, 0\0A.popsection", ""() #23, !srcloc !531
  unreachable

do.end8.i:                                        ; preds = %_compound_head.exit.i
  br i1 %tobool.not.i14.i, label %if.end.i24.i, label %if.then.i23.i, !prof !460

if.then.i23.i:                                    ; preds = %do.end8.i
  %sub.i22.i = add i32 %8, -1
  br label %PageLRU.exit

if.end.i24.i:                                     ; preds = %do.end8.i
  %11 = ptrtoint ptr %page to i32
  br label %PageLRU.exit

PageLRU.exit:                                     ; preds = %if.end.i24.i, %if.then.i23.i
  %retval.0.i25.i = phi i32 [ %sub.i22.i, %if.then.i23.i ], [ %11, %if.end.i24.i ]
  %12 = inttoptr i32 %retval.0.i25.i to ptr
  %13 = ptrtoint ptr %12 to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %12, align 4
  %15 = and i32 %14, 16
  %tobool.not = icmp eq i32 %15, 0
  br i1 %tobool.not, label %do.body11, label %if.then, !prof !460

if.then:                                          ; preds = %PageLRU.exit
  tail call void @dump_page(ptr noundef %page, ptr noundef nonnull @.str.44) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 7135, 0\0A.popsection", ""() #23, !srcloc !532
  unreachable

do.body11:                                        ; preds = %PageLRU.exit
  %16 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load volatile i32, ptr %0, align 4
  %and.i.i208 = and i32 %17, 1
  %tobool.not.i.i209 = icmp eq i32 %and.i.i208, 0
  br i1 %tobool.not.i.i209, label %if.end.i.i212, label %if.then.i.i211, !prof !460

if.then.i.i211:                                   ; preds = %do.body11
  %sub.i.i210 = add i32 %17, -1
  br label %page_count.exit

if.end.i.i212:                                    ; preds = %do.body11
  %18 = ptrtoint ptr %page to i32
  br label %page_count.exit

page_count.exit:                                  ; preds = %if.end.i.i212, %if.then.i.i211
  %retval.0.i.i213 = phi i32 [ %sub.i.i210, %if.then.i.i211 ], [ %18, %if.end.i.i212 ]
  %19 = inttoptr i32 %retval.0.i.i213 to ptr
  %_refcount.i.i.i = getelementptr inbounds %struct.page, ptr %19, i32 0, i32 3
  %call.i.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %_refcount.i.i.i, i32 noundef 4) #23
  %20 = ptrtoint ptr %_refcount.i.i.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load volatile i32, ptr %_refcount.i.i.i, align 4
  %tobool13.not = icmp eq i32 %21, 0
  br i1 %tobool13.not, label %do.end29, label %if.then20, !prof !460

if.then20:                                        ; preds = %page_count.exit
  tail call void @dump_page(ptr noundef %page, ptr noundef nonnull @.str.45) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 7136, 0\0A.popsection", ""() #23, !srcloc !533
  unreachable

do.end29:                                         ; preds = %page_count.exit
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_swapout, %cleanup)) #23
          to label %if.end32 [label %cleanup], !srcloc !461

if.end32:                                         ; preds = %do.end29
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_swapout, %if.end44)) #23
          to label %cleanup [label %if.end44], !srcloc !461

if.end44:                                         ; preds = %if.end32
  %22 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %0, align 4
  %and.i.i216 = and i32 %23, 1
  %tobool.not.i.i217 = icmp eq i32 %and.i.i216, 0
  br i1 %tobool.not.i.i217, label %if.end.i.i220, label %if.then.i.i219, !prof !460

if.then.i.i219:                                   ; preds = %if.end44
  %sub.i.i218 = add i32 %23, -1
  br label %page_memcg.exit

if.end.i.i220:                                    ; preds = %if.end44
  %24 = ptrtoint ptr %page to i32
  br label %page_memcg.exit

page_memcg.exit:                                  ; preds = %if.end.i.i220, %if.then.i.i219
  %retval.0.i.i221 = phi i32 [ %sub.i.i218, %if.then.i.i219 ], [ %24, %if.end.i.i220 ]
  %25 = inttoptr i32 %retval.0.i.i221 to ptr
  %call1.i = tail call fastcc ptr @folio_memcg(ptr noundef %25) #23
  %tobool46.not = icmp eq ptr %call1.i, null
  br i1 %tobool46.not, label %land.rhs, label %if.end99

land.rhs:                                         ; preds = %page_memcg.exit
  %.b206 = load i1, ptr @mem_cgroup_swapout.__warned, align 1
  br i1 %.b206, label %cleanup, label %if.then63, !prof !460

if.then63:                                        ; preds = %land.rhs
  tail call void @dump_page(ptr noundef %page, ptr noundef nonnull @.str.46) #23
  store i1 true, ptr @mem_cgroup_swapout.__warned, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 7146, i32 noundef 9, ptr noundef null) #23
  br label %cleanup

if.end99:                                         ; preds = %page_memcg.exit
  %call100 = tail call fastcc ptr @mem_cgroup_id_get_online(ptr noundef nonnull %call1.i)
  %26 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load volatile i32, ptr %0, align 4
  %and.i.i223 = and i32 %27, 1
  %tobool.not.i = icmp eq i32 %and.i.i223, 0
  br i1 %tobool.not.i, label %thp_nr_pages.exit, label %if.then.i224, !prof !460

if.then.i224:                                     ; preds = %if.end99
  tail call void @dump_page(ptr noundef %page, ptr noundef nonnull @.str.96) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/huge_mm.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 347, 0\0A.popsection", ""() #23, !srcloc !534
  unreachable

thp_nr_pages.exit:                                ; preds = %if.end99
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_swapout, %mem_cgroup_id.exit)) #23
          to label %if.end.i [label %mem_cgroup_id.exit], !srcloc !461

if.end.i:                                         ; preds = %thp_nr_pages.exit
  %id.i = getelementptr inbounds %struct.mem_cgroup, ptr %call100, i32 0, i32 1
  %28 = ptrtoint ptr %id.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %id.i, align 8
  %conv.i = trunc i32 %29 to i16
  br label %mem_cgroup_id.exit

mem_cgroup_id.exit:                               ; preds = %if.end.i, %thp_nr_pages.exit
  %retval.0.i225 = phi i16 [ %conv.i, %if.end.i ], [ 0, %thp_nr_pages.exit ]
  %call106 = tail call zeroext i16 @swap_cgroup_record([1 x i32] %entry.coerce, i16 noundef zeroext %retval.0.i225, i32 noundef 1) #23
  %tobool108.not = icmp eq i16 %call106, 0
  br i1 %tobool108.not, label %do.end124, label %if.then115, !prof !460

if.then115:                                       ; preds = %mem_cgroup_id.exit
  tail call void @dump_page(ptr noundef %page, ptr noundef nonnull @.str.47) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 7162, 0\0A.popsection", ""() #23, !srcloc !535
  unreachable

do.end124:                                        ; preds = %mem_cgroup_id.exit
  %30 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i.i226 = and i32 %30, 128
  %tobool.not.i227 = icmp eq i32 %and.i.i226, 0
  br i1 %tobool.not.i227, label %if.then21.i, label %do.end11.i

do.end11.i:                                       ; preds = %do.end124
  tail call void @__mod_memcg_state(ptr noundef %call100, i32 noundef 40, i32 noundef 1) #23
  br label %do.body23.i

if.then21.i:                                      ; preds = %do.end124
  tail call void @trace_hardirqs_off() #23
  tail call void @__mod_memcg_state(ptr noundef %call100, i32 noundef 40, i32 noundef 1) #23
  tail call void @trace_hardirqs_on() #23
  br label %do.body23.i

do.body23.i:                                      ; preds = %if.then21.i, %do.end11.i
  %31 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i.i = and i32 %31, 128
  %tobool32.not.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool32.not.i, label %if.then36.i, label %mod_memcg_state.exit, !prof !466

if.then36.i:                                      ; preds = %do.body23.i
  tail call void @warn_bogus_irq_restore() #23
  br label %mod_memcg_state.exit

mod_memcg_state.exit:                             ; preds = %if.then36.i, %do.body23.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %30) #23, !srcloc !467
  %memcg_data = getelementptr inbounds %struct.page, ptr %page, i32 0, i32 4
  %32 = ptrtoint ptr %memcg_data to i32
  call void @__asan_store4_noabort(i32 %32)
  store i32 0, ptr %memcg_data, align 4
  %33 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i = icmp eq ptr %33, %call1.i
  br i1 %cmp.i, label %if.end127, label %if.then126

if.then126:                                       ; preds = %mod_memcg_state.exit
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %call1.i, i32 0, i32 2
  tail call void @page_counter_uncharge(ptr noundef %memory, i32 noundef 1) #23
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %mod_memcg_state.exit
  %34 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool128.not = icmp ne i8 %34, 0
  %cmp129.not = icmp eq ptr %call1.i, %call100
  %or.cond = select i1 %tobool128.not, i1 true, i1 %cmp129.not
  br i1 %or.cond, label %do.body135, label %if.then130

if.then130:                                       ; preds = %if.end127
  %35 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i228 = icmp eq ptr %35, %call100
  br i1 %cmp.i228, label %if.end133, label %if.then132

if.then132:                                       ; preds = %if.then130
  %36 = getelementptr inbounds %struct.mem_cgroup, ptr %call100, i32 0, i32 3
  tail call void @page_counter_charge(ptr noundef %36, i32 noundef 1) #23
  br label %if.end133

if.end133:                                        ; preds = %if.then132, %if.then130
  %37 = getelementptr inbounds %struct.mem_cgroup, ptr %call1.i, i32 0, i32 3
  tail call void @page_counter_uncharge(ptr noundef %37, i32 noundef 1) #23
  br label %do.body135

do.body135:                                       ; preds = %if.end133, %if.end127
  %38 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i = and i32 %38, 128
  %tobool150.not = icmp eq i32 %and.i, 0
  br i1 %tobool150.not, label %do.body160, label %do.end168, !prof !466

do.body160:                                       ; preds = %do.body135
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 7182, 0\0A.popsection", ""() #23, !srcloc !536
  unreachable

do.end168:                                        ; preds = %do.body135
  tail call void @__count_memcg_events(ptr noundef nonnull %call1.i, i32 noundef 1, i32 noundef 1) #23
  %vmstats_percpu.i = getelementptr inbounds %struct.mem_cgroup, ptr %call1.i, i32 0, i32 39
  %39 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load ptr, ptr %vmstats_percpu.i, align 8
  %nr_page_events.i = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %40, i32 0, i32 4
  %41 = ptrtoint ptr %nr_page_events.i to i32
  %42 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i229 = and i32 %42, -16384
  %43 = inttoptr i32 %and.i.i229 to ptr
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %43, i32 0, i32 3
  %44 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load i32, ptr %cpu.i, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %45
  %46 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %47, %41
  %48 = inttoptr i32 %add.i to ptr
  %49 = ptrtoint ptr %48 to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load i32, ptr %48, align 4
  %add7.i = add i32 %50, 1
  store i32 %add7.i, ptr %48, align 4
  %51 = ptrtoint ptr %page to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load volatile i32, ptr %page, align 4
  %cmp.i.not.i231 = icmp eq i32 %52, -1
  br i1 %cmp.i.not.i231, label %if.then.i232, label %page_to_nid.exit, !prof !466

if.then.i232:                                     ; preds = %do.end168
  tail call void @dump_page(ptr noundef %page, ptr noundef nonnull @.str.170) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/mm.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1368, 0\0A.popsection", ""() #23, !srcloc !469
  unreachable

page_to_nid.exit:                                 ; preds = %do.end168
  %53 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %53)
  %54 = load ptr, ptr %vmstats_percpu.i, align 8
  %nr_page_events.i.i = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %54, i32 0, i32 4
  %55 = ptrtoint ptr %nr_page_events.i.i to i32
  %56 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i234 = and i32 %56, -16384
  %57 = inttoptr i32 %and.i.i.i234 to ptr
  %cpu.i.i = getelementptr inbounds %struct.thread_info, ptr %57, i32 0, i32 3
  %58 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load i32, ptr %cpu.i.i, align 4
  %arrayidx.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %59
  %60 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load i32, ptr %arrayidx.i.i, align 4
  %add.i.i = add i32 %61, %55
  %62 = inttoptr i32 %add.i.i to ptr
  %63 = ptrtoint ptr %62 to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load i32, ptr %62, align 4
  %arrayidx23.i.i = getelementptr %struct.memcg_vmstats_percpu, ptr %54, i32 0, i32 5, i32 0
  %65 = ptrtoint ptr %arrayidx23.i.i to i32
  %add28.i.i = add i32 %61, %65
  %66 = inttoptr i32 %add28.i.i to ptr
  %67 = ptrtoint ptr %66 to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load i32, ptr %66, align 4
  %sub.i.i235 = sub i32 %68, %64
  %cmp.i.i = icmp slt i32 %sub.i.i235, 0
  br i1 %cmp.i.i, label %if.then.i236, label %memcg_check_events.exit

if.then.i236:                                     ; preds = %page_to_nid.exit
  %add30.i.i = add i32 %64, 128
  %69 = ptrtoint ptr %66 to i32
  call void @__asan_store4_noabort(i32 %69)
  store i32 %add30.i.i, ptr %66, align 4
  %70 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %70)
  %71 = load ptr, ptr %vmstats_percpu.i, align 8
  %nr_page_events.i16.i = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %71, i32 0, i32 4
  %72 = ptrtoint ptr %nr_page_events.i16.i to i32
  %73 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i17.i = and i32 %73, -16384
  %74 = inttoptr i32 %and.i.i17.i to ptr
  %cpu.i18.i = getelementptr inbounds %struct.thread_info, ptr %74, i32 0, i32 3
  %75 = ptrtoint ptr %cpu.i18.i to i32
  call void @__asan_load4_noabort(i32 %75)
  %76 = load i32, ptr %cpu.i18.i, align 4
  %arrayidx.i19.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %76
  %77 = ptrtoint ptr %arrayidx.i19.i to i32
  call void @__asan_load4_noabort(i32 %77)
  %78 = load i32, ptr %arrayidx.i19.i, align 4
  %add.i20.i = add i32 %78, %72
  %79 = inttoptr i32 %add.i20.i to ptr
  %80 = ptrtoint ptr %79 to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load i32, ptr %79, align 4
  %arrayidx23.i21.i = getelementptr %struct.memcg_vmstats_percpu, ptr %71, i32 0, i32 5, i32 1
  %82 = ptrtoint ptr %arrayidx23.i21.i to i32
  %add28.i22.i = add i32 %78, %82
  %83 = inttoptr i32 %add28.i22.i to ptr
  %84 = ptrtoint ptr %83 to i32
  call void @__asan_load4_noabort(i32 %84)
  %85 = load i32, ptr %83, align 4
  %sub.i23.i = sub i32 %85, %81
  %cmp.i24.i = icmp slt i32 %sub.i23.i, 0
  br i1 %cmp.i24.i, label %if.then10.i, label %while.body.i247

while.body.i247:                                  ; preds = %if.end.i256, %if.then.i236
  %memcg.addr.06.i246 = phi ptr [ %add.ptr.i.i253, %if.end.i256 ], [ %call1.i, %if.then.i236 ]
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i246, i1 noundef zeroext false) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_swapout, %land.rhs.i.i249)) #23
          to label %if.end.i256 [label %land.rhs.i.i249], !srcloc !461

land.rhs.i.i249:                                  ; preds = %while.body.i247
  %86 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i248 = icmp eq i8 %86, 0
  br i1 %tobool4.not.i.i248, label %if.then.i250, label %if.end.i256

if.then.i250:                                     ; preds = %land.rhs.i.i249
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i246, i1 noundef zeroext true) #23
  br label %if.end.i256

if.end.i256:                                      ; preds = %if.then.i250, %land.rhs.i.i249, %while.body.i247
  %parent.i.i251 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.06.i246, i32 0, i32 2, i32 13
  %87 = ptrtoint ptr %parent.i.i251 to i32
  call void @__asan_load4_noabort(i32 %87)
  %88 = load ptr, ptr %parent.i.i251, align 4
  %tobool.not.i.i252 = icmp eq ptr %88, null
  %add.ptr.i.i253 = getelementptr i8, ptr %88, i32 -176
  %tobool.not7.i254 = icmp eq ptr %add.ptr.i.i253, null
  %tobool.not.i255 = or i1 %tobool.not.i.i252, %tobool.not7.i254
  br i1 %tobool.not.i255, label %memcg_check_events.exit, label %while.body.i247

if.then10.i:                                      ; preds = %if.then.i236
  %add32.i.i = add i32 %81, 1024
  %89 = ptrtoint ptr %83 to i32
  call void @__asan_store4_noabort(i32 %89)
  store i32 %add32.i.i, ptr %83, align 4
  br label %while.body.i

while.body.i:                                     ; preds = %if.end.i244, %if.then10.i
  %memcg.addr.06.i = phi ptr [ %add.ptr.i.i, %if.end.i244 ], [ %call1.i, %if.then10.i ]
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i, i1 noundef zeroext false) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_swapout, %land.rhs.i.i)) #23
          to label %if.end.i244 [label %land.rhs.i.i], !srcloc !461

land.rhs.i.i:                                     ; preds = %while.body.i
  %90 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i = icmp eq i8 %90, 0
  br i1 %tobool4.not.i.i, label %if.then.i241, label %if.end.i244

if.then.i241:                                     ; preds = %land.rhs.i.i
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i, i1 noundef zeroext true) #23
  br label %if.end.i244

if.end.i244:                                      ; preds = %if.then.i241, %land.rhs.i.i, %while.body.i
  %parent.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.06.i, i32 0, i32 2, i32 13
  %91 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %91)
  %92 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i242 = icmp eq ptr %92, null
  %add.ptr.i.i = getelementptr i8, ptr %92, i32 -176
  %tobool.not7.i = icmp eq ptr %add.ptr.i.i, null
  %tobool.not.i243 = or i1 %tobool.not.i.i242, %tobool.not7.i
  br i1 %tobool.not.i243, label %mem_cgroup_threshold.exit, label %while.body.i

mem_cgroup_threshold.exit:                        ; preds = %if.end.i244
  tail call fastcc void @mem_cgroup_update_tree(ptr noundef nonnull %call1.i, i32 noundef 0) #23
  br label %memcg_check_events.exit

memcg_check_events.exit:                          ; preds = %mem_cgroup_threshold.exit, %if.end.i256, %page_to_nid.exit
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call1.i, i32 0, i32 7
  %93 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %93)
  %94 = load i32, ptr %flags.i, align 4
  %and.i237 = and i32 %94, 1
  %tobool.not.i238 = icmp eq i32 %and.i237, 0
  br i1 %tobool.not.i238, label %if.then.i239, label %cleanup

if.then.i239:                                     ; preds = %memcg_check_events.exit
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call1.i, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i) #23
  br label %cleanup

cleanup:                                          ; preds = %if.then.i239, %memcg_check_events.exit, %if.then63, %land.rhs, %if.end32, %do.end29
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc ptr @mem_cgroup_id_get_online(ptr noundef %memcg) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %old.i.i.i = alloca i32, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end47, %entry
  %memcg.addr.0 = phi ptr [ %memcg, %entry ], [ %spec.select, %if.end47 ]
  %ref = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 1, i32 1
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %old.i.i.i) #23
  %call.i.i.i.i.i.i = call zeroext i1 @__kasan_check_read(ptr noundef %ref, i32 noundef 4) #23
  %0 = ptrtoint ptr %ref to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile i32, ptr %ref, align 4
  br label %do.body.i.i.i

do.body.i.i.i:                                    ; preds = %arch_atomic_cmpxchg_relaxed.exit.i.i.i.i.i, %while.cond
  %2 = phi i32 [ %1, %while.cond ], [ %asmresult3.i.i.i.i.i.i, %arch_atomic_cmpxchg_relaxed.exit.i.i.i.i.i ]
  %3 = ptrtoint ptr %old.i.i.i to i32
  call void @__asan_store4_noabort(i32 %3)
  store i32 %2, ptr %old.i.i.i, align 4
  %tobool.not.i.i.i = icmp eq i32 %2, 0
  br i1 %tobool.not.i.i.i, label %if.end4.i.i.i, label %do.cond.i.i.i

do.cond.i.i.i:                                    ; preds = %do.body.i.i.i
  %add.i.i.i = add i32 %2, 1
  %call.i.i.i.i.i = call zeroext i1 @__kasan_check_write(ptr noundef %ref, i32 noundef 4) #23
  %call.i3.i.i.i.i = call zeroext i1 @__kasan_check_write(ptr noundef nonnull %old.i.i.i, i32 noundef 4) #23
  %4 = ptrtoint ptr %old.i.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %old.i.i.i, align 4
  call void @llvm.prefetch.p0(ptr %ref, i32 1, i32 3, i32 1) #23
  br label %do.body.i.i.i.i.i.i

do.body.i.i.i.i.i.i:                              ; preds = %do.body.i.i.i.i.i.i, %do.cond.i.i.i
  %6 = call { i32, i32 } asm sideeffect "@ atomic_cmpxchg\0Aldrex\09$1, [$3]\0Amov\09$0, #0\0Ateq\09$1, $4\0Astrexeq $0, $5, [$3]\0A", "=&r,=&r,=*Qo,r,Ir,r,*Qo,~{cc}"(ptr elementtype(i32) %ref, ptr %ref, i32 %5, i32 %add.i.i.i, ptr elementtype(i32) %ref) #23, !srcloc !537
  %asmresult.i.i.i.i.i.i = extractvalue { i32, i32 } %6, 0
  %tobool.not.i.i.i.i.i.i = icmp eq i32 %asmresult.i.i.i.i.i.i, 0
  br i1 %tobool.not.i.i.i.i.i.i, label %arch_atomic_cmpxchg_relaxed.exit.i.i.i.i.i, label %do.body.i.i.i.i.i.i

arch_atomic_cmpxchg_relaxed.exit.i.i.i.i.i:       ; preds = %do.body.i.i.i.i.i.i
  %asmresult3.i.i.i.i.i.i = extractvalue { i32, i32 } %6, 1
  %cmp.not.i.i.i.i.i = icmp eq i32 %asmresult3.i.i.i.i.i.i, %5
  br i1 %cmp.not.i.i.i.i.i, label %if.end4.i.i.i, label %do.body.i.i.i, !prof !460

if.end4.i.i.i:                                    ; preds = %arch_atomic_cmpxchg_relaxed.exit.i.i.i.i.i, %do.body.i.i.i
  %7 = ptrtoint ptr %old.i.i.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load i32, ptr %old.i.i.i, align 4
  %add5.i.i.i = add i32 %8, 1
  %9 = or i32 %add5.i.i.i, %8
  %.not.i.i.i = icmp sgt i32 %9, -1
  br i1 %.not.i.i.i, label %refcount_inc_not_zero.exit, label %if.then10.i.i.i, !prof !460

if.then10.i.i.i:                                  ; preds = %if.end4.i.i.i
  call void @refcount_warn_saturate(ptr noundef %ref, i32 noundef 0) #23
  %10 = ptrtoint ptr %old.i.i.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %.pr = load i32, ptr %old.i.i.i, align 4
  br label %refcount_inc_not_zero.exit

refcount_inc_not_zero.exit:                       ; preds = %if.then10.i.i.i, %if.end4.i.i.i
  %11 = phi i32 [ %8, %if.end4.i.i.i ], [ %.pr, %if.then10.i.i.i ]
  %tobool12.i.i.i.not = icmp eq i32 %11, 0
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %old.i.i.i) #23
  br i1 %tobool12.i.i.i.not, label %while.body, label %while.end

while.body:                                       ; preds = %refcount_inc_not_zero.exit
  %12 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp = icmp eq ptr %memcg.addr.0, %12
  br i1 %cmp, label %land.rhs, label %if.end47

land.rhs:                                         ; preds = %while.body
  %.b58 = load i1, ptr @mem_cgroup_id_get_online.__already_done, align 1
  br i1 %.b58, label %do.body39, label %if.then, !prof !460

if.then:                                          ; preds = %land.rhs
  store i1 true, ptr @mem_cgroup_id_get_online.__already_done, align 1
  call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 7111, i32 noundef 9, ptr noundef null) #23
  br label %do.body39

do.body39:                                        ; preds = %if.then, %land.rhs
  call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 7112, 0\0A.popsection", ""() #23, !srcloc !538
  unreachable

if.end47:                                         ; preds = %while.body
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 2, i32 13
  %13 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %parent.i, align 4
  %tobool.not.i = icmp eq ptr %14, null
  %add.ptr.i = getelementptr i8, ptr %14, i32 -176
  %tobool49.not60 = icmp eq ptr %add.ptr.i, null
  %tobool49.not = or i1 %tobool.not.i, %tobool49.not60
  %spec.select = select i1 %tobool49.not, ptr %12, ptr %add.ptr.i
  br label %while.cond

while.end:                                        ; preds = %refcount_inc_not_zero.exit
  ret ptr %memcg.addr.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i16 @swap_cgroup_record([1 x i32], i16 noundef zeroext, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @__mem_cgroup_try_charge_swap(ptr noundef %page, [1 x i32] %entry.coerce) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %counter = alloca ptr, align 4
  %entry.coerce.fca.0.extract = extractvalue [1 x i32] %entry.coerce, 0
  %0 = getelementptr inbounds %struct.page, ptr %page, i32 0, i32 1
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %0, align 4
  %and.i.i = and i32 %2, 1
  %tobool.not.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i, label %thp_nr_pages.exit, label %if.then.i, !prof !460

if.then.i:                                        ; preds = %entry
  tail call void @dump_page(ptr noundef %page, ptr noundef nonnull @.str.96) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/huge_mm.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 347, 0\0A.popsection", ""() #23, !srcloc !534
  unreachable

thp_nr_pages.exit:                                ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %counter) #23
  %3 = ptrtoint ptr %counter to i32
  call void @__asan_store4_noabort(i32 %3)
  store ptr inttoptr (i32 -1 to ptr), ptr %counter, align 4, !annotation !492
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@__mem_cgroup_try_charge_swap, %cleanup)) #23
          to label %if.end [label %cleanup], !srcloc !461

if.end:                                           ; preds = %thp_nr_pages.exit
  %4 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %0, align 4
  %and.i.i118 = and i32 %5, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i118, 0
  br i1 %tobool.not.i.i, label %if.end.i.i, label %if.then.i.i, !prof !460

if.then.i.i:                                      ; preds = %if.end
  %sub.i.i = add i32 %5, -1
  br label %page_memcg.exit

if.end.i.i:                                       ; preds = %if.end
  %6 = ptrtoint ptr %page to i32
  br label %page_memcg.exit

page_memcg.exit:                                  ; preds = %if.end.i.i, %if.then.i.i
  %retval.0.i.i = phi i32 [ %sub.i.i, %if.then.i.i ], [ %6, %if.end.i.i ]
  %7 = inttoptr i32 %retval.0.i.i to ptr
  %call1.i = tail call fastcc ptr @folio_memcg(ptr noundef %7) #23
  %tobool8.not = icmp eq ptr %call1.i, null
  br i1 %tobool8.not, label %land.rhs, label %if.end58

land.rhs:                                         ; preds = %page_memcg.exit
  %.b116 = load i1, ptr @__mem_cgroup_try_charge_swap.__warned, align 1
  br i1 %.b116, label %cleanup, label %if.then25, !prof !460

if.then25:                                        ; preds = %land.rhs
  tail call void @dump_page(ptr noundef %page, ptr noundef nonnull @.str.46) #23
  store i1 true, ptr @__mem_cgroup_try_charge_swap.__warned, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 7210, i32 noundef 9, ptr noundef null) #23
  br label %cleanup

if.end58:                                         ; preds = %page_memcg.exit
  %tobool59.not = icmp eq i32 %entry.coerce.fca.0.extract, 0
  br i1 %tobool59.not, label %if.then60, label %if.end61

if.then60:                                        ; preds = %if.end58
  %arrayidx.i = getelementptr %struct.mem_cgroup, ptr %call1.i, i32 0, i32 28, i32 8
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %arrayidx.i, i32 noundef 4) #23
  tail call void @llvm.prefetch.p0(ptr %arrayidx.i, i32 1, i32 3, i32 1) #23
  %8 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %arrayidx.i, ptr %arrayidx.i, i32 1, ptr elementtype(i32) %arrayidx.i) #23, !srcloc !468
  br label %do.body.i

do.body.i:                                        ; preds = %land.rhs.i, %if.then60
  %memcg.addr.0.i = phi ptr [ %call1.i, %if.then60 ], [ %add.ptr.i.i, %land.rhs.i ]
  %arrayidx3.i = getelementptr %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 27, i32 8
  %call.i.i33.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %arrayidx3.i, i32 noundef 4) #23
  tail call void @llvm.prefetch.p0(ptr %arrayidx3.i, i32 1, i32 3, i32 1) #23
  %9 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %arrayidx3.i, ptr %arrayidx3.i, i32 1, ptr elementtype(i32) %arrayidx3.i) #23, !srcloc !468
  %swap_events_file.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 16
  tail call void @cgroup_file_notify(ptr noundef %swap_events_file.i) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@__mem_cgroup_try_charge_swap, %cleanup)) #23
          to label %if.end13.i [label %cleanup], !srcloc !461

if.end13.i:                                       ; preds = %do.body.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7) to i32))
  %10 = load i32, ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7), align 4
  %and.i = and i32 %10, 32
  %tobool14.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool14.not.i, label %do.cond.i, label %cleanup

do.cond.i:                                        ; preds = %if.end13.i
  %parent.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 2, i32 13
  %11 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i119 = icmp eq ptr %12, null
  %add.ptr.i.i = getelementptr i8, ptr %12, i32 -176
  %tobool18.not36.i = icmp eq ptr %add.ptr.i.i, null
  %tobool18.not.i = or i1 %tobool.not.i.i119, %tobool18.not36.i
  br i1 %tobool18.not.i, label %cleanup, label %land.rhs.i

land.rhs.i:                                       ; preds = %do.cond.i
  %13 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i = icmp eq ptr %13, %add.ptr.i.i
  br i1 %cmp.i.i, label %cleanup, label %do.body.i

if.end61:                                         ; preds = %if.end58
  %call62 = tail call fastcc ptr @mem_cgroup_id_get_online(ptr noundef nonnull %call1.i)
  %14 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool63.not = icmp eq i8 %14, 0
  br i1 %tobool63.not, label %land.lhs.true, label %if.end70

land.lhs.true:                                    ; preds = %if.end61
  %15 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i = icmp eq ptr %15, %call62
  br i1 %cmp.i, label %if.end70, label %land.lhs.true65

land.lhs.true65:                                  ; preds = %land.lhs.true
  %16 = getelementptr inbounds %struct.mem_cgroup, ptr %call62, i32 0, i32 3
  %call66 = call zeroext i1 @page_counter_try_charge(ptr noundef %16, i32 noundef 1, ptr noundef nonnull %counter) #23
  br i1 %call66, label %if.end70, label %if.then67

if.then67:                                        ; preds = %land.lhs.true65
  call fastcc void @memcg_memory_event(ptr noundef %call62, i32 noundef 7)
  call fastcc void @memcg_memory_event(ptr noundef %call62, i32 noundef 8)
  call fastcc void @mem_cgroup_id_put_many(ptr noundef %call62, i32 noundef 1) #23
  br label %cleanup

if.end70:                                         ; preds = %land.lhs.true65, %land.lhs.true, %if.end61
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@__mem_cgroup_try_charge_swap, %mem_cgroup_id.exit)) #23
          to label %if.end.i [label %mem_cgroup_id.exit], !srcloc !461

if.end.i:                                         ; preds = %if.end70
  %id.i = getelementptr inbounds %struct.mem_cgroup, ptr %call62, i32 0, i32 1
  %17 = ptrtoint ptr %id.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %id.i, align 8
  %conv.i = trunc i32 %18 to i16
  br label %mem_cgroup_id.exit

mem_cgroup_id.exit:                               ; preds = %if.end.i, %if.end70
  %retval.0.i120 = phi i16 [ %conv.i, %if.end.i ], [ 0, %if.end70 ]
  %call73 = call zeroext i16 @swap_cgroup_record([1 x i32] %entry.coerce, i16 noundef zeroext %retval.0.i120, i32 noundef 1) #23
  %tobool75.not = icmp eq i16 %call73, 0
  br i1 %tobool75.not, label %do.end91, label %if.then82, !prof !460

if.then82:                                        ; preds = %mem_cgroup_id.exit
  call void @dump_page(ptr noundef %page, ptr noundef nonnull @.str.47) #23
  call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 7233, 0\0A.popsection", ""() #23, !srcloc !539
  unreachable

do.end91:                                         ; preds = %mem_cgroup_id.exit
  %19 = call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i.i121 = and i32 %19, 128
  %tobool.not.i122 = icmp eq i32 %and.i.i121, 0
  br i1 %tobool.not.i122, label %if.then21.i, label %do.end11.i

do.end11.i:                                       ; preds = %do.end91
  call void @__mod_memcg_state(ptr noundef %call62, i32 noundef 40, i32 noundef 1) #23
  br label %do.body23.i

if.then21.i:                                      ; preds = %do.end91
  call void @trace_hardirqs_off() #23
  call void @__mod_memcg_state(ptr noundef %call62, i32 noundef 40, i32 noundef 1) #23
  call void @trace_hardirqs_on() #23
  br label %do.body23.i

do.body23.i:                                      ; preds = %if.then21.i, %do.end11.i
  %20 = call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i.i = and i32 %20, 128
  %tobool32.not.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool32.not.i, label %if.then36.i, label %mod_memcg_state.exit, !prof !466

if.then36.i:                                      ; preds = %do.body23.i
  call void @warn_bogus_irq_restore() #23
  br label %mod_memcg_state.exit

mod_memcg_state.exit:                             ; preds = %if.then36.i, %do.body23.i
  call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %19) #23, !srcloc !467
  br label %cleanup

cleanup:                                          ; preds = %mod_memcg_state.exit, %if.then67, %land.rhs.i, %do.cond.i, %if.end13.i, %do.body.i, %if.then25, %land.rhs, %thp_nr_pages.exit
  %retval.0 = phi i32 [ 0, %mod_memcg_state.exit ], [ -12, %if.then67 ], [ 0, %if.then25 ], [ 0, %land.rhs ], [ 0, %do.body.i ], [ 0, %if.end13.i ], [ 0, %do.cond.i ], [ 0, %land.rhs.i ], [ 0, %thp_nr_pages.exit ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %counter) #23
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @memcg_memory_event(ptr noundef %memcg, i32 noundef %event) unnamed_addr #5 align 64 {
entry:
  %event.off = add i32 %event, -6
  %switch = icmp ult i32 %event.off, 3
  %arrayidx = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 28, i32 %event
  %call.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %arrayidx, i32 noundef 4) #23
  tail call void @llvm.prefetch.p0(ptr %arrayidx, i32 1, i32 3, i32 1) #23
  %0 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %arrayidx, ptr %arrayidx, i32 1, ptr elementtype(i32) %arrayidx) #23, !srcloc !468
  br i1 %switch, label %do.body.preheader, label %if.then

if.then:                                          ; preds = %entry
  %events_local_file = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 15
  tail call void @cgroup_file_notify(ptr noundef %events_local_file) #23
  br label %do.body.preheader

do.body.preheader:                                ; preds = %if.then, %entry
  br label %do.body

do.body:                                          ; preds = %land.rhs, %do.body.preheader
  %memcg.addr.0 = phi ptr [ %add.ptr.i, %land.rhs ], [ %memcg, %do.body.preheader ]
  %arrayidx3 = getelementptr %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 27, i32 %event
  %call.i.i33 = tail call zeroext i1 @__kasan_check_write(ptr noundef %arrayidx3, i32 noundef 4) #23
  tail call void @llvm.prefetch.p0(ptr %arrayidx3, i32 1, i32 3, i32 1) #23
  %1 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %arrayidx3, ptr %arrayidx3, i32 1, ptr elementtype(i32) %arrayidx3) #23, !srcloc !468
  %events_file = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 14
  %swap_events_file = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 16
  %events_file.sink = select i1 %switch, ptr %swap_events_file, ptr %events_file
  tail call void @cgroup_file_notify(ptr noundef %events_file.sink) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@memcg_memory_event, %do.end)) #23
          to label %if.end13 [label %do.end], !srcloc !461

if.end13:                                         ; preds = %do.body
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7) to i32))
  %2 = load i32, ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7), align 4
  %and = and i32 %2, 32
  %tobool14.not = icmp eq i32 %and, 0
  br i1 %tobool14.not, label %do.cond, label %do.end

do.cond:                                          ; preds = %if.end13
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 2, i32 13
  %3 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %parent.i, align 4
  %tobool.not.i = icmp eq ptr %4, null
  %add.ptr.i = getelementptr i8, ptr %4, i32 -176
  %tobool18.not36 = icmp eq ptr %add.ptr.i, null
  %tobool18.not = or i1 %tobool.not.i, %tobool18.not36
  br i1 %tobool18.not, label %do.end, label %land.rhs

land.rhs:                                         ; preds = %do.cond
  %5 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i = icmp eq ptr %5, %add.ptr.i
  br i1 %cmp.i, label %do.end, label %do.body

do.end:                                           ; preds = %land.rhs, %do.cond, %if.end13, %do.body
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local void @__mem_cgroup_uncharge_swap([1 x i32] %entry.coerce, i32 noundef %nr_pages) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call zeroext i16 @swap_cgroup_record([1 x i32] %entry.coerce, i16 noundef zeroext 0, i32 noundef %nr_pages) #23
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %3, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %entry
  %call.i25 = tail call i32 @rcu_read_lock_held() #23
  %tobool.not.i26 = icmp eq i32 %call.i25, 0
  br i1 %tobool.not.i26, label %land.rhs.i, label %mem_cgroup_from_id.exit

land.rhs.i:                                       ; preds = %rcu_read_lock.exit
  %.b40.i = load i1, ptr @mem_cgroup_from_id.__already_done, align 1
  br i1 %.b40.i, label %mem_cgroup_from_id.exit, label %if.then.i27, !prof !460

if.then.i27:                                      ; preds = %land.rhs.i
  store i1 true, ptr @mem_cgroup_from_id.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 5063, i32 noundef 9, ptr noundef null) #23
  br label %mem_cgroup_from_id.exit

mem_cgroup_from_id.exit:                          ; preds = %if.then.i27, %land.rhs.i, %rcu_read_lock.exit
  %conv.i = zext i16 %call to i32
  %call37.i = tail call ptr @idr_find(ptr noundef nonnull @mem_cgroup_idr, i32 noundef %conv.i) #23
  %tobool.not = icmp eq ptr %call37.i, null
  br i1 %tobool.not, label %if.end15, label %if.then

if.then:                                          ; preds = %mem_cgroup_from_id.exit
  %4 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool5.not = icmp eq i8 %4, 0
  br i1 %tobool5.not, label %land.lhs.true, label %if.end14

land.lhs.true:                                    ; preds = %if.then
  %5 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i = icmp eq ptr %5, %call37.i
  br i1 %cmp.i, label %if.end14, label %if.then7

if.then7:                                         ; preds = %land.lhs.true
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@__mem_cgroup_uncharge_swap, %if.else)) #23
          to label %if.end14.sink.split [label %if.else], !srcloc !461

if.else:                                          ; preds = %if.then7
  br label %if.end14.sink.split

if.end14.sink.split:                              ; preds = %if.else, %if.then7
  %6 = getelementptr inbounds %struct.mem_cgroup, ptr %call37.i, i32 0, i32 3
  tail call void @page_counter_uncharge(ptr noundef %6, i32 noundef %nr_pages) #23
  br label %if.end14

if.end14:                                         ; preds = %if.end14.sink.split, %land.lhs.true, %if.then
  %sub = sub i32 0, %nr_pages
  %7 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i.i = and i32 %7, 128
  %tobool.not.i28 = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i28, label %if.then21.i, label %do.end11.i

do.end11.i:                                       ; preds = %if.end14
  tail call void @__mod_memcg_state(ptr noundef nonnull %call37.i, i32 noundef 40, i32 noundef %sub) #23
  br label %do.body23.i

if.then21.i:                                      ; preds = %if.end14
  tail call void @trace_hardirqs_off() #23
  tail call void @__mod_memcg_state(ptr noundef nonnull %call37.i, i32 noundef 40, i32 noundef %sub) #23
  tail call void @trace_hardirqs_on() #23
  br label %do.body23.i

do.body23.i:                                      ; preds = %if.then21.i, %do.end11.i
  %8 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i.i = and i32 %8, 128
  %tobool32.not.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool32.not.i, label %if.then36.i, label %mod_memcg_state.exit, !prof !466

if.then36.i:                                      ; preds = %do.body23.i
  tail call void @warn_bogus_irq_restore() #23
  br label %mod_memcg_state.exit

mod_memcg_state.exit:                             ; preds = %if.then36.i, %do.body23.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %7) #23, !srcloc !467
  tail call fastcc void @mem_cgroup_id_put_many(ptr noundef nonnull %call37.i, i32 noundef %nr_pages)
  br label %if.end15

if.end15:                                         ; preds = %mod_memcg_state.exit, %mem_cgroup_from_id.exit
  %call.i29 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i29, label %rcu_read_unlock.exit, label %land.lhs.true.i32

land.lhs.true.i32:                                ; preds = %if.end15
  %call1.i30 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i31 = icmp eq i32 %call1.i30, 0
  br i1 %tobool.not.i31, label %rcu_read_unlock.exit, label %land.lhs.true2.i34

land.lhs.true2.i34:                               ; preds = %land.lhs.true.i32
  %.b4.i33 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i33, label %rcu_read_unlock.exit, label %if.then.i35

if.then.i35:                                      ; preds = %land.lhs.true2.i34
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i35, %land.lhs.true2.i34, %land.lhs.true.i32, %if.end15
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %9 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i36 = and i32 %9, -16384
  %10 = inttoptr i32 %and.i.i.i.i.i36 to ptr
  %preempt_count.i.i.i.i37 = getelementptr inbounds %struct.thread_info, ptr %10, i32 0, i32 1
  %11 = ptrtoint ptr %preempt_count.i.i.i.i37 to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %preempt_count.i.i.i.i37, align 4
  %sub.i.i.i = add i32 %12, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i37, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @mem_cgroup_id_put_many(ptr noundef %memcg, i32 noundef %n) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %ref = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 1, i32 1
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %ref, i32 noundef 4) #23
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !540
  tail call void @llvm.prefetch.p0(ptr %ref, i32 1, i32 3, i32 1) #23
  %0 = tail call { i32, i32, i32 } asm sideeffect "@ atomic_fetch_sub\0A1:\09ldrex\09$0, [$4]\0A\09sub\09$1, $0, $5\0A\09strex\09$2, $1, [$4]\0A\09teq\09$2, #0\0A\09bne\091b", "=&r,=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %ref, ptr %ref, i32 %n, ptr elementtype(i32) %ref) #23, !srcloc !541
  %asmresult.i.i.i.i.i = extractvalue { i32, i32, i32 } %0, 0
  %cmp.i.i = icmp eq i32 %asmresult.i.i.i.i.i, %n
  br i1 %cmp.i.i, label %if.then, label %if.end5.i.i

if.end5.i.i:                                      ; preds = %entry
  %sub.i.i = sub i32 %asmresult.i.i.i.i.i, %n
  %1 = or i32 %sub.i.i, %asmresult.i.i.i.i.i
  %.not.i.i = icmp sgt i32 %1, -1
  br i1 %.not.i.i, label %if.end, label %if.then10.i.i, !prof !460

if.then10.i.i:                                    ; preds = %if.end5.i.i
  tail call void @refcount_warn_saturate(ptr noundef %ref, i32 noundef 3) #23
  br label %if.end

if.then:                                          ; preds = %entry
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !542
  %id.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 1
  %2 = ptrtoint ptr %id.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %id.i, align 8
  %cmp.i = icmp sgt i32 %3, 0
  br i1 %cmp.i, label %if.then.i, label %mem_cgroup_id_remove.exit

if.then.i:                                        ; preds = %if.then
  %call.i = tail call ptr @idr_remove(ptr noundef nonnull @mem_cgroup_idr, i32 noundef %3) #23
  %4 = ptrtoint ptr %id.i to i32
  call void @__asan_store4_noabort(i32 %4)
  store i32 0, ptr %id.i, align 8
  br label %mem_cgroup_id_remove.exit

mem_cgroup_id_remove.exit:                        ; preds = %if.then.i, %if.then
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %memcg, i32 0, i32 7
  %5 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %flags.i, align 4
  %and.i = and i32 %6, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.then.i3, label %if.end

if.then.i3:                                       ; preds = %mem_cgroup_id_remove.exit
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %memcg, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i) #23
  br label %if.end

if.end:                                           ; preds = %if.then.i3, %mem_cgroup_id_remove.exit, %if.then10.i.i, %if.end5.i.i
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local i32 @mem_cgroup_get_nr_swap_pages(ptr noundef %memcg) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @nr_swap_pages, i32 noundef 4) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_swap_pages to i32))
  %0 = load volatile i32, ptr @nr_swap_pages, align 4
  %1 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_get_nr_swap_pages, %cleanup)) #23
          to label %for.cond [label %cleanup], !srcloc !461

for.cond:                                         ; preds = %for.body, %lor.lhs.false
  %nr_swap_pages.0 = phi i32 [ %8, %for.body ], [ %0, %lor.lhs.false ]
  %memcg.addr.0 = phi ptr [ %retval.0.i19, %for.body ], [ %memcg, %lor.lhs.false ]
  %2 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.not = icmp eq ptr %memcg.addr.0, %2
  br i1 %cmp.not, label %cleanup, label %for.body

for.body:                                         ; preds = %for.cond
  %3 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 3
  %max = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 3, i32 0, i32 4
  %4 = ptrtoint ptr %max to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %max, align 8
  %call.i.i.i18 = tail call zeroext i1 @__kasan_check_read(ptr noundef %3, i32 noundef 4) #23
  %6 = ptrtoint ptr %3 to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %3, align 4
  %sub = sub i32 %5, %7
  %8 = tail call i32 @llvm.smin.i32(i32 %nr_swap_pages.0, i32 %sub)
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 2, i32 13
  %9 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load ptr, ptr %parent.i, align 4
  %tobool.not.i = icmp eq ptr %10, null
  %add.ptr.i = getelementptr i8, ptr %10, i32 -176
  %retval.0.i19 = select i1 %tobool.not.i, ptr null, ptr %add.ptr.i
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ %0, %entry ], [ %0, %lor.lhs.false ], [ %nr_swap_pages.0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define dso_local zeroext i1 @mem_cgroup_swap_full(ptr noundef %page) local_unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = getelementptr inbounds %struct.page, ptr %page, i32 0, i32 1
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %0, align 4
  %and.i.i = and i32 %2, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.end.i.i, label %if.then.i.i, !prof !460

if.then.i.i:                                      ; preds = %entry
  %sub.i.i = add i32 %2, -1
  br label %_compound_head.exit.i

if.end.i.i:                                       ; preds = %entry
  %3 = ptrtoint ptr %page to i32
  br label %_compound_head.exit.i

_compound_head.exit.i:                            ; preds = %if.end.i.i, %if.then.i.i
  %retval.0.i.i = phi i32 [ %sub.i.i, %if.then.i.i ], [ %3, %if.end.i.i ]
  %4 = inttoptr i32 %retval.0.i.i to ptr
  %5 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %4, align 4
  %cmp.i.not.i = icmp eq i32 %6, -1
  %7 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load volatile i32, ptr %0, align 4
  %and.i16.i = and i32 %8, 1
  %tobool.not.i17.i = icmp eq i32 %and.i16.i, 0
  br i1 %cmp.i.not.i, label %if.then.i, label %do.end10.i, !prof !466

if.then.i:                                        ; preds = %_compound_head.exit.i
  br i1 %tobool.not.i17.i, label %if.end.i20.i, label %if.then.i19.i, !prof !460

if.then.i19.i:                                    ; preds = %if.then.i
  %sub.i18.i = add i32 %8, -1
  br label %_compound_head.exit22.i

if.end.i20.i:                                     ; preds = %if.then.i
  %9 = ptrtoint ptr %page to i32
  br label %_compound_head.exit22.i

_compound_head.exit22.i:                          ; preds = %if.end.i20.i, %if.then.i19.i
  %retval.0.i21.i = phi i32 [ %sub.i18.i, %if.then.i19.i ], [ %9, %if.end.i20.i ]
  %10 = inttoptr i32 %retval.0.i21.i to ptr
  tail call void @dump_page(ptr noundef %10, ptr noundef nonnull @.str.169) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 414, 0\0A.popsection", ""() #23, !srcloc !543
  unreachable

do.end10.i:                                       ; preds = %_compound_head.exit.i
  br i1 %tobool.not.i17.i, label %if.end.i27.i, label %if.then.i26.i, !prof !460

if.then.i26.i:                                    ; preds = %do.end10.i
  %sub.i25.i = add i32 %8, -1
  br label %PageLocked.exit

if.end.i27.i:                                     ; preds = %do.end10.i
  %11 = ptrtoint ptr %page to i32
  br label %PageLocked.exit

PageLocked.exit:                                  ; preds = %if.end.i27.i, %if.then.i26.i
  %retval.0.i28.i = phi i32 [ %sub.i25.i, %if.then.i26.i ], [ %11, %if.end.i27.i ]
  %12 = inttoptr i32 %retval.0.i28.i to ptr
  %13 = ptrtoint ptr %12 to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %12, align 4
  %and1.i.i = and i32 %14, 1
  %tobool.not = icmp eq i32 %and1.i.i, 0
  br i1 %tobool.not, label %if.then, label %do.end9, !prof !466

if.then:                                          ; preds = %PageLocked.exit
  tail call void @dump_page(ptr noundef %page, ptr noundef nonnull @.str.48) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 7282, 0\0A.popsection", ""() #23, !srcloc !544
  unreachable

do.end9:                                          ; preds = %PageLocked.exit
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @nr_swap_pages, i32 noundef 4) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_swap_pages to i32))
  %15 = load volatile i32, ptr @nr_swap_pages, align 4
  %mul.i = shl i32 %15, 1
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @total_swap_pages to i32))
  %16 = load i32, ptr @total_swap_pages, align 4
  %cmp.i = icmp slt i32 %mul.i, %16
  br i1 %cmp.i, label %cleanup46, label %if.end12

if.end12:                                         ; preds = %do.end9
  %17 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool13.not = icmp eq i8 %17, 0
  br i1 %tobool13.not, label %lor.lhs.false, label %cleanup46

lor.lhs.false:                                    ; preds = %if.end12
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_swap_full, %cleanup46)) #23
          to label %if.end25 [label %cleanup46], !srcloc !461

if.end25:                                         ; preds = %lor.lhs.false
  %18 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load volatile i32, ptr %0, align 4
  %and.i.i55 = and i32 %19, 1
  %tobool.not.i.i56 = icmp eq i32 %and.i.i55, 0
  br i1 %tobool.not.i.i56, label %if.end.i.i59, label %if.then.i.i58, !prof !460

if.then.i.i58:                                    ; preds = %if.end25
  %sub.i.i57 = add i32 %19, -1
  br label %page_memcg.exit

if.end.i.i59:                                     ; preds = %if.end25
  %20 = ptrtoint ptr %page to i32
  br label %page_memcg.exit

page_memcg.exit:                                  ; preds = %if.end.i.i59, %if.then.i.i58
  %retval.0.i.i60 = phi i32 [ %sub.i.i57, %if.then.i.i58 ], [ %20, %if.end.i.i59 ]
  %21 = inttoptr i32 %retval.0.i.i60 to ptr
  %call1.i = tail call fastcc ptr @folio_memcg(ptr noundef %21) #23
  %tobool27.not = icmp eq ptr %call1.i, null
  br i1 %tobool27.not, label %cleanup46, label %for.cond.preheader

for.cond.preheader:                               ; preds = %page_memcg.exit
  %22 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.not65 = icmp eq ptr %call1.i, %22
  br i1 %cmp.not65, label %cleanup46, label %for.body

for.body:                                         ; preds = %for.inc.critedge, %for.cond.preheader
  %memcg.066 = phi ptr [ %retval.0.i63, %for.inc.critedge ], [ %call1.i, %for.cond.preheader ]
  %23 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.066, i32 0, i32 3
  %call.i.i.i62 = tail call zeroext i1 @__kasan_check_read(ptr noundef %23, i32 noundef 4) #23
  %24 = ptrtoint ptr %23 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load volatile i32, ptr %23, align 4
  %mul = shl i32 %25, 1
  %high = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.066, i32 0, i32 3, i32 0, i32 3
  %26 = ptrtoint ptr %high to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load volatile i32, ptr %high, align 4
  %cmp35.not = icmp ult i32 %mul, %27
  br i1 %cmp35.not, label %lor.lhs.false36, label %cleanup46

lor.lhs.false36:                                  ; preds = %for.body
  %max = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.066, i32 0, i32 3, i32 0, i32 4
  %28 = ptrtoint ptr %max to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %max, align 8
  %cmp42.not = icmp ult i32 %mul, %29
  br i1 %cmp42.not, label %for.inc.critedge, label %cleanup46

for.inc.critedge:                                 ; preds = %lor.lhs.false36
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.066, i32 0, i32 2, i32 13
  %30 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %parent.i, align 4
  %tobool.not.i = icmp eq ptr %31, null
  %add.ptr.i = getelementptr i8, ptr %31, i32 -176
  %retval.0.i63 = select i1 %tobool.not.i, ptr null, ptr %add.ptr.i
  %32 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.not = icmp eq ptr %retval.0.i63, %32
  br i1 %cmp.not, label %cleanup46, label %for.body

cleanup46:                                        ; preds = %for.inc.critedge, %lor.lhs.false36, %for.body, %for.cond.preheader, %page_memcg.exit, %lor.lhs.false, %if.end12, %do.end9
  %retval.2 = phi i1 [ true, %do.end9 ], [ false, %if.end12 ], [ false, %page_memcg.exit ], [ false, %lor.lhs.false ], [ false, %for.cond.preheader ], [ true, %for.body ], [ true, %lor.lhs.false36 ], [ false, %for.inc.critedge ]
  ret i1 %retval.2
}

; Function Attrs: cold mustprogress nofree nounwind null_pointer_is_valid optsize sanitize_address sspstrong willreturn uwtable(sync)
define internal i32 @setup_swap_account(ptr nocapture noundef readonly %s) #11 section ".init.text" align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call i32 @strcmp(ptr noundef %s, ptr noundef nonnull dereferenceable(2) @.str.171) #28
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end4.sink.split, label %if.else

if.else:                                          ; preds = %entry
  %call1 = tail call i32 @strcmp(ptr noundef %s, ptr noundef nonnull dereferenceable(2) @.str.172) #28
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4.sink.split, label %if.end4

if.end4.sink.split:                               ; preds = %if.else, %entry
  %.sink = phi i8 [ 0, %entry ], [ 1, %if.else ]
  store i8 %.sink, ptr @cgroup_memory_noswap, align 1
  br label %if.end4

if.end4:                                          ; preds = %if.end4.sink.split, %if.else
  ret i32 1
}

; Function Attrs: cold nounwind null_pointer_is_valid optsize sanitize_address sspstrong uwtable(sync)
define internal i32 @mem_cgroup_swap_init() #10 section ".init.text" align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_swap_init, %if.then)) #23
          to label %if.end [label %if.then], !srcloc !461

if.then:                                          ; preds = %entry
  store i8 1, ptr @cgroup_memory_noswap, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %0 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool.not = icmp eq i8 %0, 0
  br i1 %tobool.not, label %if.end2, label %return

if.end2:                                          ; preds = %if.end
  %call3 = tail call i32 @cgroup_add_dfl_cftypes(ptr noundef nonnull @memory_cgrp_subsys, ptr noundef nonnull @swap_files) #23
  %tobool4.not = icmp eq i32 %call3, 0
  br i1 %tobool4.not, label %if.end19, label %do.end, !prof !460

do.end:                                           ; preds = %if.end2
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 7452, i32 noundef 9, ptr noundef null) #23
  br label %if.end19

if.end19:                                         ; preds = %do.end, %if.end2
  %call27 = tail call i32 @cgroup_add_legacy_cftypes(ptr noundef nonnull @memory_cgrp_subsys, ptr noundef nonnull @memsw_files) #23
  %tobool28.not = icmp eq i32 %call27, 0
  br i1 %tobool28.not, label %return, label %do.end44, !prof !460

do.end44:                                         ; preds = %if.end19
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 7453, i32 noundef 9, ptr noundef null) #23
  br label %return

return:                                           ; preds = %do.end44, %if.end19, %if.end
  ret i32 0
}

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @rcu_lock_acquire(ptr nocapture noundef readnone %map) #5 align 64 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  tail call void @lock_acquire(ptr noundef nonnull @rcu_lock_map, i32 noundef 0, i32 noundef 0, i32 noundef 2, i32 noundef 0, ptr noundef null, i32 noundef ptrtoint (ptr blockaddress(@rcu_lock_acquire, %__here) to i32)) #23
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @rcu_is_watching() local_unnamed_addr #4

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @rcu_lock_release(ptr nocapture noundef readnone %map) #5 align 64 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  tail call void @lock_release(ptr noundef nonnull @rcu_lock_map, i32 noundef ptrtoint (ptr blockaddress(@rcu_lock_release, %__here) to i32)) #23
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @rcu_read_unlock_strict() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @__kasan_check_read(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @_raw_spin_trylock(ptr noundef) local_unnamed_addr #4 section ".spinlock.text"

; Function Attrs: null_pointer_is_valid
declare dso_local void @cgroup_rstat_flush_irqsafe(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind readonly
declare i32 @llvm.read_register.i32(metadata) #12

; Function Attrs: null_pointer_is_valid
declare dso_local void @cgroup_rstat_updated(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @__kasan_check_write(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: inaccessiblemem_or_argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.prefetch.p0(ptr nocapture readonly, i32 immarg, i32 immarg, i32) #13

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @lock_is_held_type(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @percpu_ref_get_many(ptr noundef %ref, i32 noundef %nr) unnamed_addr #5 align 64 {
entry:
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %3, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %entry
  %4 = ptrtoint ptr %ref to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %ref, align 4
  %and.i = and i32 %5, 3
  %tobool.not.i41 = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i41, label %do.body1, label %if.else, !prof !460

do.body1:                                         ; preds = %rcu_read_lock.exit
  %6 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %7 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i42 = and i32 %7, -16384
  %8 = inttoptr i32 %and.i42 to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %8, i32 0, i32 3
  %9 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %cpu, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %10
  %11 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %arrayidx, align 4
  %add = add i32 %12, %5
  %13 = inttoptr i32 %add to ptr
  %14 = ptrtoint ptr %13 to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %13, align 4
  %add15 = add i32 %15, %nr
  store i32 %add15, ptr %13, align 4
  %16 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i = and i32 %16, 128
  %tobool.not = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not, label %if.then29, label %do.end31, !prof !466

if.then29:                                        ; preds = %do.body1
  tail call void @warn_bogus_irq_restore() #23
  br label %do.end31

do.end31:                                         ; preds = %if.then29, %do.body1
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %6) #23, !srcloc !467
  br label %if.end38

if.else:                                          ; preds = %rcu_read_lock.exit
  %data = getelementptr inbounds %struct.percpu_ref, ptr %ref, i32 0, i32 1
  %17 = ptrtoint ptr %data to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %data, align 4
  %call.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %18, i32 noundef 4) #23
  tail call void @llvm.prefetch.p0(ptr %18, i32 1, i32 3, i32 1) #23
  %19 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %18, ptr %18, i32 %nr, ptr elementtype(i32) %18) #23, !srcloc !468
  br label %if.end38

if.end38:                                         ; preds = %if.else, %do.end31
  %call.i43 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i43, label %rcu_read_unlock.exit, label %land.lhs.true.i46

land.lhs.true.i46:                                ; preds = %if.end38
  %call1.i44 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i45 = icmp eq i32 %call1.i44, 0
  br i1 %tobool.not.i45, label %rcu_read_unlock.exit, label %land.lhs.true2.i48

land.lhs.true2.i48:                               ; preds = %land.lhs.true.i46
  %.b4.i47 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i47, label %rcu_read_unlock.exit, label %if.then.i49

if.then.i49:                                      ; preds = %land.lhs.true2.i48
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i49, %land.lhs.true2.i48, %land.lhs.true.i46, %if.end38
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %20 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i50 = and i32 %20, -16384
  %21 = inttoptr i32 %and.i.i.i.i.i50 to ptr
  %preempt_count.i.i.i.i51 = getelementptr inbounds %struct.thread_info, ptr %21, i32 0, i32 1
  %22 = ptrtoint ptr %preempt_count.i.i.i.i51 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %preempt_count.i.i.i.i51, align 4
  %sub.i.i.i = add i32 %23, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i51, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  ret void
}

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc zeroext i1 @percpu_ref_tryget(ptr noundef %ref) unnamed_addr #5 align 64 {
entry:
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i.i.i.i, align 4
  %add.i.i.i.i = add i32 %3, 1
  store volatile i32 %add.i.i.i.i, ptr %preempt_count.i.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i.i, label %rcu_read_lock.exit.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %entry
  %call1.i.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i.i = icmp eq i32 %call1.i.i, 0
  br i1 %tobool.not.i.i, label %rcu_read_lock.exit.i, label %land.lhs.true2.i.i

land.lhs.true2.i.i:                               ; preds = %land.lhs.true.i.i
  %.b4.i.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i.i, label %rcu_read_lock.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true2.i.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit.i

rcu_read_lock.exit.i:                             ; preds = %if.then.i.i, %land.lhs.true2.i.i, %land.lhs.true.i.i, %entry
  %4 = ptrtoint ptr %ref to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %ref, align 4
  %and.i.i = and i32 %5, 3
  %tobool.not.i1.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i1.i, label %do.body1.i, label %if.else.i, !prof !460

do.body1.i:                                       ; preds = %rcu_read_lock.exit.i
  %6 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %7 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i2.i = and i32 %7, -16384
  %8 = inttoptr i32 %and.i2.i to ptr
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %8, i32 0, i32 3
  %9 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %cpu.i, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %10
  %11 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %12, %5
  %13 = inttoptr i32 %add.i to ptr
  %14 = ptrtoint ptr %13 to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %13, align 4
  %add15.i = add i32 %15, 1
  store i32 %add15.i, ptr %13, align 4
  %16 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i.i = and i32 %16, 128
  %tobool.not.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i, label %if.then29.i, label %do.end31.i, !prof !466

if.then29.i:                                      ; preds = %do.body1.i
  tail call void @warn_bogus_irq_restore() #23
  br label %do.end31.i

do.end31.i:                                       ; preds = %if.then29.i, %do.body1.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %6) #23, !srcloc !467
  br label %if.end39.i

if.else.i:                                        ; preds = %rcu_read_lock.exit.i
  %data.i = getelementptr inbounds %struct.percpu_ref, ptr %ref, i32 0, i32 1
  %17 = ptrtoint ptr %data.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %data.i, align 4
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %18, i32 noundef 4) #23
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !523
  tail call void @llvm.prefetch.p0(ptr %18, i32 1, i32 3, i32 1) #23
  %19 = tail call { i32, i32, i32 } asm sideeffect "@ atomic_add_unless\0A1:\09ldrex\09$0, [$4]\0A\09teq\09$0, $5\0A\09beq\092f\0A\09add\09$1, $0, $6\0A\09strex\09$2, $1, [$4]\0A\09teq\09$2, #0\0A\09bne\091b\0A2:", "=&r,=&r,=&r,=*Qo,r,r,r,*Qo,~{cc}"(ptr elementtype(i32) %18, ptr %18, i32 0, i32 1, ptr elementtype(i32) %18) #23, !srcloc !524
  %asmresult.i.i.i.i.i = extractvalue { i32, i32, i32 } %19, 0
  %cmp.not.i.i.i.i.i = icmp eq i32 %asmresult.i.i.i.i.i, 0
  br i1 %cmp.not.i.i.i.i.i, label %atomic_long_add_unless.exit.i, label %do.end11.i.i.i.i.i

do.end11.i.i.i.i.i:                               ; preds = %if.else.i
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !525
  br label %atomic_long_add_unless.exit.i

atomic_long_add_unless.exit.i:                    ; preds = %do.end11.i.i.i.i.i, %if.else.i
  %cmp.i.i.i.i = icmp ne i32 %asmresult.i.i.i.i.i, 0
  br label %if.end39.i

if.end39.i:                                       ; preds = %atomic_long_add_unless.exit.i, %do.end31.i
  %ret.0.off0.i = phi i1 [ true, %do.end31.i ], [ %cmp.i.i.i.i, %atomic_long_add_unless.exit.i ]
  %call.i3.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i3.i, label %percpu_ref_tryget_many.exit, label %land.lhs.true.i6.i

land.lhs.true.i6.i:                               ; preds = %if.end39.i
  %call1.i4.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i5.i = icmp eq i32 %call1.i4.i, 0
  br i1 %tobool.not.i5.i, label %percpu_ref_tryget_many.exit, label %land.lhs.true2.i8.i

land.lhs.true2.i8.i:                              ; preds = %land.lhs.true.i6.i
  %.b4.i7.i = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i7.i, label %percpu_ref_tryget_many.exit, label %if.then.i9.i

if.then.i9.i:                                     ; preds = %land.lhs.true2.i8.i
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %percpu_ref_tryget_many.exit

percpu_ref_tryget_many.exit:                      ; preds = %if.then.i9.i, %land.lhs.true2.i8.i, %land.lhs.true.i6.i, %if.end39.i
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %20 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i10.i = and i32 %20, -16384
  %21 = inttoptr i32 %and.i.i.i.i.i10.i to ptr
  %preempt_count.i.i.i.i11.i = getelementptr inbounds %struct.thread_info, ptr %21, i32 0, i32 1
  %22 = ptrtoint ptr %preempt_count.i.i.i.i11.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %preempt_count.i.i.i.i11.i, align 4
  %sub.i.i.i.i = add i32 %23, -1
  store volatile i32 %sub.i.i.i.i, ptr %preempt_count.i.i.i.i11.i, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  ret i1 %ret.0.off0.i
}

; Function Attrs: inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @percpu_ref_put(ptr noundef %ref) unnamed_addr #5 align 64 {
entry:
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i.i.i.i, align 4
  %add.i.i.i.i = add i32 %3, 1
  store volatile i32 %add.i.i.i.i, ptr %preempt_count.i.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i.i, label %rcu_read_lock.exit.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %entry
  %call1.i.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i.i = icmp eq i32 %call1.i.i, 0
  br i1 %tobool.not.i.i, label %rcu_read_lock.exit.i, label %land.lhs.true2.i.i

land.lhs.true2.i.i:                               ; preds = %land.lhs.true.i.i
  %.b4.i.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i.i, label %rcu_read_lock.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true2.i.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit.i

rcu_read_lock.exit.i:                             ; preds = %if.then.i.i, %land.lhs.true2.i.i, %land.lhs.true.i.i, %entry
  %4 = ptrtoint ptr %ref to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %ref, align 4
  %and.i.i = and i32 %5, 3
  %tobool.not.i1.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i1.i, label %do.body1.i, label %if.else.i, !prof !460

do.body1.i:                                       ; preds = %rcu_read_lock.exit.i
  %6 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %7 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i2.i = and i32 %7, -16384
  %8 = inttoptr i32 %and.i2.i to ptr
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %8, i32 0, i32 3
  %9 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %cpu.i, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %10
  %11 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %arrayidx.i, align 4
  %add.i = add i32 %12, %5
  %13 = inttoptr i32 %add.i to ptr
  %14 = ptrtoint ptr %13 to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %13, align 4
  %add15.i = add i32 %15, -1
  store i32 %add15.i, ptr %13, align 4
  %16 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i.i = and i32 %16, 128
  %tobool.not.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i, label %if.then29.i, label %do.end31.i, !prof !466

if.then29.i:                                      ; preds = %do.body1.i
  tail call void @warn_bogus_irq_restore() #23
  br label %do.end31.i

do.end31.i:                                       ; preds = %if.then29.i, %do.body1.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %6) #23, !srcloc !467
  br label %if.end48.i

if.else.i:                                        ; preds = %rcu_read_lock.exit.i
  %data.i = getelementptr inbounds %struct.percpu_ref, ptr %ref, i32 0, i32 1
  %17 = ptrtoint ptr %data.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %data.i, align 4
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %18, i32 noundef 4) #23
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !545
  tail call void @llvm.prefetch.p0(ptr %18, i32 1, i32 3, i32 1) #23
  %19 = tail call { i32, i32 } asm sideeffect "@ atomic_sub_return\0A1:\09ldrex\09$0, [$3]\0A\09sub\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %18, ptr %18, i32 1, ptr elementtype(i32) %18) #23, !srcloc !546
  %asmresult.i.i.i.i.i.i = extractvalue { i32, i32 } %19, 0
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !547
  %cmp.i.i.i.i = icmp eq i32 %asmresult.i.i.i.i.i.i, 0
  br i1 %cmp.i.i.i.i, label %if.then45.i, label %if.end48.i, !prof !466

if.then45.i:                                      ; preds = %if.else.i
  %20 = ptrtoint ptr %data.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %data.i, align 4
  %release.i = getelementptr inbounds %struct.percpu_ref_data, ptr %21, i32 0, i32 1
  %22 = ptrtoint ptr %release.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %release.i, align 4
  tail call void %23(ptr noundef %ref) #23
  br label %if.end48.i

if.end48.i:                                       ; preds = %if.then45.i, %if.else.i, %do.end31.i
  %call.i3.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i3.i, label %percpu_ref_put_many.exit, label %land.lhs.true.i6.i

land.lhs.true.i6.i:                               ; preds = %if.end48.i
  %call1.i4.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i5.i = icmp eq i32 %call1.i4.i, 0
  br i1 %tobool.not.i5.i, label %percpu_ref_put_many.exit, label %land.lhs.true2.i8.i

land.lhs.true2.i8.i:                              ; preds = %land.lhs.true.i6.i
  %.b4.i7.i = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i7.i, label %percpu_ref_put_many.exit, label %if.then.i9.i

if.then.i9.i:                                     ; preds = %land.lhs.true2.i8.i
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %percpu_ref_put_many.exit

percpu_ref_put_many.exit:                         ; preds = %if.then.i9.i, %land.lhs.true2.i8.i, %land.lhs.true.i6.i, %if.end48.i
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %24 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i10.i = and i32 %24, -16384
  %25 = inttoptr i32 %and.i.i.i.i.i10.i to ptr
  %preempt_count.i.i.i.i11.i = getelementptr inbounds %struct.thread_info, ptr %25, i32 0, i32 1
  %26 = ptrtoint ptr %preempt_count.i.i.i.i11.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load volatile i32, ptr %preempt_count.i.i.i.i11.i, align 4
  %sub.i.i.i.i = add i32 %27, -1
  store volatile i32 %sub.i.i.i.i, ptr %preempt_count.i.i.i.i11.i, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @_raw_spin_lock(ptr noundef) local_unnamed_addr #4 section ".spinlock.text"

; Function Attrs: null_pointer_is_valid
declare dso_local void @_raw_spin_lock_irq(ptr noundef) local_unnamed_addr #4 section ".spinlock.text"

; Function Attrs: null_pointer_is_valid
declare dso_local void @pr_cont_kernfs_path(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @seq_buf_printf(ptr noundef, ptr noundef, ...) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid allocsize(2)
declare dso_local noalias ptr @kmem_cache_alloc_trace(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #14

; Function Attrs: null_pointer_is_valid allocsize(0)
declare dso_local noalias ptr @__kmalloc(i32 noundef, i32 noundef) local_unnamed_addr #15

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.ctlz.i32(i32, i1 immarg) #16

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @autoremove_wake_function(ptr noundef, i32 noundef, i32 noundef, ptr noundef) #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @_raw_spin_unlock(ptr noundef) local_unnamed_addr #4 section ".spinlock.text"

; Function Attrs: nocallback nofree nosync nounwind readnone willreturn
declare ptr @llvm.returnaddress(i32 immarg) #17

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @mutex_lock_killable_nested(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @out_of_memory(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @mutex_unlock(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @__wake_up(ptr noundef, i32 noundef, i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @_raw_spin_unlock_irqrestore(ptr noundef, i32 noundef) local_unnamed_addr #4 section ".spinlock.text"

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @try_to_free_mem_cgroup_pages(ptr noundef, i32 noundef, i32 noundef, i1 noundef zeroext) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @div64_u64(i64 noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare { i32, i1 } @llvm.umul.with.overflow.i32(i32, i32) #16

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @page_address(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc ptr @get_mem_cgroup_from_objcg(ptr noundef %objcg) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %3, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %entry
  %memcg.i = getelementptr inbounds %struct.obj_cgroup, ptr %objcg, i32 0, i32 1
  br label %retry

retry:                                            ; preds = %css_tryget.exit, %rcu_read_lock.exit
  %4 = ptrtoint ptr %memcg.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile ptr, ptr %memcg.i, align 4
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %5, i32 0, i32 7
  %6 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %flags.i, align 4
  %and.i = and i32 %7, 1
  %tobool.not.i5 = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i5, label %css_tryget.exit, label %if.end

css_tryget.exit:                                  ; preds = %retry
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %5, i32 0, i32 2
  %call.i6 = tail call fastcc zeroext i1 @percpu_ref_tryget(ptr noundef %refcnt.i) #23
  br i1 %call.i6, label %if.end, label %retry, !prof !460

if.end:                                           ; preds = %css_tryget.exit, %retry
  %call.i8 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i8, label %rcu_read_unlock.exit, label %land.lhs.true.i11

land.lhs.true.i11:                                ; preds = %if.end
  %call1.i9 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i10 = icmp eq i32 %call1.i9, 0
  br i1 %tobool.not.i10, label %rcu_read_unlock.exit, label %land.lhs.true2.i13

land.lhs.true2.i13:                               ; preds = %land.lhs.true.i11
  %.b4.i12 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i12, label %rcu_read_unlock.exit, label %if.then.i14

if.then.i14:                                      ; preds = %land.lhs.true2.i13
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i14, %land.lhs.true2.i13, %land.lhs.true.i11, %if.end
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %8 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i15 = and i32 %8, -16384
  %9 = inttoptr i32 %and.i.i.i.i.i15 to ptr
  %preempt_count.i.i.i.i16 = getelementptr inbounds %struct.thread_info, ptr %9, i32 0, i32 1
  %10 = ptrtoint ptr %preempt_count.i.i.i.i16 to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %preempt_count.i.i.i.i16, align 4
  %sub.i.i.i = add i32 %11, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i16, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  ret ptr %5
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @try_charge_memcg(ptr noundef %memcg, i32 noundef %gfp_mask, i32 noundef %nr_pages) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %wait.i = alloca %struct.wait_queue_entry, align 4
  %counter = alloca ptr, align 4
  %pflags = alloca i32, align 4
  %0 = tail call i32 @llvm.umax.i32(i32 %nr_pages, i32 32)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %counter) #23
  %1 = ptrtoint ptr %counter to i32
  call void @__asan_store4_noabort(i32 %1)
  store ptr inttoptr (i32 -1 to ptr), ptr %counter, align 4, !annotation !492
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %pflags) #23
  %2 = ptrtoint ptr %pflags to i32
  call void @__asan_store4_noabort(i32 %2)
  store i32 -1, ptr %pflags, align 4, !annotation !492
  %cmp.i195 = icmp ugt i32 %nr_pages, 32
  %3 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 3
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2
  %and = and i32 %gfp_mask, 512
  %tobool.not = icmp eq i32 %and, 0
  %and.i203 = and i32 %gfp_mask, 1024
  %tobool.i204 = icmp ne i32 %and.i203, 0
  %and50 = and i32 %gfp_mask, 65536
  %tobool51.not = icmp eq i32 %and50, 0
  %cmp55 = icmp ult i32 %nr_pages, 9
  %4 = getelementptr inbounds %struct.wait_queue_entry, ptr %wait.i, i32 0, i32 1
  %5 = getelementptr inbounds %struct.wait_queue_entry, ptr %wait.i, i32 0, i32 2
  %6 = getelementptr inbounds %struct.wait_queue_entry, ptr %wait.i, i32 0, i32 3
  %7 = getelementptr inbounds %struct.wait_queue_entry, ptr %wait.i, i32 0, i32 3, i32 1
  %and64 = and i32 %gfp_mask, 16384
  %tobool65.not = icmp eq i32 %and64, 0
  %mul = shl i32 %nr_pages, 12
  %dec.i = add i32 %mul, -1
  %shr.i = lshr i32 %dec.i, 12
  %tobool.not.i.i = icmp eq i32 %dec.i, 4095
  %8 = call i32 @llvm.ctlz.i32(i32 %shr.i, i1 true) #23, !range !548
  %sub.i.i = sub nuw nsw i32 32, %8
  %cond.i.i = select i1 %tobool.not.i.i, i32 0, i32 %sub.i.i
  br label %retry.outer

retry.outer:                                      ; preds = %if.end72, %entry
  %may_swap.0.off0.ph = phi i1 [ %may_swap.1.off0, %if.end72 ], [ true, %entry ]
  %drained.0.off0.ph = phi i1 [ true, %if.end72 ], [ false, %entry ]
  %batch.0.ph = phi i32 [ %batch.0.ph279, %if.end72 ], [ %0, %entry ]
  br label %retry.outer273.outer

retry.outer273.outer:                             ; preds = %if.end60, %retry.outer
  %may_swap.0.off0.ph274.ph = phi i1 [ %may_swap.1.off0, %if.end60 ], [ %may_swap.0.off0.ph, %retry.outer ]
  %drained.0.off0.ph275.ph = phi i1 [ true, %if.end60 ], [ %drained.0.off0.ph, %retry.outer ]
  %nr_retries.0.ph.ph = phi i32 [ %dec, %if.end60 ], [ 16, %retry.outer ]
  %batch.0.ph276.ph = phi i32 [ %batch.0.ph279, %if.end60 ], [ %batch.0.ph, %retry.outer ]
  br label %retry.outer273

retry.outer273:                                   ; preds = %retry.outer273.backedge, %retry.outer273.outer
  %may_swap.0.off0.ph274 = phi i1 [ %may_swap.0.off0.ph274.ph, %retry.outer273.outer ], [ %may_swap.1.off0, %retry.outer273.backedge ]
  %drained.0.off0.ph275 = phi i1 [ %drained.0.off0.ph275.ph, %retry.outer273.outer ], [ true, %retry.outer273.backedge ]
  %batch.0.ph276 = phi i32 [ %batch.0.ph276.ph, %retry.outer273.outer ], [ %batch.0.ph279, %retry.outer273.backedge ]
  br label %retry.outer277

retry.outer277:                                   ; preds = %if.end14, %retry.outer273
  %may_swap.0.off0.ph278 = phi i1 [ %may_swap.0.off0.ph274, %retry.outer273 ], [ %may_swap.1.off0, %if.end14 ]
  %batch.0.ph279 = phi i32 [ %batch.0.ph276, %retry.outer273 ], [ %nr_pages, %if.end14 ]
  %cmp15 = icmp ugt i32 %batch.0.ph279, %nr_pages
  br label %retry

retry:                                            ; preds = %mem_cgroup_margin.exit, %retry.outer277
  %may_swap.0.off0 = phi i1 [ %may_swap.1.off0, %mem_cgroup_margin.exit ], [ %may_swap.0.off0.ph278, %retry.outer277 ]
  br i1 %cmp.i195, label %if.end, label %do.body1.i

do.body1.i:                                       ; preds = %retry
  %9 = call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i.i196 = and i32 %9, 128
  %tobool10.not.i = icmp eq i32 %and.i.i196, 0
  br i1 %tobool10.not.i, label %if.then11.i, label %do.body15.i

if.then11.i:                                      ; preds = %do.body1.i
  call void @trace_hardirqs_off() #23
  br label %do.body15.i

do.body15.i:                                      ; preds = %if.then11.i, %do.body1.i
  %10 = call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i70.i = and i32 %10, -16384
  %11 = inttoptr i32 %and.i70.i to ptr
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %11, i32 0, i32 3
  %12 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %cpu.i, align 4
  %arrayidx.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %13
  %14 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %arrayidx.i, align 4
  %add.i197 = add i32 %15, ptrtoint (ptr @memcg_stock to i32)
  %16 = inttoptr i32 %add.i197 to ptr
  %17 = ptrtoint ptr %16 to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load ptr, ptr %16, align 4
  %cmp21.i = icmp eq ptr %18, %memcg
  br i1 %cmp21.i, label %land.lhs.true.i, label %do.body29.i

land.lhs.true.i:                                  ; preds = %do.body15.i
  %nr_pages23.i = getelementptr inbounds %struct.memcg_stock_pcp, ptr %16, i32 0, i32 1
  %19 = ptrtoint ptr %nr_pages23.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %nr_pages23.i, align 4
  %cmp24.not.i = icmp ult i32 %20, %nr_pages
  br i1 %cmp24.not.i, label %do.body29.i, label %if.then26.i

if.then26.i:                                      ; preds = %land.lhs.true.i
  %sub.i198 = sub i32 %20, %nr_pages
  %21 = ptrtoint ptr %nr_pages23.i to i32
  call void @__asan_store4_noabort(i32 %21)
  store i32 %sub.i198, ptr %nr_pages23.i, align 4
  br label %do.body29.i

do.body29.i:                                      ; preds = %if.then26.i, %land.lhs.true.i, %do.body15.i
  %ret.0.off0.i = phi i1 [ true, %if.then26.i ], [ false, %land.lhs.true.i ], [ false, %do.body15.i ]
  br i1 %tobool10.not.i, label %if.then38.i, label %do.body40.i

if.then38.i:                                      ; preds = %do.body29.i
  call void @trace_hardirqs_on() #23
  br label %do.body40.i

do.body40.i:                                      ; preds = %if.then38.i, %do.body29.i
  %22 = call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i.i = and i32 %22, 128
  %tobool48.not.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool48.not.i, label %if.then52.i, label %consume_stock.exit, !prof !466

if.then52.i:                                      ; preds = %do.body40.i
  call void @warn_bogus_irq_restore() #23
  br label %consume_stock.exit

consume_stock.exit:                               ; preds = %if.then52.i, %do.body40.i
  call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %9) #23, !srcloc !467
  br i1 %ret.0.off0.i, label %cleanup131, label %if.end

if.end:                                           ; preds = %consume_stock.exit, %retry
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@try_charge_memcg, %land.rhs.i)) #23
          to label %if.then3 [label %land.rhs.i], !srcloc !461

land.rhs.i:                                       ; preds = %if.end
  %23 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i = icmp eq i8 %23, 0
  br i1 %tobool4.not.i, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %land.rhs.i
  %call2 = call zeroext i1 @page_counter_try_charge(ptr noundef %3, i32 noundef %batch.0.ph279, ptr noundef nonnull %counter) #23
  br i1 %call2, label %if.then3, label %if.else

if.then3:                                         ; preds = %lor.lhs.false, %land.rhs.i, %if.end
  %call4 = call zeroext i1 @page_counter_try_charge(ptr noundef %memory, i32 noundef %batch.0.ph279, ptr noundef nonnull %counter) #23
  br i1 %call4, label %done_restock, label %if.end6

if.end6:                                          ; preds = %if.then3
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@try_charge_memcg, %land.rhs.i201)) #23
          to label %if.end9 [label %land.rhs.i201], !srcloc !461

land.rhs.i201:                                    ; preds = %if.end6
  %24 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i200 = icmp eq i8 %24, 0
  br i1 %tobool4.not.i200, label %if.then8, label %if.end9

if.then8:                                         ; preds = %land.rhs.i201
  call void @page_counter_uncharge(ptr noundef %3, i32 noundef %batch.0.ph279) #23
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %land.rhs.i201, %if.end6
  %25 = ptrtoint ptr %counter to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load ptr, ptr %counter, align 4
  %add.ptr = getelementptr i8, ptr %26, i32 -176
  br label %if.end14

if.else:                                          ; preds = %lor.lhs.false
  %27 = ptrtoint ptr %counter to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %counter, align 4
  %add.ptr13 = getelementptr i8, ptr %28, i32 -232
  br label %if.end14

if.end14:                                         ; preds = %if.else, %if.end9
  %mem_over_limit.0 = phi ptr [ %add.ptr, %if.end9 ], [ %add.ptr13, %if.else ]
  %may_swap.1.off0 = phi i1 [ %may_swap.0.off0, %if.end9 ], [ false, %if.else ]
  br i1 %cmp15, label %retry.outer277, label %if.end17

if.end17:                                         ; preds = %if.end14
  br i1 %tobool.not, label %if.end19, label %force

if.end19:                                         ; preds = %if.end17
  %29 = call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i = and i32 %29, -16384
  %30 = inttoptr i32 %and.i to ptr
  %task = getelementptr inbounds %struct.thread_info, ptr %30, i32 0, i32 2
  %31 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %task, align 8
  %flags = getelementptr inbounds %struct.task_struct, ptr %32, i32 0, i32 3
  %33 = ptrtoint ptr %flags to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load i32, ptr %flags, align 4
  %and21 = and i32 %34, 2048
  %tobool22.not = icmp eq i32 %and21, 0
  br i1 %tobool22.not, label %if.end26, label %force, !prof !460

if.end26:                                         ; preds = %if.end19
  %memcg_in_oom.i = getelementptr inbounds %struct.task_struct, ptr %32, i32 0, i32 202
  %35 = ptrtoint ptr %memcg_in_oom.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load ptr, ptr %memcg_in_oom.i, align 8
  %tobool.i = icmp eq ptr %36, null
  %or.cond241 = and i1 %tobool.i204, %tobool.i
  br i1 %or.cond241, label %if.end40, label %nomem, !prof !549

if.end40:                                         ; preds = %if.end26
  %arrayidx.i205 = getelementptr %struct.mem_cgroup, ptr %mem_over_limit.0, i32 0, i32 28, i32 2
  %call.i.i.i = call zeroext i1 @__kasan_check_write(ptr noundef %arrayidx.i205, i32 noundef 4) #23
  call void @llvm.prefetch.p0(ptr %arrayidx.i205, i32 1, i32 3, i32 1) #23
  %37 = call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %arrayidx.i205, ptr %arrayidx.i205, i32 1, ptr elementtype(i32) %arrayidx.i205) #23, !srcloc !468
  %events_local_file.i = getelementptr inbounds %struct.mem_cgroup, ptr %mem_over_limit.0, i32 0, i32 15
  call void @cgroup_file_notify(ptr noundef %events_local_file.i) #23
  br label %do.body.i

do.body.i:                                        ; preds = %land.rhs.i210, %if.end40
  %memcg.addr.0.i = phi ptr [ %mem_over_limit.0, %if.end40 ], [ %add.ptr.i.i, %land.rhs.i210 ]
  %arrayidx3.i = getelementptr %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 27, i32 2
  %call.i.i33.i = call zeroext i1 @__kasan_check_write(ptr noundef %arrayidx3.i, i32 noundef 4) #23
  call void @llvm.prefetch.p0(ptr %arrayidx3.i, i32 1, i32 3, i32 1) #23
  %38 = call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %arrayidx3.i, ptr %arrayidx3.i, i32 1, ptr elementtype(i32) %arrayidx3.i) #23, !srcloc !468
  %events_file.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 14
  call void @cgroup_file_notify(ptr noundef %events_file.i) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@try_charge_memcg, %memcg_memory_event.exit)) #23
          to label %if.end13.i [label %memcg_memory_event.exit], !srcloc !461

if.end13.i:                                       ; preds = %do.body.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7) to i32))
  %39 = load i32, ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7), align 4
  %and.i208 = and i32 %39, 32
  %tobool14.not.i = icmp eq i32 %and.i208, 0
  br i1 %tobool14.not.i, label %do.cond.i, label %memcg_memory_event.exit

do.cond.i:                                        ; preds = %if.end13.i
  %parent.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 2, i32 13
  %40 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i209 = icmp eq ptr %41, null
  %add.ptr.i.i = getelementptr i8, ptr %41, i32 -176
  %tobool18.not36.i = icmp eq ptr %add.ptr.i.i, null
  %tobool18.not.i = or i1 %tobool.not.i.i209, %tobool18.not36.i
  br i1 %tobool18.not.i, label %memcg_memory_event.exit, label %land.rhs.i210

land.rhs.i210:                                    ; preds = %do.cond.i
  %42 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i = icmp eq ptr %42, %add.ptr.i.i
  br i1 %cmp.i.i, label %memcg_memory_event.exit, label %do.body.i

memcg_memory_event.exit:                          ; preds = %land.rhs.i210, %do.cond.i, %if.end13.i, %do.body.i
  call void @psi_memstall_enter(ptr noundef nonnull %pflags) #23
  %call42 = call i32 @try_to_free_mem_cgroup_pages(ptr noundef %mem_over_limit.0, i32 noundef %nr_pages, i32 noundef %gfp_mask, i1 noundef zeroext %may_swap.1.off0) #23
  call void @psi_memstall_leave(ptr noundef nonnull %pflags) #23
  %memory.i = getelementptr inbounds %struct.mem_cgroup, ptr %mem_over_limit.0, i32 0, i32 2
  %call.i.i.i.i = call zeroext i1 @__kasan_check_read(ptr noundef %memory.i, i32 noundef 4) #23
  %43 = ptrtoint ptr %memory.i to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load volatile i32, ptr %memory.i, align 4
  %max.i = getelementptr inbounds %struct.mem_cgroup, ptr %mem_over_limit.0, i32 0, i32 2, i32 4
  %45 = ptrtoint ptr %max.i to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load volatile i32, ptr %max.i, align 16
  %47 = call i32 @llvm.usub.sat.i32(i32 %46, i32 %44) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@try_charge_memcg, %land.rhs.i.i)) #23
          to label %mem_cgroup_margin.exit [label %land.rhs.i.i], !srcloc !461

land.rhs.i.i:                                     ; preds = %memcg_memory_event.exit
  %48 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i = icmp eq i8 %48, 0
  br i1 %tobool4.not.i.i, label %if.then3.i, label %mem_cgroup_margin.exit

if.then3.i:                                       ; preds = %land.rhs.i.i
  %49 = getelementptr inbounds %struct.mem_cgroup, ptr %mem_over_limit.0, i32 0, i32 3
  %call.i.i.i30.i = call zeroext i1 @__kasan_check_read(ptr noundef %49, i32 noundef 4) #23
  %50 = ptrtoint ptr %49 to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load volatile i32, ptr %49, align 4
  %max9.i = getelementptr inbounds %struct.mem_cgroup, ptr %mem_over_limit.0, i32 0, i32 3, i32 0, i32 4
  %52 = ptrtoint ptr %max9.i to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load volatile i32, ptr %max9.i, align 8
  %cmp10.i = icmp ugt i32 %53, %51
  br i1 %cmp10.i, label %if.then11.i211, label %mem_cgroup_margin.exit

if.then11.i211:                                   ; preds = %if.then3.i
  %sub12.i = sub i32 %53, %51
  %54 = call i32 @llvm.umin.i32(i32 %47, i32 %sub12.i) #23
  br label %mem_cgroup_margin.exit

mem_cgroup_margin.exit:                           ; preds = %if.then11.i211, %if.then3.i, %land.rhs.i.i, %memcg_memory_event.exit
  %margin.1.i = phi i32 [ %54, %if.then11.i211 ], [ 0, %if.then3.i ], [ %47, %land.rhs.i.i ], [ %47, %memcg_memory_event.exit ]
  %cmp44.not = icmp ult i32 %margin.1.i, %nr_pages
  br i1 %cmp44.not, label %if.end46, label %retry

if.end46:                                         ; preds = %mem_cgroup_margin.exit
  br i1 %drained.0.off0.ph275, label %if.end49, label %if.then48

if.then48:                                        ; preds = %if.end46
  call fastcc void @drain_all_stock(ptr noundef %mem_over_limit.0)
  br label %retry.outer273.backedge

if.end49:                                         ; preds = %if.end46
  br i1 %tobool51.not, label %if.end53, label %nomem

if.end53:                                         ; preds = %if.end49
  %tobool54.not = icmp ne i32 %call42, 0
  %or.cond = and i1 %cmp55, %tobool54.not
  br i1 %or.cond, label %retry.outer273.backedge, label %if.end57

if.end57:                                         ; preds = %if.end53
  %55 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 8), align 4
  %tobool.not.i212 = icmp eq ptr %55, null
  br i1 %tobool.not.i212, label %if.end60, label %land.lhs.true.i214

land.lhs.true.i214:                               ; preds = %if.end57
  %56 = call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i213 = and i32 %56, -16384
  %57 = inttoptr i32 %and.i.i213 to ptr
  %task.i = getelementptr inbounds %struct.thread_info, ptr %57, i32 0, i32 2
  %58 = ptrtoint ptr %task.i to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load ptr, ptr %task.i, align 8
  %cmp.not.i = icmp eq ptr %59, %55
  br i1 %cmp.not.i, label %if.end60, label %if.then.i216

if.then.i216:                                     ; preds = %land.lhs.true.i214
  call void @_raw_spin_lock(ptr noundef nonnull @mc) #23
  %60 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 2), align 4
  %61 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 3), align 4
  %tobool.not.i.i215 = icmp eq ptr %60, null
  br i1 %tobool.not.i.i215, label %mem_cgroup_under_move.exit.thread14.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i216
  %cmp.i.i.i = icmp eq ptr %60, %mem_over_limit.0
  br i1 %cmp.i.i.i, label %mem_cgroup_under_move.exit.thread.i, label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %if.end.i.i
  %62 = ptrtoint ptr %60 to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load ptr, ptr %60, align 128
  %64 = ptrtoint ptr %mem_over_limit.0 to i32
  call void @__asan_load4_noabort(i32 %64)
  %65 = load ptr, ptr %mem_over_limit.0, align 128
  %root.i.i.i.i = getelementptr inbounds %struct.cgroup, ptr %63, i32 0, i32 19
  %66 = ptrtoint ptr %root.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %66)
  %67 = load ptr, ptr %root.i.i.i.i, align 4
  %root1.i.i.i.i = getelementptr inbounds %struct.cgroup, ptr %65, i32 0, i32 19
  %68 = ptrtoint ptr %root1.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load ptr, ptr %root1.i.i.i.i, align 4
  %cmp.not.i.i.i.i = icmp eq ptr %67, %69
  br i1 %cmp.not.i.i.i.i, label %lor.lhs.false.i.i.i.i, label %lor.rhs.i.i

lor.lhs.false.i.i.i.i:                            ; preds = %if.end.i.i.i
  %level.i.i.i.i = getelementptr inbounds %struct.cgroup, ptr %63, i32 0, i32 2
  %70 = ptrtoint ptr %level.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %70)
  %71 = load i32, ptr %level.i.i.i.i, align 4
  %level2.i.i.i.i = getelementptr inbounds %struct.cgroup, ptr %65, i32 0, i32 2
  %72 = ptrtoint ptr %level2.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %72)
  %73 = load i32, ptr %level2.i.i.i.i, align 4
  %cmp3.i.i.i.i = icmp slt i32 %71, %73
  br i1 %cmp3.i.i.i.i, label %lor.rhs.i.i, label %mem_cgroup_is_descendant.exit.i.i

mem_cgroup_is_descendant.exit.i.i:                ; preds = %lor.lhs.false.i.i.i.i
  %arrayidx.i.i.i.i = getelementptr %struct.cgroup, ptr %63, i32 0, i32 37, i32 %73
  %74 = ptrtoint ptr %arrayidx.i.i.i.i to i32
  call void @__asan_load8_noabort(i32 %74)
  %75 = load i64, ptr %arrayidx.i.i.i.i, align 8
  %kn.i.i.i.i.i = getelementptr inbounds %struct.cgroup, ptr %65, i32 0, i32 11
  %76 = ptrtoint ptr %kn.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %76)
  %77 = load ptr, ptr %kn.i.i.i.i.i, align 8
  %id.i.i.i.i.i = getelementptr inbounds %struct.kernfs_node, ptr %77, i32 0, i32 10
  %78 = ptrtoint ptr %id.i.i.i.i.i to i32
  call void @__asan_load8_noabort(i32 %78)
  %79 = load i64, ptr %id.i.i.i.i.i, align 8
  %cmp5.i.i.i.i = icmp eq i64 %75, %79
  %cmp.i5.i.i = icmp eq ptr %61, %mem_over_limit.0
  %or.cond.i.i = select i1 %cmp5.i.i.i.i, i1 true, i1 %cmp.i5.i.i
  br i1 %or.cond.i.i, label %mem_cgroup_under_move.exit.thread.i, label %if.end.i9.i.i

lor.rhs.i.i:                                      ; preds = %lor.lhs.false.i.i.i.i, %if.end.i.i.i
  %cmp.i5.old.i.i = icmp eq ptr %61, %mem_over_limit.0
  br i1 %cmp.i5.old.i.i, label %mem_cgroup_under_move.exit.thread.i, label %if.end.i9.i.i

if.end.i9.i.i:                                    ; preds = %lor.rhs.i.i, %mem_cgroup_is_descendant.exit.i.i
  %80 = ptrtoint ptr %61 to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load ptr, ptr %61, align 128
  %root.i.i6.i.i = getelementptr inbounds %struct.cgroup, ptr %81, i32 0, i32 19
  %82 = ptrtoint ptr %root.i.i6.i.i to i32
  call void @__asan_load4_noabort(i32 %82)
  %83 = load ptr, ptr %root.i.i6.i.i, align 4
  %cmp.not.i.i8.i.i = icmp eq ptr %83, %69
  br i1 %cmp.not.i.i8.i.i, label %lor.lhs.false.i.i13.i.i, label %mem_cgroup_under_move.exit.thread14.i

lor.lhs.false.i.i13.i.i:                          ; preds = %if.end.i9.i.i
  %level.i.i10.i.i = getelementptr inbounds %struct.cgroup, ptr %81, i32 0, i32 2
  %84 = ptrtoint ptr %level.i.i10.i.i to i32
  call void @__asan_load4_noabort(i32 %84)
  %85 = load i32, ptr %level.i.i10.i.i, align 4
  %level2.i.i11.i.i = getelementptr inbounds %struct.cgroup, ptr %65, i32 0, i32 2
  %86 = ptrtoint ptr %level2.i.i11.i.i to i32
  call void @__asan_load4_noabort(i32 %86)
  %87 = load i32, ptr %level2.i.i11.i.i, align 4
  %cmp3.i.i12.i.i = icmp slt i32 %85, %87
  br i1 %cmp3.i.i12.i.i, label %mem_cgroup_under_move.exit.thread14.i, label %mem_cgroup_under_move.exit.i

mem_cgroup_under_move.exit.thread.i:              ; preds = %lor.rhs.i.i, %mem_cgroup_is_descendant.exit.i.i, %if.end.i.i
  call void @_raw_spin_unlock(ptr noundef nonnull @mc) #23
  br label %if.then2.i

mem_cgroup_under_move.exit.thread14.i:            ; preds = %lor.lhs.false.i.i13.i.i, %if.end.i9.i.i, %if.then.i216
  call void @_raw_spin_unlock(ptr noundef nonnull @mc) #23
  br label %if.end60

mem_cgroup_under_move.exit.i:                     ; preds = %lor.lhs.false.i.i13.i.i
  %arrayidx.i.i14.i.i = getelementptr %struct.cgroup, ptr %81, i32 0, i32 37, i32 %87
  %88 = ptrtoint ptr %arrayidx.i.i14.i.i to i32
  call void @__asan_load8_noabort(i32 %88)
  %89 = load i64, ptr %arrayidx.i.i14.i.i, align 8
  %kn.i.i.i15.i.i = getelementptr inbounds %struct.cgroup, ptr %65, i32 0, i32 11
  %90 = ptrtoint ptr %kn.i.i.i15.i.i to i32
  call void @__asan_load4_noabort(i32 %90)
  %91 = load ptr, ptr %kn.i.i.i15.i.i, align 8
  %id.i.i.i16.i.i = getelementptr inbounds %struct.kernfs_node, ptr %91, i32 0, i32 10
  %92 = ptrtoint ptr %id.i.i.i16.i.i to i32
  call void @__asan_load8_noabort(i32 %92)
  %93 = load i64, ptr %id.i.i.i16.i.i, align 8
  %cmp5.i.i17.i.i = icmp eq i64 %89, %93
  call void @_raw_spin_unlock(ptr noundef nonnull @mc) #23
  br i1 %cmp5.i.i17.i.i, label %if.then2.i, label %if.end60

if.then2.i:                                       ; preds = %mem_cgroup_under_move.exit.i, %mem_cgroup_under_move.exit.thread.i
  call void @llvm.lifetime.start.p0(i64 20, ptr nonnull %wait.i) #23
  %94 = ptrtoint ptr %wait.i to i32
  call void @__asan_store4_noabort(i32 %94)
  store i32 0, ptr %wait.i, align 4
  %95 = ptrtoint ptr %task.i to i32
  call void @__asan_load4_noabort(i32 %95)
  %96 = load ptr, ptr %task.i, align 8
  %97 = ptrtoint ptr %4 to i32
  call void @__asan_store4_noabort(i32 %97)
  store ptr %96, ptr %4, align 4
  %98 = ptrtoint ptr %5 to i32
  call void @__asan_store4_noabort(i32 %98)
  store ptr @autoremove_wake_function, ptr %5, align 4
  %99 = ptrtoint ptr %6 to i32
  call void @__asan_store4_noabort(i32 %99)
  store ptr %6, ptr %6, align 4
  %100 = ptrtoint ptr %7 to i32
  call void @__asan_store4_noabort(i32 %100)
  store ptr %6, ptr %7, align 4
  call void @prepare_to_wait(ptr noundef getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 9), ptr noundef nonnull %wait.i, i32 noundef 1) #23
  %101 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 8), align 4
  %tobool8.not.i = icmp eq ptr %101, null
  br i1 %tobool8.not.i, label %mem_cgroup_wait_acct_move.exit, label %if.then9.i

if.then9.i:                                       ; preds = %if.then2.i
  call void @schedule() #23
  br label %mem_cgroup_wait_acct_move.exit

mem_cgroup_wait_acct_move.exit:                   ; preds = %if.then9.i, %if.then2.i
  call void @finish_wait(ptr noundef getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 9), ptr noundef nonnull %wait.i) #23
  call void @llvm.lifetime.end.p0(i64 20, ptr nonnull %wait.i) #23
  br label %retry.outer273.backedge

retry.outer273.backedge:                          ; preds = %mem_cgroup_wait_acct_move.exit, %if.end53, %if.then48
  br label %retry.outer273

if.end60:                                         ; preds = %mem_cgroup_under_move.exit.i, %mem_cgroup_under_move.exit.thread14.i, %land.lhs.true.i214, %if.end57
  %dec = add i32 %nr_retries.0.ph.ph, -1
  %tobool61.not = icmp eq i32 %nr_retries.0.ph.ph, 0
  br i1 %tobool61.not, label %if.end63, label %retry.outer273.outer

if.end63:                                         ; preds = %if.end60
  br i1 %tobool65.not, label %if.end67, label %nomem

if.end67:                                         ; preds = %if.end63
  br i1 %drained.0.off0.ph, label %land.lhs.true69, label %if.end72

land.lhs.true69:                                  ; preds = %if.end67
  %102 = call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i219 = and i32 %102, -16384
  %103 = inttoptr i32 %and.i.i219 to ptr
  %task.i220 = getelementptr inbounds %struct.thread_info, ptr %103, i32 0, i32 2
  %104 = ptrtoint ptr %task.i220 to i32
  call void @__asan_load4_noabort(i32 %104)
  %105 = load ptr, ptr %task.i220, align 8
  %signal.i.i = getelementptr inbounds %struct.task_struct, ptr %105, i32 0, i32 111
  %106 = ptrtoint ptr %signal.i.i to i32
  call void @__asan_load4_noabort(i32 %106)
  %107 = load ptr, ptr %signal.i.i, align 16
  %oom_mm.i.i = getelementptr inbounds %struct.signal_struct, ptr %107, i32 0, i32 59
  %108 = ptrtoint ptr %oom_mm.i.i to i32
  call void @__asan_load4_noabort(i32 %108)
  %109 = load ptr, ptr %oom_mm.i.i, align 4
  %tobool.i.not.i = icmp eq ptr %109, null
  br i1 %tobool.i.not.i, label %lor.lhs.false.i, label %nomem

lor.lhs.false.i:                                  ; preds = %land.lhs.true69
  %stack.i.i.i.i = getelementptr inbounds %struct.task_struct, ptr %105, i32 0, i32 1
  %110 = ptrtoint ptr %stack.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %110)
  %111 = load ptr, ptr %stack.i.i.i.i, align 4
  %112 = ptrtoint ptr %111 to i32
  call void @__asan_load4_noabort(i32 %112)
  %113 = load volatile i32, ptr %111, align 4
  %and1.i.i.i.i.i.i = and i32 %113, 1
  %tobool.not.i.i221 = icmp eq i32 %and1.i.i.i.i.i.i, 0
  br i1 %tobool.not.i.i221, label %task_is_dying.exit, label %fatal_signal_pending.exit.i

fatal_signal_pending.exit.i:                      ; preds = %lor.lhs.false.i
  %signal.i.i.i = getelementptr inbounds %struct.task_struct, ptr %105, i32 0, i32 116, i32 1
  %114 = ptrtoint ptr %signal.i.i.i to i32
  call void @__asan_load4_noabort(i32 %114)
  %115 = load i32, ptr %signal.i.i.i, align 4
  %116 = and i32 %115, 256
  %tobool.not.i222 = icmp eq i32 %116, 0
  br i1 %tobool.not.i222, label %task_is_dying.exit, label %nomem

task_is_dying.exit:                               ; preds = %fatal_signal_pending.exit.i, %lor.lhs.false.i
  %flags.i = getelementptr inbounds %struct.task_struct, ptr %105, i32 0, i32 3
  %117 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %117)
  %118 = load i32, ptr %flags.i, align 4
  %and.i223 = and i32 %118, 4
  %tobool7.i.not = icmp eq i32 %and.i223, 0
  br i1 %tobool7.i.not, label %if.end72, label %nomem

if.end72:                                         ; preds = %task_is_dying.exit, %if.end67
  %call74 = call fastcc i32 @mem_cgroup_oom(ptr noundef %mem_over_limit.0, i32 noundef %gfp_mask, i32 noundef %cond.i.i)
  %cmp75 = icmp eq i32 %call74, 0
  br i1 %cmp75, label %retry.outer, label %nomem

nomem:                                            ; preds = %if.end72, %task_is_dying.exit, %fatal_signal_pending.exit.i, %land.lhs.true69, %if.end63, %if.end49, %if.end26
  %and78 = and i32 %gfp_mask, 32768
  %tobool79.not = icmp eq i32 %and78, 0
  br i1 %tobool79.not, label %cleanup131, label %force

force:                                            ; preds = %nomem, %if.end19, %if.end17
  call void @page_counter_charge(ptr noundef %memory, i32 noundef %nr_pages) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@try_charge_memcg, %land.rhs.i225)) #23
          to label %cleanup131 [label %land.rhs.i225], !srcloc !461

land.rhs.i225:                                    ; preds = %force
  %119 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i224 = icmp eq i8 %119, 0
  br i1 %tobool4.not.i224, label %if.then84, label %cleanup131

if.then84:                                        ; preds = %land.rhs.i225
  call void @page_counter_charge(ptr noundef %3, i32 noundef %nr_pages) #23
  br label %cleanup131

done_restock:                                     ; preds = %if.then3
  %cmp86 = icmp ugt i32 %batch.0.ph279, %nr_pages
  br i1 %cmp86, label %if.then87, label %do.body.preheader

if.then87:                                        ; preds = %done_restock
  %sub = sub i32 %batch.0.ph279, %nr_pages
  call fastcc void @refill_stock(ptr noundef %memcg, i32 noundef %sub)
  br label %do.body.preheader

do.body.preheader:                                ; preds = %if.then87, %done_restock
  br label %do.body

do.body:                                          ; preds = %do.cond127, %do.body.preheader
  %memcg.addr.0 = phi ptr [ %add.ptr.i, %do.cond127 ], [ %memcg, %do.body.preheader ]
  %memory89 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 2
  %call.i.i.i227 = call zeroext i1 @__kasan_check_read(ptr noundef %memory89, i32 noundef 4) #23
  %120 = ptrtoint ptr %memory89 to i32
  call void @__asan_load4_noabort(i32 %120)
  %121 = load volatile i32, ptr %memory89, align 4
  %high = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 2, i32 3
  %122 = ptrtoint ptr %high to i32
  call void @__asan_load4_noabort(i32 %122)
  %123 = load volatile i32, ptr %high, align 4
  %cmp94 = icmp ugt i32 %121, %123
  %124 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 3
  %call.i.i.i228 = call zeroext i1 @__kasan_check_read(ptr noundef %124, i32 noundef 4) #23
  %125 = ptrtoint ptr %124 to i32
  call void @__asan_load4_noabort(i32 %125)
  %126 = load volatile i32, ptr %124, align 4
  %high100 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 3, i32 0, i32 3
  %127 = ptrtoint ptr %high100 to i32
  call void @__asan_load4_noabort(i32 %127)
  %128 = load volatile i32, ptr %high100, align 4
  %129 = call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i = and i32 %129, -16384
  %130 = inttoptr i32 %and.i.i to ptr
  %preempt_count.i = getelementptr inbounds %struct.thread_info, ptr %130, i32 0, i32 1
  %131 = ptrtoint ptr %preempt_count.i to i32
  call void @__asan_load4_noabort(i32 %131)
  %132 = load volatile i32, ptr %preempt_count.i, align 4
  %and104 = and i32 %132, 15728640
  %133 = call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i191 = and i32 %133, -16384
  %134 = inttoptr i32 %and.i.i191 to ptr
  %preempt_count.i192 = getelementptr inbounds %struct.thread_info, ptr %134, i32 0, i32 1
  %135 = ptrtoint ptr %preempt_count.i192 to i32
  call void @__asan_load4_noabort(i32 %135)
  %136 = load volatile i32, ptr %preempt_count.i192, align 4
  %and106 = and i32 %136, 983040
  %or = or i32 %and106, %and104
  %137 = call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i193 = and i32 %137, -16384
  %138 = inttoptr i32 %and.i.i193 to ptr
  %preempt_count.i194 = getelementptr inbounds %struct.thread_info, ptr %138, i32 0, i32 1
  %139 = ptrtoint ptr %preempt_count.i194 to i32
  call void @__asan_load4_noabort(i32 %139)
  %140 = load volatile i32, ptr %preempt_count.i194, align 4
  %and108 = and i32 %140, 65280
  %or109 = or i32 %or, %and108
  %tobool110.not = icmp eq i32 %or109, 0
  br i1 %tobool110.not, label %if.end116, label %if.then111

if.then111:                                       ; preds = %do.body
  br i1 %cmp94, label %if.then113, label %do.cond127

if.then113:                                       ; preds = %if.then111
  %high_work = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 6
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @system_wq to i32))
  %141 = load ptr, ptr @system_wq, align 4
  %call.i.i = call zeroext i1 @queue_work_on(i32 noundef 4, ptr noundef %141, ptr noundef %high_work) #23
  br label %cleanup131

if.end116:                                        ; preds = %do.body
  %cmp101 = icmp ugt i32 %126, %128
  %brmerge = select i1 %cmp94, i1 true, i1 %cmp101
  br i1 %brmerge, label %if.then120, label %do.cond127

if.then120:                                       ; preds = %if.end116
  %142 = call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i229 = and i32 %142, -16384
  %143 = inttoptr i32 %and.i229 to ptr
  %task122 = getelementptr inbounds %struct.thread_info, ptr %143, i32 0, i32 2
  %144 = ptrtoint ptr %task122 to i32
  call void @__asan_load4_noabort(i32 %144)
  %145 = load ptr, ptr %task122, align 8
  %memcg_nr_pages_over_high = getelementptr inbounds %struct.task_struct, ptr %145, i32 0, i32 205
  %146 = ptrtoint ptr %memcg_nr_pages_over_high to i32
  call void @__asan_load4_noabort(i32 %146)
  %147 = load i32, ptr %memcg_nr_pages_over_high, align 4
  %add = add i32 %147, %batch.0.ph279
  store i32 %add, ptr %memcg_nr_pages_over_high, align 4
  %148 = load ptr, ptr %task122, align 8
  %stack.i.i = getelementptr inbounds %struct.task_struct, ptr %148, i32 0, i32 1
  %149 = ptrtoint ptr %stack.i.i to i32
  call void @__asan_load4_noabort(i32 %149)
  %150 = load ptr, ptr %stack.i.i, align 4
  %call.i.i.i230 = call i32 @_test_and_set_bit(i32 noundef 2, ptr noundef %150) #23
  %tobool.not.i231 = icmp eq i32 %call.i.i.i230, 0
  br i1 %tobool.not.i231, label %if.then.i232, label %cleanup131

if.then.i232:                                     ; preds = %if.then120
  call void @kick_process(ptr noundef %148) #23
  br label %cleanup131

do.cond127:                                       ; preds = %if.end116, %if.then111
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0, i32 0, i32 2, i32 13
  %151 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %151)
  %152 = load ptr, ptr %parent.i, align 4
  %tobool.not.i234 = icmp eq ptr %152, null
  %add.ptr.i = getelementptr i8, ptr %152, i32 -176
  %tobool129.not242 = icmp eq ptr %add.ptr.i, null
  %tobool129.not = or i1 %tobool.not.i234, %tobool129.not242
  br i1 %tobool129.not, label %cleanup131, label %do.body

cleanup131:                                       ; preds = %do.cond127, %if.then.i232, %if.then120, %if.then113, %if.then84, %land.rhs.i225, %force, %nomem, %consume_stock.exit
  %retval.0 = phi i32 [ -12, %nomem ], [ 0, %if.then84 ], [ 0, %land.rhs.i225 ], [ 0, %force ], [ 0, %if.then113 ], [ 0, %if.then120 ], [ 0, %if.then.i232 ], [ 0, %do.cond127 ], [ 0, %consume_stock.exit ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %pflags) #23
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %counter) #23
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @drain_all_stock(ptr noundef readonly %root_memcg) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call i32 @mutex_trylock(ptr noundef nonnull @percpu_charge_mutex) #23
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %cleanup, label %do.body

do.body:                                          ; preds = %entry
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i to ptr
  %preempt_count.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i, align 4
  %add.i = add i32 %3, 1
  store volatile i32 %add.i, ptr %preempt_count.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !550
  %4 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i = and i32 %4, -16384
  %5 = inttoptr i32 %and.i to ptr
  %cpu2 = getelementptr inbounds %struct.thread_info, ptr %5, i32 0, i32 3
  %6 = ptrtoint ptr %cpu2 to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %cpu2, align 4
  %call379 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_online_mask) #29
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %8 = load i32, ptr @nr_cpu_ids, align 4
  %cmp80 = icmp ult i32 %call379, %8
  br i1 %cmp80, label %for.body, label %do.body30

for.body:                                         ; preds = %if.end29, %do.body
  %call381 = phi i32 [ %call3, %if.end29 ], [ %call379, %do.body ]
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call381
  %9 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %arrayidx, align 4
  %add = add i32 %10, ptrtoint (ptr @memcg_stock to i32)
  %11 = inttoptr i32 %add to ptr
  %12 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %12, -16384
  %13 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 1
  %14 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %15, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %for.body
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %for.body
  %16 = ptrtoint ptr %11 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %11, align 4
  %tobool9.not = icmp eq ptr %17, null
  br i1 %tobool9.not, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %rcu_read_lock.exit
  %nr_pages = getelementptr inbounds %struct.memcg_stock_pcp, ptr %11, i32 0, i32 1
  %18 = ptrtoint ptr %nr_pages to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %nr_pages, align 4
  %tobool10.not = icmp eq i32 %19, 0
  br i1 %tobool10.not, label %if.else, label %land.lhs.true11

land.lhs.true11:                                  ; preds = %land.lhs.true
  %cmp.i = icmp eq ptr %17, %root_memcg
  br i1 %cmp.i, label %land.lhs.true19.critedge, label %if.end.i

if.end.i:                                         ; preds = %land.lhs.true11
  %20 = ptrtoint ptr %17 to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %17, align 128
  %22 = ptrtoint ptr %root_memcg to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %root_memcg, align 128
  %root.i.i = getelementptr inbounds %struct.cgroup, ptr %21, i32 0, i32 19
  %24 = ptrtoint ptr %root.i.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %root.i.i, align 4
  %root1.i.i = getelementptr inbounds %struct.cgroup, ptr %23, i32 0, i32 19
  %26 = ptrtoint ptr %root1.i.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load ptr, ptr %root1.i.i, align 4
  %cmp.not.i.i = icmp eq ptr %25, %27
  br i1 %cmp.not.i.i, label %lor.lhs.false.i.i, label %if.else

lor.lhs.false.i.i:                                ; preds = %if.end.i
  %level.i.i = getelementptr inbounds %struct.cgroup, ptr %21, i32 0, i32 2
  %28 = ptrtoint ptr %level.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %level.i.i, align 4
  %level2.i.i = getelementptr inbounds %struct.cgroup, ptr %23, i32 0, i32 2
  %30 = ptrtoint ptr %level2.i.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load i32, ptr %level2.i.i, align 4
  %cmp3.i.i = icmp slt i32 %29, %31
  br i1 %cmp3.i.i, label %if.else, label %mem_cgroup_is_descendant.exit

mem_cgroup_is_descendant.exit:                    ; preds = %lor.lhs.false.i.i
  %arrayidx.i.i = getelementptr %struct.cgroup, ptr %21, i32 0, i32 37, i32 %31
  %32 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load8_noabort(i32 %32)
  %33 = load i64, ptr %arrayidx.i.i, align 8
  %kn.i.i.i = getelementptr inbounds %struct.cgroup, ptr %23, i32 0, i32 11
  %34 = ptrtoint ptr %kn.i.i.i to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load ptr, ptr %kn.i.i.i, align 8
  %id.i.i.i = getelementptr inbounds %struct.kernfs_node, ptr %35, i32 0, i32 10
  %36 = ptrtoint ptr %id.i.i.i to i32
  call void @__asan_load8_noabort(i32 %36)
  %37 = load i64, ptr %id.i.i.i, align 8
  %cmp5.i.i = icmp eq i64 %33, %37
  br i1 %cmp5.i.i, label %land.lhs.true19.critedge, label %if.else

if.else:                                          ; preds = %mem_cgroup_is_descendant.exit, %lor.lhs.false.i.i, %if.end.i, %land.lhs.true, %rcu_read_lock.exit
  %38 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i47 = and i32 %38, -16384
  %39 = inttoptr i32 %and.i.i.i47 to ptr
  %preempt_count.i.i48 = getelementptr inbounds %struct.thread_info, ptr %39, i32 0, i32 1
  %40 = ptrtoint ptr %preempt_count.i.i48 to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load volatile i32, ptr %preempt_count.i.i48, align 4
  %and.i49 = and i32 %41, 15728640
  %42 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i36.i = and i32 %42, -16384
  %43 = inttoptr i32 %and.i.i36.i to ptr
  %preempt_count.i37.i = getelementptr inbounds %struct.thread_info, ptr %43, i32 0, i32 1
  %44 = ptrtoint ptr %preempt_count.i37.i to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load volatile i32, ptr %preempt_count.i37.i, align 4
  %and2.i = and i32 %45, 983040
  %or.i = or i32 %and2.i, %and.i49
  %46 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i38.i = and i32 %46, -16384
  %47 = inttoptr i32 %and.i.i38.i to ptr
  %preempt_count.i39.i = getelementptr inbounds %struct.thread_info, ptr %47, i32 0, i32 1
  %48 = ptrtoint ptr %preempt_count.i39.i to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load volatile i32, ptr %preempt_count.i39.i, align 4
  %and5.i = and i32 %49, 256
  %or6.i = or i32 %or.i, %and5.i
  %tobool.not.i50 = icmp eq i32 %or6.i, 0
  br i1 %tobool.not.i50, label %land.lhs.true.i51, label %if.end15.i

land.lhs.true.i51:                                ; preds = %if.else
  %task_obj.i = getelementptr inbounds %struct.memcg_stock_pcp, ptr %11, i32 0, i32 2
  %50 = ptrtoint ptr %task_obj.i to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load ptr, ptr %task_obj.i, align 4
  %tobool7.not.i = icmp eq ptr %51, null
  br i1 %tobool7.not.i, label %if.end15.i, label %if.then.i52

if.then.i52:                                      ; preds = %land.lhs.true.i51
  %memcg.i.i = getelementptr inbounds %struct.obj_cgroup, ptr %51, i32 0, i32 1
  %52 = ptrtoint ptr %memcg.i.i to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load volatile ptr, ptr %memcg.i.i, align 4
  %tobool11.not.i = icmp eq ptr %53, null
  br i1 %tobool11.not.i, label %if.end15.i, label %land.lhs.true12.i

land.lhs.true12.i:                                ; preds = %if.then.i52
  %cmp.i.i = icmp eq ptr %53, %root_memcg
  br i1 %cmp.i.i, label %obj_stock_flush_required.exit, label %if.end.i.i53

if.end.i.i53:                                     ; preds = %land.lhs.true12.i
  %54 = ptrtoint ptr %53 to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load ptr, ptr %53, align 128
  %56 = ptrtoint ptr %root_memcg to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load ptr, ptr %root_memcg, align 128
  %root.i.i.i = getelementptr inbounds %struct.cgroup, ptr %55, i32 0, i32 19
  %58 = ptrtoint ptr %root.i.i.i to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load ptr, ptr %root.i.i.i, align 4
  %root1.i.i.i = getelementptr inbounds %struct.cgroup, ptr %57, i32 0, i32 19
  %60 = ptrtoint ptr %root1.i.i.i to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load ptr, ptr %root1.i.i.i, align 4
  %cmp.not.i.i.i = icmp eq ptr %59, %61
  br i1 %cmp.not.i.i.i, label %lor.lhs.false.i.i.i, label %if.end15.i

lor.lhs.false.i.i.i:                              ; preds = %if.end.i.i53
  %level.i.i.i = getelementptr inbounds %struct.cgroup, ptr %55, i32 0, i32 2
  %62 = ptrtoint ptr %level.i.i.i to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load i32, ptr %level.i.i.i, align 4
  %level2.i.i.i = getelementptr inbounds %struct.cgroup, ptr %57, i32 0, i32 2
  %64 = ptrtoint ptr %level2.i.i.i to i32
  call void @__asan_load4_noabort(i32 %64)
  %65 = load i32, ptr %level2.i.i.i, align 4
  %cmp3.i.i.i = icmp slt i32 %63, %65
  br i1 %cmp3.i.i.i, label %if.end15.i, label %mem_cgroup_is_descendant.exit.i

mem_cgroup_is_descendant.exit.i:                  ; preds = %lor.lhs.false.i.i.i
  %arrayidx.i.i.i = getelementptr %struct.cgroup, ptr %55, i32 0, i32 37, i32 %65
  %66 = ptrtoint ptr %arrayidx.i.i.i to i32
  call void @__asan_load8_noabort(i32 %66)
  %67 = load i64, ptr %arrayidx.i.i.i, align 8
  %kn.i.i.i.i = getelementptr inbounds %struct.cgroup, ptr %57, i32 0, i32 11
  %68 = ptrtoint ptr %kn.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load ptr, ptr %kn.i.i.i.i, align 8
  %id.i.i.i.i = getelementptr inbounds %struct.kernfs_node, ptr %69, i32 0, i32 10
  %70 = ptrtoint ptr %id.i.i.i.i to i32
  call void @__asan_load8_noabort(i32 %70)
  %71 = load i64, ptr %id.i.i.i.i, align 8
  %cmp5.i.i.i = icmp eq i64 %67, %71
  br i1 %cmp5.i.i.i, label %obj_stock_flush_required.exit, label %if.end15.i

if.end15.i:                                       ; preds = %mem_cgroup_is_descendant.exit.i, %lor.lhs.false.i.i.i, %if.end.i.i53, %if.then.i52, %land.lhs.true.i51, %if.else
  %irq_obj.i = getelementptr inbounds %struct.memcg_stock_pcp, ptr %11, i32 0, i32 3
  %72 = ptrtoint ptr %irq_obj.i to i32
  call void @__asan_load4_noabort(i32 %72)
  %73 = load ptr, ptr %irq_obj.i, align 4
  %tobool17.not.i = icmp eq ptr %73, null
  br i1 %tobool17.not.i, label %if.end27.i, label %if.then18.i

if.then18.i:                                      ; preds = %if.end15.i
  %memcg.i40.i = getelementptr inbounds %struct.obj_cgroup, ptr %73, i32 0, i32 1
  %74 = ptrtoint ptr %memcg.i40.i to i32
  call void @__asan_load4_noabort(i32 %74)
  %75 = load volatile ptr, ptr %memcg.i40.i, align 4
  %tobool22.not.i = icmp eq ptr %75, null
  br i1 %tobool22.not.i, label %if.end27.i, label %land.lhs.true23.i

land.lhs.true23.i:                                ; preds = %if.then18.i
  %cmp.i41.i = icmp eq ptr %75, %root_memcg
  br i1 %cmp.i41.i, label %obj_stock_flush_required.exit, label %if.end.i45.i

if.end.i45.i:                                     ; preds = %land.lhs.true23.i
  %76 = ptrtoint ptr %75 to i32
  call void @__asan_load4_noabort(i32 %76)
  %77 = load ptr, ptr %75, align 128
  %78 = ptrtoint ptr %root_memcg to i32
  call void @__asan_load4_noabort(i32 %78)
  %79 = load ptr, ptr %root_memcg, align 128
  %root.i.i42.i = getelementptr inbounds %struct.cgroup, ptr %77, i32 0, i32 19
  %80 = ptrtoint ptr %root.i.i42.i to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load ptr, ptr %root.i.i42.i, align 4
  %root1.i.i43.i = getelementptr inbounds %struct.cgroup, ptr %79, i32 0, i32 19
  %82 = ptrtoint ptr %root1.i.i43.i to i32
  call void @__asan_load4_noabort(i32 %82)
  %83 = load ptr, ptr %root1.i.i43.i, align 4
  %cmp.not.i.i44.i = icmp eq ptr %81, %83
  br i1 %cmp.not.i.i44.i, label %lor.lhs.false.i.i49.i, label %if.end27.i

lor.lhs.false.i.i49.i:                            ; preds = %if.end.i45.i
  %level.i.i46.i = getelementptr inbounds %struct.cgroup, ptr %77, i32 0, i32 2
  %84 = ptrtoint ptr %level.i.i46.i to i32
  call void @__asan_load4_noabort(i32 %84)
  %85 = load i32, ptr %level.i.i46.i, align 4
  %level2.i.i47.i = getelementptr inbounds %struct.cgroup, ptr %79, i32 0, i32 2
  %86 = ptrtoint ptr %level2.i.i47.i to i32
  call void @__asan_load4_noabort(i32 %86)
  %87 = load i32, ptr %level2.i.i47.i, align 4
  %cmp3.i.i48.i = icmp slt i32 %85, %87
  br i1 %cmp3.i.i48.i, label %if.end27.i, label %mem_cgroup_is_descendant.exit56.i

mem_cgroup_is_descendant.exit56.i:                ; preds = %lor.lhs.false.i.i49.i
  %arrayidx.i.i50.i = getelementptr %struct.cgroup, ptr %77, i32 0, i32 37, i32 %87
  %88 = ptrtoint ptr %arrayidx.i.i50.i to i32
  call void @__asan_load8_noabort(i32 %88)
  %89 = load i64, ptr %arrayidx.i.i50.i, align 8
  %kn.i.i.i51.i = getelementptr inbounds %struct.cgroup, ptr %79, i32 0, i32 11
  %90 = ptrtoint ptr %kn.i.i.i51.i to i32
  call void @__asan_load4_noabort(i32 %90)
  %91 = load ptr, ptr %kn.i.i.i51.i, align 8
  %id.i.i.i52.i = getelementptr inbounds %struct.kernfs_node, ptr %91, i32 0, i32 10
  %92 = ptrtoint ptr %id.i.i.i52.i to i32
  call void @__asan_load8_noabort(i32 %92)
  %93 = load i64, ptr %id.i.i.i52.i, align 8
  %cmp5.i.i53.i = icmp eq i64 %89, %93
  br i1 %cmp5.i.i53.i, label %obj_stock_flush_required.exit, label %if.end27.i

if.end27.i:                                       ; preds = %mem_cgroup_is_descendant.exit56.i, %lor.lhs.false.i.i49.i, %if.end.i45.i, %if.then18.i, %if.end15.i
  br label %obj_stock_flush_required.exit

obj_stock_flush_required.exit:                    ; preds = %if.end27.i, %mem_cgroup_is_descendant.exit56.i, %land.lhs.true23.i, %mem_cgroup_is_descendant.exit.i, %land.lhs.true12.i
  %retval.0.i54 = phi i1 [ false, %if.end27.i ], [ true, %mem_cgroup_is_descendant.exit.i ], [ true, %mem_cgroup_is_descendant.exit56.i ], [ true, %land.lhs.true12.i ], [ true, %land.lhs.true23.i ]
  %call.i55 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i55, label %rcu_read_unlock.exit, label %land.lhs.true.i58

land.lhs.true.i58:                                ; preds = %obj_stock_flush_required.exit
  %call1.i56 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i57 = icmp eq i32 %call1.i56, 0
  br i1 %tobool.not.i57, label %rcu_read_unlock.exit, label %land.lhs.true2.i60

land.lhs.true2.i60:                               ; preds = %land.lhs.true.i58
  %.b4.i59 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i59, label %rcu_read_unlock.exit, label %if.then.i61

if.then.i61:                                      ; preds = %land.lhs.true2.i60
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i61, %land.lhs.true2.i60, %land.lhs.true.i58, %obj_stock_flush_required.exit
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %94 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i62 = and i32 %94, -16384
  %95 = inttoptr i32 %and.i.i.i.i.i62 to ptr
  %preempt_count.i.i.i.i63 = getelementptr inbounds %struct.thread_info, ptr %95, i32 0, i32 1
  %96 = ptrtoint ptr %preempt_count.i.i.i.i63 to i32
  call void @__asan_load4_noabort(i32 %96)
  %97 = load volatile i32, ptr %preempt_count.i.i.i.i63, align 4
  %sub.i.i.i = add i32 %97, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i63, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  br i1 %retval.0.i54, label %land.lhs.true19, label %if.end29

land.lhs.true19.critedge:                         ; preds = %mem_cgroup_is_descendant.exit, %land.lhs.true11
  %call.i64 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i64, label %rcu_read_unlock.exit74, label %land.lhs.true.i67

land.lhs.true.i67:                                ; preds = %land.lhs.true19.critedge
  %call1.i65 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i66 = icmp eq i32 %call1.i65, 0
  br i1 %tobool.not.i66, label %rcu_read_unlock.exit74, label %land.lhs.true2.i69

land.lhs.true2.i69:                               ; preds = %land.lhs.true.i67
  %.b4.i68 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i68, label %rcu_read_unlock.exit74, label %if.then.i70

if.then.i70:                                      ; preds = %land.lhs.true2.i69
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit74

rcu_read_unlock.exit74:                           ; preds = %if.then.i70, %land.lhs.true2.i69, %land.lhs.true.i67, %land.lhs.true19.critedge
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %98 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i71 = and i32 %98, -16384
  %99 = inttoptr i32 %and.i.i.i.i.i71 to ptr
  %preempt_count.i.i.i.i72 = getelementptr inbounds %struct.thread_info, ptr %99, i32 0, i32 1
  %100 = ptrtoint ptr %preempt_count.i.i.i.i72 to i32
  call void @__asan_load4_noabort(i32 %100)
  %101 = load volatile i32, ptr %preempt_count.i.i.i.i72, align 4
  %sub.i.i.i73 = add i32 %101, -1
  store volatile i32 %sub.i.i.i73, ptr %preempt_count.i.i.i.i72, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  br label %land.lhs.true19

land.lhs.true19:                                  ; preds = %rcu_read_unlock.exit74, %rcu_read_unlock.exit
  %flags = getelementptr inbounds %struct.memcg_stock_pcp, ptr %11, i32 0, i32 5
  %call20 = tail call i32 @_test_and_set_bit(i32 noundef 0, ptr noundef %flags) #23
  %tobool21.not = icmp eq i32 %call20, 0
  br i1 %tobool21.not, label %if.then22, label %if.end29

if.then22:                                        ; preds = %land.lhs.true19
  %cmp23 = icmp eq i32 %call381, %7
  %work = getelementptr inbounds %struct.memcg_stock_pcp, ptr %11, i32 0, i32 4
  br i1 %cmp23, label %if.then24, label %if.else25

if.then24:                                        ; preds = %if.then22
  tail call void @drain_local_stock(ptr noundef %work)
  br label %if.end29

if.else25:                                        ; preds = %if.then22
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @system_wq to i32))
  %102 = load ptr, ptr @system_wq, align 4
  %call.i75 = tail call zeroext i1 @queue_work_on(i32 noundef %call381, ptr noundef %102, ptr noundef %work) #23
  br label %if.end29

if.end29:                                         ; preds = %if.else25, %if.then24, %land.lhs.true19, %rcu_read_unlock.exit
  %call3 = tail call i32 @cpumask_next(i32 noundef %call381, ptr noundef nonnull @__cpu_online_mask) #29
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %103 = load i32, ptr @nr_cpu_ids, align 4
  %cmp = icmp ult i32 %call3, %103
  br i1 %cmp, label %for.body, label %do.body30

do.body30:                                        ; preds = %if.end29, %do.body
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !551
  %104 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i45 = and i32 %104, -16384
  %105 = inttoptr i32 %and.i.i.i45 to ptr
  %preempt_count.i.i46 = getelementptr inbounds %struct.thread_info, ptr %105, i32 0, i32 1
  %106 = ptrtoint ptr %preempt_count.i.i46 to i32
  call void @__asan_load4_noabort(i32 %106)
  %107 = load volatile i32, ptr %preempt_count.i.i46, align 4
  %sub.i = add i32 %107, -1
  store volatile i32 %sub.i, ptr %preempt_count.i.i46, align 4
  tail call void @mutex_unlock(ptr noundef nonnull @percpu_charge_mutex) #23
  br label %cleanup

cleanup:                                          ; preds = %do.body30, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @mem_cgroup_oom(ptr noundef %memcg, i32 noundef %mask, i32 noundef %order) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %cmp = icmp sgt i32 %order, 3
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %arrayidx.i = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 28, i32 3
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %arrayidx.i, i32 noundef 4) #23
  tail call void @llvm.prefetch.p0(ptr %arrayidx.i, i32 1, i32 3, i32 1) #23
  %0 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %arrayidx.i, ptr %arrayidx.i, i32 1, ptr elementtype(i32) %arrayidx.i) #23, !srcloc !468
  %events_local_file.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 15
  tail call void @cgroup_file_notify(ptr noundef %events_local_file.i) #23
  br label %do.body.i

do.body.i:                                        ; preds = %land.rhs.i, %if.end
  %memcg.addr.0.i = phi ptr [ %memcg, %if.end ], [ %add.ptr.i.i, %land.rhs.i ]
  %arrayidx3.i = getelementptr %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 27, i32 3
  %call.i.i33.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %arrayidx3.i, i32 noundef 4) #23
  tail call void @llvm.prefetch.p0(ptr %arrayidx3.i, i32 1, i32 3, i32 1) #23
  %1 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %arrayidx3.i, ptr %arrayidx3.i, i32 1, ptr elementtype(i32) %arrayidx3.i) #23, !srcloc !468
  %events_file.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 14
  tail call void @cgroup_file_notify(ptr noundef %events_file.i) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_oom, %memcg_memory_event.exit)) #23
          to label %if.end13.i [label %memcg_memory_event.exit], !srcloc !461

if.end13.i:                                       ; preds = %do.body.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7) to i32))
  %2 = load i32, ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7), align 4
  %and.i = and i32 %2, 32
  %tobool14.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool14.not.i, label %do.cond.i, label %memcg_memory_event.exit

do.cond.i:                                        ; preds = %if.end13.i
  %parent.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 2, i32 13
  %3 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i = icmp eq ptr %4, null
  %add.ptr.i.i = getelementptr i8, ptr %4, i32 -176
  %tobool18.not36.i = icmp eq ptr %add.ptr.i.i, null
  %tobool18.not.i = or i1 %tobool.not.i.i, %tobool18.not36.i
  br i1 %tobool18.not.i, label %memcg_memory_event.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %do.cond.i
  %5 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i = icmp eq ptr %5, %add.ptr.i.i
  br i1 %cmp.i.i, label %memcg_memory_event.exit, label %do.body.i

memcg_memory_event.exit:                          ; preds = %land.rhs.i, %do.cond.i, %if.end13.i, %do.body.i
  %oom_kill_disable = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 13
  %6 = ptrtoint ptr %oom_kill_disable to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %oom_kill_disable, align 8
  %tobool.not = icmp eq i32 %7, 0
  br i1 %tobool.not, label %if.end11, label %if.then1

if.then1:                                         ; preds = %memcg_memory_event.exit
  %8 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i36 = and i32 %8, -16384
  %9 = inttoptr i32 %and.i36 to ptr
  %task = getelementptr inbounds %struct.thread_info, ptr %9, i32 0, i32 2
  %10 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %task, align 8
  %in_user_fault = getelementptr inbounds %struct.task_struct, ptr %11, i32 0, i32 65
  %12 = ptrtoint ptr %in_user_fault to i32
  call void @__asan_load2_noabort(i32 %12)
  %bf.load = load i16, ptr %in_user_fault, align 8
  %13 = and i16 %bf.load, 4096
  %tobool2.not = icmp eq i16 %13, 0
  br i1 %tobool2.not, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.then1
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %memcg, i32 0, i32 7
  %14 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %flags.i, align 4
  %and.i37 = and i32 %15, 1
  %tobool.not.i = icmp eq i32 %and.i37, 0
  br i1 %tobool.not.i, label %if.then.i, label %css_get.exit

if.then.i:                                        ; preds = %if.end4
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %memcg, i32 0, i32 2
  tail call fastcc void @percpu_ref_get_many(ptr noundef %refcnt.i, i32 noundef 1) #23
  br label %css_get.exit

css_get.exit:                                     ; preds = %if.then.i, %if.end4
  %16 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %task, align 8
  %memcg_in_oom = getelementptr inbounds %struct.task_struct, ptr %17, i32 0, i32 202
  %18 = ptrtoint ptr %memcg_in_oom to i32
  call void @__asan_store4_noabort(i32 %18)
  store ptr %memcg, ptr %memcg_in_oom, align 8
  %19 = load ptr, ptr %task, align 8
  %memcg_oom_gfp_mask = getelementptr inbounds %struct.task_struct, ptr %19, i32 0, i32 203
  %20 = ptrtoint ptr %memcg_oom_gfp_mask to i32
  call void @__asan_store4_noabort(i32 %20)
  store i32 %mask, ptr %memcg_oom_gfp_mask, align 4
  %21 = load ptr, ptr %task, align 8
  %memcg_oom_order = getelementptr inbounds %struct.task_struct, ptr %21, i32 0, i32 204
  %22 = ptrtoint ptr %memcg_oom_order to i32
  call void @__asan_store4_noabort(i32 %22)
  store i32 %order, ptr %memcg_oom_order, align 32
  br label %cleanup

if.end11:                                         ; preds = %memcg_memory_event.exit
  tail call void @_raw_spin_lock(ptr noundef nonnull @memcg_oom_lock) #23
  %call.i = tail call ptr @mem_cgroup_iter(ptr noundef %memcg, ptr noundef null, ptr noundef null) #23
  %cmp.not5.i = icmp eq ptr %call.i, null
  br i1 %cmp.not5.i, label %mem_cgroup_mark_under_oom.exit, label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %if.end11
  %iter.06.i = phi ptr [ %call1.i, %for.body.i ], [ %call.i, %if.end11 ]
  %under_oom.i = getelementptr inbounds %struct.mem_cgroup, ptr %iter.06.i, i32 0, i32 11
  %23 = ptrtoint ptr %under_oom.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %under_oom.i, align 16
  %inc.i = add i32 %24, 1
  store i32 %inc.i, ptr %under_oom.i, align 16
  %call1.i = tail call ptr @mem_cgroup_iter(ptr noundef %memcg, ptr noundef nonnull %iter.06.i, ptr noundef null) #23
  %cmp.not.i = icmp eq ptr %call1.i, null
  br i1 %cmp.not.i, label %mem_cgroup_mark_under_oom.exit, label %for.body.i

mem_cgroup_mark_under_oom.exit:                   ; preds = %for.body.i, %if.end11
  tail call void @_raw_spin_unlock(ptr noundef nonnull @memcg_oom_lock) #23
  %call12 = tail call fastcc zeroext i1 @mem_cgroup_oom_trylock(ptr noundef %memcg)
  br i1 %call12, label %if.then14, label %if.end15

if.then14:                                        ; preds = %mem_cgroup_mark_under_oom.exit
  %call.i38 = tail call ptr @mem_cgroup_iter(ptr noundef %memcg, ptr noundef null, ptr noundef null) #23
  %cmp.not6.i = icmp eq ptr %call.i38, null
  br i1 %cmp.not6.i, label %if.end15, label %for.body.i39

for.body.i39:                                     ; preds = %mem_cgroup_oom_notify_cb.exit.i, %if.then14
  %iter.07.i = phi ptr [ %call2.i, %mem_cgroup_oom_notify_cb.exit.i ], [ %call.i38, %if.then14 ]
  tail call void @_raw_spin_lock(ptr noundef nonnull @memcg_oom_lock) #23
  %oom_notify.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %iter.07.i, i32 0, i32 20
  %25 = ptrtoint ptr %oom_notify.i.i to i32
  call void @__asan_load4_noabort(i32 %25)
  %ev.01.i.i = load ptr, ptr %oom_notify.i.i, align 4
  %cmp.not2.i.i = icmp eq ptr %ev.01.i.i, %oom_notify.i.i
  br i1 %cmp.not2.i.i, label %mem_cgroup_oom_notify_cb.exit.i, label %for.body.i.i

for.body.i.i:                                     ; preds = %for.body.i.i, %for.body.i39
  %ev.03.i.i = phi ptr [ %ev.0.i.i, %for.body.i.i ], [ %ev.01.i.i, %for.body.i39 ]
  %eventfd.i.i = getelementptr inbounds %struct.mem_cgroup_eventfd_list, ptr %ev.03.i.i, i32 0, i32 1
  %26 = ptrtoint ptr %eventfd.i.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load ptr, ptr %eventfd.i.i, align 4
  %call.i.i = tail call i64 @eventfd_signal(ptr noundef %27, i64 noundef 1) #23
  %28 = ptrtoint ptr %ev.03.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %ev.0.i.i = load ptr, ptr %ev.03.i.i, align 4
  %cmp.not.i.i = icmp eq ptr %ev.0.i.i, %oom_notify.i.i
  br i1 %cmp.not.i.i, label %mem_cgroup_oom_notify_cb.exit.i, label %for.body.i.i

mem_cgroup_oom_notify_cb.exit.i:                  ; preds = %for.body.i.i, %for.body.i39
  tail call void @_raw_spin_unlock(ptr noundef nonnull @memcg_oom_lock) #23
  %call2.i = tail call ptr @mem_cgroup_iter(ptr noundef %memcg, ptr noundef nonnull %iter.07.i, ptr noundef null) #23
  %cmp.not.i40 = icmp eq ptr %call2.i, null
  br i1 %cmp.not.i40, label %if.end15, label %for.body.i39

if.end15:                                         ; preds = %mem_cgroup_oom_notify_cb.exit.i, %if.then14, %mem_cgroup_mark_under_oom.exit
  tail call void @_raw_spin_lock(ptr noundef nonnull @memcg_oom_lock) #23
  %call.i41 = tail call ptr @mem_cgroup_iter(ptr noundef %memcg, ptr noundef null, ptr noundef null) #23
  %cmp.not8.i = icmp eq ptr %call.i41, null
  br i1 %cmp.not8.i, label %mem_cgroup_unmark_under_oom.exit, label %for.body.i43

for.body.i43:                                     ; preds = %for.inc.i, %if.end15
  %iter.09.i = phi ptr [ %call3.i, %for.inc.i ], [ %call.i41, %if.end15 ]
  %under_oom.i42 = getelementptr inbounds %struct.mem_cgroup, ptr %iter.09.i, i32 0, i32 11
  %29 = ptrtoint ptr %under_oom.i42 to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %under_oom.i42, align 16
  %cmp1.i = icmp sgt i32 %30, 0
  br i1 %cmp1.i, label %if.then.i44, label %for.inc.i

if.then.i44:                                      ; preds = %for.body.i43
  %dec.i = add nsw i32 %30, -1
  %31 = ptrtoint ptr %under_oom.i42 to i32
  call void @__asan_store4_noabort(i32 %31)
  store i32 %dec.i, ptr %under_oom.i42, align 16
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then.i44, %for.body.i43
  %call3.i = tail call ptr @mem_cgroup_iter(ptr noundef %memcg, ptr noundef nonnull %iter.09.i, ptr noundef null) #23
  %cmp.not.i45 = icmp eq ptr %call3.i, null
  br i1 %cmp.not.i45, label %mem_cgroup_unmark_under_oom.exit, label %for.body.i43

mem_cgroup_unmark_under_oom.exit:                 ; preds = %for.inc.i, %if.end15
  tail call void @_raw_spin_unlock(ptr noundef nonnull @memcg_oom_lock) #23
  %call16 = tail call fastcc zeroext i1 @mem_cgroup_out_of_memory(ptr noundef %memcg, i32 noundef %mask, i32 noundef %order)
  %not.call16 = xor i1 %call16, true
  %. = zext i1 %not.call16 to i32
  br i1 %call12, label %if.then20, label %cleanup

if.then20:                                        ; preds = %mem_cgroup_unmark_under_oom.exit
  tail call void @_raw_spin_lock(ptr noundef nonnull @memcg_oom_lock) #23
  %32 = tail call ptr @llvm.returnaddress(i32 0) #23
  %33 = ptrtoint ptr %32 to i32
  tail call void @lock_release(ptr noundef nonnull @memcg_oom_lock_dep_map, i32 noundef %33) #23
  %call.i46 = tail call ptr @mem_cgroup_iter(ptr noundef %memcg, ptr noundef null, ptr noundef null) #23
  %cmp.not5.i47 = icmp eq ptr %call.i46, null
  br i1 %cmp.not5.i47, label %mem_cgroup_oom_unlock.exit, label %for.body.i51

for.body.i51:                                     ; preds = %for.body.i51, %if.then20
  %iter.06.i48 = phi ptr [ %call1.i49, %for.body.i51 ], [ %call.i46, %if.then20 ]
  %oom_lock.i = getelementptr inbounds %struct.mem_cgroup, ptr %iter.06.i48, i32 0, i32 10
  %34 = ptrtoint ptr %oom_lock.i to i32
  call void @__asan_store1_noabort(i32 %34)
  store i8 0, ptr %oom_lock.i, align 1
  %call1.i49 = tail call ptr @mem_cgroup_iter(ptr noundef %memcg, ptr noundef nonnull %iter.06.i48, ptr noundef null) #23
  %cmp.not.i50 = icmp eq ptr %call1.i49, null
  br i1 %cmp.not.i50, label %mem_cgroup_oom_unlock.exit, label %for.body.i51

mem_cgroup_oom_unlock.exit:                       ; preds = %for.body.i51, %if.then20
  tail call void @_raw_spin_unlock(ptr noundef nonnull @memcg_oom_lock) #23
  br label %cleanup

cleanup:                                          ; preds = %mem_cgroup_oom_unlock.exit, %mem_cgroup_unmark_under_oom.exit, %css_get.exit, %if.then1, %entry
  %retval.0 = phi i32 [ 2, %css_get.exit ], [ 3, %entry ], [ 3, %if.then1 ], [ %., %mem_cgroup_oom_unlock.exit ], [ %., %mem_cgroup_unmark_under_oom.exit ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @mutex_trylock(ptr noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree nounwind null_pointer_is_valid readonly willreturn
declare dso_local i32 @cpumask_next(i32 noundef, ptr noundef) local_unnamed_addr #18

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @_test_and_set_bit(i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @drain_local_stock(ptr nocapture noundef readnone %dummy) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i = and i32 %0, 128
  %tobool.not = icmp eq i32 %and.i, 0
  br i1 %tobool.not, label %if.then, label %do.body12

if.then:                                          ; preds = %entry
  tail call void @trace_hardirqs_off() #23
  br label %do.body12

do.body12:                                        ; preds = %if.then, %entry
  %1 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i69 = and i32 %1, -16384
  %2 = inttoptr i32 %and.i69 to ptr
  %cpu = getelementptr inbounds %struct.thread_info, ptr %2, i32 0, i32 3
  %3 = ptrtoint ptr %cpu to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %cpu, align 4
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %4
  %5 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %arrayidx, align 4
  %add = add i32 %6, ptrtoint (ptr @memcg_stock to i32)
  %7 = inttoptr i32 %add to ptr
  %irq_obj = getelementptr inbounds %struct.memcg_stock_pcp, ptr %7, i32 0, i32 3
  tail call fastcc void @drain_obj_stock(ptr noundef %irq_obj)
  %8 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i = and i32 %8, -16384
  %9 = inttoptr i32 %and.i.i to ptr
  %preempt_count.i = getelementptr inbounds %struct.thread_info, ptr %9, i32 0, i32 1
  %10 = ptrtoint ptr %preempt_count.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %preempt_count.i, align 4
  %and = and i32 %11, 15728640
  %12 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i65 = and i32 %12, -16384
  %13 = inttoptr i32 %and.i.i65 to ptr
  %preempt_count.i66 = getelementptr inbounds %struct.thread_info, ptr %13, i32 0, i32 1
  %14 = ptrtoint ptr %preempt_count.i66 to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %preempt_count.i66, align 4
  %and20 = and i32 %15, 983040
  %or = or i32 %and20, %and
  %16 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i67 = and i32 %16, -16384
  %17 = inttoptr i32 %and.i.i67 to ptr
  %preempt_count.i68 = getelementptr inbounds %struct.thread_info, ptr %17, i32 0, i32 1
  %18 = ptrtoint ptr %preempt_count.i68 to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load volatile i32, ptr %preempt_count.i68, align 4
  %and23 = and i32 %19, 256
  %or24 = or i32 %or, %and23
  %tobool25.not = icmp eq i32 %or24, 0
  br i1 %tobool25.not, label %if.then26, label %if.end27

if.then26:                                        ; preds = %do.body12
  %task_obj = getelementptr inbounds %struct.memcg_stock_pcp, ptr %7, i32 0, i32 2
  tail call fastcc void @drain_obj_stock(ptr noundef %task_obj)
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %do.body12
  %20 = ptrtoint ptr %7 to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %7, align 4
  %tobool.not.i = icmp eq ptr %21, null
  br i1 %tobool.not.i, label %drain_stock.exit, label %if.end.i

if.end.i:                                         ; preds = %if.end27
  %nr_pages.i = getelementptr inbounds %struct.memcg_stock_pcp, ptr %7, i32 0, i32 1
  %22 = ptrtoint ptr %nr_pages.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load i32, ptr %nr_pages.i, align 4
  %tobool1.not.i = icmp eq i32 %23, 0
  br i1 %tobool1.not.i, label %if.end8.i, label %if.then2.i

if.then2.i:                                       ; preds = %if.end.i
  %memory.i = getelementptr inbounds %struct.mem_cgroup, ptr %21, i32 0, i32 2
  tail call void @page_counter_uncharge(ptr noundef %memory.i, i32 noundef %23) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@drain_local_stock, %land.rhs.i.i)) #23
          to label %if.end6.i [label %land.rhs.i.i], !srcloc !461

land.rhs.i.i:                                     ; preds = %if.then2.i
  %24 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i = icmp eq i8 %24, 0
  br i1 %tobool4.not.i.i, label %if.then4.i, label %if.end6.i

if.then4.i:                                       ; preds = %land.rhs.i.i
  %25 = getelementptr inbounds %struct.mem_cgroup, ptr %21, i32 0, i32 3
  %26 = ptrtoint ptr %nr_pages.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %nr_pages.i, align 4
  tail call void @page_counter_uncharge(ptr noundef %25, i32 noundef %27) #23
  br label %if.end6.i

if.end6.i:                                        ; preds = %if.then4.i, %land.rhs.i.i, %if.then2.i
  %28 = ptrtoint ptr %nr_pages.i to i32
  call void @__asan_store4_noabort(i32 %28)
  store i32 0, ptr %nr_pages.i, align 4
  br label %if.end8.i

if.end8.i:                                        ; preds = %if.end6.i, %if.end.i
  %flags.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %21, i32 0, i32 7
  %29 = ptrtoint ptr %flags.i.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %flags.i.i, align 4
  %and.i.i70 = and i32 %30, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i70, 0
  br i1 %tobool.not.i.i, label %if.then.i.i, label %css_put.exit.i

if.then.i.i:                                      ; preds = %if.end8.i
  %refcnt.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %21, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i.i) #23
  br label %css_put.exit.i

css_put.exit.i:                                   ; preds = %if.then.i.i, %if.end8.i
  %31 = ptrtoint ptr %7 to i32
  call void @__asan_store4_noabort(i32 %31)
  store ptr null, ptr %7, align 4
  br label %drain_stock.exit

drain_stock.exit:                                 ; preds = %css_put.exit.i, %if.end27
  %flags28 = getelementptr inbounds %struct.memcg_stock_pcp, ptr %7, i32 0, i32 5
  tail call void @_clear_bit(i32 noundef 0, ptr noundef %flags28) #23
  br i1 %tobool.not, label %if.then38, label %do.body40

if.then38:                                        ; preds = %drain_stock.exit
  tail call void @trace_hardirqs_on() #23
  br label %do.body40

do.body40:                                        ; preds = %if.then38, %drain_stock.exit
  %32 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i72 = and i32 %32, 128
  %tobool48.not = icmp eq i32 %and.i.i72, 0
  br i1 %tobool48.not, label %if.then52, label %do.end55, !prof !466

if.then52:                                        ; preds = %do.body40
  tail call void @warn_bogus_irq_restore() #23
  br label %do.end55

do.end55:                                         ; preds = %if.then52, %do.body40
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %0) #23, !srcloc !467
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @_clear_bit(i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @queue_work_on(i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @kick_process(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @mem_cgroup_shrink_node(ptr noundef, i32 noundef, i1 noundef zeroext, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @rb_prev(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @rb_erase(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @rb_insert_color(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @_raw_spin_unlock_irq(ptr noundef) local_unnamed_addr #4 section ".spinlock.text"

; Function Attrs: null_pointer_is_valid
declare dso_local i64 @eventfd_signal(ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__traceiter_track_foreign_dirty(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @rcu_read_lock_sched_held() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__msecs_to_jiffies(i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__traceiter_flush_foreign(ptr noundef, ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @static_key_slow_inc(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @idr_alloc(ptr noundef, ptr noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid allocsize(0)
declare dso_local noalias ptr @__alloc_percpu_gfp(i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #15

; Function Attrs: null_pointer_is_valid
declare dso_local void @__init_work(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @high_work_func(ptr noundef %work) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %work, i32 -400
  %0 = tail call fastcc i32 @reclaim_high(ptr noundef %add.ptr, i32 noundef 32)
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @__mutex_init(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @__raw_spin_lock_init(ptr noundef, ptr noundef, ptr noundef, i16 noundef signext) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @vmpressure_init(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @idr_replace(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @lruvec_init(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @wb_domain_init(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @lockdep_init_map_type(ptr noundef, ptr noundef, ptr noundef, i32 noundef, i8 noundef zeroext, i8 noundef zeroext, i8 noundef zeroext) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @free_percpu(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @static_key_enable(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @ida_alloc_range(ptr noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @down_write(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @memcg_update_all_list_lrus(i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @up_write(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @ida_free(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @percpu_ref_init(ptr noundef, ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @obj_cgroup_release(ptr noundef %ref) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %nr_charged_bytes = getelementptr inbounds %struct.obj_cgroup, ptr %ref, i32 0, i32 2
  %call.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %nr_charged_bytes, i32 noundef 4) #23
  %0 = ptrtoint ptr %nr_charged_bytes to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile i32, ptr %nr_charged_bytes, align 4
  %and = and i32 %1, 4095
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end29, label %land.rhs

land.rhs:                                         ; preds = %entry
  %.b67 = load i1, ptr @obj_cgroup_release.__already_done, align 1
  br i1 %.b67, label %if.end29, label %if.then, !prof !460

if.then:                                          ; preds = %land.rhs
  store i1 true, ptr @obj_cgroup_release.__already_done, align 1
  tail call void (ptr, i32, i32, ptr, ...) @warn_slowpath_fmt(ptr noundef nonnull @.str.1, i32 noundef 295, i32 noundef 9, ptr noundef null) #23
  br label %if.end29

if.end29:                                         ; preds = %if.then, %land.rhs, %entry
  %tobool37.not = icmp ult i32 %1, 4096
  br i1 %tobool37.not, label %do.body41, label %if.then38

if.then38:                                        ; preds = %if.end29
  %shr = lshr i32 %1, 12
  %call.i = tail call fastcc ptr @get_mem_cgroup_from_objcg(ptr noundef %ref) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@obj_cgroup_release, %if.then.i)) #23
          to label %if.end.i [label %if.then.i], !srcloc !461

if.then.i:                                        ; preds = %if.then38
  %kmem.i = getelementptr inbounds %struct.mem_cgroup, ptr %call.i, i32 0, i32 4
  tail call void @page_counter_uncharge(ptr noundef %kmem.i, i32 noundef %shr) #23
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.then38
  tail call fastcc void @refill_stock(ptr noundef %call.i, i32 noundef %shr) #23
  %flags.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call.i, i32 0, i32 7
  %2 = ptrtoint ptr %flags.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %flags.i.i, align 4
  %and.i.i = and i32 %3, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.then.i.i, label %do.body41

if.then.i.i:                                      ; preds = %if.end.i
  %refcnt.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call.i, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i.i) #23
  br label %do.body41

do.body41:                                        ; preds = %if.then.i.i, %if.end.i, %if.end29
  %call44 = tail call i32 @_raw_spin_lock_irqsave(ptr noundef nonnull @objcg_lock) #23
  %4 = getelementptr inbounds %struct.obj_cgroup, ptr %ref, i32 0, i32 3
  %call.i.i68 = tail call zeroext i1 @__list_del_entry_valid(ptr noundef %4) #23
  br i1 %call.i.i68, label %if.end.i.i, label %list_del.exit

if.end.i.i:                                       ; preds = %do.body41
  %prev.i.i = getelementptr inbounds %struct.obj_cgroup, ptr %ref, i32 0, i32 3, i32 0, i32 1
  %5 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %prev.i.i, align 4
  %7 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %4, align 4
  %prev1.i.i.i = getelementptr inbounds %struct.list_head, ptr %8, i32 0, i32 1
  %9 = ptrtoint ptr %prev1.i.i.i to i32
  call void @__asan_store4_noabort(i32 %9)
  store ptr %6, ptr %prev1.i.i.i, align 4
  %10 = ptrtoint ptr %6 to i32
  call void @__asan_store4_noabort(i32 %10)
  store volatile ptr %8, ptr %6, align 4
  br label %list_del.exit

list_del.exit:                                    ; preds = %if.end.i.i, %do.body41
  %11 = ptrtoint ptr %4 to i32
  call void @__asan_store4_noabort(i32 %11)
  store ptr inttoptr (i32 256 to ptr), ptr %4, align 4
  %prev.i = getelementptr inbounds %struct.obj_cgroup, ptr %ref, i32 0, i32 3, i32 0, i32 1
  %12 = ptrtoint ptr %prev.i to i32
  call void @__asan_store4_noabort(i32 %12)
  store ptr inttoptr (i32 290 to ptr), ptr %prev.i, align 4
  tail call void @_raw_spin_unlock_irqrestore(ptr noundef nonnull @objcg_lock, i32 noundef %call44) #23
  tail call void @percpu_ref_exit(ptr noundef %ref) #23
  %tobool50.not = icmp eq ptr %ref, null
  br i1 %tobool50.not, label %if.end55, label %do.end54

do.end54:                                         ; preds = %list_del.exit
  tail call void @kvfree_call_rcu(ptr noundef %4, ptr noundef nonnull inttoptr (i32 16 to ptr)) #23
  br label %if.end55

if.end55:                                         ; preds = %do.end54, %list_del.exit
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @percpu_ref_exit(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @kvfree_call_rcu(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @__list_del_entry_valid(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @idr_remove(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @wb_domain_exit(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @alloc_shrinker_info(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @queue_delayed_work_on(i32 noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @flush_memcg_stats_dwork(ptr nocapture noundef readnone %w) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call fastcc void @__mem_cgroup_flush_stats()
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @system_unbound_wq to i32))
  %0 = load ptr, ptr @system_unbound_wq, align 4
  %call.i = tail call zeroext i1 @queue_delayed_work_on(i32 noundef 4, ptr noundef %0, ptr noundef nonnull @stats_flush_dwork, i32 noundef 200) #23
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @delayed_work_timer_fn(ptr noundef) #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @page_counter_set_min(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @page_counter_set_low(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @memcg_offline_kmem(ptr noundef %memcg) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %kmemcg_id1 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 32
  %0 = ptrtoint ptr %kmemcg_id1 to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %kmemcg_id1, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2, i32 13
  %2 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %parent.i, align 4
  %tobool.not.i = icmp eq ptr %3, null
  %add.ptr.i = getelementptr i8, ptr %3, i32 -176
  %tobool.not26 = icmp eq ptr %add.ptr.i, null
  %tobool.not = or i1 %tobool.not.i, %tobool.not26
  br i1 %tobool.not, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr @root_mem_cgroup, align 4
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %parent.0 = phi ptr [ %add.ptr.i, %if.end ], [ %4, %if.then2 ]
  %objcg1.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 33
  %5 = ptrtoint ptr %objcg1.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %objcg1.i, align 8
  store volatile ptr null, ptr %objcg1.i, align 8
  tail call void @_raw_spin_lock_irq(ptr noundef nonnull @objcg_lock) #23
  %7 = getelementptr inbounds %struct.obj_cgroup, ptr %6, i32 0, i32 3
  %objcg_list.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 34
  %8 = ptrtoint ptr %objcg_list.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %objcg_list.i, align 4
  %call.i.i.i = tail call zeroext i1 @__list_add_valid(ptr noundef %7, ptr noundef %objcg_list.i, ptr noundef %9) #23
  br i1 %call.i.i.i, label %if.end.i.i.i, label %list_add.exit.i

if.end.i.i.i:                                     ; preds = %if.end3
  %prev1.i.i.i = getelementptr inbounds %struct.list_head, ptr %9, i32 0, i32 1
  %10 = ptrtoint ptr %prev1.i.i.i to i32
  call void @__asan_store4_noabort(i32 %10)
  store ptr %7, ptr %prev1.i.i.i, align 4
  %11 = ptrtoint ptr %7 to i32
  call void @__asan_store4_noabort(i32 %11)
  store ptr %9, ptr %7, align 4
  %prev3.i.i.i = getelementptr inbounds %struct.obj_cgroup, ptr %6, i32 0, i32 3, i32 0, i32 1
  %12 = ptrtoint ptr %prev3.i.i.i to i32
  call void @__asan_store4_noabort(i32 %12)
  store ptr %objcg_list.i, ptr %prev3.i.i.i, align 4
  %13 = ptrtoint ptr %objcg_list.i to i32
  call void @__asan_store4_noabort(i32 %13)
  store volatile ptr %7, ptr %objcg_list.i, align 4
  br label %list_add.exit.i

list_add.exit.i:                                  ; preds = %if.end.i.i.i, %if.end3
  %14 = ptrtoint ptr %objcg_list.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %.pn71.i = load ptr, ptr %objcg_list.i, align 4
  %cmp41.not72.i = icmp eq ptr %.pn71.i, %objcg_list.i
  br i1 %cmp41.not72.i, label %for.end.i, label %do.body46.i

do.body46.i:                                      ; preds = %do.body46.i, %list_add.exit.i
  %.pn73.i = phi ptr [ %.pn.i, %do.body46.i ], [ %.pn71.i, %list_add.exit.i ]
  %memcg47.i = getelementptr i8, ptr %.pn73.i, i32 -8
  %15 = ptrtoint ptr %memcg47.i to i32
  call void @__asan_store4_noabort(i32 %15)
  store volatile ptr %parent.0, ptr %memcg47.i, align 4
  %16 = ptrtoint ptr %.pn73.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %.pn.i = load ptr, ptr %.pn73.i, align 4
  %cmp41.not.i = icmp eq ptr %.pn.i, %objcg_list.i
  br i1 %cmp41.not.i, label %for.end.i, label %do.body46.i

for.end.i:                                        ; preds = %do.body46.i, %list_add.exit.i
  %17 = ptrtoint ptr %objcg_list.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load volatile ptr, ptr %objcg_list.i, align 4
  %cmp.i.not.i.i = icmp eq ptr %18, %objcg_list.i
  br i1 %cmp.i.not.i.i, label %memcg_reparent_objcgs.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %for.end.i
  %objcg_list57.i = getelementptr inbounds %struct.mem_cgroup, ptr %parent.0, i32 0, i32 34
  %19 = ptrtoint ptr %objcg_list57.i to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %objcg_list57.i, align 4
  %prev2.i.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 34, i32 1
  %21 = ptrtoint ptr %prev2.i.i.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %prev2.i.i.i, align 4
  %prev3.i.i70.i = getelementptr inbounds %struct.list_head, ptr %18, i32 0, i32 1
  %23 = ptrtoint ptr %prev3.i.i70.i to i32
  call void @__asan_store4_noabort(i32 %23)
  store ptr %objcg_list57.i, ptr %prev3.i.i70.i, align 4
  store ptr %18, ptr %objcg_list57.i, align 4
  %24 = ptrtoint ptr %22 to i32
  call void @__asan_store4_noabort(i32 %24)
  store ptr %20, ptr %22, align 4
  %prev6.i.i.i = getelementptr inbounds %struct.list_head, ptr %20, i32 0, i32 1
  %25 = ptrtoint ptr %prev6.i.i.i to i32
  call void @__asan_store4_noabort(i32 %25)
  store ptr %22, ptr %prev6.i.i.i, align 4
  br label %memcg_reparent_objcgs.exit

memcg_reparent_objcgs.exit:                       ; preds = %if.then.i.i, %for.end.i
  tail call void @_raw_spin_unlock_irq(ptr noundef nonnull @objcg_lock) #23
  tail call void @percpu_ref_kill_and_confirm(ptr noundef %6, ptr noundef null) #23
  %26 = ptrtoint ptr %kmemcg_id1 to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %kmemcg_id1, align 4
  %cmp5 = icmp slt i32 %27, 0
  br i1 %cmp5, label %do.body9, label %do.end15, !prof !466

do.body9:                                         ; preds = %memcg_reparent_objcgs.exit
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 3669, 0\0A.popsection", ""() #23, !srcloc !552
  unreachable

do.end15:                                         ; preds = %memcg_reparent_objcgs.exit
  tail call void @memcg_drain_all_list_lrus(i32 noundef %27, ptr noundef %parent.0) #23
  tail call void @ida_free(ptr noundef nonnull @memcg_cache_ida, i32 noundef %27) #23
  %28 = ptrtoint ptr %kmemcg_id1 to i32
  call void @__asan_store4_noabort(i32 %28)
  store i32 -1, ptr %kmemcg_id1, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end15, %entry
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @reparent_shrinker_deferred(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @wb_memcg_offline(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @memcg_drain_all_list_lrus(i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @__list_add_valid(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @percpu_ref_kill_and_confirm(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @wb_wait_for_completion(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @static_key_slow_dec(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @vmpressure_cleanup(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @cancel_work_sync(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @free_shrinker_info(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @page_counter_set_max(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @cgroup_taskset_first(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @cgroup_taskset_next(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @get_task_mm(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @mmput(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @mem_cgroup_count_precharge(ptr noundef %mm) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_mmap_lock_start_locking, i32 0, i32 1), ptr blockaddress(@mem_cgroup_count_precharge, %if.then.i.i)) #23
          to label %__mmap_lock_trace_start_locking.exit.i [label %if.then.i.i], !srcloc !461

if.then.i.i:                                      ; preds = %entry
  tail call void @__mmap_lock_do_trace_start_locking(ptr noundef %mm, i1 noundef zeroext false) #23
  br label %__mmap_lock_trace_start_locking.exit.i

__mmap_lock_trace_start_locking.exit.i:           ; preds = %if.then.i.i, %entry
  %mmap_lock.i = getelementptr inbounds %struct.anon.28, ptr %mm, i32 0, i32 15
  tail call void @down_read(ptr noundef %mmap_lock.i) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_mmap_lock_acquire_returned, i32 0, i32 1), ptr blockaddress(@mem_cgroup_count_precharge, %if.then.i3.i)) #23
          to label %mmap_read_lock.exit [label %if.then.i3.i], !srcloc !461

if.then.i3.i:                                     ; preds = %__mmap_lock_trace_start_locking.exit.i
  tail call void @__mmap_lock_do_trace_acquire_returned(ptr noundef %mm, i1 noundef zeroext false, i1 noundef zeroext true) #23
  br label %mmap_read_lock.exit

mmap_read_lock.exit:                              ; preds = %if.then.i3.i, %__mmap_lock_trace_start_locking.exit.i
  %highest_vm_end = getelementptr inbounds %struct.anon.28, ptr %mm, i32 0, i32 7
  %0 = ptrtoint ptr %highest_vm_end to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %highest_vm_end, align 8
  %call = tail call i32 @walk_page_range(ptr noundef %mm, i32 noundef 0, i32 noundef %1, ptr noundef nonnull @precharge_walk_ops, ptr noundef null) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_mmap_lock_released, i32 0, i32 1), ptr blockaddress(@mem_cgroup_count_precharge, %if.then.i.i4)) #23
          to label %mmap_read_unlock.exit [label %if.then.i.i4], !srcloc !461

if.then.i.i4:                                     ; preds = %mmap_read_lock.exit
  tail call void @__mmap_lock_do_trace_released(ptr noundef %mm, i1 noundef zeroext false) #23
  br label %mmap_read_unlock.exit

mmap_read_unlock.exit:                            ; preds = %if.then.i.i4, %mmap_read_lock.exit
  tail call void @up_read(ptr noundef %mmap_lock.i) #23
  %2 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 5), align 4
  store i32 0, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 5), align 4
  ret i32 %2
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @mem_cgroup_do_precharge(i32 noundef %count) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 3), align 4
  %1 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i = icmp eq ptr %1, %0
  br i1 %cmp.i.i, label %if.then, label %try_charge.exit

try_charge.exit:                                  ; preds = %entry
  %call1.i = tail call fastcc i32 @try_charge_memcg(ptr noundef %0, i32 noundef 2240, i32 noundef %count) #23
  %tobool.not = icmp eq i32 %call1.i, 0
  br i1 %tobool.not, label %if.then, label %while.cond.preheader

while.cond.preheader:                             ; preds = %try_charge.exit
  %tobool1.not22 = icmp eq i32 %count, 0
  br i1 %tobool1.not22, label %cleanup, label %while.body

if.then:                                          ; preds = %try_charge.exit, %entry
  %2 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 5), align 4
  %add = add i32 %2, %count
  store i32 %add, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 5), align 4
  br label %cleanup

while.body:                                       ; preds = %if.end5, %while.cond.preheader
  %dec23.in = phi i32 [ %dec23, %if.end5 ], [ %count, %while.cond.preheader ]
  %dec23 = add i32 %dec23.in, -1
  %3 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 3), align 4
  %4 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i12 = icmp eq ptr %4, %3
  br i1 %cmp.i.i12, label %if.end5, label %try_charge.exit16

try_charge.exit16:                                ; preds = %while.body
  %call1.i13 = tail call fastcc i32 @try_charge_memcg(ptr noundef %3, i32 noundef 68800, i32 noundef 1) #23
  %tobool3.not = icmp eq i32 %call1.i13, 0
  br i1 %tobool3.not, label %if.end5, label %cleanup

if.end5:                                          ; preds = %try_charge.exit16, %while.body
  %5 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 5), align 4
  %inc = add i32 %5, 1
  store i32 %inc, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 5), align 4
  tail call void @__might_resched(ptr noundef nonnull @.str.1, i32 noundef 5458, i32 noundef 0) #23
  %call.i = tail call i32 @__cond_resched() #23
  %tobool1.not = icmp eq i32 %dec23, 0
  br i1 %tobool1.not, label %cleanup, label %while.body

cleanup:                                          ; preds = %if.end5, %try_charge.exit16, %if.then, %while.cond.preheader
  %retval.0 = phi i32 [ 0, %if.then ], [ 0, %while.cond.preheader ], [ %call1.i13, %try_charge.exit16 ], [ 0, %if.end5 ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @walk_page_range(ptr noundef, i32 noundef, i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @__mmap_lock_do_trace_start_locking(ptr noundef, i1 noundef zeroext) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @__mmap_lock_do_trace_acquire_returned(ptr noundef, i1 noundef zeroext, i1 noundef zeroext) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @mem_cgroup_count_precharge_pte_range(ptr nocapture noundef readonly %pmd, i32 noundef %addr, i32 noundef %end, ptr nocapture noundef readonly %walk) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %vma1 = getelementptr inbounds %struct.mm_walk, ptr %walk, i32 0, i32 3
  %0 = ptrtoint ptr %vma1 to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %vma1, align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @mem_map to i32))
  %2 = load ptr, ptr @mem_map, align 4
  %3 = ptrtoint ptr %pmd to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load i32, ptr %pmd, align 4
  %shr.i = lshr i32 %4, 12
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__pv_phys_pfn_offset to i32))
  %5 = load i32, ptr @__pv_phys_pfn_offset, align 4
  %sub.i = sub i32 %shr.i, %5
  %ptl.i.i = getelementptr %struct.page, ptr %2, i32 %sub.i, i32 1, i32 0, i32 3
  %6 = ptrtoint ptr %ptl.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %ptl.i.i, align 4
  %add.ptr = getelementptr %struct.page, ptr %2, i32 %sub.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @pgprot_kernel to i32))
  %8 = load i32, ptr @pgprot_kernel, align 4
  %or.i = or i32 %8, 512
  %9 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %9, -16384
  %10 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %10, i32 0, i32 1
  %11 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %12, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !553
  %13 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i1.i.i = and i32 %13, -16384
  %14 = inttoptr i32 %and.i.i.i1.i.i to ptr
  %task.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %14, i32 0, i32 2
  %15 = ptrtoint ptr %task.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load ptr, ptr %task.i.i.i.i, align 8
  %pagefault_disabled.i.i.i.i = getelementptr inbounds %struct.task_struct, ptr %16, i32 0, i32 213
  %17 = ptrtoint ptr %pagefault_disabled.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %pagefault_disabled.i.i.i.i, align 8
  %inc.i.i.i.i = add i32 %18, 1
  store i32 %inc.i.i.i.i, ptr %pagefault_disabled.i.i.i.i, align 8
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !554
  %call.i.i = tail call ptr @__kmap_local_page_prot(ptr noundef %add.ptr, i32 noundef %or.i) #23
  %shr.i51 = lshr i32 %addr, 12
  %and.i = and i32 %shr.i51, 511
  %add.ptr13 = getelementptr i32, ptr %call.i.i, i32 %and.i
  tail call void @_raw_spin_lock(ptr noundef %7) #23
  %cmp15.not52 = icmp eq i32 %addr, %end
  br i1 %cmp15.not52, label %do.body21, label %for.body

for.body:                                         ; preds = %for.inc, %entry
  %addr.addr.054 = phi i32 [ %add20, %for.inc ], [ %addr, %entry ]
  %pte.053 = phi ptr [ %incdec.ptr, %for.inc ], [ %add.ptr13, %entry ]
  %19 = ptrtoint ptr %pte.053 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %pte.053, align 4
  %call16 = tail call fastcc i32 @get_mctgt_type(ptr noundef %1, i32 noundef %addr.addr.054, i32 noundef %20, ptr noundef null)
  %tobool17.not = icmp eq i32 %call16, 0
  br i1 %tobool17.not, label %for.inc, label %if.then18

if.then18:                                        ; preds = %for.body
  %21 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 5), align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 5), align 4
  br label %for.inc

for.inc:                                          ; preds = %if.then18, %for.body
  %incdec.ptr = getelementptr i32, ptr %pte.053, i32 1
  %add20 = add i32 %addr.addr.054, 4096
  %cmp15.not = icmp eq i32 %add20, %end
  br i1 %cmp15.not, label %do.body21, label %for.body

do.body21:                                        ; preds = %for.inc, %entry
  %pte.0.lcssa = phi ptr [ %add.ptr13, %entry ], [ %incdec.ptr, %for.inc ]
  tail call void @_raw_spin_unlock(ptr noundef %7) #23
  %add.ptr26 = getelementptr i32, ptr %pte.0.lcssa, i32 -1
  tail call void @kunmap_local_indexed(ptr noundef %add.ptr26) #23
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !555
  %22 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i1.i = and i32 %22, -16384
  %23 = inttoptr i32 %and.i.i.i1.i to ptr
  %task.i.i.i = getelementptr inbounds %struct.thread_info, ptr %23, i32 0, i32 2
  %24 = ptrtoint ptr %task.i.i.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %task.i.i.i, align 8
  %pagefault_disabled.i.i.i = getelementptr inbounds %struct.task_struct, ptr %25, i32 0, i32 213
  %26 = ptrtoint ptr %pagefault_disabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %pagefault_disabled.i.i.i, align 8
  %dec.i.i.i = add i32 %27, -1
  store i32 %dec.i.i.i, ptr %pagefault_disabled.i.i.i, align 8
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !556
  %28 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i = and i32 %28, -16384
  %29 = inttoptr i32 %and.i.i.i.i to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %29, i32 0, i32 1
  %30 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %sub.i.i = add i32 %31, -1
  store volatile i32 %sub.i.i, ptr %preempt_count.i.i.i, align 4
  tail call void @__might_resched(ptr noundef nonnull @.str.1, i32 noundef 5816, i32 noundef 0) #23
  %call.i = tail call i32 @__cond_resched() #23
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @get_mctgt_type(ptr noundef %vma, i32 noundef %addr, i32 noundef %ptent, ptr noundef writeonly %target) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %and = and i32 %ptent, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call fastcc ptr @mc_handle_present_pte(ptr noundef %vma, i32 noundef %addr, i32 noundef %ptent)
  br label %if.end13

if.else:                                          ; preds = %entry
  %tobool.not.i = icmp eq i32 %ptent, 0
  br i1 %tobool.not.i, label %if.then10, label %if.then6

if.then6:                                         ; preds = %if.else
  %shr3.i.i = lshr i32 %ptent, 7
  %0 = shl i32 %ptent, 24
  %shl.i.i.i = and i32 %0, 2080374784
  %or.i.i.i = or i32 %shl.i.i.i, %shr3.i.i
  %1 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 4), align 4
  %and.i78 = and i32 %1, 1
  %tobool.not.i79 = icmp ne i32 %and.i78, 0
  %cmp.i.i = icmp ult i32 %or.i.i.i, 2013265920
  %or.cond.i = and i1 %cmp.i.i, %tobool.not.i79
  br i1 %or.cond.i, label %if.end15.i, label %cleanup

if.end15.i:                                       ; preds = %if.then6
  %shr.i.i = lshr exact i32 %shl.i.i.i, 26
  %arrayidx.i = getelementptr [0 x ptr], ptr @swapper_spaces, i32 0, i32 %shr.i.i
  %2 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %arrayidx.i, align 4
  %shr.i = lshr i32 %ptent, 21
  %arrayidx20.i = getelementptr %struct.address_space, ptr %3, i32 %shr.i
  %call.i.i = tail call ptr @pagecache_get_page(ptr noundef %arrayidx20.i, i32 noundef %shr3.i.i, i32 noundef 0, i32 noundef 0) #23
  br label %if.end13

if.then10:                                        ; preds = %if.else
  %vm_file.i = getelementptr inbounds %struct.vm_area_struct, ptr %vma, i32 0, i32 14
  %4 = ptrtoint ptr %vm_file.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %vm_file.i, align 4
  %tobool.not.i80 = icmp eq ptr %5, null
  br i1 %tobool.not.i80, label %cleanup, label %if.end.i

if.end.i:                                         ; preds = %if.then10
  %6 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 4), align 4
  %and.i81 = and i32 %6, 2
  %tobool1.not.i = icmp eq i32 %and.i81, 0
  br i1 %tobool1.not.i, label %cleanup, label %if.end3.i

if.end3.i:                                        ; preds = %if.end.i
  %f_mapping.i = getelementptr inbounds %struct.file, ptr %5, i32 0, i32 18
  %7 = ptrtoint ptr %f_mapping.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %f_mapping.i, align 4
  %9 = ptrtoint ptr %vma to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %vma, align 4
  %sub.i.i = sub i32 %addr, %10
  %shr.i.i82 = lshr i32 %sub.i.i, 12
  %vm_pgoff.i.i = getelementptr inbounds %struct.vm_area_struct, ptr %vma, i32 0, i32 13
  %11 = ptrtoint ptr %vm_pgoff.i.i to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %vm_pgoff.i.i, align 4
  %add.i.i = add i32 %shr.i.i82, %12
  %call5.i = tail call ptr @find_get_incore_page(ptr noundef %8, i32 noundef %add.i.i) #23
  br label %if.end13

if.end13:                                         ; preds = %if.end3.i, %if.end15.i, %if.then
  %ent.sroa.0.1 = phi i32 [ 0, %if.then ], [ %or.i.i.i, %if.end15.i ], [ 0, %if.end3.i ]
  %page.0 = phi ptr [ %call, %if.then ], [ %call.i.i, %if.end15.i ], [ %call5.i, %if.end3.i ]
  %tobool14.not = icmp eq ptr %page.0, null
  br i1 %tobool14.not, label %land.lhs.true, label %if.then19.critedge

land.lhs.true:                                    ; preds = %if.end13
  %tobool15.not = icmp eq i32 %ent.sroa.0.1, 0
  br i1 %tobool15.not, label %cleanup, label %land.lhs.true43

if.then19.critedge:                               ; preds = %if.end13
  %13 = getelementptr inbounds %struct.page, ptr %page.0, i32 0, i32 1
  %14 = ptrtoint ptr %13 to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %13, align 4
  %and.i.i = and i32 %15, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.end.i.i, label %if.then.i.i, !prof !460

if.then.i.i:                                      ; preds = %if.then19.critedge
  %sub.i.i84 = add i32 %15, -1
  br label %page_memcg.exit

if.end.i.i:                                       ; preds = %if.then19.critedge
  %16 = ptrtoint ptr %page.0 to i32
  br label %page_memcg.exit

page_memcg.exit:                                  ; preds = %if.end.i.i, %if.then.i.i
  %retval.0.i.i = phi i32 [ %sub.i.i84, %if.then.i.i ], [ %16, %if.end.i.i ]
  %17 = inttoptr i32 %retval.0.i.i to ptr
  %call1.i = tail call fastcc ptr @folio_memcg(ptr noundef %17) #23
  %18 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 2), align 4
  %cmp = icmp eq ptr %call1.i, %18
  br i1 %cmp, label %if.then21, label %if.then31

if.then21:                                        ; preds = %page_memcg.exit
  %tobool25.not = icmp eq ptr %target, null
  br i1 %tobool25.not, label %if.then31, label %if.end33.thread

if.then31:                                        ; preds = %if.then21, %page_memcg.exit
  %ret.1113 = phi i32 [ 0, %page_memcg.exit ], [ 1, %if.then21 ]
  %19 = ptrtoint ptr %13 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load volatile i32, ptr %13, align 4
  %and.i.i85 = and i32 %20, 1
  %tobool.not.i.i86 = icmp eq i32 %and.i.i85, 0
  br i1 %tobool.not.i.i86, label %if.end.i.i89, label %if.then.i.i88, !prof !460

if.then.i.i88:                                    ; preds = %if.then31
  %sub.i.i87 = add i32 %20, -1
  br label %_compound_head.exit.i

if.end.i.i89:                                     ; preds = %if.then31
  %21 = ptrtoint ptr %page.0 to i32
  br label %_compound_head.exit.i

_compound_head.exit.i:                            ; preds = %if.end.i.i89, %if.then.i.i88
  %retval.0.i.i90 = phi i32 [ %sub.i.i87, %if.then.i.i88 ], [ %21, %if.end.i.i89 ]
  %22 = inttoptr i32 %retval.0.i.i90 to ptr
  %_refcount.i.i.i.i.i = getelementptr inbounds %struct.page, ptr %22, i32 0, i32 3
  %call.i.i.i.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %_refcount.i.i.i.i.i, i32 noundef 4) #23
  %23 = ptrtoint ptr %_refcount.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load volatile i32, ptr %_refcount.i.i.i.i.i, align 4
  %cmp.i.i.i.i = icmp eq i32 %24, 0
  br i1 %cmp.i.i.i.i, label %if.then.i.i.i.i, label %do.end5.i.i.i.i, !prof !466

if.then.i.i.i.i:                                  ; preds = %_compound_head.exit.i
  tail call void @dump_page(ptr noundef %22, ptr noundef nonnull @.str.122) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/mm.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 717, 0\0A.popsection", ""() #23, !srcloc !557
  unreachable

do.end5.i.i.i.i:                                  ; preds = %_compound_head.exit.i
  %call.i.i.i10.i.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %_refcount.i.i.i.i.i, i32 noundef 4) #23
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !545
  tail call void @llvm.prefetch.p0(ptr %_refcount.i.i.i.i.i, i32 1, i32 3, i32 1) #23
  %25 = tail call { i32, i32 } asm sideeffect "@ atomic_sub_return\0A1:\09ldrex\09$0, [$3]\0A\09sub\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %_refcount.i.i.i.i.i, ptr %_refcount.i.i.i.i.i, i32 1, ptr elementtype(i32) %_refcount.i.i.i.i.i) #23, !srcloc !546
  %asmresult.i.i.i.i.i.i.i.i.i.i = extractvalue { i32, i32 } %25, 0
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !547
  %cmp.i.i.i.i.i.i.i = icmp eq i32 %asmresult.i.i.i.i.i.i.i.i.i.i, 0
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_page_ref_mod_and_test, i32 0, i32 1), ptr blockaddress(@get_mctgt_type, %if.then.i.i.i.i.i)) #23
          to label %folio_put_testzero.exit.i.i [label %if.then.i.i.i.i.i], !srcloc !461

if.then.i.i.i.i.i:                                ; preds = %do.end5.i.i.i.i
  %conv.i.i.i.i.i = zext i1 %cmp.i.i.i.i.i.i.i to i32
  tail call void @__page_ref_mod_and_test(ptr noundef %22, i32 noundef -1, i32 noundef %conv.i.i.i.i.i) #23
  br label %folio_put_testzero.exit.i.i

folio_put_testzero.exit.i.i:                      ; preds = %if.then.i.i.i.i.i, %do.end5.i.i.i.i
  br i1 %cmp.i.i.i.i.i.i.i, label %if.then.i4.i, label %if.end33

if.then.i4.i:                                     ; preds = %folio_put_testzero.exit.i.i
  tail call void @__put_page(ptr noundef %22) #23
  br label %if.end33

if.end33:                                         ; preds = %if.then.i4.i, %folio_put_testzero.exit.i.i
  %tobool35.not = icmp eq i32 %ent.sroa.0.1, 0
  %brmerge = select i1 %tobool35.not, i1 true, i1 %cmp
  %ret.1113.mux = select i1 %tobool35.not, i32 %ret.1113, i32 1
  br i1 %brmerge, label %cleanup, label %land.lhs.true43

if.end33.thread:                                  ; preds = %if.then21
  %26 = ptrtoint ptr %target to i32
  call void @__asan_store4_noabort(i32 %26)
  store ptr %page.0, ptr %target, align 4
  br label %cleanup

land.lhs.true43:                                  ; preds = %if.end33, %land.lhs.true
  %27 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 2), align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@get_mctgt_type, %mem_cgroup_id.exit)) #23
          to label %if.end.i91 [label %mem_cgroup_id.exit], !srcloc !461

if.end.i91:                                       ; preds = %land.lhs.true43
  %id.i = getelementptr inbounds %struct.mem_cgroup, ptr %27, i32 0, i32 1
  %28 = ptrtoint ptr %id.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %id.i, align 8
  %conv.i = trunc i32 %29 to i16
  br label %mem_cgroup_id.exit

mem_cgroup_id.exit:                               ; preds = %if.end.i91, %land.lhs.true43
  %retval.0.i92 = phi i16 [ %conv.i, %if.end.i91 ], [ 0, %land.lhs.true43 ]
  %.fca.0.insert = insertvalue [1 x i32] poison, i32 %ent.sroa.0.1, 0
  %call45 = tail call zeroext i16 @lookup_swap_cgroup_id([1 x i32] %.fca.0.insert) #23
  %cmp47 = icmp eq i16 %retval.0.i92, %call45
  br i1 %cmp47, label %if.then49, label %cleanup

if.then49:                                        ; preds = %mem_cgroup_id.exit
  %tobool50.not = icmp eq ptr %target, null
  br i1 %tobool50.not, label %cleanup, label %if.then51

if.then51:                                        ; preds = %if.then49
  %30 = ptrtoint ptr %target to i32
  call void @__asan_store4_noabort(i32 %30)
  store i32 %ent.sroa.0.1, ptr %target, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.then51, %if.then49, %mem_cgroup_id.exit, %if.end33.thread, %if.end33, %land.lhs.true, %if.end.i, %if.then10, %if.then6
  %retval.0 = phi i32 [ 0, %land.lhs.true ], [ 2, %if.then51 ], [ 2, %if.then49 ], [ 0, %mem_cgroup_id.exit ], [ %ret.1113.mux, %if.end33 ], [ 0, %if.end.i ], [ 0, %if.then10 ], [ 0, %if.then6 ], [ 1, %if.end33.thread ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @__might_resched(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @__kmap_local_page_prot(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc ptr @mc_handle_present_pte(ptr noundef %vma, i32 noundef %addr, i32 noundef %ptent) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call ptr @vm_normal_page(ptr noundef %vma, i32 noundef %addr, i32 noundef %ptent) #23
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %call1 = tail call zeroext i1 @page_mapped(ptr noundef nonnull %call) #23
  br i1 %call1, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %0 = getelementptr inbounds %struct.page, ptr %call, i32 0, i32 1
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %0, align 4
  %and.i2.i = and i32 %2, 1
  %tobool.not.i.i = icmp eq i32 %and.i2.i, 0
  br i1 %tobool.not.i.i, label %if.end.i.i, label %if.then.i.i, !prof !460

if.then.i.i:                                      ; preds = %if.end
  %sub.i.i = add i32 %2, -1
  br label %PageAnon.exit

if.end.i.i:                                       ; preds = %if.end
  %3 = ptrtoint ptr %call to i32
  br label %PageAnon.exit

PageAnon.exit:                                    ; preds = %if.end.i.i, %if.then.i.i
  %retval.0.i.i = phi i32 [ %sub.i.i, %if.then.i.i ], [ %3, %if.end.i.i ]
  %4 = inttoptr i32 %retval.0.i.i to ptr
  %mapping.i.i = getelementptr inbounds %struct.anon.153, ptr %4, i32 0, i32 2
  %5 = ptrtoint ptr %mapping.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %mapping.i.i, align 4
  %7 = ptrtoint ptr %6 to i32
  %and.i.i = and i32 %7, 1
  %cmp.i.i.not = icmp eq i32 %and.i.i, 0
  %8 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 4), align 4
  br i1 %cmp.i.i.not, label %if.else, label %if.then3

if.then3:                                         ; preds = %PageAnon.exit
  %and = and i32 %8, 1
  %tobool4.not = icmp eq i32 %and, 0
  br i1 %tobool4.not, label %cleanup, label %if.end11

if.else:                                          ; preds = %PageAnon.exit
  %and7 = and i32 %8, 2
  %tobool8.not = icmp eq i32 %and7, 0
  br i1 %tobool8.not, label %cleanup, label %if.end11

if.end11:                                         ; preds = %if.else, %if.then3
  %_refcount.i.i = getelementptr inbounds %struct.page, ptr %call, i32 0, i32 3
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %_refcount.i.i, i32 noundef 4) #23
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !523
  tail call void @llvm.prefetch.p0(ptr %_refcount.i.i, i32 1, i32 3, i32 1) #23
  %9 = tail call { i32, i32, i32 } asm sideeffect "@ atomic_add_unless\0A1:\09ldrex\09$0, [$4]\0A\09teq\09$0, $5\0A\09beq\092f\0A\09add\09$1, $0, $6\0A\09strex\09$2, $1, [$4]\0A\09teq\09$2, #0\0A\09bne\091b\0A2:", "=&r,=&r,=&r,=*Qo,r,r,r,*Qo,~{cc}"(ptr elementtype(i32) %_refcount.i.i, ptr %_refcount.i.i, i32 0, i32 1, ptr elementtype(i32) %_refcount.i.i) #23, !srcloc !524
  %asmresult.i.i.i.i.i = extractvalue { i32, i32, i32 } %9, 0
  %cmp.not.i.i.i.i.i = icmp eq i32 %asmresult.i.i.i.i.i, 0
  br i1 %cmp.not.i.i.i.i.i, label %atomic_add_unless.exit.i.i, label %do.end11.i.i.i.i.i

do.end11.i.i.i.i.i:                               ; preds = %if.end11
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !525
  br label %atomic_add_unless.exit.i.i

atomic_add_unless.exit.i.i:                       ; preds = %do.end11.i.i.i.i.i, %if.end11
  %cmp.i.i.i.i = icmp ne i32 %asmresult.i.i.i.i.i, 0
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_page_ref_mod_unless, i32 0, i32 1), ptr blockaddress(@mc_handle_present_pte, %if.then.i.i19)) #23
          to label %get_page_unless_zero.exit [label %if.then.i.i19], !srcloc !461

if.then.i.i19:                                    ; preds = %atomic_add_unless.exit.i.i
  %conv.i.i = zext i1 %cmp.i.i.i.i to i32
  tail call void @__page_ref_mod_unless(ptr noundef nonnull %call, i32 noundef 1, i32 noundef %conv.i.i) #23
  br label %get_page_unless_zero.exit

get_page_unless_zero.exit:                        ; preds = %if.then.i.i19, %atomic_add_unless.exit.i.i
  %call. = select i1 %cmp.i.i.i.i, ptr %call, ptr null
  br label %cleanup

cleanup:                                          ; preds = %get_page_unless_zero.exit, %if.else, %if.then3, %lor.lhs.false, %entry
  %retval.0 = phi ptr [ null, %lor.lhs.false ], [ null, %entry ], [ null, %if.then3 ], [ null, %if.else ], [ %call., %get_page_unless_zero.exit ]
  ret ptr %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @vm_normal_page(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @page_mapped(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @__page_ref_mod_unless(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @pagecache_get_page(ptr noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @find_get_incore_page(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @__put_page(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @__page_ref_mod_and_test(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @kunmap_local_indexed(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__cond_resched() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @__mmap_lock_do_trace_released(ptr noundef, i1 noundef zeroext) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @__mem_cgroup_clear_mc() unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 2), align 4
  %1 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 3), align 4
  %2 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 5), align 4
  %tobool.not = icmp eq i32 %2, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i = icmp eq ptr %3, %1
  br i1 %cmp.i.i, label %cancel_charge.exit, label %if.end.i

if.end.i:                                         ; preds = %if.then
  %memory.i = getelementptr inbounds %struct.mem_cgroup, ptr %1, i32 0, i32 2
  tail call void @page_counter_uncharge(ptr noundef %memory.i, i32 noundef %2) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@__mem_cgroup_clear_mc, %land.rhs.i.i)) #23
          to label %cancel_charge.exit [label %land.rhs.i.i], !srcloc !461

land.rhs.i.i:                                     ; preds = %if.end.i
  %4 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool4.not.i.i, label %if.then2.i, label %cancel_charge.exit

if.then2.i:                                       ; preds = %land.rhs.i.i
  %5 = getelementptr inbounds %struct.mem_cgroup, ptr %1, i32 0, i32 3
  tail call void @page_counter_uncharge(ptr noundef %5, i32 noundef %2) #23
  br label %cancel_charge.exit

cancel_charge.exit:                               ; preds = %if.then2.i, %land.rhs.i.i, %if.end.i, %if.then
  store i32 0, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 5), align 4
  br label %if.end

if.end:                                           ; preds = %cancel_charge.exit, %entry
  %6 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 6), align 4
  %tobool1.not = icmp eq i32 %6, 0
  br i1 %tobool1.not, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  %7 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 2), align 4
  %8 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i13 = icmp eq ptr %8, %7
  br i1 %cmp.i.i13, label %cancel_charge.exit19, label %if.end.i15

if.end.i15:                                       ; preds = %if.then2
  %memory.i14 = getelementptr inbounds %struct.mem_cgroup, ptr %7, i32 0, i32 2
  tail call void @page_counter_uncharge(ptr noundef %memory.i14, i32 noundef %6) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@__mem_cgroup_clear_mc, %land.rhs.i.i17)) #23
          to label %cancel_charge.exit19 [label %land.rhs.i.i17], !srcloc !461

land.rhs.i.i17:                                   ; preds = %if.end.i15
  %9 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i16 = icmp eq i8 %9, 0
  br i1 %tobool4.not.i.i16, label %if.then2.i18, label %cancel_charge.exit19

if.then2.i18:                                     ; preds = %land.rhs.i.i17
  %10 = getelementptr inbounds %struct.mem_cgroup, ptr %7, i32 0, i32 3
  tail call void @page_counter_uncharge(ptr noundef %10, i32 noundef %6) #23
  br label %cancel_charge.exit19

cancel_charge.exit19:                             ; preds = %if.then2.i18, %land.rhs.i.i17, %if.end.i15, %if.then2
  store i32 0, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 6), align 4
  br label %if.end3

if.end3:                                          ; preds = %cancel_charge.exit19, %if.end
  %11 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 7), align 4
  %tobool4.not = icmp eq i32 %11, 0
  br i1 %tobool4.not, label %if.end11, label %if.then5

if.then5:                                         ; preds = %if.end3
  %12 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 2), align 4
  %13 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i = icmp eq ptr %13, %12
  br i1 %cmp.i, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.then5
  %14 = getelementptr inbounds %struct.mem_cgroup, ptr %12, i32 0, i32 3
  tail call void @page_counter_uncharge(ptr noundef %14, i32 noundef %11) #23
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.then5
  %15 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 2), align 4
  %16 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 7), align 4
  tail call fastcc void @mem_cgroup_id_put_many(ptr noundef %15, i32 noundef %16)
  %17 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 3), align 4
  %18 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i20 = icmp eq ptr %18, %17
  br i1 %cmp.i20, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end7
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %17, i32 0, i32 2
  %19 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 7), align 4
  tail call void @page_counter_uncharge(ptr noundef %memory, i32 noundef %19) #23
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end7
  store i32 0, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 7), align 4
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.end3
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %memcg_oom_recover.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end11
  %under_oom.i = getelementptr inbounds %struct.mem_cgroup, ptr %0, i32 0, i32 11
  %20 = ptrtoint ptr %under_oom.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load i32, ptr %under_oom.i, align 16
  %tobool1.not.i = icmp eq i32 %21, 0
  br i1 %tobool1.not.i, label %memcg_oom_recover.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  tail call void @__wake_up(ptr noundef nonnull @memcg_oom_waitq, i32 noundef 3, i32 noundef 0, ptr noundef nonnull %0) #23
  br label %memcg_oom_recover.exit

memcg_oom_recover.exit:                           ; preds = %if.then.i, %land.lhs.true.i, %if.end11
  %tobool.not.i22 = icmp eq ptr %1, null
  br i1 %tobool.not.i22, label %memcg_oom_recover.exit28, label %land.lhs.true.i25

land.lhs.true.i25:                                ; preds = %memcg_oom_recover.exit
  %under_oom.i23 = getelementptr inbounds %struct.mem_cgroup, ptr %1, i32 0, i32 11
  %22 = ptrtoint ptr %under_oom.i23 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load i32, ptr %under_oom.i23, align 16
  %tobool1.not.i24 = icmp eq i32 %23, 0
  br i1 %tobool1.not.i24, label %memcg_oom_recover.exit28, label %if.then.i26

if.then.i26:                                      ; preds = %land.lhs.true.i25
  tail call void @__wake_up(ptr noundef nonnull @memcg_oom_waitq, i32 noundef 3, i32 noundef 0, ptr noundef nonnull %1) #23
  br label %memcg_oom_recover.exit28

memcg_oom_recover.exit28:                         ; preds = %if.then.i26, %land.lhs.true.i25, %memcg_oom_recover.exit
  tail call void @__wake_up(ptr noundef getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 9), i32 noundef 3, i32 noundef 0, ptr noundef null) #23
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @mem_cgroup_move_charge() unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call void @lru_add_drain_all() #23
  %0 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 2), align 4
  %moving_account = getelementptr inbounds %struct.mem_cgroup, ptr %0, i32 0, i32 37
  %call.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %moving_account, i32 noundef 4) #23
  tail call void @llvm.prefetch.p0(ptr %moving_account, i32 1, i32 3, i32 1) #23
  %1 = tail call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %moving_account, ptr %moving_account, i32 1, ptr elementtype(i32) %moving_account) #23, !srcloc !468
  tail call void @synchronize_rcu() #23
  br label %retry

retry:                                            ; preds = %if.then, %entry
  %2 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 1), align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_mmap_lock_start_locking, i32 0, i32 1), ptr blockaddress(@mem_cgroup_move_charge, %if.then.i.i)) #23
          to label %__mmap_lock_trace_start_locking.exit.i [label %if.then.i.i], !srcloc !461

if.then.i.i:                                      ; preds = %retry
  tail call void @__mmap_lock_do_trace_start_locking(ptr noundef %2, i1 noundef zeroext false) #23
  br label %__mmap_lock_trace_start_locking.exit.i

__mmap_lock_trace_start_locking.exit.i:           ; preds = %if.then.i.i, %retry
  %mmap_lock.i = getelementptr inbounds %struct.anon.28, ptr %2, i32 0, i32 15
  %call.i = tail call i32 @down_read_trylock(ptr noundef %mmap_lock.i) #23
  %cmp.i = icmp ne i32 %call.i, 0
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_mmap_lock_acquire_returned, i32 0, i32 1), ptr blockaddress(@mem_cgroup_move_charge, %if.then.i5.i)) #23
          to label %mmap_read_trylock.exit [label %if.then.i5.i], !srcloc !461

if.then.i5.i:                                     ; preds = %__mmap_lock_trace_start_locking.exit.i
  tail call void @__mmap_lock_do_trace_acquire_returned(ptr noundef %2, i1 noundef zeroext false, i1 noundef zeroext %cmp.i) #23
  br label %mmap_read_trylock.exit

mmap_read_trylock.exit:                           ; preds = %if.then.i5.i, %__mmap_lock_trace_start_locking.exit.i
  br i1 %cmp.i, label %if.end, label %if.then, !prof !460

if.then:                                          ; preds = %mmap_read_trylock.exit
  tail call fastcc void @__mem_cgroup_clear_mc()
  tail call void @__might_resched(ptr noundef nonnull @.str.1, i32 noundef 6121, i32 noundef 0) #23
  %call.i7 = tail call i32 @__cond_resched() #23
  br label %retry

if.end:                                           ; preds = %mmap_read_trylock.exit
  %3 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 1), align 4
  %highest_vm_end = getelementptr inbounds %struct.anon.28, ptr %3, i32 0, i32 7
  %4 = ptrtoint ptr %highest_vm_end to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %highest_vm_end, align 8
  %call4 = tail call i32 @walk_page_range(ptr noundef %3, i32 noundef 0, i32 noundef %5, ptr noundef nonnull @charge_walk_ops, ptr noundef null) #23
  %6 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 1), align 4
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_mmap_lock_released, i32 0, i32 1), ptr blockaddress(@mem_cgroup_move_charge, %if.then.i.i8)) #23
          to label %mmap_read_unlock.exit [label %if.then.i.i8], !srcloc !461

if.then.i.i8:                                     ; preds = %if.end
  tail call void @__mmap_lock_do_trace_released(ptr noundef %6, i1 noundef zeroext false) #23
  br label %mmap_read_unlock.exit

mmap_read_unlock.exit:                            ; preds = %if.then.i.i8, %if.end
  %mmap_lock.i9 = getelementptr inbounds %struct.anon.28, ptr %6, i32 0, i32 15
  tail call void @up_read(ptr noundef %mmap_lock.i9) #23
  %7 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 2), align 4
  %moving_account5 = getelementptr inbounds %struct.mem_cgroup, ptr %7, i32 0, i32 37
  %call.i.i6 = tail call zeroext i1 @__kasan_check_write(ptr noundef %moving_account5, i32 noundef 4) #23
  tail call void @llvm.prefetch.p0(ptr %moving_account5, i32 1, i32 3, i32 1) #23
  %8 = tail call { i32, i32 } asm sideeffect "@ atomic_sub\0A1:\09ldrex\09$0, [$3]\0A\09sub\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %moving_account5, ptr %moving_account5, i32 1, ptr elementtype(i32) %moving_account5) #23, !srcloc !558
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @lru_add_drain_all() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @synchronize_rcu() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @down_read_trylock(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @mem_cgroup_move_charge_pte_range(ptr nocapture noundef readonly %pmd, i32 noundef %addr, i32 noundef %end, ptr nocapture noundef readonly %walk) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %target = alloca %union.mc_target, align 4
  %vma1 = getelementptr inbounds %struct.mm_walk, ptr %walk, i32 0, i32 3
  %0 = ptrtoint ptr %vma1 to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %vma1, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %target) #23
  %2 = ptrtoint ptr %target to i32
  call void @__asan_store4_noabort(i32 %2)
  store ptr inttoptr (i32 -1 to ptr), ptr %target, align 4, !annotation !492
  br label %retry

retry:                                            ; preds = %if.then105, %entry
  %addr.addr.0 = phi i32 [ %addr, %entry ], [ %addr.addr.1161, %if.then105 ]
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @mem_map to i32))
  %3 = load ptr, ptr @mem_map, align 4
  %4 = ptrtoint ptr %pmd to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %pmd, align 4
  %shr.i = lshr i32 %5, 12
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__pv_phys_pfn_offset to i32))
  %6 = load i32, ptr @__pv_phys_pfn_offset, align 4
  %sub.i = sub i32 %shr.i, %6
  %ptl.i.i = getelementptr %struct.page, ptr %3, i32 %sub.i, i32 1, i32 0, i32 3
  %7 = ptrtoint ptr %ptl.i.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %ptl.i.i, align 4
  %add.ptr = getelementptr %struct.page, ptr %3, i32 %sub.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @pgprot_kernel to i32))
  %9 = load i32, ptr @pgprot_kernel, align 4
  %or.i = or i32 %9, 512
  %10 = call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %10, -16384
  %11 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %11, i32 0, i32 1
  %12 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %13, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  call void asm sideeffect "", "~{memory}"() #23, !srcloc !553
  %14 = call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i1.i.i = and i32 %14, -16384
  %15 = inttoptr i32 %and.i.i.i1.i.i to ptr
  %task.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %15, i32 0, i32 2
  %16 = ptrtoint ptr %task.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load ptr, ptr %task.i.i.i.i, align 8
  %pagefault_disabled.i.i.i.i = getelementptr inbounds %struct.task_struct, ptr %17, i32 0, i32 213
  %18 = ptrtoint ptr %pagefault_disabled.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load i32, ptr %pagefault_disabled.i.i.i.i, align 8
  %inc.i.i.i.i = add i32 %19, 1
  store i32 %inc.i.i.i.i, ptr %pagefault_disabled.i.i.i.i, align 8
  call void asm sideeffect "", "~{memory}"() #23, !srcloc !554
  %call.i.i = call ptr @__kmap_local_page_prot(ptr noundef %add.ptr, i32 noundef %or.i) #23
  %shr.i137 = lshr i32 %addr.addr.0, 12
  %and.i = and i32 %shr.i137, 511
  %add.ptr58 = getelementptr i32, ptr %call.i.i, i32 %and.i
  call void @_raw_spin_lock(ptr noundef %8) #23
  %cmp60.not159 = icmp eq i32 %addr.addr.0, %end
  br i1 %cmp60.not159, label %if.end110.critedge, label %for.body

for.body:                                         ; preds = %for.inc, %retry
  %addr.addr.1161 = phi i32 [ %add91, %for.inc ], [ %addr.addr.0, %retry ]
  %pte.0160 = phi ptr [ %incdec.ptr, %for.inc ], [ %add.ptr58, %retry ]
  %incdec.ptr = getelementptr i32, ptr %pte.0160, i32 1
  %20 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 5), align 4
  %tobool61.not = icmp eq i32 %20, 0
  br i1 %tobool61.not, label %if.then105, label %if.end63

if.end63:                                         ; preds = %for.body
  %21 = ptrtoint ptr %pte.0160 to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load i32, ptr %pte.0160, align 4
  %call64 = call fastcc i32 @get_mctgt_type(ptr noundef %1, i32 noundef %addr.addr.1161, i32 noundef %22, ptr noundef nonnull %target)
  switch i32 %call64, label %for.inc [
    i32 3, label %sw.bb65.thread
    i32 1, label %land.lhs.true
    i32 2, label %sw.bb82
  ]

sw.bb65.thread:                                   ; preds = %if.end63
  %23 = ptrtoint ptr %target to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %target, align 4
  br label %if.end74

land.lhs.true:                                    ; preds = %if.end63
  %25 = ptrtoint ptr %target to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load ptr, ptr %target, align 4
  %call71 = call i32 @isolate_lru_page(ptr noundef %26) #23
  %tobool72.not = icmp eq i32 %call71, 0
  br i1 %tobool72.not, label %if.end74, label %put

if.end74:                                         ; preds = %land.lhs.true, %sw.bb65.thread
  %27 = phi ptr [ %24, %sw.bb65.thread ], [ %26, %land.lhs.true ]
  %device.0.off0149 = phi i1 [ true, %sw.bb65.thread ], [ false, %land.lhs.true ]
  %28 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 2), align 4
  %29 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 3), align 4
  %call75 = call fastcc i32 @mem_cgroup_move_account(ptr noundef %27, ptr noundef %28, ptr noundef %29)
  %tobool76.not = icmp eq i32 %call75, 0
  br i1 %tobool76.not, label %if.then77, label %if.end78

if.then77:                                        ; preds = %if.end74
  %30 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 5), align 4
  %dec = add i32 %30, -1
  store i32 %dec, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 5), align 4
  %31 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 6), align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 6), align 4
  br label %if.end78

if.end78:                                         ; preds = %if.then77, %if.end74
  br i1 %device.0.off0149, label %put, label %if.then80

if.then80:                                        ; preds = %if.end78
  call void @putback_lru_page(ptr noundef %27) #23
  br label %put

put:                                              ; preds = %if.then80, %if.end78, %land.lhs.true
  %32 = phi ptr [ %27, %if.end78 ], [ %27, %if.then80 ], [ %26, %land.lhs.true ]
  %33 = getelementptr inbounds %struct.page, ptr %32, i32 0, i32 1
  %34 = ptrtoint ptr %33 to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load volatile i32, ptr %33, align 4
  %and.i.i = and i32 %35, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.end.i.i, label %if.then.i.i, !prof !460

if.then.i.i:                                      ; preds = %put
  %sub.i.i = add i32 %35, -1
  br label %_compound_head.exit.i

if.end.i.i:                                       ; preds = %put
  %36 = ptrtoint ptr %32 to i32
  br label %_compound_head.exit.i

_compound_head.exit.i:                            ; preds = %if.end.i.i, %if.then.i.i
  %retval.0.i.i = phi i32 [ %sub.i.i, %if.then.i.i ], [ %36, %if.end.i.i ]
  %37 = inttoptr i32 %retval.0.i.i to ptr
  %_refcount.i.i.i.i.i = getelementptr inbounds %struct.page, ptr %37, i32 0, i32 3
  %call.i.i.i.i.i.i.i = call zeroext i1 @__kasan_check_read(ptr noundef %_refcount.i.i.i.i.i, i32 noundef 4) #23
  %38 = ptrtoint ptr %_refcount.i.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load volatile i32, ptr %_refcount.i.i.i.i.i, align 4
  %cmp.i.i.i.i = icmp eq i32 %39, 0
  br i1 %cmp.i.i.i.i, label %if.then.i.i.i.i, label %do.end5.i.i.i.i, !prof !466

if.then.i.i.i.i:                                  ; preds = %_compound_head.exit.i
  %40 = inttoptr i32 %retval.0.i.i to ptr
  call void @dump_page(ptr noundef %40, ptr noundef nonnull @.str.122) #23
  call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/mm.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 717, 0\0A.popsection", ""() #23, !srcloc !557
  unreachable

do.end5.i.i.i.i:                                  ; preds = %_compound_head.exit.i
  %call.i.i.i10.i.i.i.i = call zeroext i1 @__kasan_check_write(ptr noundef %_refcount.i.i.i.i.i, i32 noundef 4) #23
  call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !545
  call void @llvm.prefetch.p0(ptr %_refcount.i.i.i.i.i, i32 1, i32 3, i32 1) #23
  %41 = call { i32, i32 } asm sideeffect "@ atomic_sub_return\0A1:\09ldrex\09$0, [$3]\0A\09sub\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %_refcount.i.i.i.i.i, ptr %_refcount.i.i.i.i.i, i32 1, ptr elementtype(i32) %_refcount.i.i.i.i.i) #23, !srcloc !546
  %asmresult.i.i.i.i.i.i.i.i.i.i = extractvalue { i32, i32 } %41, 0
  call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !547
  %cmp.i.i.i.i.i.i.i = icmp eq i32 %asmresult.i.i.i.i.i.i.i.i.i.i, 0
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (%struct.tracepoint, ptr @__tracepoint_page_ref_mod_and_test, i32 0, i32 1), ptr blockaddress(@mem_cgroup_move_charge_pte_range, %if.then.i.i.i.i.i)) #23
          to label %folio_put_testzero.exit.i.i [label %if.then.i.i.i.i.i], !srcloc !461

if.then.i.i.i.i.i:                                ; preds = %do.end5.i.i.i.i
  %conv.i.i.i.i.i = zext i1 %cmp.i.i.i.i.i.i.i to i32
  call void @__page_ref_mod_and_test(ptr noundef %37, i32 noundef -1, i32 noundef %conv.i.i.i.i.i) #23
  br label %folio_put_testzero.exit.i.i

folio_put_testzero.exit.i.i:                      ; preds = %if.then.i.i.i.i.i, %do.end5.i.i.i.i
  br i1 %cmp.i.i.i.i.i.i.i, label %if.then.i4.i, label %for.inc

if.then.i4.i:                                     ; preds = %folio_put_testzero.exit.i.i
  call void @__put_page(ptr noundef %37) #23
  br label %for.inc

sw.bb82:                                          ; preds = %if.end63
  %42 = ptrtoint ptr %target to i32
  call void @__asan_load4_noabort(i32 %42)
  %ent.sroa.0.0.copyload = load i32, ptr %target, align 4
  %43 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 2), align 4
  %44 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 3), align 4
  %.fca.0.insert = insertvalue [1 x i32] poison, i32 %ent.sroa.0.0.copyload, 0
  %call83 = call fastcc i32 @mem_cgroup_move_swap_account([1 x i32] %.fca.0.insert, ptr noundef %43, ptr noundef %44)
  %tobool84.not = icmp eq i32 %call83, 0
  br i1 %tobool84.not, label %if.then85, label %for.inc

if.then85:                                        ; preds = %sw.bb82
  %45 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 5), align 4
  %dec86 = add i32 %45, -1
  store i32 %dec86, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 5), align 4
  %46 = load ptr, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 3), align 4
  %ref.i = getelementptr inbounds %struct.mem_cgroup, ptr %46, i32 0, i32 1, i32 1
  %call.i.i.i.i.i = call zeroext i1 @__kasan_check_write(ptr noundef %ref.i, i32 noundef 4) #23
  call void @llvm.prefetch.p0(ptr %ref.i, i32 1, i32 3, i32 1) #23
  %47 = call { i32, i32, i32 } asm sideeffect "@ atomic_fetch_add\0A1:\09ldrex\09$0, [$4]\0A\09add\09$1, $0, $5\0A\09strex\09$2, $1, [$4]\0A\09teq\09$2, #0\0A\09bne\091b", "=&r,=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %ref.i, ptr %ref.i, i32 1, ptr elementtype(i32) %ref.i) #23, !srcloc !559
  %asmresult.i.i.i.i.i = extractvalue { i32, i32, i32 } %47, 0
  %tobool1.not.i.i.i = icmp eq i32 %asmresult.i.i.i.i.i, 0
  br i1 %tobool1.not.i.i.i, label %if.end15.sink.split.i.i.i, label %if.else.i.i.i, !prof !466

if.else.i.i.i:                                    ; preds = %if.then85
  %add.i.i.i138 = add i32 %asmresult.i.i.i.i.i, 1
  %48 = or i32 %add.i.i.i138, %asmresult.i.i.i.i.i
  %.not.i.i.i = icmp sgt i32 %48, -1
  br i1 %.not.i.i.i, label %mem_cgroup_id_get_many.exit, label %if.end15.sink.split.i.i.i, !prof !460

if.end15.sink.split.i.i.i:                        ; preds = %if.else.i.i.i, %if.then85
  %.sink.i.i.i = phi i32 [ 2, %if.then85 ], [ 1, %if.else.i.i.i ]
  call void @refcount_warn_saturate(ptr noundef %ref.i, i32 noundef %.sink.i.i.i) #23
  br label %mem_cgroup_id_get_many.exit

mem_cgroup_id_get_many.exit:                      ; preds = %if.end15.sink.split.i.i.i, %if.else.i.i.i
  %49 = load i32, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 7), align 4
  %inc87 = add i32 %49, 1
  store i32 %inc87, ptr getelementptr inbounds (%struct.move_charge_struct, ptr @mc, i32 0, i32 7), align 4
  br label %for.inc

for.inc:                                          ; preds = %mem_cgroup_id_get_many.exit, %sw.bb82, %if.then.i4.i, %folio_put_testzero.exit.i.i, %if.end63
  %add91 = add i32 %addr.addr.1161, 4096
  %cmp60.not = icmp eq i32 %add91, %end
  br i1 %cmp60.not, label %if.end110.critedge, label %for.body

if.then105:                                       ; preds = %for.body
  call void @_raw_spin_unlock(ptr noundef %8) #23
  call void @kunmap_local_indexed(ptr noundef %pte.0160) #23
  call void asm sideeffect "", "~{memory}"() #23, !srcloc !555
  %50 = call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i1.i = and i32 %50, -16384
  %51 = inttoptr i32 %and.i.i.i1.i to ptr
  %task.i.i.i = getelementptr inbounds %struct.thread_info, ptr %51, i32 0, i32 2
  %52 = ptrtoint ptr %task.i.i.i to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load ptr, ptr %task.i.i.i, align 8
  %pagefault_disabled.i.i.i = getelementptr inbounds %struct.task_struct, ptr %53, i32 0, i32 213
  %54 = ptrtoint ptr %pagefault_disabled.i.i.i to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load i32, ptr %pagefault_disabled.i.i.i, align 8
  %dec.i.i.i = add i32 %55, -1
  store i32 %dec.i.i.i, ptr %pagefault_disabled.i.i.i, align 8
  call void asm sideeffect "", "~{memory}"() #23, !srcloc !556
  %56 = call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i = and i32 %56, -16384
  %57 = inttoptr i32 %and.i.i.i.i to ptr
  %preempt_count.i.i.i = getelementptr inbounds %struct.thread_info, ptr %57, i32 0, i32 1
  %58 = ptrtoint ptr %preempt_count.i.i.i to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load volatile i32, ptr %preempt_count.i.i.i, align 4
  %sub.i.i139 = add i32 %59, -1
  store volatile i32 %sub.i.i139, ptr %preempt_count.i.i.i, align 4
  call void @__might_resched(ptr noundef nonnull @.str.1, i32 noundef 6080, i32 noundef 0) #23
  %call.i = call i32 @__cond_resched() #23
  %call106 = call fastcc i32 @mem_cgroup_do_precharge(i32 noundef 1)
  %tobool107.not = icmp eq i32 %call106, 0
  br i1 %tobool107.not, label %retry, label %cleanup111

if.end110.critedge:                               ; preds = %for.inc, %retry
  %pte.0.lcssa = phi ptr [ %incdec.ptr, %for.inc ], [ %add.ptr58, %retry ]
  call void @_raw_spin_unlock(ptr noundef %8) #23
  %add.ptr97.c = getelementptr i32, ptr %pte.0.lcssa, i32 -1
  call void @kunmap_local_indexed(ptr noundef %add.ptr97.c) #23
  call void asm sideeffect "", "~{memory}"() #23, !srcloc !555
  %60 = call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i1.i140 = and i32 %60, -16384
  %61 = inttoptr i32 %and.i.i.i1.i140 to ptr
  %task.i.i.i141 = getelementptr inbounds %struct.thread_info, ptr %61, i32 0, i32 2
  %62 = ptrtoint ptr %task.i.i.i141 to i32
  call void @__asan_load4_noabort(i32 %62)
  %63 = load ptr, ptr %task.i.i.i141, align 8
  %pagefault_disabled.i.i.i142 = getelementptr inbounds %struct.task_struct, ptr %63, i32 0, i32 213
  %64 = ptrtoint ptr %pagefault_disabled.i.i.i142 to i32
  call void @__asan_load4_noabort(i32 %64)
  %65 = load i32, ptr %pagefault_disabled.i.i.i142, align 8
  %dec.i.i.i143 = add i32 %65, -1
  store i32 %dec.i.i.i143, ptr %pagefault_disabled.i.i.i142, align 8
  call void asm sideeffect "", "~{memory}"() #23, !srcloc !556
  %66 = call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i144 = and i32 %66, -16384
  %67 = inttoptr i32 %and.i.i.i.i144 to ptr
  %preempt_count.i.i.i145 = getelementptr inbounds %struct.thread_info, ptr %67, i32 0, i32 1
  %68 = ptrtoint ptr %preempt_count.i.i.i145 to i32
  call void @__asan_load4_noabort(i32 %68)
  %69 = load volatile i32, ptr %preempt_count.i.i.i145, align 4
  %sub.i.i146 = add i32 %69, -1
  store volatile i32 %sub.i.i146, ptr %preempt_count.i.i.i145, align 4
  call void @__might_resched(ptr noundef nonnull @.str.1, i32 noundef 6080, i32 noundef 0) #23
  %call.i147 = call i32 @__cond_resched() #23
  br label %cleanup111

cleanup111:                                       ; preds = %if.end110.critedge, %if.then105
  %ret.1 = phi i32 [ 0, %if.end110.critedge ], [ %call106, %if.then105 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %target) #23
  ret i32 %ret.1
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @isolate_lru_page(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @mem_cgroup_move_account(ptr noundef %page, ptr noundef %from, ptr noundef %to) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = getelementptr inbounds %struct.page, ptr %page, i32 0, i32 1
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %0, align 4
  %and.i13 = and i32 %2, 1
  %tobool.not.i = icmp eq i32 %and.i13, 0
  br i1 %tobool.not.i, label %if.end.i, label %if.then.i, !prof !460

if.then.i:                                        ; preds = %entry
  %sub.i = add i32 %2, -1
  br label %_compound_head.exit

if.end.i:                                         ; preds = %entry
  %3 = ptrtoint ptr %page to i32
  br label %_compound_head.exit

_compound_head.exit:                              ; preds = %if.end.i, %if.then.i
  %retval.0.i = phi i32 [ %sub.i, %if.then.i ], [ %3, %if.end.i ]
  %4 = inttoptr i32 %retval.0.i to ptr
  %cmp = icmp eq ptr %from, %to
  br i1 %cmp, label %do.body4, label %do.body10, !prof !466

do.body4:                                         ; preds = %_compound_head.exit
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 5578, 0\0A.popsection", ""() #23, !srcloc !560
  unreachable

do.body10:                                        ; preds = %_compound_head.exit
  %5 = getelementptr inbounds %struct.page, ptr %4, i32 0, i32 1
  %6 = ptrtoint ptr %5 to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %5, align 4
  %and.i.i.i = and i32 %7, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool.not.i.i, label %folio_test_lru.exit, label %if.then.i.i, !prof !460

if.then.i.i:                                      ; preds = %do.body10
  tail call void @dump_page(ptr noundef %4, ptr noundef nonnull @.str.96) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #23, !srcloc !470
  unreachable

folio_test_lru.exit:                              ; preds = %do.body10
  %8 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load volatile i32, ptr %4, align 4
  %10 = and i32 %9, 16
  %tobool.i.not = icmp eq i32 %10, 0
  br i1 %tobool.i.not, label %do.end48, label %if.then18, !prof !460

if.then18:                                        ; preds = %folio_test_lru.exit
  tail call void @dump_page(ptr noundef %4, ptr noundef nonnull @.str.123) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 5579, 0\0A.popsection", ""() #23, !srcloc !561
  unreachable

do.end48:                                         ; preds = %folio_test_lru.exit
  %11 = ptrtoint ptr %5 to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %5, align 4
  %and.i.i.i14 = and i32 %12, 1
  %tobool.not.i.i15 = icmp eq i32 %and.i.i.i14, 0
  br i1 %tobool.not.i.i15, label %folio_flags.exit.i, label %if.then.i.i16, !prof !460

if.then.i.i16:                                    ; preds = %do.end48
  tail call void @dump_page(ptr noundef %4, ptr noundef nonnull @.str.96) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #23, !srcloc !470
  unreachable

folio_flags.exit.i:                               ; preds = %do.end48
  %call.i.i.i = tail call zeroext i1 @__kasan_check_write(ptr noundef %4, i32 noundef 4) #23
  %13 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %4, align 4
  %and.i.i4.i = and i32 %14, 1
  %tobool.not.i.i.i = icmp eq i32 %and.i.i4.i, 0
  br i1 %tobool.not.i.i.i, label %folio_trylock.exit, label %out

folio_trylock.exit:                               ; preds = %folio_flags.exit.i
  tail call void @llvm.prefetch.p0(ptr %4, i32 1, i32 3, i32 1) #23
  %15 = tail call { i32, i32, i32 } asm sideeffect "@ atomic_fetch_or\0A1:\09ldrex\09$0, [$4]\0A\09orr\09$1, $0, $5\0A\09strex\09$2, $1, [$4]\0A\09teq\09$2, #0\0A\09bne\091b", "=&r,=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %4, ptr %4, i32 1, ptr elementtype(i32) %4) #23, !srcloc !562
  %asmresult.i.i.i.i.i.i = extractvalue { i32, i32, i32 } %15, 0
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !563
  %and1.i.i.i = and i32 %asmresult.i.i.i.i.i.i, 1
  %phi.cmp.i.i = icmp eq i32 %and1.i.i.i, 0
  br i1 %phi.cmp.i.i, label %if.end51, label %out

if.end51:                                         ; preds = %folio_trylock.exit
  %call52 = tail call fastcc ptr @folio_memcg(ptr noundef %4)
  %cmp53.not = icmp eq ptr %call52, %from
  br i1 %cmp53.not, label %if.end55, label %out_unlock

if.end55:                                         ; preds = %if.end51
  %16 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load volatile i32, ptr %4, align 4
  %cmp.i.not.i.i.i = icmp eq i32 %17, -1
  br i1 %cmp.i.not.i.i.i, label %if.then.i.i.i, label %folio_pgdat.exit, !prof !466

if.then.i.i.i:                                    ; preds = %if.end55
  tail call void @dump_page(ptr noundef %4, ptr noundef nonnull @.str.170) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/mm.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1368, 0\0A.popsection", ""() #23, !srcloc !469
  unreachable

folio_pgdat.exit:                                 ; preds = %if.end55
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %out.i)) #23
          to label %if.end.i19 [label %out.i], !srcloc !461

if.end.i19:                                       ; preds = %folio_pgdat.exit
  %tobool.not.i18 = icmp eq ptr %from, null
  br i1 %tobool.not.i18, label %if.then1.i, label %if.end2.i

if.then1.i:                                       ; preds = %if.end.i19
  %18 = load ptr, ptr @root_mem_cgroup, align 4
  br label %if.end2.i

if.end2.i:                                        ; preds = %if.then1.i, %if.end.i19
  %memcg.addr.0.i = phi ptr [ %from, %if.end.i19 ], [ %18, %if.then1.i ]
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 8) to i32))
  %19 = load i32, ptr getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 8), align 64
  %arrayidx.i = getelementptr %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 45, i32 %19
  %20 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load ptr, ptr %arrayidx.i, align 4
  br label %out.i

out.i:                                            ; preds = %if.end2.i, %folio_pgdat.exit
  %lruvec.0.i = phi ptr [ %21, %if.end2.i ], [ getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 26), %folio_pgdat.exit ]
  %pgdat4.i = getelementptr inbounds %struct.lruvec, ptr %lruvec.0.i, i32 0, i32 7
  %22 = ptrtoint ptr %pgdat4.i to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %pgdat4.i, align 4
  %cmp.not.i = icmp eq ptr %23, @contig_page_data
  br i1 %cmp.not.i, label %mem_cgroup_lruvec.exit, label %if.then7.i, !prof !460

if.then7.i:                                       ; preds = %out.i
  %24 = ptrtoint ptr %pgdat4.i to i32
  call void @__asan_store4_noabort(i32 %24)
  store ptr @contig_page_data, ptr %pgdat4.i, align 4
  br label %mem_cgroup_lruvec.exit

mem_cgroup_lruvec.exit:                           ; preds = %if.then7.i, %out.i
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %out.i30)) #23
          to label %if.end.i22 [label %out.i30], !srcloc !461

if.end.i22:                                       ; preds = %mem_cgroup_lruvec.exit
  %tobool.not.i21 = icmp eq ptr %to, null
  br i1 %tobool.not.i21, label %if.then1.i23, label %if.end2.i26

if.then1.i23:                                     ; preds = %if.end.i22
  %25 = load ptr, ptr @root_mem_cgroup, align 4
  br label %if.end2.i26

if.end2.i26:                                      ; preds = %if.then1.i23, %if.end.i22
  %memcg.addr.0.i24 = phi ptr [ %to, %if.end.i22 ], [ %25, %if.then1.i23 ]
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 8) to i32))
  %26 = load i32, ptr getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 8), align 64
  %arrayidx.i25 = getelementptr %struct.mem_cgroup, ptr %memcg.addr.0.i24, i32 0, i32 45, i32 %26
  %27 = ptrtoint ptr %arrayidx.i25 to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %arrayidx.i25, align 4
  br label %out.i30

out.i30:                                          ; preds = %if.end2.i26, %mem_cgroup_lruvec.exit
  %lruvec.0.i27 = phi ptr [ %28, %if.end2.i26 ], [ getelementptr inbounds (%struct.pglist_data, ptr @contig_page_data, i32 0, i32 26), %mem_cgroup_lruvec.exit ]
  %pgdat4.i28 = getelementptr inbounds %struct.lruvec, ptr %lruvec.0.i27, i32 0, i32 7
  %29 = ptrtoint ptr %pgdat4.i28 to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %pgdat4.i28, align 4
  %cmp.not.i29 = icmp eq ptr %30, @contig_page_data
  br i1 %cmp.not.i29, label %mem_cgroup_lruvec.exit32, label %if.then7.i31, !prof !460

if.then7.i31:                                     ; preds = %out.i30
  %31 = ptrtoint ptr %pgdat4.i28 to i32
  call void @__asan_store4_noabort(i32 %31)
  store ptr @contig_page_data, ptr %pgdat4.i28, align 4
  br label %mem_cgroup_lruvec.exit32

mem_cgroup_lruvec.exit32:                         ; preds = %if.then7.i31, %out.i30
  tail call void @folio_memcg_lock(ptr noundef %4)
  %mapping.i = getelementptr inbounds %struct.anon.153, ptr %4, i32 0, i32 2
  %32 = ptrtoint ptr %mapping.i to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load ptr, ptr %mapping.i, align 4
  %34 = ptrtoint ptr %33 to i32
  %and.i = and i32 %34, 1
  %cmp.i.not = icmp eq i32 %and.i, 0
  br i1 %cmp.i.not, label %if.else, label %if.then60

if.then60:                                        ; preds = %mem_cgroup_lruvec.exit32
  %call61 = tail call zeroext i1 @folio_mapped(ptr noundef %4) #23
  br i1 %call61, label %if.then62, label %if.end85

if.then62:                                        ; preds = %if.then60
  %35 = ptrtoint ptr %pgdat4.i to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load ptr, ptr %pgdat4.i, align 4
  tail call void @__mod_node_page_state(ptr noundef %36, i32 noundef 17, i32 noundef -1) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %__mod_lruvec_state.exit)) #23
          to label %if.then.i33 [label %__mod_lruvec_state.exit], !srcloc !461

if.then.i33:                                      ; preds = %if.then62
  tail call void @__mod_memcg_lruvec_state(ptr noundef %lruvec.0.i, i32 noundef 17, i32 noundef -1) #23
  br label %__mod_lruvec_state.exit

__mod_lruvec_state.exit:                          ; preds = %if.then.i33, %if.then62
  %37 = ptrtoint ptr %pgdat4.i28 to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load ptr, ptr %pgdat4.i28, align 4
  tail call void @__mod_node_page_state(ptr noundef %38, i32 noundef 17, i32 noundef 1) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %if.end85)) #23
          to label %if.end85.sink.split [label %if.end85], !srcloc !461

if.else:                                          ; preds = %mem_cgroup_lruvec.exit32
  %39 = ptrtoint ptr %pgdat4.i to i32
  call void @__asan_load4_noabort(i32 %39)
  %40 = load ptr, ptr %pgdat4.i, align 4
  tail call void @__mod_node_page_state(ptr noundef %40, i32 noundef 19, i32 noundef -1) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %__mod_lruvec_state.exit42)) #23
          to label %if.then.i40 [label %__mod_lruvec_state.exit42], !srcloc !461

if.then.i40:                                      ; preds = %if.else
  tail call void @__mod_memcg_lruvec_state(ptr noundef %lruvec.0.i, i32 noundef 19, i32 noundef -1) #23
  br label %__mod_lruvec_state.exit42

__mod_lruvec_state.exit42:                        ; preds = %if.then.i40, %if.else
  %41 = ptrtoint ptr %pgdat4.i28 to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load ptr, ptr %pgdat4.i28, align 4
  tail call void @__mod_node_page_state(ptr noundef %42, i32 noundef 19, i32 noundef 1) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %__mod_lruvec_state.exit46)) #23
          to label %if.then.i44 [label %__mod_lruvec_state.exit46], !srcloc !461

if.then.i44:                                      ; preds = %__mod_lruvec_state.exit42
  tail call void @__mod_memcg_lruvec_state(ptr noundef %lruvec.0.i27, i32 noundef 19, i32 noundef 1) #23
  br label %__mod_lruvec_state.exit46

__mod_lruvec_state.exit46:                        ; preds = %if.then.i44, %__mod_lruvec_state.exit42
  %43 = ptrtoint ptr %5 to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load volatile i32, ptr %5, align 4
  %and.i.i.i1 = and i32 %44, 1
  %tobool.not.i.i2 = icmp eq i32 %and.i.i.i1, 0
  br i1 %tobool.not.i.i2, label %folio_test_swapbacked.exit, label %if.then.i.i3, !prof !460

if.then.i.i3:                                     ; preds = %__mod_lruvec_state.exit46
  tail call void @dump_page(ptr noundef %4, ptr noundef nonnull @.str.96) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #23, !srcloc !470
  unreachable

folio_test_swapbacked.exit:                       ; preds = %__mod_lruvec_state.exit46
  %45 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load volatile i32, ptr %4, align 4
  %47 = and i32 %46, 524288
  %tobool.i4.not = icmp eq i32 %47, 0
  br i1 %tobool.i4.not, label %if.end72, label %if.then70

if.then70:                                        ; preds = %folio_test_swapbacked.exit
  %48 = ptrtoint ptr %pgdat4.i to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load ptr, ptr %pgdat4.i, align 4
  tail call void @__mod_node_page_state(ptr noundef %49, i32 noundef 23, i32 noundef -1) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %__mod_lruvec_state.exit50)) #23
          to label %if.then.i48 [label %__mod_lruvec_state.exit50], !srcloc !461

if.then.i48:                                      ; preds = %if.then70
  tail call void @__mod_memcg_lruvec_state(ptr noundef %lruvec.0.i, i32 noundef 23, i32 noundef -1) #23
  br label %__mod_lruvec_state.exit50

__mod_lruvec_state.exit50:                        ; preds = %if.then.i48, %if.then70
  %50 = ptrtoint ptr %pgdat4.i28 to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load ptr, ptr %pgdat4.i28, align 4
  tail call void @__mod_node_page_state(ptr noundef %51, i32 noundef 23, i32 noundef 1) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %if.end72)) #23
          to label %if.then.i52 [label %if.end72], !srcloc !461

if.then.i52:                                      ; preds = %__mod_lruvec_state.exit50
  tail call void @__mod_memcg_lruvec_state(ptr noundef %lruvec.0.i27, i32 noundef 23, i32 noundef 1) #23
  br label %if.end72

if.end72:                                         ; preds = %if.then.i52, %__mod_lruvec_state.exit50, %folio_test_swapbacked.exit
  %call73 = tail call zeroext i1 @folio_mapped(ptr noundef %4) #23
  br i1 %call73, label %if.then74, label %if.end76

if.then74:                                        ; preds = %if.end72
  %52 = ptrtoint ptr %pgdat4.i to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load ptr, ptr %pgdat4.i, align 4
  tail call void @__mod_node_page_state(ptr noundef %53, i32 noundef 18, i32 noundef -1) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %__mod_lruvec_state.exit58)) #23
          to label %if.then.i56 [label %__mod_lruvec_state.exit58], !srcloc !461

if.then.i56:                                      ; preds = %if.then74
  tail call void @__mod_memcg_lruvec_state(ptr noundef %lruvec.0.i, i32 noundef 18, i32 noundef -1) #23
  br label %__mod_lruvec_state.exit58

__mod_lruvec_state.exit58:                        ; preds = %if.then.i56, %if.then74
  %54 = ptrtoint ptr %pgdat4.i28 to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load ptr, ptr %pgdat4.i28, align 4
  tail call void @__mod_node_page_state(ptr noundef %55, i32 noundef 18, i32 noundef 1) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %if.end76)) #23
          to label %if.then.i60 [label %if.end76], !srcloc !461

if.then.i60:                                      ; preds = %__mod_lruvec_state.exit58
  tail call void @__mod_memcg_lruvec_state(ptr noundef %lruvec.0.i27, i32 noundef 18, i32 noundef 1) #23
  br label %if.end76

if.end76:                                         ; preds = %if.then.i60, %__mod_lruvec_state.exit58, %if.end72
  %56 = ptrtoint ptr %5 to i32
  call void @__asan_load4_noabort(i32 %56)
  %57 = load volatile i32, ptr %5, align 4
  %and.i.i.i5 = and i32 %57, 1
  %tobool.not.i.i6 = icmp eq i32 %and.i.i.i5, 0
  br i1 %tobool.not.i.i6, label %folio_test_dirty.exit, label %if.then.i.i7, !prof !460

if.then.i.i7:                                     ; preds = %if.end76
  tail call void @dump_page(ptr noundef %4, ptr noundef nonnull @.str.96) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #23, !srcloc !470
  unreachable

folio_test_dirty.exit:                            ; preds = %if.end76
  %58 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load volatile i32, ptr %4, align 4
  %60 = and i32 %59, 8
  %tobool.i8.not = icmp eq i32 %60, 0
  br i1 %tobool.i8.not, label %if.end85, label %if.then78

if.then78:                                        ; preds = %folio_test_dirty.exit
  %call79 = tail call ptr @folio_mapping(ptr noundef %4) #23
  %61 = ptrtoint ptr %call79 to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load ptr, ptr %call79, align 4
  %call.i = tail call ptr @inode_to_bdi(ptr noundef %62) #23
  %capabilities.i = getelementptr inbounds %struct.backing_dev_info, ptr %call.i, i32 0, i32 6
  %63 = ptrtoint ptr %capabilities.i to i32
  call void @__asan_load4_noabort(i32 %63)
  %64 = load i32, ptr %capabilities.i, align 8
  %and.i63 = and i32 %64, 1
  %tobool.i64.not = icmp eq i32 %and.i63, 0
  br i1 %tobool.i64.not, label %if.end85, label %if.then81

if.then81:                                        ; preds = %if.then78
  %65 = ptrtoint ptr %pgdat4.i to i32
  call void @__asan_load4_noabort(i32 %65)
  %66 = load ptr, ptr %pgdat4.i, align 4
  tail call void @__mod_node_page_state(ptr noundef %66, i32 noundef 20, i32 noundef -1) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %__mod_lruvec_state.exit68)) #23
          to label %if.then.i66 [label %__mod_lruvec_state.exit68], !srcloc !461

if.then.i66:                                      ; preds = %if.then81
  tail call void @__mod_memcg_lruvec_state(ptr noundef %lruvec.0.i, i32 noundef 20, i32 noundef -1) #23
  br label %__mod_lruvec_state.exit68

__mod_lruvec_state.exit68:                        ; preds = %if.then.i66, %if.then81
  %67 = ptrtoint ptr %pgdat4.i28 to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load ptr, ptr %pgdat4.i28, align 4
  tail call void @__mod_node_page_state(ptr noundef %68, i32 noundef 20, i32 noundef 1) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %if.end85)) #23
          to label %if.end85.sink.split [label %if.end85], !srcloc !461

if.end85.sink.split:                              ; preds = %__mod_lruvec_state.exit68, %__mod_lruvec_state.exit
  %.sink = phi i32 [ 17, %__mod_lruvec_state.exit ], [ 20, %__mod_lruvec_state.exit68 ]
  tail call void @__mod_memcg_lruvec_state(ptr noundef %lruvec.0.i27, i32 noundef %.sink, i32 noundef 1) #23
  br label %if.end85

if.end85:                                         ; preds = %if.end85.sink.split, %__mod_lruvec_state.exit68, %if.then78, %folio_test_dirty.exit, %__mod_lruvec_state.exit, %if.then60
  %69 = ptrtoint ptr %5 to i32
  call void @__asan_load4_noabort(i32 %69)
  %70 = load volatile i32, ptr %5, align 4
  %and.i.i.i9 = and i32 %70, 1
  %tobool.not.i.i10 = icmp eq i32 %and.i.i.i9, 0
  br i1 %tobool.not.i.i10, label %folio_test_writeback.exit, label %if.then.i.i11, !prof !460

if.then.i.i11:                                    ; preds = %if.end85
  tail call void @dump_page(ptr noundef %4, ptr noundef nonnull @.str.96) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/page-flags.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 260, 0\0A.popsection", ""() #23, !srcloc !470
  unreachable

folio_test_writeback.exit:                        ; preds = %if.end85
  %71 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %71)
  %72 = load volatile i32, ptr %4, align 4
  %73 = and i32 %72, 32768
  %tobool.i12.not = icmp eq i32 %73, 0
  br i1 %tobool.i12.not, label %do.end93, label %if.then87

if.then87:                                        ; preds = %folio_test_writeback.exit
  %74 = ptrtoint ptr %pgdat4.i to i32
  call void @__asan_load4_noabort(i32 %74)
  %75 = load ptr, ptr %pgdat4.i, align 4
  tail call void @__mod_node_page_state(ptr noundef %75, i32 noundef 21, i32 noundef -1) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %__mod_lruvec_state.exit76)) #23
          to label %if.then.i74 [label %__mod_lruvec_state.exit76], !srcloc !461

if.then.i74:                                      ; preds = %if.then87
  tail call void @__mod_memcg_lruvec_state(ptr noundef %lruvec.0.i, i32 noundef 21, i32 noundef -1) #23
  br label %__mod_lruvec_state.exit76

__mod_lruvec_state.exit76:                        ; preds = %if.then.i74, %if.then87
  %76 = ptrtoint ptr %pgdat4.i28 to i32
  call void @__asan_load4_noabort(i32 %76)
  %77 = load ptr, ptr %pgdat4.i28, align 4
  tail call void @__mod_node_page_state(ptr noundef %77, i32 noundef 21, i32 noundef 1) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %do.end93)) #23
          to label %if.then.i78 [label %do.end93], !srcloc !461

if.then.i78:                                      ; preds = %__mod_lruvec_state.exit76
  tail call void @__mod_memcg_lruvec_state(ptr noundef %lruvec.0.i27, i32 noundef 21, i32 noundef 1) #23
  br label %do.end93

do.end93:                                         ; preds = %if.then.i78, %__mod_lruvec_state.exit76, %folio_test_writeback.exit
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !564
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %to, i32 0, i32 7
  %78 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %78)
  %79 = load i32, ptr %flags.i, align 4
  %and.i81 = and i32 %79, 1
  %tobool.not.i82 = icmp eq i32 %and.i81, 0
  br i1 %tobool.not.i82, label %if.then.i83, label %css_get.exit

if.then.i83:                                      ; preds = %do.end93
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %to, i32 0, i32 2
  tail call fastcc void @percpu_ref_get_many(ptr noundef %refcnt.i, i32 noundef 1) #23
  br label %css_get.exit

css_get.exit:                                     ; preds = %if.then.i83, %do.end93
  %flags.i85 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %from, i32 0, i32 7
  %80 = ptrtoint ptr %flags.i85 to i32
  call void @__asan_load4_noabort(i32 %80)
  %81 = load i32, ptr %flags.i85, align 4
  %and.i86 = and i32 %81, 1
  %tobool.not.i87 = icmp eq i32 %and.i86, 0
  br i1 %tobool.not.i87, label %if.then.i89, label %css_put.exit

if.then.i89:                                      ; preds = %css_get.exit
  %refcnt.i88 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %from, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i88) #23
  br label %css_put.exit

css_put.exit:                                     ; preds = %if.then.i89, %css_get.exit
  %82 = ptrtoint ptr %to to i32
  %memcg_data = getelementptr inbounds %struct.anon.153, ptr %4, i32 0, i32 7
  %83 = ptrtoint ptr %memcg_data to i32
  call void @__asan_store4_noabort(i32 %83)
  store i32 %82, ptr %memcg_data, align 4
  tail call fastcc void @__folio_memcg_unlock(ptr noundef %from)
  %84 = ptrtoint ptr %4 to i32
  call void @__asan_load4_noabort(i32 %84)
  %85 = load volatile i32, ptr %4, align 4
  %cmp.i.not.i.i = icmp eq i32 %85, -1
  br i1 %cmp.i.not.i.i, label %if.then.i.i91, label %folio_nid.exit, !prof !466

if.then.i.i91:                                    ; preds = %css_put.exit
  tail call void @dump_page(ptr noundef %4, ptr noundef nonnull @.str.170) #23
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22include/linux/mm.h\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 1368, 0\0A.popsection", ""() #23, !srcloc !469
  unreachable

folio_nid.exit:                                   ; preds = %css_put.exit
  %86 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i = and i32 %86, 128
  %tobool100.not = icmp eq i32 %and.i.i, 0
  tail call void asm sideeffect "\09cpsid i\09\09\09@ arch_local_irq_disable", "~{memory},~{cc}"() #23, !srcloc !521
  br i1 %tobool100.not, label %if.then103, label %if.end104

if.then103:                                       ; preds = %folio_nid.exit
  tail call void @trace_hardirqs_off() #23
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %folio_nid.exit
  tail call void @__count_memcg_events(ptr noundef %to, i32 noundef 0, i32 noundef 1) #23
  %vmstats_percpu.i = getelementptr inbounds %struct.mem_cgroup, ptr %to, i32 0, i32 39
  %87 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %87)
  %88 = load ptr, ptr %vmstats_percpu.i, align 8
  %nr_page_events.i = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %88, i32 0, i32 4
  %89 = ptrtoint ptr %nr_page_events.i to i32
  %90 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i93 = and i32 %90, -16384
  %91 = inttoptr i32 %and.i.i93 to ptr
  %cpu.i = getelementptr inbounds %struct.thread_info, ptr %91, i32 0, i32 3
  %92 = ptrtoint ptr %cpu.i to i32
  call void @__asan_load4_noabort(i32 %92)
  %93 = load i32, ptr %cpu.i, align 4
  %arrayidx.i94 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %93
  %94 = ptrtoint ptr %arrayidx.i94 to i32
  call void @__asan_load4_noabort(i32 %94)
  %95 = load i32, ptr %arrayidx.i94, align 4
  %add.i = add i32 %95, %89
  %96 = inttoptr i32 %add.i to ptr
  %97 = ptrtoint ptr %96 to i32
  call void @__asan_load4_noabort(i32 %97)
  %98 = load i32, ptr %96, align 4
  %add7.i = add i32 %98, 1
  store i32 %add7.i, ptr %96, align 4
  %99 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %99)
  %100 = load ptr, ptr %vmstats_percpu.i, align 8
  %nr_page_events.i.i = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %100, i32 0, i32 4
  %101 = ptrtoint ptr %nr_page_events.i.i to i32
  %102 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i96 = and i32 %102, -16384
  %103 = inttoptr i32 %and.i.i.i96 to ptr
  %cpu.i.i = getelementptr inbounds %struct.thread_info, ptr %103, i32 0, i32 3
  %104 = ptrtoint ptr %cpu.i.i to i32
  call void @__asan_load4_noabort(i32 %104)
  %105 = load i32, ptr %cpu.i.i, align 4
  %arrayidx.i.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %105
  %106 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %106)
  %107 = load i32, ptr %arrayidx.i.i, align 4
  %add.i.i = add i32 %107, %101
  %108 = inttoptr i32 %add.i.i to ptr
  %109 = ptrtoint ptr %108 to i32
  call void @__asan_load4_noabort(i32 %109)
  %110 = load i32, ptr %108, align 4
  %arrayidx23.i.i = getelementptr %struct.memcg_vmstats_percpu, ptr %100, i32 0, i32 5, i32 0
  %111 = ptrtoint ptr %arrayidx23.i.i to i32
  %add28.i.i = add i32 %107, %111
  %112 = inttoptr i32 %add28.i.i to ptr
  %113 = ptrtoint ptr %112 to i32
  call void @__asan_load4_noabort(i32 %113)
  %114 = load i32, ptr %112, align 4
  %sub.i.i = sub i32 %114, %110
  %cmp.i.i = icmp slt i32 %sub.i.i, 0
  br i1 %cmp.i.i, label %if.then.i97, label %memcg_check_events.exit

if.then.i97:                                      ; preds = %if.end104
  %add30.i.i = add i32 %110, 128
  %115 = ptrtoint ptr %112 to i32
  call void @__asan_store4_noabort(i32 %115)
  store i32 %add30.i.i, ptr %112, align 4
  %116 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %116)
  %117 = load ptr, ptr %vmstats_percpu.i, align 8
  %nr_page_events.i16.i = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %117, i32 0, i32 4
  %118 = ptrtoint ptr %nr_page_events.i16.i to i32
  %119 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i17.i = and i32 %119, -16384
  %120 = inttoptr i32 %and.i.i17.i to ptr
  %cpu.i18.i = getelementptr inbounds %struct.thread_info, ptr %120, i32 0, i32 3
  %121 = ptrtoint ptr %cpu.i18.i to i32
  call void @__asan_load4_noabort(i32 %121)
  %122 = load i32, ptr %cpu.i18.i, align 4
  %arrayidx.i19.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %122
  %123 = ptrtoint ptr %arrayidx.i19.i to i32
  call void @__asan_load4_noabort(i32 %123)
  %124 = load i32, ptr %arrayidx.i19.i, align 4
  %add.i20.i = add i32 %124, %118
  %125 = inttoptr i32 %add.i20.i to ptr
  %126 = ptrtoint ptr %125 to i32
  call void @__asan_load4_noabort(i32 %126)
  %127 = load i32, ptr %125, align 4
  %arrayidx23.i21.i = getelementptr %struct.memcg_vmstats_percpu, ptr %117, i32 0, i32 5, i32 1
  %128 = ptrtoint ptr %arrayidx23.i21.i to i32
  %add28.i22.i = add i32 %124, %128
  %129 = inttoptr i32 %add28.i22.i to ptr
  %130 = ptrtoint ptr %129 to i32
  call void @__asan_load4_noabort(i32 %130)
  %131 = load i32, ptr %129, align 4
  %sub.i23.i = sub i32 %131, %127
  %cmp.i24.i = icmp slt i32 %sub.i23.i, 0
  br i1 %cmp.i24.i, label %if.then10.i, label %mem_cgroup_event_ratelimit.exit26.i

mem_cgroup_event_ratelimit.exit26.i:              ; preds = %if.then.i97
  %tobool.not5.i135 = icmp eq ptr %to, null
  br i1 %tobool.not5.i135, label %memcg_check_events.exit, label %while.body.i137

while.body.i137:                                  ; preds = %if.end.i146, %mem_cgroup_event_ratelimit.exit26.i
  %memcg.addr.06.i136 = phi ptr [ %add.ptr.i.i143, %if.end.i146 ], [ %to, %mem_cgroup_event_ratelimit.exit26.i ]
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i136, i1 noundef zeroext false) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %land.rhs.i.i139)) #23
          to label %if.end.i146 [label %land.rhs.i.i139], !srcloc !461

land.rhs.i.i139:                                  ; preds = %while.body.i137
  %132 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i138 = icmp eq i8 %132, 0
  br i1 %tobool4.not.i.i138, label %if.then.i140, label %if.end.i146

if.then.i140:                                     ; preds = %land.rhs.i.i139
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i136, i1 noundef zeroext true) #23
  br label %if.end.i146

if.end.i146:                                      ; preds = %if.then.i140, %land.rhs.i.i139, %while.body.i137
  %parent.i.i141 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.06.i136, i32 0, i32 2, i32 13
  %133 = ptrtoint ptr %parent.i.i141 to i32
  call void @__asan_load4_noabort(i32 %133)
  %134 = load ptr, ptr %parent.i.i141, align 4
  %tobool.not.i.i142 = icmp eq ptr %134, null
  %add.ptr.i.i143 = getelementptr i8, ptr %134, i32 -176
  %tobool.not7.i144 = icmp eq ptr %add.ptr.i.i143, null
  %tobool.not.i145 = or i1 %tobool.not.i.i142, %tobool.not7.i144
  br i1 %tobool.not.i145, label %memcg_check_events.exit, label %while.body.i137

if.then10.i:                                      ; preds = %if.then.i97
  %add32.i.i = add i32 %127, 1024
  %135 = ptrtoint ptr %129 to i32
  call void @__asan_store4_noabort(i32 %135)
  store i32 %add32.i.i, ptr %129, align 4
  %tobool.not5.i = icmp eq ptr %to, null
  br i1 %tobool.not5.i, label %mem_cgroup_threshold.exit, label %while.body.i

while.body.i:                                     ; preds = %if.end.i134, %if.then10.i
  %memcg.addr.06.i = phi ptr [ %add.ptr.i.i, %if.end.i134 ], [ %to, %if.then10.i ]
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i, i1 noundef zeroext false) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %land.rhs.i.i)) #23
          to label %if.end.i134 [label %land.rhs.i.i], !srcloc !461

land.rhs.i.i:                                     ; preds = %while.body.i
  %136 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i = icmp eq i8 %136, 0
  br i1 %tobool4.not.i.i, label %if.then.i131, label %if.end.i134

if.then.i131:                                     ; preds = %land.rhs.i.i
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i, i1 noundef zeroext true) #23
  br label %if.end.i134

if.end.i134:                                      ; preds = %if.then.i131, %land.rhs.i.i, %while.body.i
  %parent.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.06.i, i32 0, i32 2, i32 13
  %137 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %137)
  %138 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i132 = icmp eq ptr %138, null
  %add.ptr.i.i = getelementptr i8, ptr %138, i32 -176
  %tobool.not7.i = icmp eq ptr %add.ptr.i.i, null
  %tobool.not.i133 = or i1 %tobool.not.i.i132, %tobool.not7.i
  br i1 %tobool.not.i133, label %mem_cgroup_threshold.exit, label %while.body.i

mem_cgroup_threshold.exit:                        ; preds = %if.end.i134, %if.then10.i
  tail call fastcc void @mem_cgroup_update_tree(ptr noundef %to, i32 noundef 0) #23
  br label %memcg_check_events.exit

memcg_check_events.exit:                          ; preds = %mem_cgroup_threshold.exit, %if.end.i146, %mem_cgroup_event_ratelimit.exit26.i, %if.end104
  tail call void @__count_memcg_events(ptr noundef %from, i32 noundef 1, i32 noundef 1) #23
  %vmstats_percpu.i98 = getelementptr inbounds %struct.mem_cgroup, ptr %from, i32 0, i32 39
  %139 = ptrtoint ptr %vmstats_percpu.i98 to i32
  call void @__asan_load4_noabort(i32 %139)
  %140 = load ptr, ptr %vmstats_percpu.i98, align 8
  %nr_page_events.i99 = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %140, i32 0, i32 4
  %141 = ptrtoint ptr %nr_page_events.i99 to i32
  %142 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i100 = and i32 %142, -16384
  %143 = inttoptr i32 %and.i.i100 to ptr
  %cpu.i101 = getelementptr inbounds %struct.thread_info, ptr %143, i32 0, i32 3
  %144 = ptrtoint ptr %cpu.i101 to i32
  call void @__asan_load4_noabort(i32 %144)
  %145 = load i32, ptr %cpu.i101, align 4
  %arrayidx.i102 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %145
  %146 = ptrtoint ptr %arrayidx.i102 to i32
  call void @__asan_load4_noabort(i32 %146)
  %147 = load i32, ptr %arrayidx.i102, align 4
  %add.i103 = add i32 %147, %141
  %148 = inttoptr i32 %add.i103 to ptr
  %149 = ptrtoint ptr %148 to i32
  call void @__asan_load4_noabort(i32 %149)
  %150 = load i32, ptr %148, align 4
  %add7.i104 = add i32 %150, 1
  store i32 %add7.i104, ptr %148, align 4
  %151 = ptrtoint ptr %vmstats_percpu.i98 to i32
  call void @__asan_load4_noabort(i32 %151)
  %152 = load ptr, ptr %vmstats_percpu.i98, align 8
  %nr_page_events.i.i107 = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %152, i32 0, i32 4
  %153 = ptrtoint ptr %nr_page_events.i.i107 to i32
  %154 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i108 = and i32 %154, -16384
  %155 = inttoptr i32 %and.i.i.i108 to ptr
  %cpu.i.i109 = getelementptr inbounds %struct.thread_info, ptr %155, i32 0, i32 3
  %156 = ptrtoint ptr %cpu.i.i109 to i32
  call void @__asan_load4_noabort(i32 %156)
  %157 = load i32, ptr %cpu.i.i109, align 4
  %arrayidx.i.i110 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %157
  %158 = ptrtoint ptr %arrayidx.i.i110 to i32
  call void @__asan_load4_noabort(i32 %158)
  %159 = load i32, ptr %arrayidx.i.i110, align 4
  %add.i.i111 = add i32 %159, %153
  %160 = inttoptr i32 %add.i.i111 to ptr
  %161 = ptrtoint ptr %160 to i32
  call void @__asan_load4_noabort(i32 %161)
  %162 = load i32, ptr %160, align 4
  %arrayidx23.i.i112 = getelementptr %struct.memcg_vmstats_percpu, ptr %152, i32 0, i32 5, i32 0
  %163 = ptrtoint ptr %arrayidx23.i.i112 to i32
  %add28.i.i113 = add i32 %159, %163
  %164 = inttoptr i32 %add28.i.i113 to ptr
  %165 = ptrtoint ptr %164 to i32
  call void @__asan_load4_noabort(i32 %165)
  %166 = load i32, ptr %164, align 4
  %sub.i.i114 = sub i32 %166, %162
  %cmp.i.i115 = icmp slt i32 %sub.i.i114, 0
  br i1 %cmp.i.i115, label %if.then.i126, label %memcg_check_events.exit130

if.then.i126:                                     ; preds = %memcg_check_events.exit
  %add30.i.i116 = add i32 %162, 128
  %167 = ptrtoint ptr %164 to i32
  call void @__asan_store4_noabort(i32 %167)
  store i32 %add30.i.i116, ptr %164, align 4
  %168 = ptrtoint ptr %vmstats_percpu.i98 to i32
  call void @__asan_load4_noabort(i32 %168)
  %169 = load ptr, ptr %vmstats_percpu.i98, align 8
  %nr_page_events.i16.i117 = getelementptr inbounds %struct.memcg_vmstats_percpu, ptr %169, i32 0, i32 4
  %170 = ptrtoint ptr %nr_page_events.i16.i117 to i32
  %171 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i17.i118 = and i32 %171, -16384
  %172 = inttoptr i32 %and.i.i17.i118 to ptr
  %cpu.i18.i119 = getelementptr inbounds %struct.thread_info, ptr %172, i32 0, i32 3
  %173 = ptrtoint ptr %cpu.i18.i119 to i32
  call void @__asan_load4_noabort(i32 %173)
  %174 = load i32, ptr %cpu.i18.i119, align 4
  %arrayidx.i19.i120 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %174
  %175 = ptrtoint ptr %arrayidx.i19.i120 to i32
  call void @__asan_load4_noabort(i32 %175)
  %176 = load i32, ptr %arrayidx.i19.i120, align 4
  %add.i20.i121 = add i32 %176, %170
  %177 = inttoptr i32 %add.i20.i121 to ptr
  %178 = ptrtoint ptr %177 to i32
  call void @__asan_load4_noabort(i32 %178)
  %179 = load i32, ptr %177, align 4
  %arrayidx23.i21.i122 = getelementptr %struct.memcg_vmstats_percpu, ptr %169, i32 0, i32 5, i32 1
  %180 = ptrtoint ptr %arrayidx23.i21.i122 to i32
  %add28.i22.i123 = add i32 %176, %180
  %181 = inttoptr i32 %add28.i22.i123 to ptr
  %182 = ptrtoint ptr %181 to i32
  call void @__asan_load4_noabort(i32 %182)
  %183 = load i32, ptr %181, align 4
  %sub.i23.i124 = sub i32 %183, %179
  %cmp.i24.i125 = icmp slt i32 %sub.i23.i124, 0
  br i1 %cmp.i24.i125, label %if.then10.i129, label %mem_cgroup_event_ratelimit.exit26.i127

mem_cgroup_event_ratelimit.exit26.i127:           ; preds = %if.then.i126
  %tobool.not5.i161 = icmp eq ptr %from, null
  br i1 %tobool.not5.i161, label %memcg_check_events.exit130, label %while.body.i163

while.body.i163:                                  ; preds = %if.end.i172, %mem_cgroup_event_ratelimit.exit26.i127
  %memcg.addr.06.i162 = phi ptr [ %add.ptr.i.i169, %if.end.i172 ], [ %from, %mem_cgroup_event_ratelimit.exit26.i127 ]
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i162, i1 noundef zeroext false) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %land.rhs.i.i165)) #23
          to label %if.end.i172 [label %land.rhs.i.i165], !srcloc !461

land.rhs.i.i165:                                  ; preds = %while.body.i163
  %184 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i164 = icmp eq i8 %184, 0
  br i1 %tobool4.not.i.i164, label %if.then.i166, label %if.end.i172

if.then.i166:                                     ; preds = %land.rhs.i.i165
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i162, i1 noundef zeroext true) #23
  br label %if.end.i172

if.end.i172:                                      ; preds = %if.then.i166, %land.rhs.i.i165, %while.body.i163
  %parent.i.i167 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.06.i162, i32 0, i32 2, i32 13
  %185 = ptrtoint ptr %parent.i.i167 to i32
  call void @__asan_load4_noabort(i32 %185)
  %186 = load ptr, ptr %parent.i.i167, align 4
  %tobool.not.i.i168 = icmp eq ptr %186, null
  %add.ptr.i.i169 = getelementptr i8, ptr %186, i32 -176
  %tobool.not7.i170 = icmp eq ptr %add.ptr.i.i169, null
  %tobool.not.i171 = or i1 %tobool.not.i.i168, %tobool.not7.i170
  br i1 %tobool.not.i171, label %memcg_check_events.exit130, label %while.body.i163

if.then10.i129:                                   ; preds = %if.then.i126
  %add32.i.i128 = add i32 %179, 1024
  %187 = ptrtoint ptr %181 to i32
  call void @__asan_store4_noabort(i32 %187)
  store i32 %add32.i.i128, ptr %181, align 4
  %tobool.not5.i148 = icmp eq ptr %from, null
  br i1 %tobool.not5.i148, label %mem_cgroup_threshold.exit160, label %while.body.i150

while.body.i150:                                  ; preds = %if.end.i159, %if.then10.i129
  %memcg.addr.06.i149 = phi ptr [ %add.ptr.i.i156, %if.end.i159 ], [ %from, %if.then10.i129 ]
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i149, i1 noundef zeroext false) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_move_account, %land.rhs.i.i152)) #23
          to label %if.end.i159 [label %land.rhs.i.i152], !srcloc !461

land.rhs.i.i152:                                  ; preds = %while.body.i150
  %188 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i151 = icmp eq i8 %188, 0
  br i1 %tobool4.not.i.i151, label %if.then.i153, label %if.end.i159

if.then.i153:                                     ; preds = %land.rhs.i.i152
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06.i149, i1 noundef zeroext true) #23
  br label %if.end.i159

if.end.i159:                                      ; preds = %if.then.i153, %land.rhs.i.i152, %while.body.i150
  %parent.i.i154 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.06.i149, i32 0, i32 2, i32 13
  %189 = ptrtoint ptr %parent.i.i154 to i32
  call void @__asan_load4_noabort(i32 %189)
  %190 = load ptr, ptr %parent.i.i154, align 4
  %tobool.not.i.i155 = icmp eq ptr %190, null
  %add.ptr.i.i156 = getelementptr i8, ptr %190, i32 -176
  %tobool.not7.i157 = icmp eq ptr %add.ptr.i.i156, null
  %tobool.not.i158 = or i1 %tobool.not.i.i155, %tobool.not7.i157
  br i1 %tobool.not.i158, label %mem_cgroup_threshold.exit160, label %while.body.i150

mem_cgroup_threshold.exit160:                     ; preds = %if.end.i159, %if.then10.i129
  tail call fastcc void @mem_cgroup_update_tree(ptr noundef %from, i32 noundef 0) #23
  br label %memcg_check_events.exit130

memcg_check_events.exit130:                       ; preds = %mem_cgroup_threshold.exit160, %if.end.i172, %mem_cgroup_event_ratelimit.exit26.i127, %memcg_check_events.exit
  tail call void @trace_hardirqs_on() #23
  tail call void asm sideeffect "\09cpsie i\09\09\09@ arch_local_irq_enable", "~{memory},~{cc}"() #23, !srcloc !522
  br label %out_unlock

out_unlock:                                       ; preds = %memcg_check_events.exit130, %if.end51
  %ret.0 = phi i32 [ -22, %if.end51 ], [ 0, %memcg_check_events.exit130 ]
  tail call void @folio_unlock(ptr noundef %4) #23
  br label %out

out:                                              ; preds = %out_unlock, %folio_trylock.exit, %folio_flags.exit.i
  %ret.1 = phi i32 [ %ret.0, %out_unlock ], [ -16, %folio_trylock.exit ], [ -16, %folio_flags.exit.i ]
  ret i32 %ret.1
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @putback_lru_page(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @mem_cgroup_move_swap_account([1 x i32] %entry.coerce, ptr nocapture noundef readonly %from, ptr nocapture noundef readonly %to) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_move_swap_account, %mem_cgroup_id.exit)) #23
          to label %if.end.i [label %mem_cgroup_id.exit], !srcloc !461

if.end.i:                                         ; preds = %entry
  %id.i = getelementptr inbounds %struct.mem_cgroup, ptr %from, i32 0, i32 1
  %0 = ptrtoint ptr %id.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %id.i, align 8
  %conv.i = trunc i32 %1 to i16
  br label %mem_cgroup_id.exit

mem_cgroup_id.exit:                               ; preds = %if.end.i, %entry
  %retval.0.i = phi i16 [ %conv.i, %if.end.i ], [ 0, %entry ]
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_move_swap_account, %mem_cgroup_id.exit16)) #23
          to label %if.end.i14 [label %mem_cgroup_id.exit16], !srcloc !461

if.end.i14:                                       ; preds = %mem_cgroup_id.exit
  %id.i12 = getelementptr inbounds %struct.mem_cgroup, ptr %to, i32 0, i32 1
  %2 = ptrtoint ptr %id.i12 to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %id.i12, align 8
  %conv.i13 = trunc i32 %3 to i16
  br label %mem_cgroup_id.exit16

mem_cgroup_id.exit16:                             ; preds = %if.end.i14, %mem_cgroup_id.exit
  %retval.0.i15 = phi i16 [ %conv.i13, %if.end.i14 ], [ 0, %mem_cgroup_id.exit ]
  %call5 = tail call zeroext i16 @swap_cgroup_cmpxchg([1 x i32] %entry.coerce, i16 noundef zeroext %retval.0.i, i16 noundef zeroext %retval.0.i15) #23
  %cmp = icmp eq i16 %call5, %retval.0.i
  br i1 %cmp, label %if.then, label %cleanup

if.then:                                          ; preds = %mem_cgroup_id.exit16
  %4 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i.i = and i32 %4, 128
  %tobool.not.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i, label %if.then21.i, label %do.end11.i

do.end11.i:                                       ; preds = %if.then
  tail call void @__mod_memcg_state(ptr noundef %from, i32 noundef 40, i32 noundef -1) #23
  br label %do.body23.i

if.then21.i:                                      ; preds = %if.then
  tail call void @trace_hardirqs_off() #23
  tail call void @__mod_memcg_state(ptr noundef %from, i32 noundef 40, i32 noundef -1) #23
  tail call void @trace_hardirqs_on() #23
  br label %do.body23.i

do.body23.i:                                      ; preds = %if.then21.i, %do.end11.i
  %5 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i.i = and i32 %5, 128
  %tobool32.not.i = icmp eq i32 %and.i.i.i, 0
  br i1 %tobool32.not.i, label %if.then36.i, label %mod_memcg_state.exit, !prof !466

if.then36.i:                                      ; preds = %do.body23.i
  tail call void @warn_bogus_irq_restore() #23
  br label %mod_memcg_state.exit

mod_memcg_state.exit:                             ; preds = %if.then36.i, %do.body23.i
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %4) #23, !srcloc !467
  %6 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ arch_local_irq_save\0A\09cpsid\09i", "=r,~{memory},~{cc}"() #23, !srcloc !464
  %and.i.i17 = and i32 %6, 128
  %tobool.not.i18 = icmp eq i32 %and.i.i17, 0
  br i1 %tobool.not.i18, label %if.then21.i20, label %do.end11.i19

do.end11.i19:                                     ; preds = %mod_memcg_state.exit
  tail call void @__mod_memcg_state(ptr noundef %to, i32 noundef 40, i32 noundef 1) #23
  br label %do.body23.i23

if.then21.i20:                                    ; preds = %mod_memcg_state.exit
  tail call void @trace_hardirqs_off() #23
  tail call void @__mod_memcg_state(ptr noundef %to, i32 noundef 40, i32 noundef 1) #23
  tail call void @trace_hardirqs_on() #23
  br label %do.body23.i23

do.body23.i23:                                    ; preds = %if.then21.i20, %do.end11.i19
  %7 = tail call i32 asm sideeffect "\09mrs\09$0, cpsr\09@ local_save_flags", "=r,~{memory},~{cc}"() #23, !srcloc !465
  %and.i.i.i21 = and i32 %7, 128
  %tobool32.not.i22 = icmp eq i32 %and.i.i.i21, 0
  br i1 %tobool32.not.i22, label %if.then36.i24, label %mod_memcg_state.exit25, !prof !466

if.then36.i24:                                    ; preds = %do.body23.i23
  tail call void @warn_bogus_irq_restore() #23
  br label %mod_memcg_state.exit25

mod_memcg_state.exit25:                           ; preds = %if.then36.i24, %do.body23.i23
  tail call void asm sideeffect "\09msr\09cpsr_c, $0\09@ local_irq_restore", "r,~{memory},~{cc}"(i32 %6) #23, !srcloc !467
  br label %cleanup

cleanup:                                          ; preds = %mod_memcg_state.exit25, %mem_cgroup_id.exit16
  %retval.0 = phi i32 [ 0, %mod_memcg_state.exit25 ], [ -22, %mem_cgroup_id.exit16 ]
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i1 @folio_mapped(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @folio_mapping(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @folio_unlock(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @inode_to_bdi(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local zeroext i16 @swap_cgroup_cmpxchg([1 x i32], i16 noundef zeroext, i16 noundef zeroext) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i64 @memory_current_read(ptr noundef %css, ptr nocapture noundef readnone %cft) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 2
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %memory, i32 noundef 4) #23
  %0 = ptrtoint ptr %memory to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile i32, ptr %memory, align 4
  %conv = zext i32 %1 to i64
  %mul = shl nuw nsw i64 %conv, 12
  ret i64 %mul
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memory_min_show(ptr noundef %m, ptr nocapture noundef readnone %v) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %private.i.i = getelementptr inbounds %struct.seq_file, ptr %m, i32 0, i32 11
  %0 = ptrtoint ptr %private.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private.i.i, align 8
  %call.i.i = tail call ptr @of_css(ptr noundef %1) #23
  %min = getelementptr inbounds %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 2, i32 1
  %2 = ptrtoint ptr %min to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %min, align 4
  %cmp.i = icmp eq i32 %3, 2147483647
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  tail call void @seq_puts(ptr noundef %m, ptr noundef nonnull @.str.124) #23
  br label %seq_puts_memcg_tunable.exit

if.else.i:                                        ; preds = %entry
  %conv.i = zext i32 %3 to i64
  %mul.i = shl nuw nsw i64 %conv.i, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.125, i64 noundef %mul.i) #23
  br label %seq_puts_memcg_tunable.exit

seq_puts_memcg_tunable.exit:                      ; preds = %if.else.i, %if.then.i
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memory_min_write(ptr noundef %of, ptr noundef %buf, i32 noundef %nbytes, i64 noundef %off) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %min = alloca i32, align 4
  %call = tail call ptr @of_css(ptr noundef %of) #23
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %min) #23
  %0 = ptrtoint ptr %min to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %min, align 4, !annotation !492
  %call.i = tail call ptr @strim(ptr noundef %buf) #23
  %call3 = call i32 @page_counter_memparse(ptr noundef %call.i, ptr noundef nonnull @.str.126, ptr noundef nonnull %min) #23
  %tobool.not = icmp eq i32 %call3, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 2
  %1 = ptrtoint ptr %min to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %min, align 4
  call void @page_counter_set_min(ptr noundef %memory, i32 noundef %2) #23
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %nbytes, %if.end ], [ %call3, %entry ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %min) #23
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memory_low_show(ptr noundef %m, ptr nocapture noundef readnone %v) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %private.i.i = getelementptr inbounds %struct.seq_file, ptr %m, i32 0, i32 11
  %0 = ptrtoint ptr %private.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private.i.i, align 8
  %call.i.i = tail call ptr @of_css(ptr noundef %1) #23
  %low = getelementptr inbounds %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 2, i32 2
  %2 = ptrtoint ptr %low to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %low, align 8
  %cmp.i = icmp eq i32 %3, 2147483647
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  tail call void @seq_puts(ptr noundef %m, ptr noundef nonnull @.str.124) #23
  br label %seq_puts_memcg_tunable.exit

if.else.i:                                        ; preds = %entry
  %conv.i = zext i32 %3 to i64
  %mul.i = shl nuw nsw i64 %conv.i, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.125, i64 noundef %mul.i) #23
  br label %seq_puts_memcg_tunable.exit

seq_puts_memcg_tunable.exit:                      ; preds = %if.else.i, %if.then.i
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memory_low_write(ptr noundef %of, ptr noundef %buf, i32 noundef %nbytes, i64 noundef %off) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %low = alloca i32, align 4
  %call = tail call ptr @of_css(ptr noundef %of) #23
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %low) #23
  %0 = ptrtoint ptr %low to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %low, align 4, !annotation !492
  %call.i = tail call ptr @strim(ptr noundef %buf) #23
  %call3 = call i32 @page_counter_memparse(ptr noundef %call.i, ptr noundef nonnull @.str.126, ptr noundef nonnull %low) #23
  %tobool.not = icmp eq i32 %call3, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 2
  %1 = ptrtoint ptr %low to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %low, align 4
  call void @page_counter_set_low(ptr noundef %memory, i32 noundef %2) #23
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %nbytes, %if.end ], [ %call3, %entry ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %low) #23
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memory_high_show(ptr noundef %m, ptr nocapture noundef readnone %v) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %private.i.i = getelementptr inbounds %struct.seq_file, ptr %m, i32 0, i32 11
  %0 = ptrtoint ptr %private.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private.i.i, align 8
  %call.i.i = tail call ptr @of_css(ptr noundef %1) #23
  %high = getelementptr inbounds %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 2, i32 3
  %2 = ptrtoint ptr %high to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %high, align 4
  %cmp.i = icmp eq i32 %3, 2147483647
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  tail call void @seq_puts(ptr noundef %m, ptr noundef nonnull @.str.124) #23
  br label %seq_puts_memcg_tunable.exit

if.else.i:                                        ; preds = %entry
  %conv.i = zext i32 %3 to i64
  %mul.i = shl nuw nsw i64 %conv.i, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.125, i64 noundef %mul.i) #23
  br label %seq_puts_memcg_tunable.exit

seq_puts_memcg_tunable.exit:                      ; preds = %if.else.i, %if.then.i
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memory_high_write(ptr noundef %of, ptr noundef %buf, i32 noundef %nbytes, i64 noundef %off) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %high = alloca i32, align 4
  %call = tail call ptr @of_css(ptr noundef %of) #23
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %high) #23
  %0 = ptrtoint ptr %high to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %high, align 4, !annotation !492
  %call.i = tail call ptr @strim(ptr noundef %buf) #23
  %call3 = call i32 @page_counter_memparse(ptr noundef %call.i, ptr noundef nonnull @.str.126, ptr noundef nonnull %high) #23
  %tobool.not = icmp eq i32 %call3, 0
  br i1 %tobool.not, label %if.end, label %cleanup22

if.end:                                           ; preds = %entry
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 2
  %1 = ptrtoint ptr %high to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %high, align 4
  %high.i = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 2, i32 3
  %3 = ptrtoint ptr %high.i to i32
  call void @__asan_store4_noabort(i32 %3)
  store volatile i32 %2, ptr %high.i, align 4
  %call.i.i.i45 = call zeroext i1 @__kasan_check_read(ptr noundef %memory, i32 noundef 4) #23
  %4 = ptrtoint ptr %memory to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %memory, align 4
  %6 = ptrtoint ptr %high to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %high, align 4
  %cmp.not46 = icmp ugt i32 %5, %7
  br i1 %cmp.not46, label %if.end7, label %for.end

if.end7:                                          ; preds = %cleanup, %if.end
  %8 = phi i32 [ %24, %cleanup ], [ %7, %if.end ]
  %9 = phi i32 [ %22, %cleanup ], [ %5, %if.end ]
  %drained.0.off048 = phi i1 [ true, %cleanup ], [ false, %if.end ]
  %nr_retries.047 = phi i32 [ %nr_retries.2, %cleanup ], [ 16, %if.end ]
  %10 = call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i = and i32 %10, -16384
  %11 = inttoptr i32 %and.i to ptr
  %task = getelementptr inbounds %struct.thread_info, ptr %11, i32 0, i32 2
  %12 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %task, align 8
  %stack.i.i = getelementptr inbounds %struct.task_struct, ptr %13, i32 0, i32 1
  %14 = ptrtoint ptr %stack.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %stack.i.i, align 4
  %16 = ptrtoint ptr %15 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load volatile i32, ptr %15, align 4
  %18 = and i32 %17, 256
  %tobool.not.i = icmp eq i32 %18, 0
  br i1 %tobool.not.i, label %signal_pending.exit, label %for.end, !prof !460

signal_pending.exit:                              ; preds = %if.end7
  %19 = ptrtoint ptr %15 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load volatile i32, ptr %15, align 4
  %and1.i.i.i.i.i = and i32 %20, 1
  %tobool10.not = icmp eq i32 %and1.i.i.i.i.i, 0
  br i1 %tobool10.not, label %if.end12, label %for.end

if.end12:                                         ; preds = %signal_pending.exit
  br i1 %drained.0.off048, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end12
  call fastcc void @drain_all_stock(ptr noundef %call)
  br label %cleanup

if.end15:                                         ; preds = %if.end12
  %sub = sub i32 %9, %8
  %call16 = call i32 @try_to_free_mem_cgroup_pages(ptr noundef %call, i32 noundef %sub, i32 noundef 3264, i1 noundef zeroext true) #23
  %tobool17.not = icmp eq i32 %call16, 0
  br i1 %tobool17.not, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %if.end15
  %dec = add i32 %nr_retries.047, -1
  %tobool18.not = icmp eq i32 %nr_retries.047, 0
  br i1 %tobool18.not, label %for.end, label %cleanup

cleanup:                                          ; preds = %land.lhs.true, %if.end15, %if.then14
  %nr_retries.2 = phi i32 [ %nr_retries.047, %if.then14 ], [ %nr_retries.047, %if.end15 ], [ %dec, %land.lhs.true ]
  %call.i.i.i = call zeroext i1 @__kasan_check_read(ptr noundef %memory, i32 noundef 4) #23
  %21 = ptrtoint ptr %memory to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load volatile i32, ptr %memory, align 4
  %23 = ptrtoint ptr %high to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %high, align 4
  %cmp.not = icmp ugt i32 %22, %24
  br i1 %cmp.not, label %if.end7, label %for.end

for.end:                                          ; preds = %cleanup, %land.lhs.true, %signal_pending.exit, %if.end7, %if.end
  %cgwb_domain.i = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 41
  call void @_raw_spin_lock(ptr noundef %cgwb_domain.i) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %25 = load volatile i32, ptr @jiffies, align 128
  %dirty_limit_tstamp.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 41, i32 4
  %26 = ptrtoint ptr %dirty_limit_tstamp.i.i to i32
  call void @__asan_store4_noabort(i32 %26)
  store i32 %25, ptr %dirty_limit_tstamp.i.i, align 4
  %dirty_limit.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 41, i32 5
  %27 = ptrtoint ptr %dirty_limit.i.i to i32
  call void @__asan_store4_noabort(i32 %27)
  store i32 0, ptr %dirty_limit.i.i, align 8
  call void @_raw_spin_unlock(ptr noundef %cgwb_domain.i) #23
  br label %cleanup22

cleanup22:                                        ; preds = %for.end, %entry
  %retval.0 = phi i32 [ %nbytes, %for.end ], [ %call3, %entry ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %high) #23
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memory_max_show(ptr noundef %m, ptr nocapture noundef readnone %v) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %private.i.i = getelementptr inbounds %struct.seq_file, ptr %m, i32 0, i32 11
  %0 = ptrtoint ptr %private.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private.i.i, align 8
  %call.i.i = tail call ptr @of_css(ptr noundef %1) #23
  %max = getelementptr inbounds %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 2, i32 4
  %2 = ptrtoint ptr %max to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %max, align 16
  %cmp.i = icmp eq i32 %3, 2147483647
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  tail call void @seq_puts(ptr noundef %m, ptr noundef nonnull @.str.124) #23
  br label %seq_puts_memcg_tunable.exit

if.else.i:                                        ; preds = %entry
  %conv.i = zext i32 %3 to i64
  %mul.i = shl nuw nsw i64 %conv.i, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.125, i64 noundef %mul.i) #23
  br label %seq_puts_memcg_tunable.exit

seq_puts_memcg_tunable.exit:                      ; preds = %if.else.i, %if.then.i
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memory_max_write(ptr noundef %of, ptr noundef %buf, i32 noundef %nbytes, i64 noundef %off) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %max = alloca i32, align 4
  %call = tail call ptr @of_css(ptr noundef %of) #23
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %max) #23
  %0 = ptrtoint ptr %max to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %max, align 4, !annotation !492
  %call.i63 = tail call ptr @strim(ptr noundef %buf) #23
  %call3 = call i32 @page_counter_memparse(ptr noundef %call.i63, ptr noundef nonnull @.str.126, ptr noundef nonnull %max) #23
  %tobool.not = icmp eq i32 %call3, 0
  br i1 %tobool.not, label %if.end, label %cleanup42

if.end:                                           ; preds = %entry
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 2
  %max4 = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 2, i32 4
  %call.i = call zeroext i1 @__kasan_check_write(ptr noundef %max4, i32 noundef 4) #23
  call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !565
  %1 = ptrtoint ptr %max to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %max, align 4
  call void @llvm.prefetch.p0(ptr %max4, i32 1, i32 3, i32 1) #23
  %3 = call { i32, i32 } asm sideeffect "@\09__xchg4\0A1:\09ldrex\09$0, [$3]\0A\09strex\09$1, $2, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,r,r,~{memory},~{cc}"(i32 %2, ptr %max4) #23, !srcloc !497
  call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !566
  %arrayidx.i = getelementptr %struct.mem_cgroup, ptr %call, i32 0, i32 28, i32 3
  %events_local_file.i = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 15
  %call.i.i.i77 = call zeroext i1 @__kasan_check_read(ptr noundef %memory, i32 noundef 4) #23
  %4 = ptrtoint ptr %memory to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %memory, align 4
  %6 = ptrtoint ptr %max to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load i32, ptr %max, align 4
  %cmp.not78 = icmp ugt i32 %5, %7
  br i1 %cmp.not78, label %if.end23, label %for.end

if.end23:                                         ; preds = %cleanup, %if.end
  %8 = phi i32 [ %30, %cleanup ], [ %7, %if.end ]
  %9 = phi i32 [ %28, %cleanup ], [ %5, %if.end ]
  %nr_reclaims.080 = phi i32 [ %nr_reclaims.2, %cleanup ], [ 16, %if.end ]
  %drained.0.off079 = phi i1 [ true, %cleanup ], [ false, %if.end ]
  %10 = call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i = and i32 %10, -16384
  %11 = inttoptr i32 %and.i to ptr
  %task = getelementptr inbounds %struct.thread_info, ptr %11, i32 0, i32 2
  %12 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load ptr, ptr %task, align 8
  %stack.i.i = getelementptr inbounds %struct.task_struct, ptr %13, i32 0, i32 1
  %14 = ptrtoint ptr %stack.i.i to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load ptr, ptr %stack.i.i, align 4
  %16 = ptrtoint ptr %15 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load volatile i32, ptr %15, align 4
  %18 = and i32 %17, 256
  %tobool.not.i = icmp eq i32 %18, 0
  br i1 %tobool.not.i, label %signal_pending.exit, label %for.end, !prof !460

signal_pending.exit:                              ; preds = %if.end23
  %19 = ptrtoint ptr %15 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load volatile i32, ptr %15, align 4
  %and1.i.i.i.i.i = and i32 %20, 1
  %tobool26.not = icmp eq i32 %and1.i.i.i.i.i, 0
  br i1 %tobool26.not, label %if.end28, label %for.end

if.end28:                                         ; preds = %signal_pending.exit
  br i1 %drained.0.off079, label %if.end31, label %if.then30

if.then30:                                        ; preds = %if.end28
  call fastcc void @drain_all_stock(ptr noundef %call)
  br label %cleanup

if.end31:                                         ; preds = %if.end28
  %tobool32.not = icmp eq i32 %nr_reclaims.080, 0
  br i1 %tobool32.not, label %if.end38, label %if.then33

if.then33:                                        ; preds = %if.end31
  %sub = sub i32 %9, %8
  %call34 = call i32 @try_to_free_mem_cgroup_pages(ptr noundef %call, i32 noundef %sub, i32 noundef 3264, i1 noundef zeroext true) #23
  %tobool35.not = icmp eq i32 %call34, 0
  %dec = sext i1 %tobool35.not to i32
  %spec.select = add i32 %nr_reclaims.080, %dec
  br label %cleanup

if.end38:                                         ; preds = %if.end31
  %call.i.i.i64 = call zeroext i1 @__kasan_check_write(ptr noundef %arrayidx.i, i32 noundef 4) #23
  call void @llvm.prefetch.p0(ptr %arrayidx.i, i32 1, i32 3, i32 1) #23
  %21 = call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %arrayidx.i, ptr %arrayidx.i, i32 1, ptr elementtype(i32) %arrayidx.i) #23, !srcloc !468
  call void @cgroup_file_notify(ptr noundef %events_local_file.i) #23
  br label %do.body.i

do.body.i:                                        ; preds = %land.rhs.i, %if.end38
  %memcg.addr.0.i = phi ptr [ %call, %if.end38 ], [ %add.ptr.i.i, %land.rhs.i ]
  %arrayidx3.i = getelementptr %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 27, i32 3
  %call.i.i33.i = call zeroext i1 @__kasan_check_write(ptr noundef %arrayidx3.i, i32 noundef 4) #23
  call void @llvm.prefetch.p0(ptr %arrayidx3.i, i32 1, i32 3, i32 1) #23
  %22 = call { i32, i32 } asm sideeffect "@ atomic_add\0A1:\09ldrex\09$0, [$3]\0A\09add\09$0, $0, $4\0A\09strex\09$1, $0, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,=*Qo,r,Ir,*Qo,~{cc}"(ptr elementtype(i32) %arrayidx3.i, ptr %arrayidx3.i, i32 1, ptr elementtype(i32) %arrayidx3.i) #23, !srcloc !468
  %events_file.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 14
  call void @cgroup_file_notify(ptr noundef %events_file.i) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@memory_max_write, %memcg_memory_event.exit)) #23
          to label %if.end13.i [label %memcg_memory_event.exit], !srcloc !461

if.end13.i:                                       ; preds = %do.body.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7) to i32))
  %23 = load i32, ptr getelementptr inbounds (%struct.cgroup_root, ptr @cgrp_dfl_root, i32 0, i32 7), align 4
  %and.i66 = and i32 %23, 32
  %tobool14.not.i = icmp eq i32 %and.i66, 0
  br i1 %tobool14.not.i, label %do.cond.i, label %memcg_memory_event.exit

do.cond.i:                                        ; preds = %if.end13.i
  %parent.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.0.i, i32 0, i32 2, i32 13
  %24 = ptrtoint ptr %parent.i.i to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load ptr, ptr %parent.i.i, align 4
  %tobool.not.i.i = icmp eq ptr %25, null
  %add.ptr.i.i = getelementptr i8, ptr %25, i32 -176
  %tobool18.not36.i = icmp eq ptr %add.ptr.i.i, null
  %tobool18.not.i = or i1 %tobool.not.i.i, %tobool18.not36.i
  br i1 %tobool18.not.i, label %memcg_memory_event.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %do.cond.i
  %26 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i = icmp eq ptr %26, %add.ptr.i.i
  br i1 %cmp.i.i, label %memcg_memory_event.exit, label %do.body.i

memcg_memory_event.exit:                          ; preds = %land.rhs.i, %do.cond.i, %if.end13.i, %do.body.i
  %call39 = call fastcc zeroext i1 @mem_cgroup_out_of_memory(ptr noundef %call, i32 noundef 3264, i32 noundef 0)
  br i1 %call39, label %cleanup, label %for.end

cleanup:                                          ; preds = %memcg_memory_event.exit, %if.then33, %if.then30
  %nr_reclaims.2 = phi i32 [ %spec.select, %if.then33 ], [ %nr_reclaims.080, %if.then30 ], [ 0, %memcg_memory_event.exit ]
  %call.i.i.i = call zeroext i1 @__kasan_check_read(ptr noundef %memory, i32 noundef 4) #23
  %27 = ptrtoint ptr %memory to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load volatile i32, ptr %memory, align 4
  %29 = ptrtoint ptr %max to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %max, align 4
  %cmp.not = icmp ugt i32 %28, %30
  br i1 %cmp.not, label %if.end23, label %for.end

for.end:                                          ; preds = %cleanup, %memcg_memory_event.exit, %signal_pending.exit, %if.end23, %if.end
  %cgwb_domain.i = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 41
  call void @_raw_spin_lock(ptr noundef %cgwb_domain.i) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @jiffies to i32))
  %31 = load volatile i32, ptr @jiffies, align 128
  %dirty_limit_tstamp.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 41, i32 4
  %32 = ptrtoint ptr %dirty_limit_tstamp.i.i to i32
  call void @__asan_store4_noabort(i32 %32)
  store i32 %31, ptr %dirty_limit_tstamp.i.i, align 4
  %dirty_limit.i.i = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 41, i32 5
  %33 = ptrtoint ptr %dirty_limit.i.i to i32
  call void @__asan_store4_noabort(i32 %33)
  store i32 0, ptr %dirty_limit.i.i, align 8
  call void @_raw_spin_unlock(ptr noundef %cgwb_domain.i) #23
  br label %cleanup42

cleanup42:                                        ; preds = %for.end, %entry
  %retval.0 = phi i32 [ %nbytes, %for.end ], [ %call3, %entry ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %max) #23
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memory_events_show(ptr noundef %m, ptr nocapture noundef readnone %v) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %private.i.i = getelementptr inbounds %struct.seq_file, ptr %m, i32 0, i32 11
  %0 = ptrtoint ptr %private.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private.i.i, align 8
  %call.i.i = tail call ptr @of_css(ptr noundef %1) #23
  %memory_events = getelementptr inbounds %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 27
  tail call fastcc void @__memory_events_show(ptr noundef %m, ptr noundef %memory_events)
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memory_events_local_show(ptr noundef %m, ptr nocapture noundef readnone %v) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %private.i.i = getelementptr inbounds %struct.seq_file, ptr %m, i32 0, i32 11
  %0 = ptrtoint ptr %private.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private.i.i, align 8
  %call.i.i = tail call ptr @of_css(ptr noundef %1) #23
  %memory_events_local = getelementptr inbounds %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 28
  tail call fastcc void @__memory_events_show(ptr noundef %m, ptr noundef %memory_events_local)
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memory_stat_show(ptr noundef %m, ptr nocapture noundef readnone %v) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %private.i.i = getelementptr inbounds %struct.seq_file, ptr %m, i32 0, i32 11
  %0 = ptrtoint ptr %private.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private.i.i, align 8
  %call.i.i = tail call ptr @of_css(ptr noundef %1) #23
  %call1 = tail call fastcc ptr @memory_stat_format(ptr noundef %call.i.i)
  %tobool.not = icmp eq ptr %call1, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  tail call void @seq_puts(ptr noundef %m, ptr noundef nonnull %call1) #23
  tail call void @kfree(ptr noundef nonnull %call1) #23
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memory_oom_group_show(ptr noundef %m, ptr nocapture noundef readnone %v) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %private.i.i = getelementptr inbounds %struct.seq_file, ptr %m, i32 0, i32 11
  %0 = ptrtoint ptr %private.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private.i.i, align 8
  %call.i.i = tail call ptr @of_css(ptr noundef %1) #23
  %oom_group = getelementptr inbounds %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 9
  %2 = ptrtoint ptr %oom_group to i32
  call void @__asan_load1_noabort(i32 %2)
  %3 = load i8, ptr %oom_group, align 4, !range !488
  %4 = zext i8 %3 to i32
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.133, i32 noundef %4) #23
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memory_oom_group_write(ptr noundef %of, ptr noundef %buf, i32 noundef %nbytes, i64 noundef %off) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %oom_group = alloca i32, align 4
  %call = tail call ptr @of_css(ptr noundef %of) #23
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oom_group) #23
  %0 = ptrtoint ptr %oom_group to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %oom_group, align 4, !annotation !492
  %call.i = tail call ptr @strim(ptr noundef %buf) #23
  %tobool.not = icmp eq ptr %call.i, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call3 = call i32 @kstrtoint(ptr noundef nonnull %call.i, i32 noundef 0, ptr noundef nonnull %oom_group) #23
  %tobool4.not = icmp eq i32 %call3, 0
  br i1 %tobool4.not, label %if.end6, label %cleanup

if.end6:                                          ; preds = %if.end
  %1 = ptrtoint ptr %oom_group to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %oom_group, align 4
  %switch = icmp ult i32 %2, 2
  br i1 %switch, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end6
  %tobool10 = icmp ne i32 %2, 0
  %oom_group11 = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 9
  %frombool = zext i1 %tobool10 to i8
  %3 = ptrtoint ptr %oom_group11 to i32
  call void @__asan_store1_noabort(i32 %3)
  store i8 %frombool, ptr %oom_group11, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end9, %if.end6, %if.end, %entry
  %retval.0 = phi i32 [ %nbytes, %if.end9 ], [ -22, %entry ], [ %call3, %if.end ], [ -22, %if.end6 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oom_group) #23
  ret i32 %retval.0
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @seq_puts(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @seq_printf(ptr noundef, ptr noundef, ...) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @of_css(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @page_counter_memparse(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @strim(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @__memory_events_show(ptr noundef %m, ptr noundef %events) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %events, i32 noundef 4) #23
  %0 = ptrtoint ptr %events to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load volatile i32, ptr %events, align 4
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.127, i32 noundef %1) #23
  %arrayidx1 = getelementptr %struct.atomic_t, ptr %events, i32 1
  %call.i.i21 = tail call zeroext i1 @__kasan_check_read(ptr noundef %arrayidx1, i32 noundef 4) #23
  %2 = ptrtoint ptr %arrayidx1 to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %arrayidx1, align 4
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.128, i32 noundef %3) #23
  %arrayidx3 = getelementptr %struct.atomic_t, ptr %events, i32 2
  %call.i.i22 = tail call zeroext i1 @__kasan_check_read(ptr noundef %arrayidx3, i32 noundef 4) #23
  %4 = ptrtoint ptr %arrayidx3 to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %arrayidx3, align 4
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.129, i32 noundef %5) #23
  %arrayidx5 = getelementptr %struct.atomic_t, ptr %events, i32 3
  %call.i.i23 = tail call zeroext i1 @__kasan_check_read(ptr noundef %arrayidx5, i32 noundef 4) #23
  %6 = ptrtoint ptr %arrayidx5 to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %arrayidx5, align 4
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.130, i32 noundef %7) #23
  %arrayidx7 = getelementptr %struct.atomic_t, ptr %events, i32 4
  %call.i.i24 = tail call zeroext i1 @__kasan_check_read(ptr noundef %arrayidx7, i32 noundef 4) #23
  %8 = ptrtoint ptr %arrayidx7 to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load volatile i32, ptr %arrayidx7, align 4
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.131, i32 noundef %9) #23
  %arrayidx9 = getelementptr %struct.atomic_t, ptr %events, i32 5
  %call.i.i25 = tail call zeroext i1 @__kasan_check_read(ptr noundef %arrayidx9, i32 noundef 4) #23
  %10 = ptrtoint ptr %arrayidx9 to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %arrayidx9, align 4
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.132, i32 noundef %11) #23
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @kstrtoint(ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i64 @mem_cgroup_read_u64(ptr noundef %css, ptr nocapture noundef readonly %cft) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %private = getelementptr inbounds %struct.cftype, ptr %cft, i32 0, i32 1
  %0 = ptrtoint ptr %private to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %private, align 4
  %shr = lshr i32 %1, 16
  %trunc = trunc i32 %shr to i16
  switch i16 %trunc, label %do.body [
    i16 0, label %sw.bb
    i16 1, label %sw.bb1
    i16 3, label %sw.bb2
    i16 4, label %sw.bb3
  ]

sw.bb:                                            ; preds = %entry
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 2
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %2 = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 3
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %kmem = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 4
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  %tcpmem = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 5
  br label %sw.epilog

do.body:                                          ; preds = %entry
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 3601, 0\0A.popsection", ""() #23, !srcloc !567
  unreachable

sw.epilog:                                        ; preds = %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %counter.0 = phi ptr [ %tcpmem, %sw.bb3 ], [ %kmem, %sw.bb2 ], [ %2, %sw.bb1 ], [ %memory, %sw.bb ]
  %trunc56 = trunc i32 %1 to i16
  switch i16 %trunc56, label %do.body34 [
    i16 0, label %sw.bb9
    i16 1, label %sw.bb22
    i16 2, label %sw.bb25
    i16 3, label %sw.bb28
    i16 4, label %sw.bb30
  ]

sw.bb9:                                           ; preds = %sw.epilog
  %memory10 = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 2
  %cmp = icmp eq ptr %counter.0, %memory10
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb9
  %3 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i = icmp eq ptr %3, %css
  br i1 %cmp.i.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.then
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @stats_flush_threshold, i32 noundef 4) #23
  %4 = load volatile i32, ptr @stats_flush_threshold, align 4
  %call.i.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @__num_online_cpus, i32 noundef 4) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__num_online_cpus to i32))
  %5 = load volatile i32, ptr @__num_online_cpus, align 4
  %cmp.i20.i = icmp ugt i32 %4, %5
  br i1 %cmp.i20.i, label %if.then.i.i, label %mem_cgroup_flush_stats.exit.i

if.then.i.i:                                      ; preds = %if.then.i
  tail call fastcc void @__mem_cgroup_flush_stats() #23
  br label %mem_cgroup_flush_stats.exit.i

mem_cgroup_flush_stats.exit.i:                    ; preds = %if.then.i.i, %if.then.i
  %arrayidx.i.i = getelementptr %struct.mem_cgroup, ptr %css, i32 0, i32 26, i32 0, i32 19
  %6 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %arrayidx.i.i, align 4
  %arrayidx.i22.i = getelementptr %struct.mem_cgroup, ptr %css, i32 0, i32 26, i32 0, i32 17
  %8 = ptrtoint ptr %arrayidx.i22.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load volatile i32, ptr %arrayidx.i22.i, align 4
  %add.i = add i32 %9, %7
  br label %mem_cgroup_usage.exit

if.else.i:                                        ; preds = %if.then
  %call.i.i.i25.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %memory10, i32 noundef 4) #23
  %10 = ptrtoint ptr %memory10 to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load volatile i32, ptr %memory10, align 4
  br label %mem_cgroup_usage.exit

mem_cgroup_usage.exit:                            ; preds = %if.else.i, %mem_cgroup_flush_stats.exit.i
  %val.0.i = phi i32 [ %add.i, %mem_cgroup_flush_stats.exit.i ], [ %11, %if.else.i ]
  %conv = zext i32 %val.0.i to i64
  %mul = shl nuw nsw i64 %conv, 12
  br label %cleanup

if.end:                                           ; preds = %sw.bb9
  %12 = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 3
  %cmp12 = icmp eq ptr %counter.0, %12
  br i1 %cmp12, label %if.then14, label %if.end18

if.then14:                                        ; preds = %if.end
  %13 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i57 = icmp eq ptr %13, %css
  br i1 %cmp.i.i57, label %if.then.i61, label %if.else.i67

if.then.i61:                                      ; preds = %if.then14
  %call.i.i.i.i58 = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @stats_flush_threshold, i32 noundef 4) #23
  %14 = load volatile i32, ptr @stats_flush_threshold, align 4
  %call.i.i.i.i.i59 = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @__num_online_cpus, i32 noundef 4) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__num_online_cpus to i32))
  %15 = load volatile i32, ptr @__num_online_cpus, align 4
  %cmp.i20.i60 = icmp ugt i32 %14, %15
  br i1 %cmp.i20.i60, label %if.then.i.i62, label %mem_cgroup_flush_stats.exit.i66

if.then.i.i62:                                    ; preds = %if.then.i61
  tail call fastcc void @__mem_cgroup_flush_stats() #23
  br label %mem_cgroup_flush_stats.exit.i66

mem_cgroup_flush_stats.exit.i66:                  ; preds = %if.then.i.i62, %if.then.i61
  %arrayidx.i.i63 = getelementptr %struct.mem_cgroup, ptr %css, i32 0, i32 26, i32 0, i32 19
  %16 = ptrtoint ptr %arrayidx.i.i63 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load volatile i32, ptr %arrayidx.i.i63, align 4
  %arrayidx.i22.i64 = getelementptr %struct.mem_cgroup, ptr %css, i32 0, i32 26, i32 0, i32 17
  %18 = ptrtoint ptr %arrayidx.i22.i64 to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load volatile i32, ptr %arrayidx.i22.i64, align 4
  %add.i65 = add i32 %19, %17
  %arrayidx.i24.i = getelementptr %struct.mem_cgroup, ptr %css, i32 0, i32 26, i32 0, i32 40
  %20 = ptrtoint ptr %arrayidx.i24.i to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load volatile i32, ptr %arrayidx.i24.i, align 4
  %add5.i = add i32 %add.i65, %21
  br label %mem_cgroup_usage.exit69

if.else.i67:                                      ; preds = %if.then14
  %call.i.i.i26.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %12, i32 noundef 4) #23
  %22 = ptrtoint ptr %12 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load volatile i32, ptr %12, align 4
  br label %mem_cgroup_usage.exit69

mem_cgroup_usage.exit69:                          ; preds = %if.else.i67, %mem_cgroup_flush_stats.exit.i66
  %val.0.i68 = phi i32 [ %add5.i, %mem_cgroup_flush_stats.exit.i66 ], [ %23, %if.else.i67 ]
  %conv16 = zext i32 %val.0.i68 to i64
  %mul17 = shl nuw nsw i64 %conv16, 12
  br label %cleanup

if.end18:                                         ; preds = %if.end
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %counter.0, i32 noundef 4) #23
  %24 = ptrtoint ptr %counter.0 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load volatile i32, ptr %counter.0, align 4
  %conv20 = zext i32 %25 to i64
  %mul21 = shl nuw nsw i64 %conv20, 12
  br label %cleanup

sw.bb22:                                          ; preds = %sw.epilog
  %max = getelementptr inbounds %struct.page_counter, ptr %counter.0, i32 0, i32 4
  %26 = ptrtoint ptr %max to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load i32, ptr %max, align 4
  %conv23 = zext i32 %27 to i64
  %mul24 = shl nuw nsw i64 %conv23, 12
  br label %cleanup

sw.bb25:                                          ; preds = %sw.epilog
  %watermark = getelementptr inbounds %struct.page_counter, ptr %counter.0, i32 0, i32 11
  %28 = ptrtoint ptr %watermark to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load i32, ptr %watermark, align 4
  %conv26 = zext i32 %29 to i64
  %mul27 = shl nuw nsw i64 %conv26, 12
  br label %cleanup

sw.bb28:                                          ; preds = %sw.epilog
  %failcnt = getelementptr inbounds %struct.page_counter, ptr %counter.0, i32 0, i32 12
  %30 = ptrtoint ptr %failcnt to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load i32, ptr %failcnt, align 4
  %conv29 = zext i32 %31 to i64
  br label %cleanup

sw.bb30:                                          ; preds = %sw.epilog
  %soft_limit = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 7
  %32 = ptrtoint ptr %soft_limit to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load i32, ptr %soft_limit, align 4
  %conv31 = zext i32 %33 to i64
  %mul32 = shl nuw nsw i64 %conv31, 12
  br label %cleanup

do.body34:                                        ; preds = %sw.epilog
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 3620, 0\0A.popsection", ""() #23, !srcloc !568
  unreachable

cleanup:                                          ; preds = %sw.bb30, %sw.bb28, %sw.bb25, %sw.bb22, %if.end18, %mem_cgroup_usage.exit69, %mem_cgroup_usage.exit
  %retval.0 = phi i64 [ %mul32, %sw.bb30 ], [ %conv29, %sw.bb28 ], [ %mul27, %sw.bb25 ], [ %mul24, %sw.bb22 ], [ %mul, %mem_cgroup_usage.exit ], [ %mul17, %mem_cgroup_usage.exit69 ], [ %mul21, %if.end18 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @mem_cgroup_reset(ptr noundef %of, ptr nocapture noundef readnone %buf, i32 noundef returned %nbytes, i64 noundef %off) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call ptr @of_css(ptr noundef %of) #23
  %0 = ptrtoint ptr %of to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %of, align 4
  %priv.i = getelementptr inbounds %struct.kernfs_node, ptr %1, i32 0, i32 9
  %2 = ptrtoint ptr %priv.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %priv.i, align 8
  %private = getelementptr inbounds %struct.cftype, ptr %3, i32 0, i32 1
  %4 = ptrtoint ptr %private to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %private, align 4
  %shr = lshr i32 %5, 16
  %trunc = trunc i32 %shr to i16
  switch i16 %trunc, label %do.body [
    i16 0, label %sw.bb
    i16 1, label %sw.bb3
    i16 3, label %sw.bb4
    i16 4, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 2
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  %6 = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 3
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %kmem = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 4
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %tcpmem = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 5
  br label %sw.epilog

do.body:                                          ; preds = %entry
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 3793, 0\0A.popsection", ""() #23, !srcloc !569
  unreachable

sw.epilog:                                        ; preds = %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb
  %counter.0 = phi ptr [ %tcpmem, %sw.bb5 ], [ %kmem, %sw.bb4 ], [ %6, %sw.bb3 ], [ %memory, %sw.bb ]
  %trunc28 = trunc i32 %5 to i16
  switch i16 %trunc28, label %do.body15 [
    i16 2, label %sw.bb12
    i16 3, label %sw.bb13
  ]

sw.bb12:                                          ; preds = %sw.epilog
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %counter.0, i32 noundef 4) #23
  %7 = ptrtoint ptr %counter.0 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load volatile i32, ptr %counter.0, align 4
  %watermark.i = getelementptr inbounds %struct.page_counter, ptr %counter.0, i32 0, i32 11
  %9 = ptrtoint ptr %watermark.i to i32
  call void @__asan_store4_noabort(i32 %9)
  store i32 %8, ptr %watermark.i, align 4
  br label %sw.epilog21

sw.bb13:                                          ; preds = %sw.epilog
  %failcnt = getelementptr inbounds %struct.page_counter, ptr %counter.0, i32 0, i32 12
  %10 = ptrtoint ptr %failcnt to i32
  call void @__asan_store4_noabort(i32 %10)
  store i32 0, ptr %failcnt, align 4
  br label %sw.epilog21

do.body15:                                        ; preds = %sw.epilog
  tail call void asm sideeffect "1:\09.long ( (((0xe7f001f2) << 24) & 0xFF000000) | (((0xe7f001f2) << 8) & 0x00FF0000) | (((0xe7f001f2) >> 8) & 0x0000FF00) | (((0xe7f001f2) >> 24) & 0x000000FF) )\0A\09\0A.pushsection .rodata.str, \22aMS\22, %progbits, 1\0A2:\09.asciz \22mm/memcontrol.c\22\0A.popsection\0A.pushsection __bug_table,\22aw\22\0A.align 2\0A3:\09.word 1b, 2b\0A\09.hword 3804, 0\0A.popsection", ""() #23, !srcloc !570
  unreachable

sw.epilog21:                                      ; preds = %sw.bb13, %sw.bb12
  ret i32 %nbytes
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @mem_cgroup_write(ptr noundef %of, ptr noundef %buf, i32 noundef %nbytes, i64 noundef %off) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %nr_pages = alloca i32, align 4
  %call = tail call ptr @of_css(ptr noundef %of) #23
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %nr_pages) #23
  %0 = ptrtoint ptr %nr_pages to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %nr_pages, align 4, !annotation !492
  %call.i = tail call ptr @strim(ptr noundef %buf) #23
  %call3 = call i32 @page_counter_memparse(ptr noundef %call.i, ptr noundef nonnull @.str.134, ptr noundef nonnull %nr_pages) #23
  %tobool.not = icmp eq i32 %call3, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %1 = ptrtoint ptr %of to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %of, align 4
  %priv.i = getelementptr inbounds %struct.kernfs_node, ptr %2, i32 0, i32 9
  %3 = ptrtoint ptr %priv.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %priv.i, align 8
  %private = getelementptr inbounds %struct.cftype, ptr %4, i32 0, i32 1
  %5 = ptrtoint ptr %private to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %private, align 4
  %trunc = trunc i32 %6 to i16
  switch i16 %trunc, label %sw.epilog19.thread [
    i16 1, label %sw.bb
    i16 4, label %sw.bb18
  ]

sw.bb:                                            ; preds = %if.end
  %7 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i = icmp eq ptr %7, %call
  br i1 %cmp.i, label %cleanup, label %if.end7

if.end7:                                          ; preds = %sw.bb
  %shr = lshr i32 %6, 16
  %trunc32 = trunc i32 %shr to i16
  switch i16 %trunc32, label %sw.epilog19.thread [
    i16 0, label %sw.bb11
    i16 1, label %sw.bb13
    i16 3, label %cleanup
    i16 4, label %sw.bb16
  ]

sw.bb11:                                          ; preds = %if.end7
  %8 = ptrtoint ptr %nr_pages to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %nr_pages, align 4
  %call12 = call fastcc i32 @mem_cgroup_resize_max(ptr noundef %call, i32 noundef %9, i1 noundef zeroext false)
  br label %sw.epilog19

sw.bb13:                                          ; preds = %if.end7
  %10 = ptrtoint ptr %nr_pages to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load i32, ptr %nr_pages, align 4
  %call14 = call fastcc i32 @mem_cgroup_resize_max(ptr noundef %call, i32 noundef %11, i1 noundef zeroext true)
  br label %sw.epilog19

sw.bb16:                                          ; preds = %if.end7
  %12 = ptrtoint ptr %nr_pages to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %nr_pages, align 4
  %call17 = call fastcc i32 @memcg_update_tcp_max(ptr noundef %call, i32 noundef %13)
  br label %sw.epilog19

sw.bb18:                                          ; preds = %if.end
  %14 = ptrtoint ptr %nr_pages to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load i32, ptr %nr_pages, align 4
  %soft_limit = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 7
  %16 = ptrtoint ptr %soft_limit to i32
  call void @__asan_store4_noabort(i32 %16)
  store i32 %15, ptr %soft_limit, align 4
  br label %sw.epilog19.thread

sw.epilog19:                                      ; preds = %sw.bb16, %sw.bb13, %sw.bb11
  %ret.0 = phi i32 [ %call17, %sw.bb16 ], [ %call14, %sw.bb13 ], [ %call12, %sw.bb11 ]
  %tobool20.not = icmp eq i32 %ret.0, 0
  br i1 %tobool20.not, label %sw.epilog19.thread, label %cleanup

sw.epilog19.thread:                               ; preds = %sw.epilog19, %sw.bb18, %if.end7, %if.end
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog19.thread, %sw.epilog19, %if.end7, %sw.bb, %entry
  %retval.0 = phi i32 [ %call3, %entry ], [ %nbytes, %sw.epilog19.thread ], [ %ret.0, %sw.epilog19 ], [ -22, %sw.bb ], [ -95, %if.end7 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %nr_pages) #23
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memcg_stat_show(ptr noundef %m, ptr nocapture noundef readnone %v) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %private.i.i = getelementptr inbounds %struct.seq_file, ptr %m, i32 0, i32 11
  %0 = ptrtoint ptr %private.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private.i.i, align 8
  %call.i.i = tail call ptr @of_css(ptr noundef %1) #23
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @stats_flush_threshold, i32 noundef 4) #23
  %2 = load volatile i32, ptr @stats_flush_threshold, align 4
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @__num_online_cpus, i32 noundef 4) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__num_online_cpus to i32))
  %3 = load volatile i32, ptr @__num_online_cpus, align 4
  %cmp.i = icmp ugt i32 %2, %3
  br i1 %cmp.i, label %if.then.i, label %mem_cgroup_flush_stats.exit

if.then.i:                                        ; preds = %entry
  tail call fastcc void @__mem_cgroup_flush_stats() #23
  br label %mem_cgroup_flush_stats.exit

mem_cgroup_flush_stats.exit:                      ; preds = %if.then.i, %entry
  %vmstats_percpu.i = getelementptr inbounds %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 39
  br label %for.body

for.cond6.preheader:                              ; preds = %cleanup, %land.rhs.i
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 53) to i32))
  %4 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 53), align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %5 = load i32, ptr @nr_cpu_ids, align 4
  %call7.i = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp8.i = icmp ult i32 %call7.i, %5
  br i1 %cmp8.i, label %do.body.lr.ph.i180, label %memcg_events_local.exit

for.body:                                         ; preds = %cleanup, %mem_cgroup_flush_stats.exit
  %i.0219 = phi i32 [ 0, %mem_cgroup_flush_stats.exit ], [ %inc, %cleanup ]
  %arrayidx = getelementptr [7 x i32], ptr @memcg1_stats, i32 0, i32 %i.0219
  %cmp1 = icmp eq i32 %i.0219, 6
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@memcg_stat_show, %land.rhs.i)) #23
          to label %cleanup [label %land.rhs.i], !srcloc !461

land.rhs.i:                                       ; preds = %land.lhs.true
  %6 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i = icmp eq i8 %6, 0
  br i1 %tobool4.not.i, label %if.end, label %for.cond6.preheader

if.end:                                           ; preds = %land.rhs.i, %for.body
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %7 = load i32, ptr @nr_cpu_ids, align 4
  %call9.i = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp10.i = icmp ult i32 %call9.i, %7
  br i1 %cmp10.i, label %do.body.lr.ph.i, label %memcg_page_state_local.exit

do.body.lr.ph.i:                                  ; preds = %if.end
  %8 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %arrayidx, align 4
  %10 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %vmstats_percpu.i, align 8
  %arrayidx.i = getelementptr [44 x i32], ptr %11, i32 0, i32 %9
  %12 = ptrtoint ptr %arrayidx.i to i32
  br label %do.body.i

do.body.i:                                        ; preds = %do.body.i, %do.body.lr.ph.i
  %call12.i = phi i32 [ %call9.i, %do.body.lr.ph.i ], [ %call.i, %do.body.i ]
  %x.011.i = phi i32 [ 0, %do.body.lr.ph.i ], [ %add3.i, %do.body.i ]
  %arrayidx2.i = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call12.i
  %13 = ptrtoint ptr %arrayidx2.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load i32, ptr %arrayidx2.i, align 4
  %add.i = add i32 %14, %12
  %15 = inttoptr i32 %add.i to ptr
  %16 = ptrtoint ptr %15 to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load i32, ptr %15, align 4
  %add3.i = add i32 %17, %x.011.i
  %call.i = tail call i32 @cpumask_next(i32 noundef %call12.i, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp.i175 = icmp ult i32 %call.i, %7
  br i1 %cmp.i175, label %do.body.i, label %memcg_page_state_local.exit

memcg_page_state_local.exit:                      ; preds = %do.body.i, %if.end
  %x.0.lcssa.i = phi i32 [ 0, %if.end ], [ %add3.i, %do.body.i ]
  %18 = tail call i32 @llvm.smax.i32(i32 %x.0.lcssa.i, i32 0) #23
  %arrayidx5 = getelementptr [7 x ptr], ptr @memcg1_stat_names, i32 0, i32 %i.0219
  %19 = ptrtoint ptr %arrayidx5 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load ptr, ptr %arrayidx5, align 4
  %mul = shl i32 %18, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.65, ptr noundef %20, i32 noundef %mul) #23
  br label %cleanup

cleanup:                                          ; preds = %memcg_page_state_local.exit, %land.lhs.true
  %inc = add nuw nsw i32 %i.0219, 1
  %exitcond.not = icmp eq i32 %inc, 7
  br i1 %exitcond.not, label %for.cond6.preheader, label %for.body

do.body.lr.ph.i180:                               ; preds = %for.cond6.preheader
  %21 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %vmstats_percpu.i, align 8
  %arrayidx.i179 = getelementptr %struct.memcg_vmstats_percpu, ptr %22, i32 0, i32 1, i32 0
  %23 = ptrtoint ptr %arrayidx.i179 to i32
  br label %do.body.i186

do.body.i186:                                     ; preds = %do.body.i186, %do.body.lr.ph.i180
  %call10.i = phi i32 [ %call7.i, %do.body.lr.ph.i180 ], [ %call.i184, %do.body.i186 ]
  %x.09.i = phi i32 [ 0, %do.body.lr.ph.i180 ], [ %add3.i183, %do.body.i186 ]
  %arrayidx2.i181 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call10.i
  %24 = ptrtoint ptr %arrayidx2.i181 to i32
  call void @__asan_load4_noabort(i32 %24)
  %25 = load i32, ptr %arrayidx2.i181, align 4
  %add.i182 = add i32 %25, %23
  %26 = inttoptr i32 %add.i182 to ptr
  %27 = ptrtoint ptr %26 to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load i32, ptr %26, align 4
  %add3.i183 = add i32 %28, %x.09.i
  %call.i184 = tail call i32 @cpumask_next(i32 noundef %call10.i, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp.i185 = icmp ult i32 %call.i184, %5
  br i1 %cmp.i185, label %do.body.i186, label %memcg_events_local.exit

memcg_events_local.exit:                          ; preds = %do.body.i186, %for.cond6.preheader
  %x.0.lcssa.i187 = phi i32 [ 0, %for.cond6.preheader ], [ %add3.i183, %do.body.i186 ]
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.65, ptr noundef %4, i32 noundef %x.0.lcssa.i187) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 54) to i32))
  %29 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 54), align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %30 = load i32, ptr @nr_cpu_ids, align 4
  %call7.i.1 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp8.i.1 = icmp ult i32 %call7.i.1, %30
  br i1 %cmp8.i.1, label %do.body.lr.ph.i180.1, label %memcg_events_local.exit.1

do.body.lr.ph.i180.1:                             ; preds = %memcg_events_local.exit
  %31 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %vmstats_percpu.i, align 8
  %arrayidx.i179.1 = getelementptr %struct.memcg_vmstats_percpu, ptr %32, i32 0, i32 1, i32 1
  %33 = ptrtoint ptr %arrayidx.i179.1 to i32
  br label %do.body.i186.1

do.body.i186.1:                                   ; preds = %do.body.i186.1, %do.body.lr.ph.i180.1
  %call10.i.1 = phi i32 [ %call7.i.1, %do.body.lr.ph.i180.1 ], [ %call.i184.1, %do.body.i186.1 ]
  %x.09.i.1 = phi i32 [ 0, %do.body.lr.ph.i180.1 ], [ %add3.i183.1, %do.body.i186.1 ]
  %arrayidx2.i181.1 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call10.i.1
  %34 = ptrtoint ptr %arrayidx2.i181.1 to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load i32, ptr %arrayidx2.i181.1, align 4
  %add.i182.1 = add i32 %35, %33
  %36 = inttoptr i32 %add.i182.1 to ptr
  %37 = ptrtoint ptr %36 to i32
  call void @__asan_load4_noabort(i32 %37)
  %38 = load i32, ptr %36, align 4
  %add3.i183.1 = add i32 %38, %x.09.i.1
  %call.i184.1 = tail call i32 @cpumask_next(i32 noundef %call10.i.1, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp.i185.1 = icmp ult i32 %call.i184.1, %30
  br i1 %cmp.i185.1, label %do.body.i186.1, label %memcg_events_local.exit.1

memcg_events_local.exit.1:                        ; preds = %do.body.i186.1, %memcg_events_local.exit
  %x.0.lcssa.i187.1 = phi i32 [ 0, %memcg_events_local.exit ], [ %add3.i183.1, %do.body.i186.1 ]
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.65, ptr noundef %29, i32 noundef %x.0.lcssa.i187.1) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 73) to i32))
  %39 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 73), align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %40 = load i32, ptr @nr_cpu_ids, align 4
  %call7.i.2 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp8.i.2 = icmp ult i32 %call7.i.2, %40
  br i1 %cmp8.i.2, label %do.body.lr.ph.i180.2, label %memcg_events_local.exit.2

do.body.lr.ph.i180.2:                             ; preds = %memcg_events_local.exit.1
  %41 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %41)
  %42 = load ptr, ptr %vmstats_percpu.i, align 8
  %arrayidx.i179.2 = getelementptr %struct.memcg_vmstats_percpu, ptr %42, i32 0, i32 1, i32 20
  %43 = ptrtoint ptr %arrayidx.i179.2 to i32
  br label %do.body.i186.2

do.body.i186.2:                                   ; preds = %do.body.i186.2, %do.body.lr.ph.i180.2
  %call10.i.2 = phi i32 [ %call7.i.2, %do.body.lr.ph.i180.2 ], [ %call.i184.2, %do.body.i186.2 ]
  %x.09.i.2 = phi i32 [ 0, %do.body.lr.ph.i180.2 ], [ %add3.i183.2, %do.body.i186.2 ]
  %arrayidx2.i181.2 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call10.i.2
  %44 = ptrtoint ptr %arrayidx2.i181.2 to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load i32, ptr %arrayidx2.i181.2, align 4
  %add.i182.2 = add i32 %45, %43
  %46 = inttoptr i32 %add.i182.2 to ptr
  %47 = ptrtoint ptr %46 to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load i32, ptr %46, align 4
  %add3.i183.2 = add i32 %48, %x.09.i.2
  %call.i184.2 = tail call i32 @cpumask_next(i32 noundef %call10.i.2, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp.i185.2 = icmp ult i32 %call.i184.2, %40
  br i1 %cmp.i185.2, label %do.body.i186.2, label %memcg_events_local.exit.2

memcg_events_local.exit.2:                        ; preds = %do.body.i186.2, %memcg_events_local.exit.1
  %x.0.lcssa.i187.2 = phi i32 [ 0, %memcg_events_local.exit.1 ], [ %add3.i183.2, %do.body.i186.2 ]
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.65, ptr noundef %39, i32 noundef %x.0.lcssa.i187.2) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 74) to i32))
  %49 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 74), align 4
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %50 = load i32, ptr @nr_cpu_ids, align 4
  %call7.i.3 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp8.i.3 = icmp ult i32 %call7.i.3, %50
  br i1 %cmp8.i.3, label %do.body.lr.ph.i180.3, label %memcg_events_local.exit.3

do.body.lr.ph.i180.3:                             ; preds = %memcg_events_local.exit.2
  %51 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load ptr, ptr %vmstats_percpu.i, align 8
  %arrayidx.i179.3 = getelementptr %struct.memcg_vmstats_percpu, ptr %52, i32 0, i32 1, i32 21
  %53 = ptrtoint ptr %arrayidx.i179.3 to i32
  br label %do.body.i186.3

do.body.i186.3:                                   ; preds = %do.body.i186.3, %do.body.lr.ph.i180.3
  %call10.i.3 = phi i32 [ %call7.i.3, %do.body.lr.ph.i180.3 ], [ %call.i184.3, %do.body.i186.3 ]
  %x.09.i.3 = phi i32 [ 0, %do.body.lr.ph.i180.3 ], [ %add3.i183.3, %do.body.i186.3 ]
  %arrayidx2.i181.3 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call10.i.3
  %54 = ptrtoint ptr %arrayidx2.i181.3 to i32
  call void @__asan_load4_noabort(i32 %54)
  %55 = load i32, ptr %arrayidx2.i181.3, align 4
  %add.i182.3 = add i32 %55, %53
  %56 = inttoptr i32 %add.i182.3 to ptr
  %57 = ptrtoint ptr %56 to i32
  call void @__asan_load4_noabort(i32 %57)
  %58 = load i32, ptr %56, align 4
  %add3.i183.3 = add i32 %58, %x.09.i.3
  %call.i184.3 = tail call i32 @cpumask_next(i32 noundef %call10.i.3, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp.i185.3 = icmp ult i32 %call.i184.3, %50
  br i1 %cmp.i185.3, label %do.body.i186.3, label %memcg_events_local.exit.3

memcg_events_local.exit.3:                        ; preds = %do.body.i186.3, %memcg_events_local.exit.2
  %x.0.lcssa.i187.3 = phi i32 [ 0, %memcg_events_local.exit.2 ], [ %add3.i183.3, %do.body.i186.3 ]
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.65, ptr noundef %49, i32 noundef %x.0.lcssa.i187.3) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 11) to i32))
  %59 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 11), align 4
  %add.ptr.i = getelementptr i8, ptr %59, i32 3
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %60 = load i32, ptr @nr_cpu_ids, align 4
  %call9.i188 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp10.i189 = icmp ult i32 %call9.i188, %60
  br i1 %cmp10.i189, label %do.body.lr.ph.i192, label %memcg_page_state_local.exit202

do.body.lr.ph.i192:                               ; preds = %memcg_events_local.exit.3
  %61 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %61)
  %62 = load ptr, ptr %vmstats_percpu.i, align 8
  %63 = ptrtoint ptr %62 to i32
  br label %do.body.i200

do.body.i200:                                     ; preds = %do.body.i200, %do.body.lr.ph.i192
  %call12.i193 = phi i32 [ %call9.i188, %do.body.lr.ph.i192 ], [ %call.i198, %do.body.i200 ]
  %x.011.i194 = phi i32 [ 0, %do.body.lr.ph.i192 ], [ %add3.i197, %do.body.i200 ]
  %arrayidx2.i195 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call12.i193
  %64 = ptrtoint ptr %arrayidx2.i195 to i32
  call void @__asan_load4_noabort(i32 %64)
  %65 = load i32, ptr %arrayidx2.i195, align 4
  %add.i196 = add i32 %65, %63
  %66 = inttoptr i32 %add.i196 to ptr
  %67 = ptrtoint ptr %66 to i32
  call void @__asan_load4_noabort(i32 %67)
  %68 = load i32, ptr %66, align 4
  %add3.i197 = add i32 %68, %x.011.i194
  %call.i198 = tail call i32 @cpumask_next(i32 noundef %call12.i193, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp.i199 = icmp ult i32 %call.i198, %60
  br i1 %cmp.i199, label %do.body.i200, label %memcg_page_state_local.exit202

memcg_page_state_local.exit202:                   ; preds = %do.body.i200, %memcg_events_local.exit.3
  %x.0.lcssa.i201 = phi i32 [ 0, %memcg_events_local.exit.3 ], [ %add3.i197, %do.body.i200 ]
  %69 = tail call i32 @llvm.smax.i32(i32 %x.0.lcssa.i201, i32 0) #23
  %mul21 = shl i32 %69, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.65, ptr noundef %add.ptr.i, i32 noundef %mul21) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 12) to i32))
  %70 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 12), align 4
  %add.ptr.i.1 = getelementptr i8, ptr %70, i32 3
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %71 = load i32, ptr @nr_cpu_ids, align 4
  %call9.i188.1 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp10.i189.1 = icmp ult i32 %call9.i188.1, %71
  br i1 %cmp10.i189.1, label %do.body.lr.ph.i192.1, label %memcg_page_state_local.exit202.1

do.body.lr.ph.i192.1:                             ; preds = %memcg_page_state_local.exit202
  %72 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %72)
  %73 = load ptr, ptr %vmstats_percpu.i, align 8
  %arrayidx.i191.1 = getelementptr [44 x i32], ptr %73, i32 0, i32 1
  %74 = ptrtoint ptr %arrayidx.i191.1 to i32
  br label %do.body.i200.1

do.body.i200.1:                                   ; preds = %do.body.i200.1, %do.body.lr.ph.i192.1
  %call12.i193.1 = phi i32 [ %call9.i188.1, %do.body.lr.ph.i192.1 ], [ %call.i198.1, %do.body.i200.1 ]
  %x.011.i194.1 = phi i32 [ 0, %do.body.lr.ph.i192.1 ], [ %add3.i197.1, %do.body.i200.1 ]
  %arrayidx2.i195.1 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call12.i193.1
  %75 = ptrtoint ptr %arrayidx2.i195.1 to i32
  call void @__asan_load4_noabort(i32 %75)
  %76 = load i32, ptr %arrayidx2.i195.1, align 4
  %add.i196.1 = add i32 %76, %74
  %77 = inttoptr i32 %add.i196.1 to ptr
  %78 = ptrtoint ptr %77 to i32
  call void @__asan_load4_noabort(i32 %78)
  %79 = load i32, ptr %77, align 4
  %add3.i197.1 = add i32 %79, %x.011.i194.1
  %call.i198.1 = tail call i32 @cpumask_next(i32 noundef %call12.i193.1, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp.i199.1 = icmp ult i32 %call.i198.1, %71
  br i1 %cmp.i199.1, label %do.body.i200.1, label %memcg_page_state_local.exit202.1

memcg_page_state_local.exit202.1:                 ; preds = %do.body.i200.1, %memcg_page_state_local.exit202
  %x.0.lcssa.i201.1 = phi i32 [ 0, %memcg_page_state_local.exit202 ], [ %add3.i197.1, %do.body.i200.1 ]
  %80 = tail call i32 @llvm.smax.i32(i32 %x.0.lcssa.i201.1, i32 0) #23
  %mul21.1 = shl i32 %80, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.65, ptr noundef %add.ptr.i.1, i32 noundef %mul21.1) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 13) to i32))
  %81 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 13), align 4
  %add.ptr.i.2 = getelementptr i8, ptr %81, i32 3
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %82 = load i32, ptr @nr_cpu_ids, align 4
  %call9.i188.2 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp10.i189.2 = icmp ult i32 %call9.i188.2, %82
  br i1 %cmp10.i189.2, label %do.body.lr.ph.i192.2, label %memcg_page_state_local.exit202.2

do.body.lr.ph.i192.2:                             ; preds = %memcg_page_state_local.exit202.1
  %83 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %83)
  %84 = load ptr, ptr %vmstats_percpu.i, align 8
  %arrayidx.i191.2 = getelementptr [44 x i32], ptr %84, i32 0, i32 2
  %85 = ptrtoint ptr %arrayidx.i191.2 to i32
  br label %do.body.i200.2

do.body.i200.2:                                   ; preds = %do.body.i200.2, %do.body.lr.ph.i192.2
  %call12.i193.2 = phi i32 [ %call9.i188.2, %do.body.lr.ph.i192.2 ], [ %call.i198.2, %do.body.i200.2 ]
  %x.011.i194.2 = phi i32 [ 0, %do.body.lr.ph.i192.2 ], [ %add3.i197.2, %do.body.i200.2 ]
  %arrayidx2.i195.2 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call12.i193.2
  %86 = ptrtoint ptr %arrayidx2.i195.2 to i32
  call void @__asan_load4_noabort(i32 %86)
  %87 = load i32, ptr %arrayidx2.i195.2, align 4
  %add.i196.2 = add i32 %87, %85
  %88 = inttoptr i32 %add.i196.2 to ptr
  %89 = ptrtoint ptr %88 to i32
  call void @__asan_load4_noabort(i32 %89)
  %90 = load i32, ptr %88, align 4
  %add3.i197.2 = add i32 %90, %x.011.i194.2
  %call.i198.2 = tail call i32 @cpumask_next(i32 noundef %call12.i193.2, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp.i199.2 = icmp ult i32 %call.i198.2, %82
  br i1 %cmp.i199.2, label %do.body.i200.2, label %memcg_page_state_local.exit202.2

memcg_page_state_local.exit202.2:                 ; preds = %do.body.i200.2, %memcg_page_state_local.exit202.1
  %x.0.lcssa.i201.2 = phi i32 [ 0, %memcg_page_state_local.exit202.1 ], [ %add3.i197.2, %do.body.i200.2 ]
  %91 = tail call i32 @llvm.smax.i32(i32 %x.0.lcssa.i201.2, i32 0) #23
  %mul21.2 = shl i32 %91, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.65, ptr noundef %add.ptr.i.2, i32 noundef %mul21.2) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 14) to i32))
  %92 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 14), align 4
  %add.ptr.i.3 = getelementptr i8, ptr %92, i32 3
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %93 = load i32, ptr @nr_cpu_ids, align 4
  %call9.i188.3 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp10.i189.3 = icmp ult i32 %call9.i188.3, %93
  br i1 %cmp10.i189.3, label %do.body.lr.ph.i192.3, label %memcg_page_state_local.exit202.3

do.body.lr.ph.i192.3:                             ; preds = %memcg_page_state_local.exit202.2
  %94 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %94)
  %95 = load ptr, ptr %vmstats_percpu.i, align 8
  %arrayidx.i191.3 = getelementptr [44 x i32], ptr %95, i32 0, i32 3
  %96 = ptrtoint ptr %arrayidx.i191.3 to i32
  br label %do.body.i200.3

do.body.i200.3:                                   ; preds = %do.body.i200.3, %do.body.lr.ph.i192.3
  %call12.i193.3 = phi i32 [ %call9.i188.3, %do.body.lr.ph.i192.3 ], [ %call.i198.3, %do.body.i200.3 ]
  %x.011.i194.3 = phi i32 [ 0, %do.body.lr.ph.i192.3 ], [ %add3.i197.3, %do.body.i200.3 ]
  %arrayidx2.i195.3 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call12.i193.3
  %97 = ptrtoint ptr %arrayidx2.i195.3 to i32
  call void @__asan_load4_noabort(i32 %97)
  %98 = load i32, ptr %arrayidx2.i195.3, align 4
  %add.i196.3 = add i32 %98, %96
  %99 = inttoptr i32 %add.i196.3 to ptr
  %100 = ptrtoint ptr %99 to i32
  call void @__asan_load4_noabort(i32 %100)
  %101 = load i32, ptr %99, align 4
  %add3.i197.3 = add i32 %101, %x.011.i194.3
  %call.i198.3 = tail call i32 @cpumask_next(i32 noundef %call12.i193.3, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp.i199.3 = icmp ult i32 %call.i198.3, %93
  br i1 %cmp.i199.3, label %do.body.i200.3, label %memcg_page_state_local.exit202.3

memcg_page_state_local.exit202.3:                 ; preds = %do.body.i200.3, %memcg_page_state_local.exit202.2
  %x.0.lcssa.i201.3 = phi i32 [ 0, %memcg_page_state_local.exit202.2 ], [ %add3.i197.3, %do.body.i200.3 ]
  %102 = tail call i32 @llvm.smax.i32(i32 %x.0.lcssa.i201.3, i32 0) #23
  %mul21.3 = shl i32 %102, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.65, ptr noundef %add.ptr.i.3, i32 noundef %mul21.3) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 15) to i32))
  %103 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 15), align 4
  %add.ptr.i.4 = getelementptr i8, ptr %103, i32 3
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @nr_cpu_ids to i32))
  %104 = load i32, ptr @nr_cpu_ids, align 4
  %call9.i188.4 = tail call i32 @cpumask_next(i32 noundef -1, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp10.i189.4 = icmp ult i32 %call9.i188.4, %104
  br i1 %cmp10.i189.4, label %do.body.lr.ph.i192.4, label %memcg_page_state_local.exit202.4

do.body.lr.ph.i192.4:                             ; preds = %memcg_page_state_local.exit202.3
  %105 = ptrtoint ptr %vmstats_percpu.i to i32
  call void @__asan_load4_noabort(i32 %105)
  %106 = load ptr, ptr %vmstats_percpu.i, align 8
  %arrayidx.i191.4 = getelementptr [44 x i32], ptr %106, i32 0, i32 4
  %107 = ptrtoint ptr %arrayidx.i191.4 to i32
  br label %do.body.i200.4

do.body.i200.4:                                   ; preds = %do.body.i200.4, %do.body.lr.ph.i192.4
  %call12.i193.4 = phi i32 [ %call9.i188.4, %do.body.lr.ph.i192.4 ], [ %call.i198.4, %do.body.i200.4 ]
  %x.011.i194.4 = phi i32 [ 0, %do.body.lr.ph.i192.4 ], [ %add3.i197.4, %do.body.i200.4 ]
  %arrayidx2.i195.4 = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %call12.i193.4
  %108 = ptrtoint ptr %arrayidx2.i195.4 to i32
  call void @__asan_load4_noabort(i32 %108)
  %109 = load i32, ptr %arrayidx2.i195.4, align 4
  %add.i196.4 = add i32 %109, %107
  %110 = inttoptr i32 %add.i196.4 to ptr
  %111 = ptrtoint ptr %110 to i32
  call void @__asan_load4_noabort(i32 %111)
  %112 = load i32, ptr %110, align 4
  %add3.i197.4 = add i32 %112, %x.011.i194.4
  %call.i198.4 = tail call i32 @cpumask_next(i32 noundef %call12.i193.4, ptr noundef nonnull @__cpu_possible_mask) #29
  %cmp.i199.4 = icmp ult i32 %call.i198.4, %104
  br i1 %cmp.i199.4, label %do.body.i200.4, label %memcg_page_state_local.exit202.4

memcg_page_state_local.exit202.4:                 ; preds = %do.body.i200.4, %memcg_page_state_local.exit202.3
  %x.0.lcssa.i201.4 = phi i32 [ 0, %memcg_page_state_local.exit202.3 ], [ %add3.i197.4, %do.body.i200.4 ]
  %113 = tail call i32 @llvm.smax.i32(i32 %x.0.lcssa.i201.4, i32 0) #23
  %mul21.4 = shl i32 %113, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.65, ptr noundef %add.ptr.i.4, i32 noundef %mul21.4) #23
  %tobool.not224 = icmp eq ptr %call.i.i, null
  br i1 %tobool.not224, label %for.end46, label %for.body26

for.body26:                                       ; preds = %for.body26, %memcg_page_state_local.exit202.4
  %memory.0227 = phi i32 [ %116, %for.body26 ], [ 2147483647, %memcg_page_state_local.exit202.4 ]
  %memsw.0226 = phi i32 [ %119, %for.body26 ], [ 2147483647, %memcg_page_state_local.exit202.4 ]
  %mi.0225 = phi ptr [ %add.ptr.i203, %for.body26 ], [ %call.i.i, %memcg_page_state_local.exit202.4 ]
  %max = getelementptr inbounds %struct.mem_cgroup, ptr %mi.0225, i32 0, i32 2, i32 4
  %114 = ptrtoint ptr %max to i32
  call void @__asan_load4_noabort(i32 %114)
  %115 = load volatile i32, ptr %max, align 16
  %116 = tail call i32 @llvm.umin.i32(i32 %memory.0227, i32 %115)
  %max37 = getelementptr inbounds %struct.mem_cgroup, ptr %mi.0225, i32 0, i32 3, i32 0, i32 4
  %117 = ptrtoint ptr %max37 to i32
  call void @__asan_load4_noabort(i32 %117)
  %118 = load volatile i32, ptr %max37, align 8
  %119 = tail call i32 @llvm.umin.i32(i32 %memsw.0226, i32 %118)
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %mi.0225, i32 0, i32 2, i32 13
  %120 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %120)
  %121 = load ptr, ptr %parent.i, align 4
  %tobool.not.i = icmp eq ptr %121, null
  %add.ptr.i203 = getelementptr i8, ptr %121, i32 -176
  %tobool.not250 = icmp eq ptr %add.ptr.i203, null
  %tobool.not = or i1 %tobool.not.i, %tobool.not250
  br i1 %tobool.not, label %for.end46, label %for.body26

for.end46:                                        ; preds = %for.body26, %memcg_page_state_local.exit202.4
  %memsw.0.lcssa = phi i32 [ 2147483647, %memcg_page_state_local.exit202.4 ], [ %119, %for.body26 ]
  %memory.0.lcssa = phi i32 [ 2147483647, %memcg_page_state_local.exit202.4 ], [ %116, %for.body26 ]
  %conv = zext i32 %memory.0.lcssa to i64
  %mul47 = shl nuw nsw i64 %conv, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.137, i64 noundef %mul47) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@memcg_stat_show, %land.rhs.i205)) #23
          to label %if.end52 [label %land.rhs.i205], !srcloc !461

land.rhs.i205:                                    ; preds = %for.end46
  %122 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i204 = icmp eq i8 %122, 0
  br i1 %tobool4.not.i204, label %if.then49, label %if.end52

if.then49:                                        ; preds = %land.rhs.i205
  %conv50 = zext i32 %memsw.0.lcssa to i64
  %mul51 = shl nuw nsw i64 %conv50, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.138, i64 noundef %mul51) #23
  br label %if.end52

if.end52:                                         ; preds = %if.then49, %land.rhs.i205, %for.end46
  %vmstats.i = getelementptr inbounds %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 26
  br label %for.body56

for.body56:                                       ; preds = %cleanup70, %if.end52
  %i.3229 = phi i32 [ 0, %if.end52 ], [ %inc74, %cleanup70 ]
  %arrayidx58 = getelementptr [7 x i32], ptr @memcg1_stats, i32 0, i32 %i.3229
  %cmp59 = icmp eq i32 %i.3229, 6
  br i1 %cmp59, label %land.lhs.true61, label %if.end64

land.lhs.true61:                                  ; preds = %for.body56
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@memcg_stat_show, %land.rhs.i208)) #23
          to label %cleanup70 [label %land.rhs.i208], !srcloc !461

land.rhs.i208:                                    ; preds = %land.lhs.true61
  %123 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i207 = icmp eq i8 %123, 0
  br i1 %tobool4.not.i207, label %if.end64, label %for.body79.preheader

if.end64:                                         ; preds = %land.rhs.i208, %for.body56
  %124 = ptrtoint ptr %arrayidx58 to i32
  call void @__asan_load4_noabort(i32 %124)
  %125 = load i32, ptr %arrayidx58, align 4
  %arrayidx.i210 = getelementptr [44 x i32], ptr %vmstats.i, i32 0, i32 %125
  %126 = ptrtoint ptr %arrayidx.i210 to i32
  call void @__asan_load4_noabort(i32 %126)
  %127 = load volatile i32, ptr %arrayidx.i210, align 4
  %arrayidx67 = getelementptr [7 x ptr], ptr @memcg1_stat_names, i32 0, i32 %i.3229
  %128 = ptrtoint ptr %arrayidx67 to i32
  call void @__asan_load4_noabort(i32 %128)
  %129 = load ptr, ptr %arrayidx67, align 4
  %conv68 = zext i32 %127 to i64
  %mul69 = shl nuw nsw i64 %conv68, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.139, ptr noundef %129, i64 noundef %mul69) #23
  br label %cleanup70

cleanup70:                                        ; preds = %if.end64, %land.lhs.true61
  %inc74 = add nuw nsw i32 %i.3229, 1
  %exitcond242.not = icmp eq i32 %inc74, 7
  br i1 %exitcond242.not, label %for.body79.preheader, label %for.body56

for.body79.preheader:                             ; preds = %cleanup70, %land.rhs.i208
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 53) to i32))
  %130 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 53), align 4
  %arrayidx.i213 = getelementptr %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 26, i32 1, i32 0
  %131 = ptrtoint ptr %arrayidx.i213 to i32
  call void @__asan_load4_noabort(i32 %131)
  %132 = load volatile i32, ptr %arrayidx.i213, align 4
  %conv84 = zext i32 %132 to i64
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.139, ptr noundef %130, i64 noundef %conv84) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 54) to i32))
  %133 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 54), align 4
  %arrayidx.i213.1 = getelementptr %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 26, i32 1, i32 1
  %134 = ptrtoint ptr %arrayidx.i213.1 to i32
  call void @__asan_load4_noabort(i32 %134)
  %135 = load volatile i32, ptr %arrayidx.i213.1, align 4
  %conv84.1 = zext i32 %135 to i64
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.139, ptr noundef %133, i64 noundef %conv84.1) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 73) to i32))
  %136 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 73), align 4
  %arrayidx.i213.2 = getelementptr %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 26, i32 1, i32 20
  %137 = ptrtoint ptr %arrayidx.i213.2 to i32
  call void @__asan_load4_noabort(i32 %137)
  %138 = load volatile i32, ptr %arrayidx.i213.2, align 4
  %conv84.2 = zext i32 %138 to i64
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.139, ptr noundef %136, i64 noundef %conv84.2) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 74) to i32))
  %139 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 74), align 4
  %arrayidx.i213.3 = getelementptr %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 26, i32 1, i32 21
  %140 = ptrtoint ptr %arrayidx.i213.3 to i32
  call void @__asan_load4_noabort(i32 %140)
  %141 = load volatile i32, ptr %arrayidx.i213.3, align 4
  %conv84.3 = zext i32 %141 to i64
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.139, ptr noundef %139, i64 noundef %conv84.3) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 11) to i32))
  %142 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 11), align 4
  %add.ptr.i216 = getelementptr i8, ptr %142, i32 3
  %143 = ptrtoint ptr %vmstats.i to i32
  call void @__asan_load4_noabort(i32 %143)
  %144 = load volatile i32, ptr %vmstats.i, align 4
  %conv95 = zext i32 %144 to i64
  %mul96 = shl nuw nsw i64 %conv95, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.139, ptr noundef %add.ptr.i216, i64 noundef %mul96) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 12) to i32))
  %145 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 12), align 4
  %add.ptr.i216.1 = getelementptr i8, ptr %145, i32 3
  %arrayidx.i218.1 = getelementptr %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 26, i32 0, i32 1
  %146 = ptrtoint ptr %arrayidx.i218.1 to i32
  call void @__asan_load4_noabort(i32 %146)
  %147 = load volatile i32, ptr %arrayidx.i218.1, align 4
  %conv95.1 = zext i32 %147 to i64
  %mul96.1 = shl nuw nsw i64 %conv95.1, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.139, ptr noundef %add.ptr.i216.1, i64 noundef %mul96.1) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 13) to i32))
  %148 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 13), align 4
  %add.ptr.i216.2 = getelementptr i8, ptr %148, i32 3
  %arrayidx.i218.2 = getelementptr %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 26, i32 0, i32 2
  %149 = ptrtoint ptr %arrayidx.i218.2 to i32
  call void @__asan_load4_noabort(i32 %149)
  %150 = load volatile i32, ptr %arrayidx.i218.2, align 4
  %conv95.2 = zext i32 %150 to i64
  %mul96.2 = shl nuw nsw i64 %conv95.2, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.139, ptr noundef %add.ptr.i216.2, i64 noundef %mul96.2) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 14) to i32))
  %151 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 14), align 4
  %add.ptr.i216.3 = getelementptr i8, ptr %151, i32 3
  %arrayidx.i218.3 = getelementptr %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 26, i32 0, i32 3
  %152 = ptrtoint ptr %arrayidx.i218.3 to i32
  call void @__asan_load4_noabort(i32 %152)
  %153 = load volatile i32, ptr %arrayidx.i218.3, align 4
  %conv95.3 = zext i32 %153 to i64
  %mul96.3 = shl nuw nsw i64 %conv95.3, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.139, ptr noundef %add.ptr.i216.3, i64 noundef %mul96.3) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 15) to i32))
  %154 = load ptr, ptr getelementptr inbounds ([0 x ptr], ptr @vmstat_text, i32 0, i32 15), align 4
  %add.ptr.i216.4 = getelementptr i8, ptr %154, i32 3
  %arrayidx.i218.4 = getelementptr %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 26, i32 0, i32 4
  %155 = ptrtoint ptr %arrayidx.i218.4 to i32
  call void @__asan_load4_noabort(i32 %155)
  %156 = load volatile i32, ptr %arrayidx.i218.4, align 4
  %conv95.4 = zext i32 %156 to i64
  %mul96.4 = shl nuw nsw i64 %conv95.4, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.139, ptr noundef %add.ptr.i216.4, i64 noundef %mul96.4) #23
  %call100 = tail call ptr @first_online_pgdat() #23
  %tobool102.not233 = icmp eq ptr %call100, null
  br i1 %tobool102.not233, label %for.end112, label %for.body103

for.body103:                                      ; preds = %for.body103, %for.body79.preheader
  %file_cost.0236 = phi i32 [ %add109, %for.body103 ], [ 0, %for.body79.preheader ]
  %anon_cost.0235 = phi i32 [ %add106, %for.body103 ], [ 0, %for.body79.preheader ]
  %pgdat.0234 = phi ptr [ %call111, %for.body103 ], [ %call100, %for.body79.preheader ]
  %node_id = getelementptr inbounds %struct.pglist_data, ptr %pgdat.0234, i32 0, i32 8
  %157 = ptrtoint ptr %node_id to i32
  call void @__asan_load4_noabort(i32 %157)
  %158 = load i32, ptr %node_id, align 64
  %arrayidx104 = getelementptr %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 45, i32 %158
  %159 = ptrtoint ptr %arrayidx104 to i32
  call void @__asan_load4_noabort(i32 %159)
  %160 = load ptr, ptr %arrayidx104, align 4
  %anon_cost105 = getelementptr inbounds %struct.lruvec, ptr %160, i32 0, i32 2
  %161 = ptrtoint ptr %anon_cost105 to i32
  call void @__asan_load4_noabort(i32 %161)
  %162 = load i32, ptr %anon_cost105, align 4
  %add106 = add i32 %162, %anon_cost.0235
  %file_cost108 = getelementptr inbounds %struct.lruvec, ptr %160, i32 0, i32 3
  %163 = ptrtoint ptr %file_cost108 to i32
  call void @__asan_load4_noabort(i32 %163)
  %164 = load i32, ptr %file_cost108, align 4
  %add109 = add i32 %164, %file_cost.0236
  %call111 = tail call ptr @next_online_pgdat(ptr noundef nonnull %pgdat.0234) #23
  %tobool102.not = icmp eq ptr %call111, null
  br i1 %tobool102.not, label %for.end112, label %for.body103

for.end112:                                       ; preds = %for.body103, %for.body79.preheader
  %anon_cost.0.lcssa = phi i32 [ 0, %for.body79.preheader ], [ %add106, %for.body103 ]
  %file_cost.0.lcssa = phi i32 [ 0, %for.body79.preheader ], [ %add109, %for.body103 ]
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.140, i32 noundef %anon_cost.0.lcssa) #23
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.141, i32 noundef %file_cost.0.lcssa) #23
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @mem_cgroup_force_empty_write(ptr noundef %of, ptr nocapture noundef readnone %buf, i32 noundef %nbytes, i64 noundef %off) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call ptr @of_css(ptr noundef %of) #23
  %0 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i = icmp eq ptr %0, %call
  br i1 %cmp.i, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  tail call void @lru_add_drain_all() #23
  tail call fastcc void @drain_all_stock(ptr noundef %call) #23
  %memory.i = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 2
  br label %land.rhs.i

land.rhs.i:                                       ; preds = %if.end.i, %if.end
  %nr_retries.014.i = phi i32 [ 16, %if.end ], [ %spec.select.i, %if.end.i ]
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %memory.i, i32 noundef 4) #23
  %1 = ptrtoint ptr %memory.i to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %memory.i, align 4
  %tobool1.not.i = icmp eq i32 %2, 0
  br i1 %tobool1.not.i, label %cleanup, label %while.body.i

while.body.i:                                     ; preds = %land.rhs.i
  %3 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i = and i32 %3, -16384
  %4 = inttoptr i32 %and.i.i to ptr
  %task.i = getelementptr inbounds %struct.thread_info, ptr %4, i32 0, i32 2
  %5 = ptrtoint ptr %task.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %task.i, align 8
  %stack.i.i.i = getelementptr inbounds %struct.task_struct, ptr %6, i32 0, i32 1
  %7 = ptrtoint ptr %stack.i.i.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %stack.i.i.i, align 4
  %9 = ptrtoint ptr %8 to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load volatile i32, ptr %8, align 4
  %11 = and i32 %10, 256
  %tobool.not.i.i = icmp eq i32 %11, 0
  br i1 %tobool.not.i.i, label %signal_pending.exit.i, label %cleanup, !prof !460

signal_pending.exit.i:                            ; preds = %while.body.i
  %12 = ptrtoint ptr %8 to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load volatile i32, ptr %8, align 4
  %and1.i.i.i.i.i.i = and i32 %13, 1
  %tobool4.not.i = icmp eq i32 %and1.i.i.i.i.i.i, 0
  br i1 %tobool4.not.i, label %if.end.i, label %cleanup

if.end.i:                                         ; preds = %signal_pending.exit.i
  %call5.i = tail call i32 @try_to_free_mem_cgroup_pages(ptr noundef %call, i32 noundef 1, i32 noundef 3264, i1 noundef zeroext true) #23
  %tobool6.not.i = icmp eq i32 %call5.i, 0
  %dec.i = sext i1 %tobool6.not.i to i32
  %spec.select.i = add i32 %nr_retries.014.i, %dec.i
  %tobool.not.i = icmp eq i32 %spec.select.i, 0
  br i1 %tobool.not.i, label %cleanup, label %land.rhs.i

cleanup:                                          ; preds = %if.end.i, %signal_pending.exit.i, %while.body.i, %land.rhs.i, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ %nbytes, %land.rhs.i ], [ %nbytes, %if.end.i ], [ -4, %while.body.i ], [ -4, %signal_pending.exit.i ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync)
define internal i64 @mem_cgroup_hierarchy_read(ptr nocapture noundef readnone %css, ptr nocapture noundef readnone %cft) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  ret i64 1
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @mem_cgroup_hierarchy_write(ptr nocapture noundef readnone %css, ptr nocapture noundef readnone %cft, i64 noundef %val) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %cmp = icmp eq i64 %val, 1
  br i1 %cmp, label %return, label %land.end

land.end:                                         ; preds = %entry
  %.b15 = load i1, ptr @mem_cgroup_hierarchy_write.__already_done, align 1
  br i1 %.b15, label %return, label %if.then5, !prof !460

if.then5:                                         ; preds = %land.end
  store i1 true, ptr @mem_cgroup_hierarchy_write.__already_done, align 1
  %call = tail call i32 (ptr, ...) @_printk(ptr noundef nonnull @.str.148) #25
  br label %return

return:                                           ; preds = %if.then5, %land.end, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ -22, %if.then5 ], [ -22, %land.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memcg_write_event_control(ptr noundef %of, ptr noundef %buf, i32 noundef %nbytes, i64 noundef %off) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %endp = alloca ptr, align 4
  %call = tail call ptr @of_css(ptr noundef %of) #23
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %endp) #23
  %0 = ptrtoint ptr %endp to i32
  call void @__asan_store4_noabort(i32 %0)
  store ptr inttoptr (i32 -1 to ptr), ptr %endp, align 4, !annotation !492
  %call.i = tail call ptr @strim(ptr noundef %buf) #23
  %call3 = call i32 @simple_strtoul(ptr noundef %call.i, ptr noundef nonnull %endp, i32 noundef 10) #23
  %1 = ptrtoint ptr %endp to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %endp, align 4
  %3 = ptrtoint ptr %2 to i32
  call void @__asan_load1_noabort(i32 %3)
  %4 = load i8, ptr %2, align 1
  %cmp.not = icmp eq i8 %4, 32
  br i1 %cmp.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %add.ptr = getelementptr i8, ptr %2, i32 1
  %call5 = call i32 @simple_strtoul(ptr noundef %add.ptr, ptr noundef nonnull %endp, i32 noundef 10) #23
  %5 = ptrtoint ptr %endp to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %endp, align 4
  %7 = ptrtoint ptr %6 to i32
  call void @__asan_load1_noabort(i32 %7)
  %8 = load i8, ptr %6, align 1
  switch i8 %8, label %cleanup [
    i8 32, label %if.end13
    i8 0, label %if.end13
  ]

if.end13:                                         ; preds = %if.end, %if.end
  %add.ptr14 = getelementptr i8, ptr %6, i32 1
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 7) to i32))
  %9 = load ptr, ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 7), align 4
  %call7.i.i = call noalias align 8 ptr @kmem_cache_alloc_trace(ptr noundef %9, i32 noundef 3520, i32 noundef 100) #26
  %tobool.not = icmp eq ptr %call7.i.i, null
  br i1 %tobool.not, label %cleanup, label %if.end17

if.end17:                                         ; preds = %if.end13
  %10 = ptrtoint ptr %call7.i.i to i32
  call void @__asan_store4_noabort(i32 %10)
  store ptr %call, ptr %call7.i.i, align 8
  %list = getelementptr inbounds %struct.mem_cgroup_event, ptr %call7.i.i, i32 0, i32 2
  %11 = ptrtoint ptr %list to i32
  call void @__asan_store4_noabort(i32 %11)
  store volatile ptr %list, ptr %list, align 8
  %prev.i = getelementptr inbounds %struct.mem_cgroup_event, ptr %call7.i.i, i32 0, i32 2, i32 1
  %12 = ptrtoint ptr %prev.i to i32
  call void @__asan_store4_noabort(i32 %12)
  store ptr %list, ptr %prev.i, align 4
  %pt = getelementptr inbounds %struct.mem_cgroup_event, ptr %call7.i.i, i32 0, i32 5
  %13 = ptrtoint ptr %pt to i32
  call void @__asan_store4_noabort(i32 %13)
  store ptr @memcg_event_ptable_queue_proc, ptr %pt, align 8
  %_key.i = getelementptr inbounds %struct.mem_cgroup_event, ptr %call7.i.i, i32 0, i32 5, i32 1
  %14 = ptrtoint ptr %_key.i to i32
  call void @__asan_store4_noabort(i32 %14)
  store i32 -1, ptr %_key.i, align 4
  %wait = getelementptr inbounds %struct.mem_cgroup_event, ptr %call7.i.i, i32 0, i32 7
  %15 = ptrtoint ptr %wait to i32
  call void @__asan_store4_noabort(i32 %15)
  store i32 0, ptr %wait, align 4
  %private.i = getelementptr inbounds %struct.mem_cgroup_event, ptr %call7.i.i, i32 0, i32 7, i32 1
  %16 = ptrtoint ptr %private.i to i32
  call void @__asan_store4_noabort(i32 %16)
  store ptr null, ptr %private.i, align 8
  %func1.i = getelementptr inbounds %struct.mem_cgroup_event, ptr %call7.i.i, i32 0, i32 7, i32 2
  %17 = ptrtoint ptr %func1.i to i32
  call void @__asan_store4_noabort(i32 %17)
  store ptr @memcg_event_wake, ptr %func1.i, align 4
  %remove = getelementptr inbounds %struct.mem_cgroup_event, ptr %call7.i.i, i32 0, i32 8
  call void @__init_work(ptr noundef %remove, i32 noundef 0) #23
  %18 = ptrtoint ptr %remove to i32
  call void @__asan_store4_noabort(i32 %18)
  store i32 -64, ptr %remove, align 8
  %lockdep_map = getelementptr inbounds %struct.mem_cgroup_event, ptr %call7.i.i, i32 0, i32 8, i32 3
  call void @lockdep_init_map_type(ptr noundef %lockdep_map, ptr noundef nonnull @.str.150, ptr noundef nonnull @memcg_write_event_control.__key, i32 noundef 0, i8 noundef zeroext 0, i8 noundef zeroext 0, i8 noundef zeroext 0) #23
  %entry22 = getelementptr inbounds %struct.mem_cgroup_event, ptr %call7.i.i, i32 0, i32 8, i32 1
  %19 = ptrtoint ptr %entry22 to i32
  call void @__asan_store4_noabort(i32 %19)
  store volatile ptr %entry22, ptr %entry22, align 4
  %prev.i169 = getelementptr inbounds %struct.mem_cgroup_event, ptr %call7.i.i, i32 0, i32 8, i32 1, i32 1
  %20 = ptrtoint ptr %prev.i169 to i32
  call void @__asan_store4_noabort(i32 %20)
  store ptr %entry22, ptr %prev.i169, align 8
  %func = getelementptr inbounds %struct.mem_cgroup_event, ptr %call7.i.i, i32 0, i32 8, i32 2
  %21 = ptrtoint ptr %func to i32
  call void @__asan_store4_noabort(i32 %21)
  store ptr @memcg_event_remove, ptr %func, align 4
  %call.i170 = call i32 @__fdget(i32 noundef %call3) #23, !noalias !571
  %and.i.i = and i32 %call.i170, -4
  %22 = inttoptr i32 %and.i.i to ptr
  %tobool24.not = icmp eq i32 %and.i.i, 0
  br i1 %tobool24.not, label %out_kfree, label %if.end26

if.end26:                                         ; preds = %if.end17
  %call28 = call ptr @eventfd_ctx_fileget(ptr noundef nonnull %22) #23
  %eventfd = getelementptr inbounds %struct.mem_cgroup_event, ptr %call7.i.i, i32 0, i32 1
  %23 = ptrtoint ptr %eventfd to i32
  call void @__asan_store4_noabort(i32 %23)
  store ptr %call28, ptr %eventfd, align 4
  %cmp.i = icmp ugt ptr %call28, inttoptr (i32 -4096 to ptr)
  br i1 %cmp.i, label %if.then31, label %if.end34

if.then31:                                        ; preds = %if.end26
  %24 = ptrtoint ptr %call28 to i32
  br label %out_put_efile

if.end34:                                         ; preds = %if.end26
  %call.i171 = call i32 @__fdget(i32 noundef %call5) #23, !noalias !574
  %and.i.i172 = and i32 %call.i171, -4
  %25 = inttoptr i32 %and.i.i172 to ptr
  %tobool37.not = icmp eq i32 %and.i.i172, 0
  br i1 %tobool37.not, label %out_put_eventfd, label %if.end39

if.end39:                                         ; preds = %if.end34
  %f_path.i.i = getelementptr inbounds %struct.file, ptr %25, i32 0, i32 1
  %26 = ptrtoint ptr %f_path.i.i to i32
  call void @__asan_load4_noabort(i32 %26)
  %27 = load ptr, ptr %f_path.i.i, align 8
  %mnt_userns.i.i.i = getelementptr inbounds %struct.vfsmount, ptr %27, i32 0, i32 3
  %28 = ptrtoint ptr %mnt_userns.i.i.i to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile ptr, ptr %mnt_userns.i.i.i, align 4
  call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !577
  %f_inode.i.i = getelementptr inbounds %struct.file, ptr %25, i32 0, i32 2
  %30 = ptrtoint ptr %f_inode.i.i to i32
  call void @__asan_load4_noabort(i32 %30)
  %31 = load ptr, ptr %f_inode.i.i, align 8
  %call2.i = call i32 @inode_permission(ptr noundef %29, ptr noundef %31, i32 noundef 4) #23
  %cmp42 = icmp slt i32 %call2.i, 0
  br i1 %cmp42, label %out_put_cfile, label %if.end45

if.end45:                                         ; preds = %if.end39
  %dentry = getelementptr inbounds %struct.file, ptr %25, i32 0, i32 1, i32 1
  %32 = ptrtoint ptr %dentry to i32
  call void @__asan_load4_noabort(i32 %32)
  %33 = load ptr, ptr %dentry, align 4
  %name47 = getelementptr inbounds %struct.dentry, ptr %33, i32 0, i32 4, i32 1
  %34 = ptrtoint ptr %name47 to i32
  call void @__asan_load4_noabort(i32 %34)
  %35 = load ptr, ptr %name47, align 8
  %call48 = call i32 @strcmp(ptr noundef %35, ptr noundef nonnull dereferenceable(22) @.str.151) #28
  %tobool49.not = icmp eq i32 %call48, 0
  br i1 %tobool49.not, label %if.end72, label %if.else

if.else:                                          ; preds = %if.end45
  %call51 = call i32 @strcmp(ptr noundef %35, ptr noundef nonnull dereferenceable(19) @.str.152) #28
  %tobool52.not = icmp eq i32 %call51, 0
  br i1 %tobool52.not, label %if.end72, label %if.else56

if.else56:                                        ; preds = %if.else
  %call57 = call i32 @strcmp(ptr noundef %35, ptr noundef nonnull dereferenceable(22) @.str.153) #28
  %tobool58.not = icmp eq i32 %call57, 0
  br i1 %tobool58.not, label %if.end72, label %if.else62

if.else62:                                        ; preds = %if.else56
  %call63 = call i32 @strcmp(ptr noundef %35, ptr noundef nonnull dereferenceable(28) @.str.154) #28
  %tobool64.not = icmp eq i32 %call63, 0
  br i1 %tobool64.not, label %if.end72, label %out_put_cfile

if.end72:                                         ; preds = %if.else62, %if.else56, %if.else, %if.end45
  %mem_cgroup_oom_register_event.sink = phi ptr [ @mem_cgroup_usage_register_event, %if.end45 ], [ @mem_cgroup_oom_register_event, %if.else ], [ @vmpressure_register_event, %if.else56 ], [ @memsw_cgroup_usage_register_event, %if.else62 ]
  %mem_cgroup_oom_unregister_event.sink = phi ptr [ @mem_cgroup_usage_unregister_event, %if.end45 ], [ @mem_cgroup_oom_unregister_event, %if.else ], [ @vmpressure_unregister_event, %if.else56 ], [ @memsw_cgroup_usage_unregister_event, %if.else62 ]
  %register_event54 = getelementptr inbounds %struct.mem_cgroup_event, ptr %call7.i.i, i32 0, i32 3
  %36 = ptrtoint ptr %register_event54 to i32
  call void @__asan_store4_noabort(i32 %36)
  store ptr %mem_cgroup_oom_register_event.sink, ptr %register_event54, align 8
  %unregister_event55 = getelementptr inbounds %struct.mem_cgroup_event, ptr %call7.i.i, i32 0, i32 4
  %37 = ptrtoint ptr %unregister_event55 to i32
  call void @__asan_store4_noabort(i32 %37)
  store ptr %mem_cgroup_oom_unregister_event.sink, ptr %unregister_event55, align 4
  %38 = ptrtoint ptr %dentry to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load ptr, ptr %dentry, align 4
  %d_parent = getelementptr inbounds %struct.dentry, ptr %39, i32 0, i32 3
  %40 = ptrtoint ptr %d_parent to i32
  call void @__asan_load4_noabort(i32 %40)
  %41 = load ptr, ptr %d_parent, align 8
  %call76 = call ptr @css_tryget_online_from_dir(ptr noundef %41, ptr noundef nonnull @memory_cgrp_subsys) #23
  %cmp.i175 = icmp ugt ptr %call76, inttoptr (i32 -4096 to ptr)
  br i1 %cmp.i175, label %out_put_cfile, label %if.end79

if.end79:                                         ; preds = %if.end72
  %cmp80.not = icmp eq ptr %call76, %call
  br i1 %cmp80.not, label %if.end83, label %if.then82

if.then82:                                        ; preds = %if.end79
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call76, i32 0, i32 7
  %42 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load i32, ptr %flags.i, align 4
  %and.i = and i32 %43, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %out_put_cfile.sink.split, label %out_put_cfile

if.end83:                                         ; preds = %if.end79
  %register_event84 = getelementptr inbounds %struct.mem_cgroup_event, ptr %call7.i.i, i32 0, i32 3
  %44 = ptrtoint ptr %register_event84 to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load ptr, ptr %register_event84, align 8
  %46 = ptrtoint ptr %eventfd to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load ptr, ptr %eventfd, align 4
  %call86 = call i32 %45(ptr noundef %call, ptr noundef %47, ptr noundef %add.ptr14) #23
  %tobool87.not = icmp eq i32 %call86, 0
  br i1 %tobool87.not, label %if.end89, label %out_put_css

if.end89:                                         ; preds = %if.end83
  %f_op.i = getelementptr inbounds %struct.file, ptr %22, i32 0, i32 3
  %48 = ptrtoint ptr %f_op.i to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load ptr, ptr %f_op.i, align 4
  %poll.i = getelementptr inbounds %struct.file_operations, ptr %49, i32 0, i32 9
  %50 = ptrtoint ptr %poll.i to i32
  call void @__asan_load4_noabort(i32 %50)
  %51 = load ptr, ptr %poll.i, align 4
  %tobool.not.i176 = icmp eq ptr %51, null
  br i1 %tobool.not.i176, label %vfs_poll.exit, label %if.end.i, !prof !466

if.end.i:                                         ; preds = %if.end89
  %call.i177 = call i32 %51(ptr noundef nonnull %22, ptr noundef %pt) #23
  br label %vfs_poll.exit

vfs_poll.exit:                                    ; preds = %if.end.i, %if.end89
  %event_list_lock = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 44
  call void @_raw_spin_lock_irq(ptr noundef %event_list_lock) #23
  %event_list = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 43
  %52 = ptrtoint ptr %event_list to i32
  call void @__asan_load4_noabort(i32 %52)
  %53 = load ptr, ptr %event_list, align 4
  %call.i.i = call zeroext i1 @__list_add_valid(ptr noundef %list, ptr noundef %event_list, ptr noundef %53) #23
  br i1 %call.i.i, label %if.end.i.i, label %list_add.exit

if.end.i.i:                                       ; preds = %vfs_poll.exit
  %prev1.i.i = getelementptr inbounds %struct.list_head, ptr %53, i32 0, i32 1
  %54 = ptrtoint ptr %prev1.i.i to i32
  call void @__asan_store4_noabort(i32 %54)
  store ptr %list, ptr %prev1.i.i, align 4
  %55 = ptrtoint ptr %list to i32
  call void @__asan_store4_noabort(i32 %55)
  store ptr %53, ptr %list, align 8
  %56 = ptrtoint ptr %prev.i to i32
  call void @__asan_store4_noabort(i32 %56)
  store ptr %event_list, ptr %prev.i, align 4
  %57 = ptrtoint ptr %event_list to i32
  call void @__asan_store4_noabort(i32 %57)
  store volatile ptr %list, ptr %event_list, align 4
  br label %list_add.exit

list_add.exit:                                    ; preds = %if.end.i.i, %vfs_poll.exit
  call void @_raw_spin_unlock_irq(ptr noundef %event_list_lock) #23
  %and.i178 = and i32 %call.i171, 1
  %tobool.not.i179 = icmp eq i32 %and.i178, 0
  br i1 %tobool.not.i179, label %fdput.exit, label %if.then.i180

if.then.i180:                                     ; preds = %list_add.exit
  call void @fput(ptr noundef nonnull %25) #23
  br label %fdput.exit

fdput.exit:                                       ; preds = %if.then.i180, %list_add.exit
  %and.i182 = and i32 %call.i170, 1
  %tobool.not.i183 = icmp eq i32 %and.i182, 0
  br i1 %tobool.not.i183, label %cleanup, label %if.then.i184

if.then.i184:                                     ; preds = %fdput.exit
  call void @fput(ptr noundef nonnull %22) #23
  br label %cleanup

out_put_css:                                      ; preds = %if.end83
  %flags.i187 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call, i32 0, i32 7
  %58 = ptrtoint ptr %flags.i187 to i32
  call void @__asan_load4_noabort(i32 %58)
  %59 = load i32, ptr %flags.i187, align 4
  %and.i188 = and i32 %59, 1
  %tobool.not.i189 = icmp eq i32 %and.i188, 0
  br i1 %tobool.not.i189, label %out_put_cfile.sink.split, label %out_put_cfile

out_put_cfile.sink.split:                         ; preds = %out_put_css, %if.then82
  %call.sink = phi ptr [ %call76, %if.then82 ], [ %call, %out_put_css ]
  %ret.0.ph = phi i32 [ -22, %if.then82 ], [ %call86, %out_put_css ]
  %refcnt.i190 = getelementptr inbounds %struct.cgroup_subsys_state, ptr %call.sink, i32 0, i32 2
  call fastcc void @percpu_ref_put(ptr noundef %refcnt.i190) #23
  br label %out_put_cfile

out_put_cfile:                                    ; preds = %out_put_cfile.sink.split, %out_put_css, %if.then82, %if.end72, %if.else62, %if.end39
  %ret.0 = phi i32 [ %call2.i, %if.end39 ], [ -22, %if.end72 ], [ -22, %if.else62 ], [ -22, %if.then82 ], [ %call86, %out_put_css ], [ %ret.0.ph, %out_put_cfile.sink.split ]
  %and.i194 = and i32 %call.i171, 1
  %tobool.not.i195 = icmp eq i32 %and.i194, 0
  br i1 %tobool.not.i195, label %out_put_eventfd, label %if.then.i196

if.then.i196:                                     ; preds = %out_put_cfile
  call void @fput(ptr noundef nonnull %25) #23
  br label %out_put_eventfd

out_put_eventfd:                                  ; preds = %if.then.i196, %out_put_cfile, %if.end34
  %ret.1 = phi i32 [ -9, %if.end34 ], [ %ret.0, %out_put_cfile ], [ %ret.0, %if.then.i196 ]
  %60 = ptrtoint ptr %eventfd to i32
  call void @__asan_load4_noabort(i32 %60)
  %61 = load ptr, ptr %eventfd, align 4
  call void @eventfd_ctx_put(ptr noundef %61) #23
  br label %out_put_efile

out_put_efile:                                    ; preds = %out_put_eventfd, %if.then31
  %ret.2 = phi i32 [ %24, %if.then31 ], [ %ret.1, %out_put_eventfd ]
  %and.i199 = and i32 %call.i170, 1
  %tobool.not.i200 = icmp eq i32 %and.i199, 0
  br i1 %tobool.not.i200, label %out_kfree, label %if.then.i201

if.then.i201:                                     ; preds = %out_put_efile
  call void @fput(ptr noundef nonnull %22) #23
  br label %out_kfree

out_kfree:                                        ; preds = %if.then.i201, %out_put_efile, %if.end17
  %ret.3 = phi i32 [ -9, %if.end17 ], [ %ret.2, %out_put_efile ], [ %ret.2, %if.then.i201 ]
  call void @kfree(ptr noundef nonnull %call7.i.i) #23
  br label %cleanup

cleanup:                                          ; preds = %out_kfree, %if.then.i184, %fdput.exit, %if.end13, %if.end, %entry
  %retval.0 = phi i32 [ %ret.3, %out_kfree ], [ -22, %entry ], [ -22, %if.end ], [ -12, %if.end13 ], [ %nbytes, %fdput.exit ], [ %nbytes, %if.then.i184 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %endp) #23
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i64 @mem_cgroup_swappiness_read(ptr nocapture noundef readonly %css, ptr nocapture noundef readnone %cft) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_swappiness_read, %if.end.i)) #23
          to label %mem_cgroup_swappiness.exit [label %if.end.i], !srcloc !461

if.end.i:                                         ; preds = %entry
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_enabled_key, i32 1), ptr blockaddress(@mem_cgroup_swappiness_read, %mem_cgroup_swappiness.exit)) #23
          to label %lor.lhs.false.i [label %mem_cgroup_swappiness.exit], !srcloc !461

lor.lhs.false.i:                                  ; preds = %if.end.i
  %0 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i = icmp eq ptr %0, %css
  %swappiness.i = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 12
  %spec.select.i = select i1 %cmp.i.i, ptr @vm_swappiness, ptr %swappiness.i
  br label %mem_cgroup_swappiness.exit

mem_cgroup_swappiness.exit:                       ; preds = %lor.lhs.false.i, %if.end.i, %entry
  %retval.0.in.i = phi ptr [ %spec.select.i, %lor.lhs.false.i ], [ @vm_swappiness, %entry ], [ @vm_swappiness, %if.end.i ]
  %1 = ptrtoint ptr %retval.0.in.i to i32
  call void @__asan_load4_noabort(i32 %1)
  %retval.0.i = load i32, ptr %retval.0.in.i, align 4
  %conv = sext i32 %retval.0.i to i64
  ret i64 %conv
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid sanitize_address sspstrong willreturn uwtable(sync)
define internal i32 @mem_cgroup_swappiness_write(ptr nocapture noundef writeonly %css, ptr nocapture noundef readnone %cft, i64 noundef %val) #19 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %cmp = icmp ugt i64 %val, 200
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %0 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i = icmp eq ptr %0, %css
  %conv3 = trunc i64 %val to i32
  %swappiness = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 12
  %swappiness.sink = select i1 %cmp.i, ptr @vm_swappiness, ptr %swappiness
  %1 = ptrtoint ptr %swappiness.sink to i32
  call void @__asan_store4_noabort(i32 %1)
  store i32 %conv3, ptr %swappiness.sink, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync)
define internal i64 @mem_cgroup_move_charge_read(ptr nocapture noundef readonly %css, ptr nocapture noundef readnone %cft) #20 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %move_charge_at_immigrate = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 21
  %0 = ptrtoint ptr %move_charge_at_immigrate to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %move_charge_at_immigrate, align 8
  %conv = zext i32 %1 to i64
  ret i64 %conv
}

; Function Attrs: argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid sanitize_address sspstrong willreturn writeonly uwtable(sync)
define internal i32 @mem_cgroup_move_charge_write(ptr nocapture noundef writeonly %css, ptr nocapture noundef readnone %cft, i64 noundef %val) #21 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %and = and i64 %val, 4294967292
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %conv = trunc i64 %val to i32
  %move_charge_at_immigrate = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 21
  %0 = ptrtoint ptr %move_charge_at_immigrate to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 %conv, ptr %move_charge_at_immigrate, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @mem_cgroup_oom_control_read(ptr noundef %sf, ptr nocapture noundef readnone %v) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %private.i.i = getelementptr inbounds %struct.seq_file, ptr %sf, i32 0, i32 11
  %0 = ptrtoint ptr %private.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private.i.i, align 8
  %call.i.i7 = tail call ptr @of_css(ptr noundef %1) #23
  %oom_kill_disable = getelementptr inbounds %struct.mem_cgroup, ptr %call.i.i7, i32 0, i32 13
  %2 = ptrtoint ptr %oom_kill_disable to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %oom_kill_disable, align 8
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %sf, ptr noundef nonnull @.str.156, i32 noundef %3) #23
  %under_oom = getelementptr inbounds %struct.mem_cgroup, ptr %call.i.i7, i32 0, i32 11
  %4 = ptrtoint ptr %under_oom to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load i32, ptr %under_oom, align 16
  %tobool = icmp ne i32 %5, 0
  %conv = zext i1 %tobool to i32
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %sf, ptr noundef nonnull @.str.157, i32 noundef %conv) #23
  %arrayidx = getelementptr %struct.mem_cgroup, ptr %call.i.i7, i32 0, i32 27, i32 4
  %call.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %arrayidx, i32 noundef 4) #23
  %6 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %arrayidx, align 4
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %sf, ptr noundef nonnull @.str.131, i32 noundef %7) #23
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @mem_cgroup_oom_control_write(ptr noundef %css, ptr nocapture noundef readnone %cft, i64 noundef %val) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i = icmp ne ptr %0, %css
  %switch = icmp ult i64 %val, 2
  %or.cond = and i1 %switch, %cmp.i
  br i1 %or.cond, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %conv = trunc i64 %val to i32
  %oom_kill_disable = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 13
  %1 = ptrtoint ptr %oom_kill_disable to i32
  call void @__asan_store4_noabort(i32 %1)
  store i32 %conv, ptr %oom_kill_disable, align 8
  %tobool.not = icmp ne i64 %val, 0
  %tobool.not.i = icmp eq ptr %css, null
  %or.cond11 = or i1 %tobool.not.i, %tobool.not
  br i1 %or.cond11, label %cleanup, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end
  %under_oom.i = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 11
  %2 = ptrtoint ptr %under_oom.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %under_oom.i, align 16
  %tobool1.not.i = icmp eq i32 %3, 0
  br i1 %tobool1.not.i, label %cleanup, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  tail call void @__wake_up(ptr noundef nonnull @memcg_oom_waitq, i32 noundef 3, i32 noundef 0, ptr noundef nonnull %css) #23
  br label %cleanup

cleanup:                                          ; preds = %if.then.i, %land.lhs.true.i, %if.end, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ 0, %if.end ], [ 0, %land.lhs.true.i ], [ 0, %if.then.i ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync)
define internal i32 @mem_cgroup_slab_show(ptr nocapture noundef readnone %m, ptr nocapture noundef readnone %p) #1 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @mem_cgroup_usage(ptr noundef %memcg, i1 noundef zeroext %swap) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i = icmp eq ptr %0, %memcg
  br i1 %cmp.i, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @stats_flush_threshold, i32 noundef 4) #23
  %1 = load volatile i32, ptr @stats_flush_threshold, align 4
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @__num_online_cpus, i32 noundef 4) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__num_online_cpus to i32))
  %2 = load volatile i32, ptr @__num_online_cpus, align 4
  %cmp.i20 = icmp ugt i32 %1, %2
  br i1 %cmp.i20, label %if.then.i, label %mem_cgroup_flush_stats.exit

if.then.i:                                        ; preds = %if.then
  tail call fastcc void @__mem_cgroup_flush_stats() #23
  br label %mem_cgroup_flush_stats.exit

mem_cgroup_flush_stats.exit:                      ; preds = %if.then.i, %if.then
  %arrayidx.i = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 0, i32 19
  %3 = ptrtoint ptr %arrayidx.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load volatile i32, ptr %arrayidx.i, align 4
  %arrayidx.i22 = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 0, i32 17
  %5 = ptrtoint ptr %arrayidx.i22 to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %arrayidx.i22, align 4
  %add = add i32 %6, %4
  br i1 %swap, label %if.then3, label %if.end12

if.then3:                                         ; preds = %mem_cgroup_flush_stats.exit
  %arrayidx.i24 = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 0, i32 40
  %7 = ptrtoint ptr %arrayidx.i24 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load volatile i32, ptr %arrayidx.i24, align 4
  %add5 = add i32 %8, %add
  br label %if.end12

if.else:                                          ; preds = %entry
  br i1 %swap, label %if.else9, label %if.then7

if.then7:                                         ; preds = %if.else
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2
  %call.i.i.i25 = tail call zeroext i1 @__kasan_check_read(ptr noundef %memory, i32 noundef 4) #23
  %9 = ptrtoint ptr %memory to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load volatile i32, ptr %memory, align 4
  br label %if.end12

if.else9:                                         ; preds = %if.else
  %11 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 3
  %call.i.i.i26 = tail call zeroext i1 @__kasan_check_read(ptr noundef %11, i32 noundef 4) #23
  %12 = ptrtoint ptr %11 to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load volatile i32, ptr %11, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.else9, %if.then7, %if.then3, %mem_cgroup_flush_stats.exit
  %val.0 = phi i32 [ %add5, %if.then3 ], [ %add, %mem_cgroup_flush_stats.exit ], [ %13, %if.else9 ], [ %10, %if.then7 ]
  ret i32 %val.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @mem_cgroup_resize_max(ptr noundef %memcg, i32 noundef %max, i1 noundef zeroext %memsw) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 3
  %memory = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2
  %cond = select i1 %memsw, ptr %0, ptr %memory
  %1 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i74 = and i32 %1, -16384
  %2 = inttoptr i32 %and.i74 to ptr
  %task75 = getelementptr inbounds %struct.thread_info, ptr %2, i32 0, i32 2
  %3 = ptrtoint ptr %task75 to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %task75, align 8
  %stack.i.i76 = getelementptr inbounds %struct.task_struct, ptr %4, i32 0, i32 1
  %5 = ptrtoint ptr %stack.i.i76 to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %stack.i.i76, align 4
  %7 = ptrtoint ptr %6 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load volatile i32, ptr %6, align 4
  %9 = and i32 %8, 256
  %tobool.not.i77 = icmp eq i32 %9, 0
  br i1 %tobool.not.i77, label %signal_pending.exit.lr.ph, label %if.end42, !prof !460

signal_pending.exit.lr.ph:                        ; preds = %entry
  %max9 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 3, i32 0, i32 4
  %max7 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2, i32 4
  %max19 = getelementptr inbounds %struct.page_counter, ptr %cond, i32 0, i32 4
  %lnot = xor i1 %memsw, true
  br label %signal_pending.exit

signal_pending.exit:                              ; preds = %do.cond36, %signal_pending.exit.lr.ph
  %10 = phi ptr [ %6, %signal_pending.exit.lr.ph ], [ %24, %do.cond36 ]
  %enlarge.0.off079 = phi i1 [ false, %signal_pending.exit.lr.ph ], [ %spec.select, %do.cond36 ]
  %drained.0.off078 = phi i1 [ false, %signal_pending.exit.lr.ph ], [ true, %do.cond36 ]
  %11 = ptrtoint ptr %10 to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load volatile i32, ptr %10, align 4
  %and1.i.i.i.i.i = and i32 %12, 1
  %tobool2.not = icmp eq i32 %and1.i.i.i.i.i, 0
  br i1 %tobool2.not, label %if.end, label %if.end42

if.end:                                           ; preds = %signal_pending.exit
  tail call void @mutex_lock_nested(ptr noundef nonnull @memcg_max_mutex, i32 noundef 0) #23
  br i1 %memsw, label %cond.true4, label %cond.end12

cond.true4:                                       ; preds = %if.end
  %13 = ptrtoint ptr %max7 to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %max7, align 16
  %cmp.not = icmp ugt i32 %14, %max
  br i1 %cmp.not, label %if.then17, label %if.end18

cond.end12:                                       ; preds = %if.end
  %15 = ptrtoint ptr %max9 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %max9, align 8
  %cmp10.not = icmp ult i32 %16, %max
  br i1 %cmp10.not, label %if.then17, label %if.end18

if.then17:                                        ; preds = %cond.end12, %cond.true4
  tail call void @mutex_unlock(ptr noundef nonnull @memcg_max_mutex) #23
  br label %if.end42

if.end18:                                         ; preds = %cond.end12, %cond.true4
  %17 = ptrtoint ptr %max19 to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %max19, align 4
  %cmp20 = icmp ult i32 %18, %max
  %spec.select = select i1 %cmp20, i1 true, i1 %enlarge.0.off079
  %call24 = tail call i32 @page_counter_set_max(ptr noundef %cond, i32 noundef %max) #23
  tail call void @mutex_unlock(ptr noundef nonnull @memcg_max_mutex) #23
  %tobool25.not = icmp eq i32 %call24, 0
  br i1 %tobool25.not, label %do.end37, label %if.end27

if.end27:                                         ; preds = %if.end18
  br i1 %drained.0.off078, label %if.end30, label %if.then29

if.then29:                                        ; preds = %if.end27
  tail call fastcc void @drain_all_stock(ptr noundef %memcg)
  br label %do.cond36

if.end30:                                         ; preds = %if.end27
  %call32 = tail call i32 @try_to_free_mem_cgroup_pages(ptr noundef %memcg, i32 noundef 1, i32 noundef 3264, i1 noundef zeroext %lnot) #23
  %tobool33.not = icmp eq i32 %call32, 0
  br i1 %tobool33.not, label %if.end42, label %do.cond36

do.cond36:                                        ; preds = %if.end30, %if.then29
  %19 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i = and i32 %19, -16384
  %20 = inttoptr i32 %and.i to ptr
  %task = getelementptr inbounds %struct.thread_info, ptr %20, i32 0, i32 2
  %21 = ptrtoint ptr %task to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %task, align 8
  %stack.i.i = getelementptr inbounds %struct.task_struct, ptr %22, i32 0, i32 1
  %23 = ptrtoint ptr %stack.i.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %stack.i.i, align 4
  %25 = ptrtoint ptr %24 to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load volatile i32, ptr %24, align 4
  %27 = and i32 %26, 256
  %tobool.not.i = icmp eq i32 %27, 0
  br i1 %tobool.not.i, label %signal_pending.exit, label %if.end42, !prof !460

do.end37:                                         ; preds = %if.end18
  %tobool.not.i63 = icmp ne ptr %memcg, null
  %28 = and i1 %tobool.not.i63, %spec.select
  br i1 %28, label %land.lhs.true.i, label %if.end42

land.lhs.true.i:                                  ; preds = %do.end37
  %under_oom.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 11
  %29 = ptrtoint ptr %under_oom.i to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load i32, ptr %under_oom.i, align 16
  %tobool1.not.i = icmp eq i32 %30, 0
  br i1 %tobool1.not.i, label %if.end42, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  tail call void @__wake_up(ptr noundef nonnull @memcg_oom_waitq, i32 noundef 3, i32 noundef 0, ptr noundef nonnull %memcg) #23
  br label %if.end42

if.end42:                                         ; preds = %if.then.i, %land.lhs.true.i, %do.end37, %do.cond36, %if.end30, %if.then17, %signal_pending.exit, %entry
  %ret.073 = phi i32 [ 0, %do.end37 ], [ 0, %land.lhs.true.i ], [ 0, %if.then.i ], [ -22, %if.then17 ], [ -4, %entry ], [ -4, %signal_pending.exit ], [ -16, %if.end30 ], [ -4, %do.cond36 ]
  ret i32 %ret.073
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @memcg_update_tcp_max(ptr noundef %memcg, i32 noundef %max) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call void @mutex_lock_nested(ptr noundef nonnull @memcg_max_mutex, i32 noundef 0) #23
  %tcpmem = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 5
  %call = tail call i32 @page_counter_set_max(ptr noundef %tcpmem, i32 noundef %max) #23
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %out

if.end:                                           ; preds = %entry
  %tcpmem_active = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 30
  %0 = ptrtoint ptr %tcpmem_active to i32
  call void @__asan_load1_noabort(i32 %0)
  %1 = load i8, ptr %tcpmem_active, align 4, !range !488
  %tobool1.not = icmp eq i8 %1, 0
  br i1 %tobool1.not, label %if.then2, label %out

if.then2:                                         ; preds = %if.end
  tail call void @static_key_slow_inc(ptr noundef nonnull @memcg_sockets_enabled_key) #23
  %2 = ptrtoint ptr %tcpmem_active to i32
  call void @__asan_store1_noabort(i32 %2)
  store i8 1, ptr %tcpmem_active, align 4
  br label %out

out:                                              ; preds = %if.then2, %if.end, %entry
  tail call void @mutex_unlock(ptr noundef nonnull @memcg_max_mutex) #23
  ret i32 %call
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @mutex_lock_nested(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @first_online_pgdat() local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @next_online_pgdat(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @simple_strtoul(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @memcg_event_ptable_queue_proc(ptr nocapture noundef readnone %file, ptr noundef %wqh, ptr noundef %pt) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %wqh1 = getelementptr i8, ptr %pt, i32 8
  %0 = ptrtoint ptr %wqh1 to i32
  call void @__asan_store4_noabort(i32 %0)
  store ptr %wqh, ptr %wqh1, align 4
  %wait = getelementptr i8, ptr %pt, i32 12
  tail call void @add_wait_queue(ptr noundef %wqh, ptr noundef %wait) #23
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memcg_event_wake(ptr noundef %wait, i32 noundef %mode, i32 noundef %sync, ptr noundef %key) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = ptrtoint ptr %key to i32
  %and = and i32 %0, 16
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end7, label %if.then

if.then:                                          ; preds = %entry
  %add.ptr = getelementptr i8, ptr %wait, i32 -36
  %1 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %add.ptr, align 4
  %event_list_lock = getelementptr inbounds %struct.mem_cgroup, ptr %2, i32 0, i32 44
  tail call void @_raw_spin_lock(ptr noundef %event_list_lock) #23
  %list = getelementptr i8, ptr %wait, i32 -28
  %3 = ptrtoint ptr %list to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load volatile ptr, ptr %list, align 4
  %cmp.i.not = icmp eq ptr %4, %list
  br i1 %cmp.i.not, label %if.end, label %if.then3

if.then3:                                         ; preds = %if.then
  %call.i.i = tail call zeroext i1 @__list_del_entry_valid(ptr noundef %list) #23
  br i1 %call.i.i, label %if.end.i.i, label %list_del_init.exit

if.end.i.i:                                       ; preds = %if.then3
  %prev.i.i = getelementptr i8, ptr %wait, i32 -24
  %5 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %prev.i.i, align 4
  %7 = ptrtoint ptr %list to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %list, align 4
  %prev1.i.i.i = getelementptr inbounds %struct.list_head, ptr %8, i32 0, i32 1
  %9 = ptrtoint ptr %prev1.i.i.i to i32
  call void @__asan_store4_noabort(i32 %9)
  store ptr %6, ptr %prev1.i.i.i, align 4
  %10 = ptrtoint ptr %6 to i32
  call void @__asan_store4_noabort(i32 %10)
  store volatile ptr %8, ptr %6, align 4
  br label %list_del_init.exit

list_del_init.exit:                               ; preds = %if.end.i.i, %if.then3
  %11 = ptrtoint ptr %list to i32
  call void @__asan_store4_noabort(i32 %11)
  store volatile ptr %list, ptr %list, align 4
  %prev.i3.i = getelementptr i8, ptr %wait, i32 -24
  %12 = ptrtoint ptr %prev.i3.i to i32
  call void @__asan_store4_noabort(i32 %12)
  store ptr %list, ptr %prev.i3.i, align 4
  %remove = getelementptr i8, ptr %wait, i32 20
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @system_wq to i32))
  %13 = load ptr, ptr @system_wq, align 4
  %call.i.i12 = tail call zeroext i1 @queue_work_on(i32 noundef 4, ptr noundef %13, ptr noundef %remove) #23
  br label %if.end

if.end:                                           ; preds = %list_del_init.exit, %if.then
  tail call void @_raw_spin_unlock(ptr noundef %event_list_lock) #23
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @memcg_event_remove(ptr noundef %work) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %add.ptr = getelementptr i8, ptr %work, i32 -56
  %0 = ptrtoint ptr %add.ptr to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %add.ptr, align 4
  %wqh = getelementptr i8, ptr %work, i32 -24
  %2 = ptrtoint ptr %wqh to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %wqh, align 4
  %wait = getelementptr i8, ptr %work, i32 -20
  tail call void @remove_wait_queue(ptr noundef %3, ptr noundef %wait) #23
  %unregister_event = getelementptr i8, ptr %work, i32 -36
  %4 = ptrtoint ptr %unregister_event to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load ptr, ptr %unregister_event, align 4
  %eventfd = getelementptr i8, ptr %work, i32 -52
  %6 = ptrtoint ptr %eventfd to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load ptr, ptr %eventfd, align 4
  tail call void %5(ptr noundef %1, ptr noundef %7) #23
  %8 = ptrtoint ptr %eventfd to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load ptr, ptr %eventfd, align 4
  %call = tail call i64 @eventfd_signal(ptr noundef %9, i64 noundef 1) #23
  %10 = ptrtoint ptr %eventfd to i32
  call void @__asan_load4_noabort(i32 %10)
  %11 = load ptr, ptr %eventfd, align 4
  tail call void @eventfd_ctx_put(ptr noundef %11) #23
  tail call void @kfree(ptr noundef %add.ptr) #23
  %flags.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %1, i32 0, i32 7
  %12 = ptrtoint ptr %flags.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %flags.i, align 4
  %and.i = and i32 %13, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.then.i, label %css_put.exit

if.then.i:                                        ; preds = %entry
  %refcnt.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %1, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i) #23
  br label %css_put.exit

css_put.exit:                                     ; preds = %if.then.i, %entry
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @eventfd_ctx_fileget(ptr noundef) local_unnamed_addr #4

; Function Attrs: argmemonly mustprogress nofree nounwind null_pointer_is_valid readonly willreturn
declare dso_local i32 @strcmp(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #22

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @mem_cgroup_usage_register_event(ptr noundef %memcg, ptr noundef %eventfd, ptr noundef %args) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call fastcc i32 @__mem_cgroup_usage_register_event(ptr noundef %memcg, ptr noundef %eventfd, ptr noundef %args, i32 noundef 0)
  ret i32 %call
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @mem_cgroup_usage_unregister_event(ptr noundef %memcg, ptr noundef %eventfd) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call fastcc void @__mem_cgroup_usage_unregister_event(ptr noundef %memcg, ptr noundef %eventfd, i32 noundef 0)
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @mem_cgroup_oom_register_event(ptr noundef %memcg, ptr noundef %eventfd, ptr nocapture noundef readnone %args) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  call void @__asan_load4_noabort(i32 ptrtoint (ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 7) to i32))
  %0 = load ptr, ptr getelementptr inbounds ([4 x [14 x ptr]], ptr @kmalloc_caches, i32 0, i32 0, i32 7), align 4
  %call7.i = tail call noalias align 8 ptr @kmem_cache_alloc_trace(ptr noundef %0, i32 noundef 3264, i32 noundef 12) #26
  %tobool.not = icmp eq ptr %call7.i, null
  br i1 %tobool.not, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  tail call void @_raw_spin_lock(ptr noundef nonnull @memcg_oom_lock) #23
  %eventfd1 = getelementptr inbounds %struct.mem_cgroup_eventfd_list, ptr %call7.i, i32 0, i32 1
  %1 = ptrtoint ptr %eventfd1 to i32
  call void @__asan_store4_noabort(i32 %1)
  store ptr %eventfd, ptr %eventfd1, align 8
  %oom_notify = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 20
  %2 = ptrtoint ptr %oom_notify to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %oom_notify, align 4
  %call.i.i = tail call zeroext i1 @__list_add_valid(ptr noundef nonnull %call7.i, ptr noundef %oom_notify, ptr noundef %3) #23
  br i1 %call.i.i, label %if.end.i.i, label %list_add.exit

if.end.i.i:                                       ; preds = %if.end
  %prev1.i.i = getelementptr inbounds %struct.list_head, ptr %3, i32 0, i32 1
  %4 = ptrtoint ptr %prev1.i.i to i32
  call void @__asan_store4_noabort(i32 %4)
  store ptr %call7.i, ptr %prev1.i.i, align 4
  %5 = ptrtoint ptr %call7.i to i32
  call void @__asan_store4_noabort(i32 %5)
  store ptr %3, ptr %call7.i, align 8
  %prev3.i.i = getelementptr inbounds %struct.list_head, ptr %call7.i, i32 0, i32 1
  %6 = ptrtoint ptr %prev3.i.i to i32
  call void @__asan_store4_noabort(i32 %6)
  store ptr %oom_notify, ptr %prev3.i.i, align 4
  %7 = ptrtoint ptr %oom_notify to i32
  call void @__asan_store4_noabort(i32 %7)
  store volatile ptr %call7.i, ptr %oom_notify, align 4
  br label %list_add.exit

list_add.exit:                                    ; preds = %if.end.i.i, %if.end
  %under_oom = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 11
  %8 = ptrtoint ptr %under_oom to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load i32, ptr %under_oom, align 16
  %tobool2.not = icmp eq i32 %9, 0
  br i1 %tobool2.not, label %if.end5, label %if.then3

if.then3:                                         ; preds = %list_add.exit
  %call4 = tail call i64 @eventfd_signal(ptr noundef %eventfd, i64 noundef 1) #23
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %list_add.exit
  tail call void @_raw_spin_unlock(ptr noundef nonnull @memcg_oom_lock) #23
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %entry
  %retval.0 = phi i32 [ 0, %if.end5 ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @mem_cgroup_oom_unregister_event(ptr noundef readonly %memcg, ptr noundef readnone %eventfd) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call void @_raw_spin_lock(ptr noundef nonnull @memcg_oom_lock) #23
  %oom_notify = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 20
  %0 = ptrtoint ptr %oom_notify to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %oom_notify, align 16
  %cmp.not23 = icmp eq ptr %1, %oom_notify
  br i1 %cmp.not23, label %for.end, label %for.body

for.body:                                         ; preds = %for.inc, %entry
  %ev.024 = phi ptr [ %tmp.026, %for.inc ], [ %1, %entry ]
  %2 = ptrtoint ptr %ev.024 to i32
  call void @__asan_load4_noabort(i32 %2)
  %tmp.026 = load ptr, ptr %ev.024, align 4
  %eventfd8 = getelementptr inbounds %struct.mem_cgroup_eventfd_list, ptr %ev.024, i32 0, i32 1
  %3 = ptrtoint ptr %eventfd8 to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %eventfd8, align 4
  %cmp9 = icmp eq ptr %4, %eventfd
  br i1 %cmp9, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %call.i.i = tail call zeroext i1 @__list_del_entry_valid(ptr noundef %ev.024) #23
  br i1 %call.i.i, label %if.end.i.i, label %list_del.exit

if.end.i.i:                                       ; preds = %if.then
  %prev.i.i = getelementptr inbounds %struct.list_head, ptr %ev.024, i32 0, i32 1
  %5 = ptrtoint ptr %prev.i.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load ptr, ptr %prev.i.i, align 4
  %7 = ptrtoint ptr %ev.024 to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load ptr, ptr %ev.024, align 4
  %prev1.i.i.i = getelementptr inbounds %struct.list_head, ptr %8, i32 0, i32 1
  %9 = ptrtoint ptr %prev1.i.i.i to i32
  call void @__asan_store4_noabort(i32 %9)
  store ptr %6, ptr %prev1.i.i.i, align 4
  %10 = ptrtoint ptr %6 to i32
  call void @__asan_store4_noabort(i32 %10)
  store volatile ptr %8, ptr %6, align 4
  br label %list_del.exit

list_del.exit:                                    ; preds = %if.end.i.i, %if.then
  %11 = ptrtoint ptr %ev.024 to i32
  call void @__asan_store4_noabort(i32 %11)
  store ptr inttoptr (i32 256 to ptr), ptr %ev.024, align 4
  %prev.i = getelementptr inbounds %struct.list_head, ptr %ev.024, i32 0, i32 1
  %12 = ptrtoint ptr %prev.i to i32
  call void @__asan_store4_noabort(i32 %12)
  store ptr inttoptr (i32 290 to ptr), ptr %prev.i, align 4
  tail call void @kfree(ptr noundef %ev.024) #23
  br label %for.inc

for.inc:                                          ; preds = %list_del.exit, %for.body
  %cmp.not = icmp eq ptr %tmp.026, %oom_notify
  br i1 %cmp.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %entry
  tail call void @_raw_spin_unlock(ptr noundef nonnull @memcg_oom_lock) #23
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @vmpressure_register_event(ptr noundef, ptr noundef, ptr noundef) #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @vmpressure_unregister_event(ptr noundef, ptr noundef) #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memsw_cgroup_usage_register_event(ptr noundef %memcg, ptr noundef %eventfd, ptr noundef %args) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %call = tail call fastcc i32 @__mem_cgroup_usage_register_event(ptr noundef %memcg, ptr noundef %eventfd, ptr noundef %args, i32 noundef 1)
  ret i32 %call
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal void @memsw_cgroup_usage_unregister_event(ptr noundef %memcg, ptr noundef %eventfd) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  tail call fastcc void @__mem_cgroup_usage_unregister_event(ptr noundef %memcg, ptr noundef %eventfd, i32 noundef 1)
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @css_tryget_online_from_dir(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @eventfd_ctx_put(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @add_wait_queue(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @remove_wait_queue(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__fdget(i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @inode_permission(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc i32 @__mem_cgroup_usage_register_event(ptr noundef %memcg, ptr noundef %eventfd, ptr noundef %args, i32 noundef %type) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %threshold = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %threshold) #23
  %0 = ptrtoint ptr %threshold to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %threshold, align 4, !annotation !492
  %call = call i32 @page_counter_memparse(ptr noundef %args, ptr noundef nonnull @.str.134, ptr noundef nonnull %threshold) #23
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %thresholds_lock = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 17
  call void @mutex_lock_nested(ptr noundef %thresholds_lock, i32 noundef 0) #23
  %cmp = icmp eq i32 %type, 0
  br i1 %cmp, label %if.then1, label %if.then5

if.then1:                                         ; preds = %if.end
  %thresholds2 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 18
  %1 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i138 = icmp eq ptr %1, %memcg
  br i1 %cmp.i.i138, label %if.then.i139, label %if.else.i

if.then.i139:                                     ; preds = %if.then1
  %call.i.i.i.i = call zeroext i1 @__kasan_check_read(ptr noundef nonnull @stats_flush_threshold, i32 noundef 4) #23
  %2 = load volatile i32, ptr @stats_flush_threshold, align 4
  %call.i.i.i.i.i = call zeroext i1 @__kasan_check_read(ptr noundef nonnull @__num_online_cpus, i32 noundef 4) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__num_online_cpus to i32))
  %3 = load volatile i32, ptr @__num_online_cpus, align 4
  %cmp.i20.i = icmp ugt i32 %2, %3
  br i1 %cmp.i20.i, label %if.then.i.i, label %mem_cgroup_flush_stats.exit.i

if.then.i.i:                                      ; preds = %if.then.i139
  call fastcc void @__mem_cgroup_flush_stats() #23
  br label %mem_cgroup_flush_stats.exit.i

mem_cgroup_flush_stats.exit.i:                    ; preds = %if.then.i.i, %if.then.i139
  %arrayidx.i.i = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 0, i32 19
  %4 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %arrayidx.i.i, align 4
  %arrayidx.i22.i = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 0, i32 17
  %6 = ptrtoint ptr %arrayidx.i22.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %arrayidx.i22.i, align 4
  %add.i = add i32 %7, %5
  br label %if.end12

if.else.i:                                        ; preds = %if.then1
  %memory.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2
  %call.i.i.i25.i = call zeroext i1 @__kasan_check_read(ptr noundef %memory.i, i32 noundef 4) #23
  %8 = ptrtoint ptr %memory.i to i32
  call void @__asan_load4_noabort(i32 %8)
  %9 = load volatile i32, ptr %memory.i, align 4
  br label %if.end12

if.then5:                                         ; preds = %if.end
  %memsw_thresholds = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 19
  %10 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i140 = icmp eq ptr %10, %memcg
  br i1 %cmp.i.i140, label %if.then.i144, label %if.else.i150

if.then.i144:                                     ; preds = %if.then5
  %call.i.i.i.i141 = call zeroext i1 @__kasan_check_read(ptr noundef nonnull @stats_flush_threshold, i32 noundef 4) #23
  %11 = load volatile i32, ptr @stats_flush_threshold, align 4
  %call.i.i.i.i.i142 = call zeroext i1 @__kasan_check_read(ptr noundef nonnull @__num_online_cpus, i32 noundef 4) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__num_online_cpus to i32))
  %12 = load volatile i32, ptr @__num_online_cpus, align 4
  %cmp.i20.i143 = icmp ugt i32 %11, %12
  br i1 %cmp.i20.i143, label %if.then.i.i145, label %mem_cgroup_flush_stats.exit.i149

if.then.i.i145:                                   ; preds = %if.then.i144
  call fastcc void @__mem_cgroup_flush_stats() #23
  br label %mem_cgroup_flush_stats.exit.i149

mem_cgroup_flush_stats.exit.i149:                 ; preds = %if.then.i.i145, %if.then.i144
  %arrayidx.i.i146 = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 0, i32 19
  %13 = ptrtoint ptr %arrayidx.i.i146 to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load volatile i32, ptr %arrayidx.i.i146, align 4
  %arrayidx.i22.i147 = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 0, i32 17
  %15 = ptrtoint ptr %arrayidx.i22.i147 to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load volatile i32, ptr %arrayidx.i22.i147, align 4
  %add.i148 = add i32 %16, %14
  %arrayidx.i24.i = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 0, i32 40
  %17 = ptrtoint ptr %arrayidx.i24.i to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load volatile i32, ptr %arrayidx.i24.i, align 4
  %add5.i = add i32 %add.i148, %18
  br label %if.end12

if.else.i150:                                     ; preds = %if.then5
  %19 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 3
  %call.i.i.i26.i = call zeroext i1 @__kasan_check_read(ptr noundef %19, i32 noundef 4) #23
  %20 = ptrtoint ptr %19 to i32
  call void @__asan_load4_noabort(i32 %20)
  %21 = load volatile i32, ptr %19, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.else.i150, %mem_cgroup_flush_stats.exit.i149, %if.else.i, %mem_cgroup_flush_stats.exit.i
  %thresholds.0 = phi ptr [ %thresholds2, %mem_cgroup_flush_stats.exit.i ], [ %thresholds2, %if.else.i ], [ %memsw_thresholds, %mem_cgroup_flush_stats.exit.i149 ], [ %memsw_thresholds, %if.else.i150 ]
  %usage.0 = phi i32 [ %add.i, %mem_cgroup_flush_stats.exit.i ], [ %9, %if.else.i ], [ %add5.i, %mem_cgroup_flush_stats.exit.i149 ], [ %21, %if.else.i150 ]
  %22 = ptrtoint ptr %thresholds.0 to i32
  call void @__asan_load4_noabort(i32 %22)
  %23 = load ptr, ptr %thresholds.0, align 4
  %tobool13.not = icmp eq ptr %23, null
  br i1 %tobool13.not, label %if.end8.i, label %if.end16

if.end16:                                         ; preds = %if.end12
  %cmp15 = icmp eq i32 %type, 1
  call fastcc void @__mem_cgroup_threshold(ptr noundef %memcg, i1 noundef zeroext %cmp15)
  %24 = ptrtoint ptr %thresholds.0 to i32
  call void @__asan_load4_noabort(i32 %24)
  %.pr = load ptr, ptr %thresholds.0, align 4
  %tobool18.not = icmp eq ptr %.pr, null
  br i1 %tobool18.not, label %if.end8.i, label %cond.true

cond.true:                                        ; preds = %if.end16
  %size20 = getelementptr inbounds %struct.mem_cgroup_threshold_ary, ptr %.pr, i32 0, i32 1
  %25 = ptrtoint ptr %size20 to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %size20, align 4
  %add = add i32 %26, 1
  br label %if.end8.i

if.end8.i:                                        ; preds = %cond.true, %if.end16, %if.end12
  %cond = phi i32 [ %add, %cond.true ], [ 1, %if.end16 ], [ 1, %if.end12 ]
  %27 = call { i32, i1 } @llvm.umul.with.overflow.i32(i32 %cond, i32 8) #23
  %28 = extractvalue { i32, i1 } %27, 1
  %29 = extractvalue { i32, i1 } %27, 0
  %spec.select.i = call i32 @llvm.uadd.sat.i32(i32 %29, i32 8) #23
  %retval.0.i = select i1 %28, i32 -1, i32 %spec.select.i
  %call9.i = call noalias align 128 ptr @__kmalloc(i32 noundef %retval.0.i, i32 noundef 3264) #27
  %tobool23.not = icmp eq ptr %call9.i, null
  br i1 %tobool23.not, label %unlock, label %if.end25

if.end25:                                         ; preds = %if.end8.i
  %size26 = getelementptr inbounds %struct.mem_cgroup_threshold_ary, ptr %call9.i, i32 0, i32 1
  %30 = ptrtoint ptr %size26 to i32
  call void @__asan_store4_noabort(i32 %30)
  store i32 %cond, ptr %size26, align 4
  %31 = ptrtoint ptr %thresholds.0 to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %thresholds.0, align 4
  %tobool28.not = icmp eq ptr %32, null
  br i1 %tobool28.not, label %if.end25.if.end34_crit_edge, label %if.then29

if.end25.if.end34_crit_edge:                      ; preds = %if.end25
  %.pre = add i32 %cond, -1
  br label %if.end34

if.then29:                                        ; preds = %if.end25
  %entries = getelementptr inbounds %struct.mem_cgroup_threshold_ary, ptr %call9.i, i32 0, i32 2
  %entries31 = getelementptr inbounds %struct.mem_cgroup_threshold_ary, ptr %32, i32 0, i32 2
  %sub = add i32 %cond, -1
  %33 = call { i32, i1 } @llvm.umul.with.overflow.i32(i32 %sub, i32 8) #23
  %34 = extractvalue { i32, i1 } %33, 1
  %35 = extractvalue { i32, i1 } %33, 0
  %retval.0.i153 = select i1 %34, i32 -1, i32 %35
  %36 = call ptr @memcpy(ptr %entries, ptr %entries31, i32 %retval.0.i153)
  br label %if.end34

if.end34:                                         ; preds = %if.then29, %if.end25.if.end34_crit_edge
  %sub36.pre-phi = phi i32 [ %.pre, %if.end25.if.end34_crit_edge ], [ %sub, %if.then29 ]
  %entries35 = getelementptr inbounds %struct.mem_cgroup_threshold_ary, ptr %call9.i, i32 0, i32 2
  %arrayidx = getelementptr %struct.mem_cgroup_threshold_ary, ptr %call9.i, i32 0, i32 2, i32 %sub36.pre-phi
  %37 = ptrtoint ptr %arrayidx to i32
  call void @__asan_store4_noabort(i32 %37)
  store ptr %eventfd, ptr %arrayidx, align 8
  %38 = ptrtoint ptr %threshold to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load i32, ptr %threshold, align 4
  %threshold41 = getelementptr %struct.mem_cgroup_threshold_ary, ptr %call9.i, i32 0, i32 2, i32 %sub36.pre-phi, i32 1
  %40 = ptrtoint ptr %threshold41 to i32
  call void @__asan_store4_noabort(i32 %40)
  store i32 %39, ptr %threshold41, align 4
  call void @sort(ptr noundef %entries35, i32 noundef %cond, i32 noundef 8, ptr noundef nonnull @compare_thresholds, ptr noundef null) #23
  %41 = ptrtoint ptr %call9.i to i32
  call void @__asan_store4_noabort(i32 %41)
  store i32 -1, ptr %call9.i, align 128
  %cmp44155 = icmp sgt i32 %cond, 0
  br i1 %cmp44155, label %for.body, label %for.end

for.body:                                         ; preds = %if.then49, %if.end34
  %i.0156 = phi i32 [ %inc53, %if.then49 ], [ 0, %if.end34 ]
  %threshold47 = getelementptr %struct.mem_cgroup_threshold_ary, ptr %call9.i, i32 0, i32 2, i32 %i.0156, i32 1
  %42 = ptrtoint ptr %threshold47 to i32
  call void @__asan_load4_noabort(i32 %42)
  %43 = load i32, ptr %threshold47, align 4
  %cmp48.not = icmp ugt i32 %43, %usage.0
  br i1 %cmp48.not, label %for.end, label %if.then49

if.then49:                                        ; preds = %for.body
  %44 = ptrtoint ptr %call9.i to i32
  call void @__asan_load4_noabort(i32 %44)
  %45 = load i32, ptr %call9.i, align 128
  %inc = add i32 %45, 1
  store i32 %inc, ptr %call9.i, align 128
  %inc53 = add nuw nsw i32 %i.0156, 1
  %exitcond.not = icmp eq i32 %inc53, %cond
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %if.then49, %for.body, %if.end34
  %spare = getelementptr inbounds %struct.mem_cgroup_thresholds, ptr %thresholds.0, i32 0, i32 1
  %46 = ptrtoint ptr %spare to i32
  call void @__asan_load4_noabort(i32 %46)
  %47 = load ptr, ptr %spare, align 4
  call void @kfree(ptr noundef %47) #23
  %48 = ptrtoint ptr %thresholds.0 to i32
  call void @__asan_load4_noabort(i32 %48)
  %49 = load ptr, ptr %thresholds.0, align 4
  %50 = ptrtoint ptr %spare to i32
  call void @__asan_store4_noabort(i32 %50)
  store ptr %49, ptr %spare, align 4
  call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !578
  %51 = ptrtoint ptr %thresholds.0 to i32
  call void @__asan_store4_noabort(i32 %51)
  store volatile ptr %call9.i, ptr %thresholds.0, align 4
  call void @synchronize_rcu() #23
  br label %unlock

unlock:                                           ; preds = %for.end, %if.end8.i
  %ret.0 = phi i32 [ 0, %for.end ], [ -12, %if.end8.i ]
  call void @mutex_unlock(ptr noundef %thresholds_lock) #23
  br label %cleanup

cleanup:                                          ; preds = %unlock, %entry
  %retval.0 = phi i32 [ %ret.0, %unlock ], [ %call, %entry ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %threshold) #23
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @__mem_cgroup_threshold(ptr noundef %memcg, i1 noundef zeroext %swap) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i = and i32 %0, -16384
  %1 = inttoptr i32 %and.i.i.i.i.i to ptr
  %preempt_count.i.i.i.i = getelementptr inbounds %struct.thread_info, ptr %1, i32 0, i32 1
  %2 = ptrtoint ptr %preempt_count.i.i.i.i to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %preempt_count.i.i.i.i, align 4
  %add.i.i.i = add i32 %3, 1
  store volatile i32 %add.i.i.i, ptr %preempt_count.i.i.i.i, align 4
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !462
  tail call fastcc void @rcu_lock_acquire(ptr noundef nonnull @rcu_lock_map) #23
  %call.i = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i, label %rcu_read_lock.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %call1.i = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %rcu_read_lock.exit, label %land.lhs.true2.i

land.lhs.true2.i:                                 ; preds = %land.lhs.true.i
  %.b4.i = load i1, ptr @rcu_read_lock.__warned, align 1
  br i1 %.b4.i, label %rcu_read_lock.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true2.i
  store i1 true, ptr @rcu_read_lock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 696, ptr noundef nonnull @.str.52) #23
  br label %rcu_read_lock.exit

rcu_read_lock.exit:                               ; preds = %if.then.i, %land.lhs.true2.i, %land.lhs.true.i, %entry
  br i1 %swap, label %if.else, label %if.then

if.then:                                          ; preds = %rcu_read_lock.exit
  %thresholds = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 18
  %4 = ptrtoint ptr %thresholds to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile ptr, ptr %thresholds, align 32
  %call = tail call i32 @rcu_read_lock_held() #23
  %tobool2.not = icmp eq i32 %call, 0
  br i1 %tobool2.not, label %land.lhs.true, label %if.end29

land.lhs.true:                                    ; preds = %if.then
  %call3 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool4.not = icmp eq i32 %call3, 0
  br i1 %tobool4.not, label %if.end29, label %land.lhs.true5

land.lhs.true5:                                   ; preds = %land.lhs.true
  %.b85 = load i1, ptr @__mem_cgroup_threshold.__warned, align 1
  br i1 %.b85, label %if.end29, label %if.end29.sink.split

if.else:                                          ; preds = %rcu_read_lock.exit
  %memsw_thresholds = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 19
  %6 = ptrtoint ptr %memsw_thresholds to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile ptr, ptr %memsw_thresholds, align 8
  %call17 = tail call i32 @rcu_read_lock_held() #23
  %tobool18.not = icmp eq i32 %call17, 0
  br i1 %tobool18.not, label %land.lhs.true19, label %if.end29

land.lhs.true19:                                  ; preds = %if.else
  %call20 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool21.not = icmp eq i32 %call20, 0
  br i1 %tobool21.not, label %if.end29, label %land.lhs.true22

land.lhs.true22:                                  ; preds = %land.lhs.true19
  %.b8486 = load i1, ptr @__mem_cgroup_threshold.__warned.155, align 1
  br i1 %.b8486, label %if.end29, label %if.end29.sink.split

if.end29.sink.split:                              ; preds = %land.lhs.true22, %land.lhs.true5
  %__mem_cgroup_threshold.__warned.155.sink = phi ptr [ @__mem_cgroup_threshold.__warned, %land.lhs.true5 ], [ @__mem_cgroup_threshold.__warned.155, %land.lhs.true22 ]
  %.sink = phi i32 [ 4080, %land.lhs.true5 ], [ 4082, %land.lhs.true22 ]
  %t.0.ph = phi ptr [ %5, %land.lhs.true5 ], [ %7, %land.lhs.true22 ]
  %8 = ptrtoint ptr %__mem_cgroup_threshold.__warned.155.sink to i32
  call void @__asan_store1_noabort(i32 %8)
  store i1 true, ptr %__mem_cgroup_threshold.__warned.155.sink, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.1, i32 noundef %.sink, ptr noundef nonnull @.str.2) #23
  br label %if.end29

if.end29:                                         ; preds = %if.end29.sink.split, %land.lhs.true22, %land.lhs.true19, %if.else, %land.lhs.true5, %land.lhs.true, %if.then
  %t.0 = phi ptr [ %5, %land.lhs.true5 ], [ %5, %land.lhs.true ], [ %5, %if.then ], [ %7, %land.lhs.true22 ], [ %7, %land.lhs.true19 ], [ %7, %if.else ], [ %t.0.ph, %if.end29.sink.split ]
  %tobool30.not = icmp eq ptr %t.0, null
  br i1 %tobool30.not, label %unlock, label %if.end32

if.end32:                                         ; preds = %if.end29
  %call34 = tail call fastcc i32 @mem_cgroup_usage(ptr noundef %memcg, i1 noundef zeroext %swap)
  %9 = ptrtoint ptr %t.0 to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %t.0, align 4
  %cmp96 = icmp sgt i32 %10, -1
  br i1 %cmp96, label %land.rhs, label %for.end

land.rhs:                                         ; preds = %for.body, %if.end32
  %i.097 = phi i32 [ %dec, %for.body ], [ %10, %if.end32 ]
  %threshold = getelementptr %struct.mem_cgroup_threshold_ary, ptr %t.0, i32 0, i32 2, i32 %i.097, i32 1
  %11 = ptrtoint ptr %threshold to i32
  call void @__asan_load4_noabort(i32 %11)
  %12 = load i32, ptr %threshold, align 4
  %cmp35 = icmp ugt i32 %12, %call34
  br i1 %cmp35, label %for.body, label %for.end

for.body:                                         ; preds = %land.rhs
  %arrayidx = getelementptr %struct.mem_cgroup_threshold_ary, ptr %t.0, i32 0, i32 2, i32 %i.097
  %13 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %arrayidx, align 4
  %call40 = tail call i64 @eventfd_signal(ptr noundef %14, i64 noundef 1) #23
  %dec = add nsw i32 %i.097, -1
  %cmp = icmp sgt i32 %i.097, 0
  br i1 %cmp, label %land.rhs, label %for.end

for.end:                                          ; preds = %for.body, %land.rhs, %if.end32
  %i.0.lcssa = phi i32 [ %10, %if.end32 ], [ -1, %for.body ], [ %i.097, %land.rhs ]
  %size = getelementptr inbounds %struct.mem_cgroup_threshold_ary, ptr %t.0, i32 0, i32 1
  %i.199 = add i32 %i.0.lcssa, 1
  %15 = ptrtoint ptr %size to i32
  call void @__asan_load4_noabort(i32 %15)
  %16 = load i32, ptr %size, align 4
  %cmp42100 = icmp ult i32 %i.199, %16
  br i1 %cmp42100, label %land.rhs43.preheader, label %for.end62

land.rhs43.preheader:                             ; preds = %for.end
  %threshold46105 = getelementptr %struct.mem_cgroup_threshold_ary, ptr %t.0, i32 0, i32 2, i32 %i.199, i32 1
  %17 = ptrtoint ptr %threshold46105 to i32
  call void @__asan_load4_noabort(i32 %17)
  %18 = load i32, ptr %threshold46105, align 4
  %cmp47.not106 = icmp ugt i32 %18, %call34
  br i1 %cmp47.not106, label %for.end62, label %for.body55

land.rhs43:                                       ; preds = %for.body55
  %threshold46 = getelementptr %struct.mem_cgroup_threshold_ary, ptr %t.0, i32 0, i32 2, i32 %i.1, i32 1
  %19 = ptrtoint ptr %threshold46 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load i32, ptr %threshold46, align 4
  %cmp47.not = icmp ugt i32 %20, %call34
  br i1 %cmp47.not, label %for.end62, label %for.body55

for.body55:                                       ; preds = %land.rhs43, %land.rhs43.preheader
  %i.1102107 = phi i32 [ %i.1, %land.rhs43 ], [ %i.199, %land.rhs43.preheader ]
  %arrayidx45 = getelementptr %struct.mem_cgroup_threshold_ary, ptr %t.0, i32 0, i32 2, i32 %i.1102107
  %21 = ptrtoint ptr %arrayidx45 to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %arrayidx45, align 4
  %call59 = tail call i64 @eventfd_signal(ptr noundef %22, i64 noundef 1) #23
  %i.1 = add nuw i32 %i.1102107, 1
  %23 = ptrtoint ptr %size to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load i32, ptr %size, align 4
  %cmp42 = icmp ult i32 %i.1, %24
  br i1 %cmp42, label %land.rhs43, label %for.end62

for.end62:                                        ; preds = %for.body55, %land.rhs43, %land.rhs43.preheader, %for.end
  %i.1.in.lcssa = phi i32 [ %i.0.lcssa, %for.end ], [ %i.0.lcssa, %land.rhs43.preheader ], [ %i.1102107, %land.rhs43 ], [ %i.1102107, %for.body55 ]
  %25 = ptrtoint ptr %t.0 to i32
  call void @__asan_store4_noabort(i32 %25)
  store i32 %i.1.in.lcssa, ptr %t.0, align 4
  br label %unlock

unlock:                                           ; preds = %for.end62, %if.end29
  %call.i87 = tail call zeroext i1 @rcu_is_watching() #23
  br i1 %call.i87, label %rcu_read_unlock.exit, label %land.lhs.true.i90

land.lhs.true.i90:                                ; preds = %unlock
  %call1.i88 = tail call i32 @debug_lockdep_rcu_enabled() #23
  %tobool.not.i89 = icmp eq i32 %call1.i88, 0
  br i1 %tobool.not.i89, label %rcu_read_unlock.exit, label %land.lhs.true2.i92

land.lhs.true2.i92:                               ; preds = %land.lhs.true.i90
  %.b4.i91 = load i1, ptr @rcu_read_unlock.__warned, align 1
  br i1 %.b4.i91, label %rcu_read_unlock.exit, label %if.then.i93

if.then.i93:                                      ; preds = %land.lhs.true2.i92
  store i1 true, ptr @rcu_read_unlock.__warned, align 1
  tail call void @lockdep_rcu_suspicious(ptr noundef nonnull @.str.51, i32 noundef 724, ptr noundef nonnull @.str.53) #23
  br label %rcu_read_unlock.exit

rcu_read_unlock.exit:                             ; preds = %if.then.i93, %land.lhs.true2.i92, %land.lhs.true.i90, %unlock
  tail call void asm sideeffect "", "~{memory}"() #23, !srcloc !463
  %26 = tail call i32 @llvm.read_register.i32(metadata !450) #23
  %and.i.i.i.i.i94 = and i32 %26, -16384
  %27 = inttoptr i32 %and.i.i.i.i.i94 to ptr
  %preempt_count.i.i.i.i95 = getelementptr inbounds %struct.thread_info, ptr %27, i32 0, i32 1
  %28 = ptrtoint ptr %preempt_count.i.i.i.i95 to i32
  call void @__asan_load4_noabort(i32 %28)
  %29 = load volatile i32, ptr %preempt_count.i.i.i.i95, align 4
  %sub.i.i.i = add i32 %29, -1
  store volatile i32 %sub.i.i.i, ptr %preempt_count.i.i.i.i95, align 4
  tail call void @rcu_read_unlock_strict() #23
  tail call fastcc void @rcu_lock_release(ptr noundef nonnull @rcu_lock_map) #23
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @sort(ptr noundef, i32 noundef, i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync)
define internal i32 @compare_thresholds(ptr nocapture noundef readonly %a, ptr nocapture noundef readonly %b) #20 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %threshold = getelementptr inbounds %struct.mem_cgroup_threshold, ptr %a, i32 0, i32 1
  %0 = ptrtoint ptr %threshold to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %threshold, align 4
  %threshold1 = getelementptr inbounds %struct.mem_cgroup_threshold, ptr %b, i32 0, i32 1
  %2 = ptrtoint ptr %threshold1 to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load i32, ptr %threshold1, align 4
  %cmp = icmp ugt i32 %1, %3
  %cmp4 = icmp ult i32 %1, %3
  %. = sext i1 %cmp4 to i32
  %retval.0 = select i1 %cmp, i32 1, i32 %.
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @__mem_cgroup_usage_unregister_event(ptr noundef %memcg, ptr noundef readnone %eventfd, i32 noundef %type) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %thresholds_lock = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 17
  tail call void @mutex_lock_nested(ptr noundef %thresholds_lock, i32 noundef 0) #23
  %cmp = icmp eq i32 %type, 0
  br i1 %cmp, label %if.then, label %if.then3

if.then:                                          ; preds = %entry
  %thresholds1 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 18
  %0 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i = icmp eq ptr %0, %memcg
  br i1 %cmp.i.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.then
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @stats_flush_threshold, i32 noundef 4) #23
  %1 = load volatile i32, ptr @stats_flush_threshold, align 4
  %call.i.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @__num_online_cpus, i32 noundef 4) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__num_online_cpus to i32))
  %2 = load volatile i32, ptr @__num_online_cpus, align 4
  %cmp.i20.i = icmp ugt i32 %1, %2
  br i1 %cmp.i20.i, label %if.then.i.i, label %mem_cgroup_flush_stats.exit.i

if.then.i.i:                                      ; preds = %if.then.i
  tail call fastcc void @__mem_cgroup_flush_stats() #23
  br label %mem_cgroup_flush_stats.exit.i

mem_cgroup_flush_stats.exit.i:                    ; preds = %if.then.i.i, %if.then.i
  %arrayidx.i.i = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 0, i32 19
  %3 = ptrtoint ptr %arrayidx.i.i to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load volatile i32, ptr %arrayidx.i.i, align 4
  %arrayidx.i22.i = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 0, i32 17
  %5 = ptrtoint ptr %arrayidx.i22.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load volatile i32, ptr %arrayidx.i22.i, align 4
  %add.i = add i32 %6, %4
  br label %if.end9

if.else.i:                                        ; preds = %if.then
  %memory.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 2
  %call.i.i.i25.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %memory.i, i32 noundef 4) #23
  %7 = ptrtoint ptr %memory.i to i32
  call void @__asan_load4_noabort(i32 %7)
  %8 = load volatile i32, ptr %memory.i, align 4
  br label %if.end9

if.then3:                                         ; preds = %entry
  %memsw_thresholds = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 19
  %9 = load ptr, ptr @root_mem_cgroup, align 4
  %cmp.i.i145 = icmp eq ptr %9, %memcg
  br i1 %cmp.i.i145, label %if.then.i149, label %if.else.i155

if.then.i149:                                     ; preds = %if.then3
  %call.i.i.i.i146 = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @stats_flush_threshold, i32 noundef 4) #23
  %10 = load volatile i32, ptr @stats_flush_threshold, align 4
  %call.i.i.i.i.i147 = tail call zeroext i1 @__kasan_check_read(ptr noundef nonnull @__num_online_cpus, i32 noundef 4) #23
  call void @__asan_load4_noabort(i32 ptrtoint (ptr @__num_online_cpus to i32))
  %11 = load volatile i32, ptr @__num_online_cpus, align 4
  %cmp.i20.i148 = icmp ugt i32 %10, %11
  br i1 %cmp.i20.i148, label %if.then.i.i150, label %mem_cgroup_flush_stats.exit.i154

if.then.i.i150:                                   ; preds = %if.then.i149
  tail call fastcc void @__mem_cgroup_flush_stats() #23
  br label %mem_cgroup_flush_stats.exit.i154

mem_cgroup_flush_stats.exit.i154:                 ; preds = %if.then.i.i150, %if.then.i149
  %arrayidx.i.i151 = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 0, i32 19
  %12 = ptrtoint ptr %arrayidx.i.i151 to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load volatile i32, ptr %arrayidx.i.i151, align 4
  %arrayidx.i22.i152 = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 0, i32 17
  %14 = ptrtoint ptr %arrayidx.i22.i152 to i32
  call void @__asan_load4_noabort(i32 %14)
  %15 = load volatile i32, ptr %arrayidx.i22.i152, align 4
  %add.i153 = add i32 %15, %13
  %arrayidx.i24.i = getelementptr %struct.mem_cgroup, ptr %memcg, i32 0, i32 26, i32 0, i32 40
  %16 = ptrtoint ptr %arrayidx.i24.i to i32
  call void @__asan_load4_noabort(i32 %16)
  %17 = load volatile i32, ptr %arrayidx.i24.i, align 4
  %add5.i = add i32 %add.i153, %17
  br label %if.end9

if.else.i155:                                     ; preds = %if.then3
  %18 = getelementptr inbounds %struct.mem_cgroup, ptr %memcg, i32 0, i32 3
  %call.i.i.i26.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %18, i32 noundef 4) #23
  %19 = ptrtoint ptr %18 to i32
  call void @__asan_load4_noabort(i32 %19)
  %20 = load volatile i32, ptr %18, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.else.i155, %mem_cgroup_flush_stats.exit.i154, %if.else.i, %mem_cgroup_flush_stats.exit.i
  %usage.0 = phi i32 [ %add.i, %mem_cgroup_flush_stats.exit.i ], [ %8, %if.else.i ], [ %add5.i, %mem_cgroup_flush_stats.exit.i154 ], [ %20, %if.else.i155 ]
  %thresholds.0 = phi ptr [ %thresholds1, %mem_cgroup_flush_stats.exit.i ], [ %thresholds1, %if.else.i ], [ %memsw_thresholds, %mem_cgroup_flush_stats.exit.i154 ], [ %memsw_thresholds, %if.else.i155 ]
  %21 = ptrtoint ptr %thresholds.0 to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load ptr, ptr %thresholds.0, align 4
  %tobool.not = icmp eq ptr %22, null
  br i1 %tobool.not, label %unlock, label %if.end11

if.end11:                                         ; preds = %if.end9
  %cmp12 = icmp eq i32 %type, 1
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef %memcg, i1 noundef zeroext %cmp12)
  %23 = ptrtoint ptr %thresholds.0 to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %thresholds.0, align 4
  %size14 = getelementptr inbounds %struct.mem_cgroup_threshold_ary, ptr %24, i32 0, i32 1
  %25 = ptrtoint ptr %size14 to i32
  call void @__asan_load4_noabort(i32 %25)
  %26 = load i32, ptr %size14, align 4
  %cmp15158.not = icmp eq i32 %26, 0
  br i1 %cmp15158.not, label %unlock, label %for.body

for.body:                                         ; preds = %for.body, %if.end11
  %entries.0161 = phi i32 [ %entries.1, %for.body ], [ 0, %if.end11 ]
  %size.0160 = phi i32 [ %size.1, %for.body ], [ 0, %if.end11 ]
  %i.0159 = phi i32 [ %inc24, %for.body ], [ 0, %if.end11 ]
  %arrayidx = getelementptr %struct.mem_cgroup_threshold_ary, ptr %24, i32 0, i32 2, i32 %i.0159
  %27 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %27)
  %28 = load ptr, ptr %arrayidx, align 4
  %cmp19.not = icmp eq ptr %28, %eventfd
  %not.cmp19.not = xor i1 %cmp19.not, true
  %inc = zext i1 %not.cmp19.not to i32
  %size.1 = add i32 %size.0160, %inc
  %inc22 = zext i1 %cmp19.not to i32
  %entries.1 = add i32 %entries.0161, %inc22
  %inc24 = add nuw i32 %i.0159, 1
  %exitcond.not = icmp eq i32 %inc24, %26
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body
  %phi.cmp = icmp eq i32 %entries.1, 0
  %spare = getelementptr inbounds %struct.mem_cgroup_thresholds, ptr %thresholds.0, i32 0, i32 1
  %29 = ptrtoint ptr %spare to i32
  call void @__asan_load4_noabort(i32 %29)
  %30 = load ptr, ptr %spare, align 4
  br i1 %phi.cmp, label %unlock, label %if.end27

if.end27:                                         ; preds = %for.end
  %tobool28.not = icmp eq i32 %size.1, 0
  br i1 %tobool28.not, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.end27
  tail call void @kfree(ptr noundef %30) #23
  br label %swap_buffers

if.end30:                                         ; preds = %if.end27
  %size31 = getelementptr inbounds %struct.mem_cgroup_threshold_ary, ptr %30, i32 0, i32 1
  %31 = ptrtoint ptr %size31 to i32
  call void @__asan_store4_noabort(i32 %31)
  store i32 %size.1, ptr %size31, align 4
  %32 = ptrtoint ptr %30 to i32
  call void @__asan_store4_noabort(i32 %32)
  store i32 -1, ptr %30, align 4
  %33 = ptrtoint ptr %thresholds.0 to i32
  call void @__asan_load4_noabort(i32 %33)
  %34 = load ptr, ptr %thresholds.0, align 4
  %size34163 = getelementptr inbounds %struct.mem_cgroup_threshold_ary, ptr %34, i32 0, i32 1
  %35 = ptrtoint ptr %size34163 to i32
  call void @__asan_load4_noabort(i32 %35)
  %36 = load i32, ptr %size34163, align 4
  %cmp35164.not = icmp eq i32 %36, 0
  br i1 %cmp35164.not, label %swap_buffers, label %for.body36

for.body36:                                       ; preds = %for.inc57, %if.end30
  %37 = phi ptr [ %48, %for.inc57 ], [ %34, %if.end30 ]
  %j.0166 = phi i32 [ %j.1, %for.inc57 ], [ 0, %if.end30 ]
  %i.1165 = phi i32 [ %inc58, %for.inc57 ], [ 0, %if.end30 ]
  %arrayidx39 = getelementptr %struct.mem_cgroup_threshold_ary, ptr %37, i32 0, i32 2, i32 %i.1165
  %38 = ptrtoint ptr %arrayidx39 to i32
  call void @__asan_load4_noabort(i32 %38)
  %39 = load ptr, ptr %arrayidx39, align 4
  %cmp41 = icmp eq ptr %39, %eventfd
  br i1 %cmp41, label %for.inc57, label %if.end43

if.end43:                                         ; preds = %for.body36
  %arrayidx45 = getelementptr %struct.mem_cgroup_threshold_ary, ptr %30, i32 0, i32 2, i32 %j.0166
  %40 = ptrtoint ptr %arrayidx39 to i32
  call void @__asan_loadN_noabort(i32 %40, i32 8)
  %41 = load i64, ptr %arrayidx39, align 4
  %42 = ptrtoint ptr %arrayidx45 to i32
  call void @__asan_storeN_noabort(i32 %42, i32 8)
  store i64 %41, ptr %arrayidx45, align 4
  %threshold = getelementptr %struct.mem_cgroup_threshold_ary, ptr %30, i32 0, i32 2, i32 %j.0166, i32 1
  %43 = ptrtoint ptr %threshold to i32
  call void @__asan_load4_noabort(i32 %43)
  %44 = load i32, ptr %threshold, align 4
  %cmp51.not = icmp ugt i32 %44, %usage.0
  br i1 %cmp51.not, label %if.end55, label %if.then52

if.then52:                                        ; preds = %if.end43
  %45 = ptrtoint ptr %30 to i32
  call void @__asan_load4_noabort(i32 %45)
  %46 = load i32, ptr %30, align 4
  %inc54 = add i32 %46, 1
  store i32 %inc54, ptr %30, align 4
  br label %if.end55

if.end55:                                         ; preds = %if.then52, %if.end43
  %inc56 = add i32 %j.0166, 1
  br label %for.inc57

for.inc57:                                        ; preds = %if.end55, %for.body36
  %j.1 = phi i32 [ %j.0166, %for.body36 ], [ %inc56, %if.end55 ]
  %inc58 = add nuw i32 %i.1165, 1
  %47 = ptrtoint ptr %thresholds.0 to i32
  call void @__asan_load4_noabort(i32 %47)
  %48 = load ptr, ptr %thresholds.0, align 4
  %size34 = getelementptr inbounds %struct.mem_cgroup_threshold_ary, ptr %48, i32 0, i32 1
  %49 = ptrtoint ptr %size34 to i32
  call void @__asan_load4_noabort(i32 %49)
  %50 = load i32, ptr %size34, align 4
  %cmp35 = icmp ult i32 %inc58, %50
  br i1 %cmp35, label %for.body36, label %swap_buffers

swap_buffers:                                     ; preds = %for.inc57, %if.end30, %if.then29
  %new.0 = phi ptr [ null, %if.then29 ], [ %30, %if.end30 ], [ %30, %for.inc57 ]
  %51 = ptrtoint ptr %thresholds.0 to i32
  call void @__asan_load4_noabort(i32 %51)
  %52 = load ptr, ptr %thresholds.0, align 4
  %53 = ptrtoint ptr %spare to i32
  call void @__asan_store4_noabort(i32 %53)
  store ptr %52, ptr %spare, align 4
  tail call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !579
  %54 = ptrtoint ptr %thresholds.0 to i32
  call void @__asan_store4_noabort(i32 %54)
  store volatile ptr %new.0, ptr %thresholds.0, align 4
  tail call void @synchronize_rcu() #23
  %tobool101.not = icmp eq ptr %new.0, null
  br i1 %tobool101.not, label %if.then102, label %unlock

if.then102:                                       ; preds = %swap_buffers
  %55 = ptrtoint ptr %spare to i32
  call void @__asan_load4_noabort(i32 %55)
  %56 = load ptr, ptr %spare, align 4
  tail call void @kfree(ptr noundef %56) #23
  %57 = ptrtoint ptr %spare to i32
  call void @__asan_store4_noabort(i32 %57)
  store ptr null, ptr %spare, align 4
  br label %unlock

unlock:                                           ; preds = %if.then102, %swap_buffers, %for.end, %if.end11, %if.end9
  tail call void @mutex_unlock(ptr noundef %thresholds_lock) #23
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local void @fput(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @mem_cgroup_threshold(ptr noundef %memcg) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %tobool.not5 = icmp eq ptr %memcg, null
  br i1 %tobool.not5, label %while.end, label %while.body

while.body:                                       ; preds = %if.end, %entry
  %memcg.addr.06 = phi ptr [ %add.ptr.i, %if.end ], [ %memcg, %entry ]
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06, i1 noundef zeroext false)
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@mem_cgroup_threshold, %land.rhs.i)) #23
          to label %if.end [label %land.rhs.i], !srcloc !461

land.rhs.i:                                       ; preds = %while.body
  %0 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i = icmp eq i8 %0, 0
  br i1 %tobool4.not.i, label %if.then, label %if.end

if.then:                                          ; preds = %land.rhs.i
  tail call fastcc void @__mem_cgroup_threshold(ptr noundef nonnull %memcg.addr.06, i1 noundef zeroext true)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.rhs.i, %while.body
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.06, i32 0, i32 2, i32 13
  %1 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load ptr, ptr %parent.i, align 4
  %tobool.not.i = icmp eq ptr %2, null
  %add.ptr.i = getelementptr i8, ptr %2, i32 -176
  %tobool.not7 = icmp eq ptr %add.ptr.i, null
  %tobool.not = or i1 %tobool.not.i, %tobool.not7
  br i1 %tobool.not, label %while.end, label %while.body

while.end:                                        ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal fastcc void @mem_cgroup_update_tree(ptr noundef %memcg, i32 noundef %nid) unnamed_addr #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %arrayidx = getelementptr [1 x ptr], ptr @soft_limit_tree, i32 0, i32 %nid
  %0 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %arrayidx, align 4
  %tobool.not = icmp eq ptr %1, null
  %tobool1.not39 = icmp eq ptr %memcg, null
  %or.cond = or i1 %tobool.not, %tobool1.not39
  br i1 %or.cond, label %cleanup, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %lock = getelementptr inbounds %struct.mem_cgroup_tree_per_node, ptr %1, i32 0, i32 2
  %rb_rightmost.i = getelementptr inbounds %struct.mem_cgroup_tree_per_node, ptr %1, i32 0, i32 1
  br label %for.body

for.body:                                         ; preds = %for.inc, %for.body.lr.ph
  %memcg.addr.040 = phi ptr [ %memcg, %for.body.lr.ph ], [ %add.ptr.i, %for.inc ]
  %arrayidx2 = getelementptr %struct.mem_cgroup, ptr %memcg.addr.040, i32 0, i32 45, i32 %nid
  %2 = ptrtoint ptr %arrayidx2 to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load ptr, ptr %arrayidx2, align 4
  %memory.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.040, i32 0, i32 2
  %call.i.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %memory.i, i32 noundef 4) #23
  %4 = ptrtoint ptr %memory.i to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %memory.i, align 4
  %soft_limit1.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.040, i32 0, i32 7
  %6 = ptrtoint ptr %soft_limit1.i to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %soft_limit1.i, align 4
  %8 = tail call i32 @llvm.usub.sat.i32(i32 %5, i32 %7) #23
  %tobool3.not.not = icmp ugt i32 %5, %7
  br i1 %tobool3.not.not, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %on_tree = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %3, i32 0, i32 8
  %9 = ptrtoint ptr %on_tree to i32
  call void @__asan_load1_noabort(i32 %9)
  %10 = load i8, ptr %on_tree, align 4, !range !488
  %tobool4.not = icmp eq i8 %10, 0
  br i1 %tobool4.not, label %for.inc, label %if.then5

if.then5:                                         ; preds = %lor.lhs.false, %for.body
  %call8 = tail call i32 @_raw_spin_lock_irqsave(ptr noundef %lock) #23
  %on_tree11 = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %3, i32 0, i32 8
  %11 = ptrtoint ptr %on_tree11 to i32
  call void @__asan_load1_noabort(i32 %11)
  %12 = load i8, ptr %on_tree11, align 4, !range !488
  %tobool12.not = icmp eq i8 %12, 0
  br i1 %tobool12.not, label %if.end.i34, label %if.end.i

if.end.i:                                         ; preds = %if.then5
  %tree_node.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %3, i32 0, i32 6
  %13 = ptrtoint ptr %rb_rightmost.i to i32
  call void @__asan_load4_noabort(i32 %13)
  %14 = load ptr, ptr %rb_rightmost.i, align 4
  %cmp.i = icmp eq ptr %tree_node.i, %14
  br i1 %cmp.i, label %if.then1.i, label %__mem_cgroup_remove_exceeded.exit

if.then1.i:                                       ; preds = %if.end.i
  %call.i = tail call ptr @rb_prev(ptr noundef %tree_node.i) #23
  %15 = ptrtoint ptr %rb_rightmost.i to i32
  call void @__asan_store4_noabort(i32 %15)
  store ptr %call.i, ptr %rb_rightmost.i, align 4
  br label %__mem_cgroup_remove_exceeded.exit

__mem_cgroup_remove_exceeded.exit:                ; preds = %if.then1.i, %if.end.i
  tail call void @rb_erase(ptr noundef %tree_node.i, ptr noundef nonnull %1) #23
  %16 = ptrtoint ptr %on_tree11 to i32
  call void @__asan_store1_noabort(i32 %16)
  store i8 0, ptr %on_tree11, align 4
  br label %if.end.i34

if.end.i34:                                       ; preds = %__mem_cgroup_remove_exceeded.exit, %if.then5
  %usage_in_excess.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %3, i32 0, i32 7
  %17 = ptrtoint ptr %usage_in_excess.i to i32
  call void @__asan_store4_noabort(i32 %17)
  store i32 %8, ptr %usage_in_excess.i, align 4
  br i1 %tobool3.not.not, label %while.cond.preheader.i, label %__mem_cgroup_insert_exceeded.exit

while.cond.preheader.i:                           ; preds = %if.end.i34
  %18 = ptrtoint ptr %1 to i32
  call void @__asan_load4_noabort(i32 %18)
  %19 = load ptr, ptr %1, align 4
  %tobool5.not35.i = icmp eq ptr %19, null
  br i1 %tobool5.not35.i, label %if.then11.i, label %while.body.i

while.body.i:                                     ; preds = %while.body.i, %while.cond.preheader.i
  %20 = phi ptr [ %24, %while.body.i ], [ %19, %while.cond.preheader.i ]
  %rightmost.0.off036.i = phi i1 [ %rightmost.1.off0.i, %while.body.i ], [ true, %while.cond.preheader.i ]
  %usage_in_excess7.i = getelementptr i8, ptr %20, i32 12
  %21 = ptrtoint ptr %usage_in_excess7.i to i32
  call void @__asan_load4_noabort(i32 %21)
  %22 = load i32, ptr %usage_in_excess7.i, align 4
  %cmp.i35 = icmp ugt i32 %22, %8
  %rb_left.i = getelementptr inbounds %struct.rb_node, ptr %20, i32 0, i32 2
  %rb_right.i = getelementptr inbounds %struct.rb_node, ptr %20, i32 0, i32 1
  %not.cmp.i = xor i1 %cmp.i35, true
  %rightmost.1.off0.i = select i1 %not.cmp.i, i1 %rightmost.0.off036.i, i1 false
  %p.1.i = select i1 %cmp.i35, ptr %rb_left.i, ptr %rb_right.i
  %23 = ptrtoint ptr %p.1.i to i32
  call void @__asan_load4_noabort(i32 %23)
  %24 = load ptr, ptr %p.1.i, align 4
  %tobool5.not.i = icmp eq ptr %24, null
  br i1 %tobool5.not.i, label %while.end.i, label %while.body.i

while.end.i:                                      ; preds = %while.body.i
  %phi.cast.le.i = ptrtoint ptr %20 to i32
  br i1 %rightmost.1.off0.i, label %if.then11.i, label %if.end12.i

if.then11.i:                                      ; preds = %while.end.i, %while.cond.preheader.i
  %p.0.lcssa45.i = phi ptr [ %p.1.i, %while.end.i ], [ %1, %while.cond.preheader.i ]
  %parent.0.lcssa43.i = phi i32 [ %phi.cast.le.i, %while.end.i ], [ 0, %while.cond.preheader.i ]
  %tree_node.i36 = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %3, i32 0, i32 6
  %25 = ptrtoint ptr %rb_rightmost.i to i32
  call void @__asan_store4_noabort(i32 %25)
  store ptr %tree_node.i36, ptr %rb_rightmost.i, align 4
  br label %if.end12.i

if.end12.i:                                       ; preds = %if.then11.i, %while.end.i
  %p.0.lcssa44.i = phi ptr [ %p.0.lcssa45.i, %if.then11.i ], [ %p.1.i, %while.end.i ]
  %parent.0.lcssa42.i = phi i32 [ %parent.0.lcssa43.i, %if.then11.i ], [ %phi.cast.le.i, %while.end.i ]
  %tree_node13.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %3, i32 0, i32 6
  %26 = ptrtoint ptr %tree_node13.i to i32
  call void @__asan_store4_noabort(i32 %26)
  store i32 %parent.0.lcssa42.i, ptr %tree_node13.i, align 4
  %rb_right.i.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %3, i32 0, i32 6, i32 1
  %27 = ptrtoint ptr %rb_right.i.i to i32
  call void @__asan_store4_noabort(i32 %27)
  store ptr null, ptr %rb_right.i.i, align 4
  %rb_left.i.i = getelementptr inbounds %struct.mem_cgroup_per_node, ptr %3, i32 0, i32 6, i32 2
  %28 = ptrtoint ptr %rb_left.i.i to i32
  call void @__asan_store4_noabort(i32 %28)
  store ptr null, ptr %rb_left.i.i, align 4
  %29 = ptrtoint ptr %p.0.lcssa44.i to i32
  call void @__asan_store4_noabort(i32 %29)
  store ptr %tree_node13.i, ptr %p.0.lcssa44.i, align 4
  tail call void @rb_insert_color(ptr noundef %tree_node13.i, ptr noundef nonnull %1) #23
  %30 = ptrtoint ptr %on_tree11 to i32
  call void @__asan_store1_noabort(i32 %30)
  store i8 1, ptr %on_tree11, align 4
  br label %__mem_cgroup_insert_exceeded.exit

__mem_cgroup_insert_exceeded.exit:                ; preds = %if.end12.i, %if.end.i34
  tail call void @_raw_spin_unlock_irqrestore(ptr noundef %lock, i32 noundef %call8) #23
  br label %for.inc

for.inc:                                          ; preds = %__mem_cgroup_insert_exceeded.exit, %lor.lhs.false
  %parent.i = getelementptr inbounds %struct.mem_cgroup, ptr %memcg.addr.040, i32 0, i32 2, i32 13
  %31 = ptrtoint ptr %parent.i to i32
  call void @__asan_load4_noabort(i32 %31)
  %32 = load ptr, ptr %parent.i, align 4
  %tobool.not.i38 = icmp eq ptr %32, null
  %add.ptr.i = getelementptr i8, ptr %32, i32 -176
  %tobool1.not41 = icmp eq ptr %add.ptr.i, null
  %tobool1.not = or i1 %tobool.not.i38, %tobool1.not41
  br i1 %tobool1.not, label %cleanup, label %for.body

cleanup:                                          ; preds = %for.inc, %entry
  ret void
}

; Function Attrs: null_pointer_is_valid
declare dso_local ptr @strsep(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @memcg_hotplug_cpu_dead(i32 noundef %cpu) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %arrayidx = getelementptr [4 x i32], ptr @__per_cpu_offset, i32 0, i32 %cpu
  %0 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load i32, ptr %arrayidx, align 4
  %add = add i32 %1, ptrtoint (ptr @memcg_stock to i32)
  %2 = inttoptr i32 %add to ptr
  %3 = ptrtoint ptr %2 to i32
  call void @__asan_load4_noabort(i32 %3)
  %4 = load ptr, ptr %2, align 4
  %tobool.not.i = icmp eq ptr %4, null
  br i1 %tobool.not.i, label %drain_stock.exit, label %if.end.i

if.end.i:                                         ; preds = %entry
  %nr_pages.i = getelementptr inbounds %struct.memcg_stock_pcp, ptr %2, i32 0, i32 1
  %5 = ptrtoint ptr %nr_pages.i to i32
  call void @__asan_load4_noabort(i32 %5)
  %6 = load i32, ptr %nr_pages.i, align 4
  %tobool1.not.i = icmp eq i32 %6, 0
  br i1 %tobool1.not.i, label %if.end8.i, label %if.then2.i

if.then2.i:                                       ; preds = %if.end.i
  %memory.i = getelementptr inbounds %struct.mem_cgroup, ptr %4, i32 0, i32 2
  tail call void @page_counter_uncharge(ptr noundef %memory.i, i32 noundef %6) #23
  callbr void asm sideeffect "1:\0A\09nop\0A\09.pushsection __jump_table,  \22aw\22\0A\09.word 1b, ${1:l}, ${0:c}\0A\09.popsection\0A\09", "i,i"(ptr getelementptr inbounds (i8, ptr @memory_cgrp_subsys_on_dfl_key, i32 1), ptr blockaddress(@memcg_hotplug_cpu_dead, %land.rhs.i.i)) #23
          to label %if.end6.i [label %land.rhs.i.i], !srcloc !461

land.rhs.i.i:                                     ; preds = %if.then2.i
  %7 = load i8, ptr @cgroup_memory_noswap, align 1, !range !488
  %tobool4.not.i.i = icmp eq i8 %7, 0
  br i1 %tobool4.not.i.i, label %if.then4.i, label %if.end6.i

if.then4.i:                                       ; preds = %land.rhs.i.i
  %8 = getelementptr inbounds %struct.mem_cgroup, ptr %4, i32 0, i32 3
  %9 = ptrtoint ptr %nr_pages.i to i32
  call void @__asan_load4_noabort(i32 %9)
  %10 = load i32, ptr %nr_pages.i, align 4
  tail call void @page_counter_uncharge(ptr noundef %8, i32 noundef %10) #23
  br label %if.end6.i

if.end6.i:                                        ; preds = %if.then4.i, %land.rhs.i.i, %if.then2.i
  %11 = ptrtoint ptr %nr_pages.i to i32
  call void @__asan_store4_noabort(i32 %11)
  store i32 0, ptr %nr_pages.i, align 4
  br label %if.end8.i

if.end8.i:                                        ; preds = %if.end6.i, %if.end.i
  %flags.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %4, i32 0, i32 7
  %12 = ptrtoint ptr %flags.i.i to i32
  call void @__asan_load4_noabort(i32 %12)
  %13 = load i32, ptr %flags.i.i, align 4
  %and.i.i = and i32 %13, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.then.i.i, label %css_put.exit.i

if.then.i.i:                                      ; preds = %if.end8.i
  %refcnt.i.i = getelementptr inbounds %struct.cgroup_subsys_state, ptr %4, i32 0, i32 2
  tail call fastcc void @percpu_ref_put(ptr noundef %refcnt.i.i) #23
  br label %css_put.exit.i

css_put.exit.i:                                   ; preds = %if.then.i.i, %if.end8.i
  %14 = ptrtoint ptr %2 to i32
  call void @__asan_store4_noabort(i32 %14)
  store ptr null, ptr %2, align 4
  br label %drain_stock.exit

drain_stock.exit:                                 ; preds = %css_put.exit.i, %entry
  ret i32 0
}

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @__cpuhp_setup_state(i32 noundef, ptr noundef, i1 noundef zeroext, ptr noundef, ptr noundef, i1 noundef zeroext) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @refcount_warn_saturate(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local void @cgroup_file_notify(ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @cgroup_add_dfl_cftypes(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: null_pointer_is_valid
declare dso_local i32 @cgroup_add_legacy_cftypes(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i64 @swap_current_read(ptr noundef %css, ptr nocapture noundef readnone %cft) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %0 = getelementptr inbounds %struct.mem_cgroup, ptr %css, i32 0, i32 3
  %call.i.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %0, i32 noundef 4) #23
  %1 = ptrtoint ptr %0 to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load volatile i32, ptr %0, align 4
  %conv = zext i32 %2 to i64
  %mul = shl nuw nsw i64 %conv, 12
  ret i64 %mul
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @swap_high_show(ptr noundef %m, ptr nocapture noundef readnone %v) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %private.i.i = getelementptr inbounds %struct.seq_file, ptr %m, i32 0, i32 11
  %0 = ptrtoint ptr %private.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private.i.i, align 8
  %call.i.i = tail call ptr @of_css(ptr noundef %1) #23
  %high = getelementptr inbounds %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 3, i32 0, i32 3
  %2 = ptrtoint ptr %high to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %high, align 4
  %cmp.i = icmp eq i32 %3, 2147483647
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  tail call void @seq_puts(ptr noundef %m, ptr noundef nonnull @.str.124) #23
  br label %seq_puts_memcg_tunable.exit

if.else.i:                                        ; preds = %entry
  %conv.i = zext i32 %3 to i64
  %mul.i = shl nuw nsw i64 %conv.i, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.125, i64 noundef %mul.i) #23
  br label %seq_puts_memcg_tunable.exit

seq_puts_memcg_tunable.exit:                      ; preds = %if.else.i, %if.then.i
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @swap_high_write(ptr noundef %of, ptr noundef %buf, i32 noundef %nbytes, i64 noundef %off) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %high = alloca i32, align 4
  %call = tail call ptr @of_css(ptr noundef %of) #23
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %high) #23
  %0 = ptrtoint ptr %high to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %high, align 4, !annotation !492
  %call.i = tail call ptr @strim(ptr noundef %buf) #23
  %call3 = call i32 @page_counter_memparse(ptr noundef %call.i, ptr noundef nonnull @.str.126, ptr noundef nonnull %high) #23
  %tobool.not = icmp eq i32 %call3, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %1 = ptrtoint ptr %high to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %high, align 4
  %high.i = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 3, i32 0, i32 3
  %3 = ptrtoint ptr %high.i to i32
  call void @__asan_store4_noabort(i32 %3)
  store volatile i32 %2, ptr %high.i, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %nbytes, %if.end ], [ %call3, %entry ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %high) #23
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @swap_max_show(ptr noundef %m, ptr nocapture noundef readnone %v) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %private.i.i = getelementptr inbounds %struct.seq_file, ptr %m, i32 0, i32 11
  %0 = ptrtoint ptr %private.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private.i.i, align 8
  %call.i.i = tail call ptr @of_css(ptr noundef %1) #23
  %max = getelementptr inbounds %struct.mem_cgroup, ptr %call.i.i, i32 0, i32 3, i32 0, i32 4
  %2 = ptrtoint ptr %max to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %max, align 8
  %cmp.i = icmp eq i32 %3, 2147483647
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  tail call void @seq_puts(ptr noundef %m, ptr noundef nonnull @.str.124) #23
  br label %seq_puts_memcg_tunable.exit

if.else.i:                                        ; preds = %entry
  %conv.i = zext i32 %3 to i64
  %mul.i = shl nuw nsw i64 %conv.i, 12
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.125, i64 noundef %mul.i) #23
  br label %seq_puts_memcg_tunable.exit

seq_puts_memcg_tunable.exit:                      ; preds = %if.else.i, %if.then.i
  ret i32 0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @swap_max_write(ptr noundef %of, ptr noundef %buf, i32 noundef %nbytes, i64 noundef %off) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %max = alloca i32, align 4
  %call = tail call ptr @of_css(ptr noundef %of) #23
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %max) #23
  %0 = ptrtoint ptr %max to i32
  call void @__asan_store4_noabort(i32 %0)
  store i32 -1, ptr %max, align 4, !annotation !492
  %call.i25 = tail call ptr @strim(ptr noundef %buf) #23
  %call3 = call i32 @page_counter_memparse(ptr noundef %call.i25, ptr noundef nonnull @.str.126, ptr noundef nonnull %max) #23
  %tobool.not = icmp eq i32 %call3, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %max4 = getelementptr inbounds %struct.mem_cgroup, ptr %call, i32 0, i32 3, i32 0, i32 4
  %call.i = call zeroext i1 @__kasan_check_write(ptr noundef %max4, i32 noundef 4) #23
  call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !580
  %1 = ptrtoint ptr %max to i32
  call void @__asan_load4_noabort(i32 %1)
  %2 = load i32, ptr %max, align 4
  call void @llvm.prefetch.p0(ptr %max4, i32 1, i32 3, i32 1) #23
  %3 = call { i32, i32 } asm sideeffect "@\09__xchg4\0A1:\09ldrex\09$0, [$3]\0A\09strex\09$1, $2, [$3]\0A\09teq\09$1, #0\0A\09bne\091b", "=&r,=&r,r,r,~{memory},~{cc}"(i32 %2, ptr %max4) #23, !srcloc !497
  call void asm sideeffect "mcr p15, 0, $0, c7, c10, 5", "r,~{memory}"(i32 0) #23, !srcloc !581
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %nbytes, %if.end ], [ %call3, %entry ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %max) #23
  ret i32 %retval.0
}

; Function Attrs: nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync)
define internal i32 @swap_events_show(ptr noundef %m, ptr nocapture noundef readnone %v) #3 align 64 {
entry:
  call void @llvm.arm.gnu.eabi.mcount()
  %private.i.i = getelementptr inbounds %struct.seq_file, ptr %m, i32 0, i32 11
  %0 = ptrtoint ptr %private.i.i to i32
  call void @__asan_load4_noabort(i32 %0)
  %1 = load ptr, ptr %private.i.i, align 8
  %call.i.i15 = tail call ptr @of_css(ptr noundef %1) #23
  %arrayidx = getelementptr %struct.mem_cgroup, ptr %call.i.i15, i32 0, i32 27, i32 6
  %call.i.i = tail call zeroext i1 @__kasan_check_read(ptr noundef %arrayidx, i32 noundef 4) #23
  %2 = ptrtoint ptr %arrayidx to i32
  call void @__asan_load4_noabort(i32 %2)
  %3 = load volatile i32, ptr %arrayidx, align 4
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.128, i32 noundef %3) #23
  %arrayidx3 = getelementptr %struct.mem_cgroup, ptr %call.i.i15, i32 0, i32 27, i32 7
  %call.i.i13 = tail call zeroext i1 @__kasan_check_read(ptr noundef %arrayidx3, i32 noundef 4) #23
  %4 = ptrtoint ptr %arrayidx3 to i32
  call void @__asan_load4_noabort(i32 %4)
  %5 = load volatile i32, ptr %arrayidx3, align 4
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.129, i32 noundef %5) #23
  %arrayidx6 = getelementptr %struct.mem_cgroup, ptr %call.i.i15, i32 0, i32 27, i32 8
  %call.i.i14 = tail call zeroext i1 @__kasan_check_read(ptr noundef %arrayidx6, i32 noundef 4) #23
  %6 = ptrtoint ptr %arrayidx6 to i32
  call void @__asan_load4_noabort(i32 %6)
  %7 = load volatile i32, ptr %arrayidx6, align 4
  tail call void (ptr, ptr, ...) @seq_printf(ptr noundef %m, ptr noundef nonnull @.str.173, i32 noundef %7) #23
  ret i32 0
}

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.smin.i32(i32, i32) #16

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.smax.i32(i32, i32) #16

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.abs.i32(i32, i1 immarg) #16

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.umin.i32(i32, i32) #16

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.usub.sat.i32(i32, i32) #16

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.umax.i32(i32, i32) #16

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i64 @llvm.umax.i64(i64, i64) #16

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.uadd.sat.i32(i32, i32) #16

; Function Attrs: nounwind
declare void @llvm.arm.gnu.eabi.mcount() #23

declare void @__asan_loadN_noabort(i32, i32)

declare void @__asan_load1_noabort(i32)

declare void @__asan_load2_noabort(i32)

declare void @__asan_load4_noabort(i32)

declare void @__asan_load8_noabort(i32)

declare void @__asan_storeN_noabort(i32, i32)

declare void @__asan_store1_noabort(i32)

declare void @__asan_store4_noabort(i32)

declare void @__asan_store8_noabort(i32)

declare ptr @memcpy(ptr, ptr, i32)

declare ptr @memset(ptr, i32, i32)

declare void @__asan_register_globals(i32, i32)

declare void @__asan_unregister_globals(i32, i32)

; Function Attrs: nounwind uwtable(sync)
define internal void @asan.module_ctor() #24 {
  call void @__asan_register_globals(i32 ptrtoint (ptr @0 to i32), i32 189)
  ret void
}

; Function Attrs: nounwind uwtable(sync)
define internal void @asan.module_dtor() #24 {
  call void @__asan_unregister_globals(i32 ptrtoint (ptr @0 to i32), i32 189)
  ret void
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #1 = { mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readnone sanitize_address sspstrong willreturn uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #2 = { argmemonly nocallback nofree nosync nounwind willreturn }
attributes #3 = { nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #4 = { null_pointer_is_valid "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #5 = { inlinehint nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #6 = { cold null_pointer_is_valid "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #7 = { alwaysinline nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #8 = { noinline nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #9 = { nofree norecurse nounwind null_pointer_is_valid sanitize_address sspstrong uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #10 = { cold nounwind null_pointer_is_valid optsize sanitize_address sspstrong uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #11 = { cold mustprogress nofree nounwind null_pointer_is_valid optsize sanitize_address sspstrong willreturn uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #12 = { nounwind readonly }
attributes #13 = { inaccessiblemem_or_argmemonly nocallback nofree nosync nounwind willreturn }
attributes #14 = { null_pointer_is_valid allocsize(2) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #15 = { null_pointer_is_valid allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #16 = { nocallback nofree nosync nounwind readnone speculatable willreturn }
attributes #17 = { nocallback nofree nosync nounwind readnone willreturn }
attributes #18 = { mustprogress nofree nounwind null_pointer_is_valid readonly willreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #19 = { mustprogress nofree norecurse nosync nounwind null_pointer_is_valid sanitize_address sspstrong willreturn uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #20 = { argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid readonly sanitize_address sspstrong willreturn uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #21 = { argmemonly mustprogress nofree norecurse nosync nounwind null_pointer_is_valid sanitize_address sspstrong willreturn writeonly uwtable(sync) "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" "warn-stack-size"="1024" }
attributes #22 = { argmemonly mustprogress nofree nounwind null_pointer_is_valid readonly willreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="mpcore" "target-features"="+armv6k,+dsp,+soft-float,+strict-align,-aes,-bf16,-d32,-dotprod,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fp64,-fpregs,-fullfp16,-mve,-mve.fp,-neon,-sha2,-thumb-mode,-vfp2,-vfp2sp,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" "use-soft-float"="true" }
attributes #23 = { nounwind }
attributes #24 = { nounwind uwtable(sync) "frame-pointer"="all" }
attributes #25 = { cold nounwind }
attributes #26 = { nounwind allocsize(2) }
attributes #27 = { nounwind allocsize(0) }
attributes #28 = { nobuiltin }
attributes #29 = { nounwind readonly willreturn }

!llvm.asan.globals = !{!0, !2, !4, !6, !8, !10, !12, !14, !16, !17, !18, !20, !22, !24, !26, !27, !28, !30, !31, !32, !33, !35, !36, !37, !39, !40, !41, !43, !44, !45, !46, !48, !49, !50, !52, !53, !54, !56, !57, !58, !60, !61, !62, !64, !65, !66, !68, !69, !70, !72, !73, !74, !75, !77, !78, !79, !81, !83, !85, !87, !89, !91, !93, !95, !96, !98, !100, !102, !104, !106, !108, !110, !111, !113, !115, !117, !119, !121, !123, !125, !126, !127, !129, !131, !133, !135, !137, !138, !140, !141, !143, !144, !145, !147, !148, !149, !151, !152, !154, !156, !157, !159, !161, !163, !164, !166, !168, !170, !172, !173, !174, !176, !178, !180, !182, !184, !186, !188, !190, !192, !194, !196, !198, !200, !202, !204, !206, !208, !210, !212, !214, !216, !218, !220, !222, !224, !226, !228, !230, !232, !234, !236, !238, !240, !242, !243, !245, !246, !248, !250, !252, !254, !256, !258, !259, !260, !262, !264, !266, !268, !270, !272, !274, !275, !276, !278, !279, !281, !282, !284, !285, !287, !288, !290, !291, !293, !294, !296, !297, !299, !300, !302, !303, !305, !307, !308, !310, !312, !313, !314, !316, !318, !320, !322, !324, !326, !328, !330, !332, !334, !336, !338, !340, !342, !344, !346, !348, !350, !352, !354, !355, !356, !358, !360, !362, !364, !366, !368, !370, !372, !374, !376, !378, !380, !382, !384, !386, !387, !388, !389, !390, !392, !393, !395, !397, !399, !401, !403, !405, !407, !409, !411, !412, !414, !416, !418, !419, !421, !423, !425, !427, !429, !430, !432, !433, !435, !437, !439, !440, !442, !444, !446, !448}
!llvm.named.register.sp = !{!450}
!llvm.module.flags = !{!451, !452, !453, !454, !455, !456, !457, !458}
!llvm.ident = !{!459}

!0 = !{ptr @__ksymtab_memory_cgrp_subsys, !1, !"__ksymtab_memory_cgrp_subsys", i1 false, i1 false}
!1 = !{!"../mm/memcontrol.c", i32 75, i32 1}
!2 = !{ptr @__ksymtab_int_active_memcg, !3, !"__ksymtab_int_active_memcg", i1 false, i1 false}
!3 = !{!"../mm/memcontrol.c", i32 81, i32 1}
!4 = !{ptr @memcg_kmem_enabled_key, !5, !"memcg_kmem_enabled_key", i1 false, i1 false}
!5 = !{!"../mm/memcontrol.c", i32 398, i32 1}
!6 = !{ptr @__ksymtab_memcg_kmem_enabled_key, !7, !"__ksymtab_memcg_kmem_enabled_key", i1 false, i1 false}
!7 = !{!"../mm/memcontrol.c", i32 399, i32 1}
!8 = distinct !{null, !9, !"<string literal>", i1 false, i1 false}
!9 = !{!"../mm/memcontrol.c", i32 680, i32 2}
!10 = !{ptr @__ksymtab___mod_lruvec_page_state, !11, !"__ksymtab___mod_lruvec_page_state", i1 false, i1 false}
!11 = !{!"../mm/memcontrol.c", i32 759, i32 1}
!12 = !{ptr @__ksymtab_mem_cgroup_from_task, !13, !"__ksymtab_mem_cgroup_from_task", i1 false, i1 false}
!13 = !{!"../mm/memcontrol.c", i32 886, i32 1}
!14 = distinct !{null, !15, !"__warned", i1 false, i1 false}
!15 = !{!"../mm/memcontrol.c", i32 937, i32 32}
!16 = !{ptr @.str.1, !15, !"<string literal>", i1 false, i1 false}
!17 = !{ptr @.str.2, !15, !"<string literal>", i1 false, i1 false}
!18 = !{ptr @__ksymtab_get_mem_cgroup_from_mm, !19, !"__ksymtab_get_mem_cgroup_from_mm", i1 false, i1 false}
!19 = !{!"../mm/memcontrol.c", i32 944, i32 1}
!20 = !{ptr @.str.3, !21, !"<string literal>", i1 false, i1 false}
!21 = !{!"../mm/memcontrol.c", i32 1176, i32 3}
!22 = !{ptr @.str.4, !23, !"<string literal>", i1 false, i1 false}
!23 = !{!"../mm/memcontrol.c", i32 1178, i32 3}
!24 = distinct !{null, !25, !"__already_done", i1 false, i1 false}
!25 = !{!"../mm/memcontrol.c", i32 1280, i32 6}
!26 = !{ptr @.str.5, !25, !"<string literal>", i1 false, i1 false}
!27 = !{ptr @__func__.mem_cgroup_update_lru_size, !25, !"<string literal>", i1 false, i1 false}
!28 = !{ptr @.str.6, !29, !"<string literal>", i1 false, i1 false}
!29 = !{!"../mm/memcontrol.c", i32 1522, i32 3}
!30 = !{ptr @.str.7, !29, !"<string literal>", i1 false, i1 false}
!31 = !{ptr @mem_cgroup_print_oom_context._entry, !29, !"_entry", i1 false, i1 false}
!32 = !{ptr @mem_cgroup_print_oom_context._entry_ptr, !29, !"_entry_ptr", i1 false, i1 false}
!33 = !{ptr @.str.9, !34, !"<string literal>", i1 false, i1 false}
!34 = !{!"../mm/memcontrol.c", i32 1525, i32 3}
!35 = !{ptr @mem_cgroup_print_oom_context._entry.8, !34, !"_entry", i1 false, i1 false}
!36 = !{ptr @mem_cgroup_print_oom_context._entry_ptr.10, !34, !"_entry_ptr", i1 false, i1 false}
!37 = !{ptr @.str.12, !38, !"<string literal>", i1 false, i1 false}
!38 = !{!"../mm/memcontrol.c", i32 1527, i32 3}
!39 = !{ptr @mem_cgroup_print_oom_context._entry.11, !38, !"_entry", i1 false, i1 false}
!40 = !{ptr @mem_cgroup_print_oom_context._entry_ptr.13, !38, !"_entry_ptr", i1 false, i1 false}
!41 = !{ptr @.str.14, !42, !"<string literal>", i1 false, i1 false}
!42 = !{!"../mm/memcontrol.c", i32 1542, i32 2}
!43 = !{ptr @.str.15, !42, !"<string literal>", i1 false, i1 false}
!44 = !{ptr @mem_cgroup_print_oom_meminfo._entry, !42, !"_entry", i1 false, i1 false}
!45 = !{ptr @mem_cgroup_print_oom_meminfo._entry_ptr, !42, !"_entry_ptr", i1 false, i1 false}
!46 = !{ptr @.str.17, !47, !"<string literal>", i1 false, i1 false}
!47 = !{!"../mm/memcontrol.c", i32 1546, i32 3}
!48 = !{ptr @mem_cgroup_print_oom_meminfo._entry.16, !47, !"_entry", i1 false, i1 false}
!49 = !{ptr @mem_cgroup_print_oom_meminfo._entry_ptr.18, !47, !"_entry_ptr", i1 false, i1 false}
!50 = !{ptr @.str.20, !51, !"<string literal>", i1 false, i1 false}
!51 = !{!"../mm/memcontrol.c", i32 1550, i32 3}
!52 = !{ptr @mem_cgroup_print_oom_meminfo._entry.19, !51, !"_entry", i1 false, i1 false}
!53 = !{ptr @mem_cgroup_print_oom_meminfo._entry_ptr.21, !51, !"_entry_ptr", i1 false, i1 false}
!54 = !{ptr @.str.23, !55, !"<string literal>", i1 false, i1 false}
!55 = !{!"../mm/memcontrol.c", i32 1553, i32 3}
!56 = !{ptr @mem_cgroup_print_oom_meminfo._entry.22, !55, !"_entry", i1 false, i1 false}
!57 = !{ptr @mem_cgroup_print_oom_meminfo._entry_ptr.24, !55, !"_entry_ptr", i1 false, i1 false}
!58 = !{ptr @.str.26, !59, !"<string literal>", i1 false, i1 false}
!59 = !{!"../mm/memcontrol.c", i32 1558, i32 2}
!60 = !{ptr @mem_cgroup_print_oom_meminfo._entry.25, !59, !"_entry", i1 false, i1 false}
!61 = !{ptr @mem_cgroup_print_oom_meminfo._entry_ptr.27, !59, !"_entry_ptr", i1 false, i1 false}
!62 = !{ptr @.str.29, !63, !"<string literal>", i1 false, i1 false}
!63 = !{!"../mm/memcontrol.c", i32 1560, i32 2}
!64 = !{ptr @mem_cgroup_print_oom_meminfo._entry.28, !63, !"_entry", i1 false, i1 false}
!65 = !{ptr @mem_cgroup_print_oom_meminfo._entry_ptr.30, !63, !"_entry_ptr", i1 false, i1 false}
!66 = !{ptr @.str.32, !67, !"<string literal>", i1 false, i1 false}
!67 = !{!"../mm/memcontrol.c", i32 1564, i32 2}
!68 = !{ptr @mem_cgroup_print_oom_meminfo._entry.31, !67, !"_entry", i1 false, i1 false}
!69 = !{ptr @mem_cgroup_print_oom_meminfo._entry_ptr.33, !67, !"_entry_ptr", i1 false, i1 false}
!70 = !{ptr @.str.34, !71, !"<string literal>", i1 false, i1 false}
!71 = !{!"../mm/memcontrol.c", i32 1992, i32 2}
!72 = !{ptr @.str.35, !71, !"<string literal>", i1 false, i1 false}
!73 = !{ptr @mem_cgroup_print_oom_group._entry, !71, !"_entry", i1 false, i1 false}
!74 = !{ptr @mem_cgroup_print_oom_group._entry_ptr, !71, !"_entry_ptr", i1 false, i1 false}
!75 = !{ptr @.str.37, !76, !"<string literal>", i1 false, i1 false}
!76 = !{!"../mm/memcontrol.c", i32 1994, i32 2}
!77 = !{ptr @mem_cgroup_print_oom_group._entry.36, !76, !"_entry", i1 false, i1 false}
!78 = !{ptr @mem_cgroup_print_oom_group._entry_ptr.38, !76, !"_entry_ptr", i1 false, i1 false}
!79 = distinct !{null, !80, !"__warned", i1 false, i1 false}
!80 = !{!"../mm/memcontrol.c", i32 2929, i32 11}
!81 = distinct !{null, !82, !"__already_done", i1 false, i1 false}
!82 = !{!"../mm/memcontrol.c", i32 5063, i32 2}
!83 = !{ptr @memory_cgrp_subsys, !84, !"memory_cgrp_subsys", i1 false, i1 false}
!84 = !{!"../mm/memcontrol.c", i32 6491, i32 22}
!85 = !{ptr @.str.39, !86, !"<string literal>", i1 false, i1 false}
!86 = !{!"../mm/memcontrol.c", i32 6927, i32 2}
!87 = !{ptr @.str.40, !88, !"<string literal>", i1 false, i1 false}
!88 = !{!"../mm/memcontrol.c", i32 6928, i32 2}
!89 = !{ptr @.str.41, !90, !"<string literal>", i1 false, i1 false}
!90 = !{!"../mm/memcontrol.c", i32 6929, i32 2}
!91 = !{ptr @.str.42, !92, !"<string literal>", i1 false, i1 false}
!92 = !{!"../mm/memcontrol.c", i32 6930, i32 2}
!93 = distinct !{null, !94, !"__warned", i1 false, i1 false}
!94 = !{!"../mm/memcontrol.c", i32 6940, i32 2}
!95 = !{ptr @.str.43, !94, !"<string literal>", i1 false, i1 false}
!96 = !{ptr @memcg_sockets_enabled_key, !97, !"memcg_sockets_enabled_key", i1 false, i1 false}
!97 = !{!"../mm/memcontrol.c", i32 6960, i32 1}
!98 = !{ptr @__ksymtab_memcg_sockets_enabled_key, !99, !"__ksymtab_memcg_sockets_enabled_key", i1 false, i1 false}
!99 = !{!"../mm/memcontrol.c", i32 6961, i32 1}
!100 = !{ptr @__setup_cgroup_memory, !101, !"__setup_cgroup_memory", i1 false, i1 false}
!101 = !{!"../mm/memcontrol.c", i32 7058, i32 1}
!102 = !{ptr @__initcall__kmod_memcontrol__736_7101_mem_cgroup_init4, !103, !"__initcall__kmod_memcontrol__736_7101_mem_cgroup_init4", i1 false, i1 false}
!103 = !{!"../mm/memcontrol.c", i32 7101, i32 1}
!104 = !{ptr @.str.44, !105, !"<string literal>", i1 false, i1 false}
!105 = !{!"../mm/memcontrol.c", i32 7135, i32 2}
!106 = !{ptr @.str.45, !107, !"<string literal>", i1 false, i1 false}
!107 = !{!"../mm/memcontrol.c", i32 7136, i32 2}
!108 = distinct !{null, !109, !"__warned", i1 false, i1 false}
!109 = !{!"../mm/memcontrol.c", i32 7146, i32 2}
!110 = !{ptr @.str.46, !109, !"<string literal>", i1 false, i1 false}
!111 = !{ptr @.str.47, !112, !"<string literal>", i1 false, i1 false}
!112 = !{!"../mm/memcontrol.c", i32 7162, i32 2}
!113 = distinct !{null, !114, !"__warned", i1 false, i1 false}
!114 = !{!"../mm/memcontrol.c", i32 7210, i32 2}
!115 = !{ptr @.str.48, !116, !"<string literal>", i1 false, i1 false}
!116 = !{!"../mm/memcontrol.c", i32 7282, i32 2}
!117 = !{ptr @__setup_setup_swap_account, !118, !"__setup_setup_swap_account", i1 false, i1 false}
!118 = !{!"../mm/memcontrol.c", i32 7312, i32 1}
!119 = !{ptr @__initcall__kmod_memcontrol__744_7457_mem_cgroup_swap_init1, !120, !"__initcall__kmod_memcontrol__744_7457_mem_cgroup_swap_init1", i1 false, i1 false}
!120 = !{!"../mm/memcontrol.c", i32 7457, i32 1}
!121 = !{ptr @root_mem_cgroup, !122, !"root_mem_cgroup", i1 false, i1 false}
!122 = !{!"../mm/memcontrol.c", i32 77, i32 20}
!123 = !{ptr @__pcpu_scope_int_active_memcg, !124, !"__pcpu_scope_int_active_memcg", i1 false, i1 false}
!124 = !{!"../mm/memcontrol.c", i32 80, i32 1}
!125 = !{ptr @__pcpu_unique_int_active_memcg, !124, !"__pcpu_unique_int_active_memcg", i1 false, i1 false}
!126 = !{ptr @int_active_memcg, !124, !"int_active_memcg", i1 false, i1 false}
!127 = distinct !{null, !128, !"cgroup_memory_nokmem", i1 false, i1 false}
!128 = !{!"../mm/memcontrol.c", i32 87, i32 13}
!129 = !{ptr @cgroup_memory_noswap, !130, !"cgroup_memory_noswap", i1 false, i1 false}
!130 = !{!"../mm/memcontrol.c", i32 91, i32 6}
!131 = !{ptr @soft_limit_tree, !132, !"soft_limit_tree", i1 false, i1 false}
!132 = !{!"../mm/memcontrol.c", i32 124, i32 31}
!133 = !{ptr @memcg_nr_cache_ids, !134, !"memcg_nr_cache_ids", i1 false, i1 false}
!134 = !{!"../mm/memcontrol.c", i32 362, i32 5}
!135 = !{ptr @__pcpu_unique_stats_updates, !136, !"__pcpu_unique_stats_updates", i1 false, i1 false}
!136 = !{!"../mm/memcontrol.c", i32 629, i32 8}
!137 = !{ptr @stats_updates, !136, !"stats_updates", i1 false, i1 false}
!138 = !{ptr @__pcpu_unique_memcg_stock, !139, !"__pcpu_unique_memcg_stock", i1 false, i1 false}
!139 = !{!"../mm/memcontrol.c", i32 2110, i32 8}
!140 = !{ptr @memcg_stock, !139, !"memcg_stock", i1 false, i1 false}
!141 = !{ptr @.str.49, !142, !"<string literal>", i1 false, i1 false}
!142 = !{!"../mm/memcontrol.c", i32 365, i32 8}
!143 = !{ptr @.str.50, !142, !"<string literal>", i1 false, i1 false}
!144 = !{ptr @memcg_cache_ids_sem, !142, !"memcg_cache_ids_sem", i1 false, i1 false}
!145 = distinct !{null, !146, !"__warned", i1 false, i1 false}
!146 = !{!"../include/linux/rcupdate.h", i32 695, i32 2}
!147 = !{ptr @.str.51, !146, !"<string literal>", i1 false, i1 false}
!148 = !{ptr @.str.52, !146, !"<string literal>", i1 false, i1 false}
!149 = distinct !{null, !150, !"__warned", i1 false, i1 false}
!150 = !{!"../include/linux/rcupdate.h", i32 723, i32 2}
!151 = !{ptr @.str.53, !150, !"<string literal>", i1 false, i1 false}
!152 = !{ptr @stats_flush_threshold, !153, !"stats_flush_threshold", i1 false, i1 false}
!153 = !{!"../mm/memcontrol.c", i32 630, i32 17}
!154 = !{ptr @.str.54, !155, !"<string literal>", i1 false, i1 false}
!155 = !{!"../mm/memcontrol.c", i32 628, i32 8}
!156 = !{ptr @stats_flush_lock, !155, !"stats_flush_lock", i1 false, i1 false}
!157 = distinct !{null, !158, !"<string literal>", i1 false, i1 false}
!158 = !{!"../mm/memcontrol.c", i32 638, i32 6}
!159 = distinct !{null, !160, !"<string literal>", i1 false, i1 false}
!160 = !{!"../mm/memcontrol.c", i32 641, i32 3}
!161 = distinct !{null, !162, !"__warned", i1 false, i1 false}
!162 = !{!"../include/linux/cgroup.h", i32 494, i32 9}
!163 = !{ptr @.str.57, !162, !"<string literal>", i1 false, i1 false}
!164 = !{ptr @.str.58, !165, !"<string literal>", i1 false, i1 false}
!165 = !{!"../include/linux/memcontrol.h", i32 396, i32 2}
!166 = distinct !{null, !167, !"<string literal>", i1 false, i1 false}
!167 = !{!"../include/linux/memcontrol.h", i32 397, i32 2}
!168 = distinct !{null, !169, !"<string literal>", i1 false, i1 false}
!169 = !{!"../include/linux/memcontrol.h", i32 398, i32 2}
!170 = distinct !{null, !171, !"__warned", i1 false, i1 false}
!171 = !{!"../include/linux/memcontrol.h", i32 746, i32 2}
!172 = !{ptr @.str.61, !171, !"<string literal>", i1 false, i1 false}
!173 = !{ptr @.str.62, !171, !"<string literal>", i1 false, i1 false}
!174 = !{ptr @.str.63, !175, !"<string literal>", i1 false, i1 false}
!175 = !{!"../mm/memcontrol.c", i32 1462, i32 22}
!176 = !{ptr @.str.64, !177, !"<string literal>", i1 false, i1 false}
!177 = !{!"../mm/memcontrol.c", i32 1467, i32 23}
!178 = !{ptr @.str.65, !179, !"<string literal>", i1 false, i1 false}
!179 = !{!"../mm/memcontrol.c", i32 1473, i32 21}
!180 = !{ptr @.str.66, !181, !"<string literal>", i1 false, i1 false}
!181 = !{!"../mm/memcontrol.c", i32 1479, i32 21}
!182 = !{ptr @.str.67, !183, !"<string literal>", i1 false, i1 false}
!183 = !{!"../mm/memcontrol.c", i32 1482, i32 21}
!184 = distinct !{null, !185, !"__already_done", i1 false, i1 false}
!185 = !{!"../mm/memcontrol.c", i32 1502, i32 2}
!186 = !{ptr @.str.68, !187, !"<string literal>", i1 false, i1 false}
!187 = !{!"../mm/memcontrol.c", i32 1372, i32 4}
!188 = !{ptr @.str.69, !189, !"<string literal>", i1 false, i1 false}
!189 = !{!"../mm/memcontrol.c", i32 1373, i32 4}
!190 = !{ptr @.str.70, !191, !"<string literal>", i1 false, i1 false}
!191 = !{!"../mm/memcontrol.c", i32 1374, i32 4}
!192 = !{ptr @.str.71, !193, !"<string literal>", i1 false, i1 false}
!193 = !{!"../mm/memcontrol.c", i32 1375, i32 4}
!194 = !{ptr @.str.72, !195, !"<string literal>", i1 false, i1 false}
!195 = !{!"../mm/memcontrol.c", i32 1376, i32 4}
!196 = !{ptr @.str.73, !197, !"<string literal>", i1 false, i1 false}
!197 = !{!"../mm/memcontrol.c", i32 1377, i32 4}
!198 = !{ptr @.str.74, !199, !"<string literal>", i1 false, i1 false}
!199 = !{!"../mm/memcontrol.c", i32 1378, i32 4}
!200 = !{ptr @.str.75, !201, !"<string literal>", i1 false, i1 false}
!201 = !{!"../mm/memcontrol.c", i32 1379, i32 4}
!202 = !{ptr @.str.76, !203, !"<string literal>", i1 false, i1 false}
!203 = !{!"../mm/memcontrol.c", i32 1380, i32 4}
!204 = !{ptr @.str.77, !205, !"<string literal>", i1 false, i1 false}
!205 = !{!"../mm/memcontrol.c", i32 1381, i32 4}
!206 = !{ptr @.str.78, !207, !"<string literal>", i1 false, i1 false}
!207 = !{!"../mm/memcontrol.c", i32 1382, i32 4}
!208 = !{ptr @.str.79, !209, !"<string literal>", i1 false, i1 false}
!209 = !{!"../mm/memcontrol.c", i32 1384, i32 4}
!210 = !{ptr @.str.80, !211, !"<string literal>", i1 false, i1 false}
!211 = !{!"../mm/memcontrol.c", i32 1391, i32 4}
!212 = !{ptr @.str.81, !213, !"<string literal>", i1 false, i1 false}
!213 = !{!"../mm/memcontrol.c", i32 1392, i32 4}
!214 = !{ptr @.str.82, !215, !"<string literal>", i1 false, i1 false}
!215 = !{!"../mm/memcontrol.c", i32 1393, i32 4}
!216 = !{ptr @.str.83, !217, !"<string literal>", i1 false, i1 false}
!217 = !{!"../mm/memcontrol.c", i32 1394, i32 4}
!218 = !{ptr @.str.84, !219, !"<string literal>", i1 false, i1 false}
!219 = !{!"../mm/memcontrol.c", i32 1395, i32 4}
!220 = !{ptr @.str.85, !221, !"<string literal>", i1 false, i1 false}
!221 = !{!"../mm/memcontrol.c", i32 1396, i32 4}
!222 = !{ptr @.str.86, !223, !"<string literal>", i1 false, i1 false}
!223 = !{!"../mm/memcontrol.c", i32 1397, i32 4}
!224 = !{ptr @.str.87, !225, !"<string literal>", i1 false, i1 false}
!225 = !{!"../mm/memcontrol.c", i32 1400, i32 4}
!226 = !{ptr @.str.88, !227, !"<string literal>", i1 false, i1 false}
!227 = !{!"../mm/memcontrol.c", i32 1401, i32 4}
!228 = !{ptr @.str.89, !229, !"<string literal>", i1 false, i1 false}
!229 = !{!"../mm/memcontrol.c", i32 1402, i32 4}
!230 = !{ptr @.str.90, !231, !"<string literal>", i1 false, i1 false}
!231 = !{!"../mm/memcontrol.c", i32 1403, i32 4}
!232 = !{ptr @.str.91, !233, !"<string literal>", i1 false, i1 false}
!233 = !{!"../mm/memcontrol.c", i32 1404, i32 4}
!234 = !{ptr @.str.92, !235, !"<string literal>", i1 false, i1 false}
!235 = !{!"../mm/memcontrol.c", i32 1405, i32 4}
!236 = !{ptr @.str.93, !237, !"<string literal>", i1 false, i1 false}
!237 = !{!"../mm/memcontrol.c", i32 1406, i32 4}
!238 = !{ptr @memory_stats, !239, !"memory_stats", i1 false, i1 false}
!239 = !{!"../mm/memcontrol.c", i32 1371, i32 33}
!240 = !{ptr @.str.94, !241, !"<string literal>", i1 false, i1 false}
!241 = !{!"../mm/memcontrol.c", i32 1761, i32 8}
!242 = !{ptr @memcg_oom_waitq, !241, !"memcg_oom_waitq", i1 false, i1 false}
!243 = !{ptr @.str.95, !244, !"<string literal>", i1 false, i1 false}
!244 = !{!"../mm/memcontrol.c", i32 1680, i32 8}
!245 = !{ptr @memcg_oom_lock, !244, !"memcg_oom_lock", i1 false, i1 false}
!246 = !{ptr @memcg_oom_lock_dep_map, !247, !"memcg_oom_lock_dep_map", i1 false, i1 false}
!247 = !{!"../mm/memcontrol.c", i32 1675, i32 27}
!248 = !{ptr @.str.96, !249, !"<string literal>", i1 false, i1 false}
!249 = !{!"../include/linux/page-flags.h", i32 260, i32 2}
!250 = distinct !{null, !251, !"<string literal>", i1 false, i1 false}
!251 = !{!"../include/linux/page-flags.h", i32 261, i32 2}
!252 = !{ptr @.str.98, !253, !"<string literal>", i1 false, i1 false}
!253 = !{!"../mm/slab.h", i32 444, i32 2}
!254 = !{ptr @.str.99, !255, !"<string literal>", i1 false, i1 false}
!255 = !{!"../mm/slab.h", i32 446, i32 2}
!256 = !{ptr @.str.100, !257, !"<string literal>", i1 false, i1 false}
!257 = !{!"../mm/memcontrol.c", i32 2111, i32 8}
!258 = !{ptr @.str.101, !257, !"<string literal>", i1 false, i1 false}
!259 = !{ptr @percpu_charge_mutex, !257, !"percpu_charge_mutex", i1 false, i1 false}
!260 = !{ptr @.str.102, !261, !"<string literal>", i1 false, i1 false}
!261 = !{!"../mm/memcontrol.c", i32 196, i32 10}
!262 = !{ptr @.str.103, !263, !"<string literal>", i1 false, i1 false}
!263 = !{!"../mm/memcontrol.c", i32 197, i32 11}
!264 = !{ptr @mc, !265, !"mc", i1 false, i1 false}
!265 = !{!"../mm/memcontrol.c", i32 195, i32 3}
!266 = !{ptr @.str.104, !267, !"<string literal>", i1 false, i1 false}
!267 = !{!"../include/linux/memcontrol.h", i32 537, i32 2}
!268 = !{ptr @.str.105, !269, !"<string literal>", i1 false, i1 false}
!269 = !{!"../include/linux/memcontrol.h", i32 538, i32 2}
!270 = distinct !{null, !271, !"<string literal>", i1 false, i1 false}
!271 = !{!"../include/linux/memcontrol.h", i32 419, i32 2}
!272 = distinct !{null, !273, !"__already_done", i1 false, i1 false}
!273 = !{!"../include/trace/events/writeback.h", i32 237, i32 1}
!274 = !{ptr @.str.107, !273, !"<string literal>", i1 false, i1 false}
!275 = distinct !{null, !273, !"__warned", i1 false, i1 false}
!276 = distinct !{null, !277, !"__already_done", i1 false, i1 false}
!277 = !{!"../include/linux/cpumask.h", i32 108, i32 2}
!278 = !{ptr @.str.108, !277, !"<string literal>", i1 false, i1 false}
!279 = distinct !{null, !280, !"__already_done", i1 false, i1 false}
!280 = !{!"../include/trace/events/writeback.h", i32 274, i32 1}
!281 = distinct !{null, !280, !"__warned", i1 false, i1 false}
!282 = !{ptr @.str.109, !283, !"<string literal>", i1 false, i1 false}
!283 = !{!"../mm/memcontrol.c", i32 5024, i32 8}
!284 = !{ptr @mem_cgroup_idr, !283, !"mem_cgroup_idr", i1 false, i1 false}
!285 = !{ptr @mem_cgroup_alloc.__key, !286, !"__key", i1 false, i1 false}
!286 = !{!"../mm/memcontrol.c", i32 5159, i32 2}
!287 = !{ptr @.str.110, !286, !"<string literal>", i1 false, i1 false}
!288 = !{ptr @mem_cgroup_alloc.__key.111, !289, !"__key", i1 false, i1 false}
!289 = !{!"../mm/memcontrol.c", i32 5161, i32 2}
!290 = !{ptr @.str.112, !289, !"<string literal>", i1 false, i1 false}
!291 = !{ptr @mem_cgroup_alloc.__key.113, !292, !"__key", i1 false, i1 false}
!292 = !{!"../mm/memcontrol.c", i32 5162, i32 2}
!293 = !{ptr @.str.114, !292, !"<string literal>", i1 false, i1 false}
!294 = !{ptr @mem_cgroup_alloc.__key.115, !295, !"__key", i1 false, i1 false}
!295 = !{!"../mm/memcontrol.c", i32 5165, i32 2}
!296 = !{ptr @.str.116, !295, !"<string literal>", i1 false, i1 false}
!297 = !{ptr @.str.117, !298, !"<string literal>", i1 false, i1 false}
!298 = !{!"../mm/memcontrol.c", i32 97, i32 8}
!299 = !{ptr @memcg_cgwb_frn_waitq, !298, !"memcg_cgwb_frn_waitq", i1 false, i1 false}
!300 = !{ptr @.str.118, !301, !"<string literal>", i1 false, i1 false}
!301 = !{!"../mm/memcontrol.c", i32 361, i32 8}
!302 = !{ptr @memcg_cache_ida, !301, !"memcg_cache_ida", i1 false, i1 false}
!303 = distinct !{null, !304, !"__already_done", i1 false, i1 false}
!304 = !{!"../mm/memcontrol.c", i32 295, i32 2}
!305 = !{ptr @.str.119, !306, !"<string literal>", i1 false, i1 false}
!306 = !{!"../mm/memcontrol.c", i32 257, i32 8}
!307 = !{ptr @objcg_lock, !306, !"objcg_lock", i1 false, i1 false}
!308 = distinct !{null, !309, !"cgroup_memory_nosocket", i1 false, i1 false}
!309 = !{!"../mm/memcontrol.c", i32 84, i32 13}
!310 = !{ptr @.str.120, !311, !"<string literal>", i1 false, i1 false}
!311 = !{!"../mm/memcontrol.c", i32 627, i32 8}
!312 = !{ptr @.str.121, !311, !"<string literal>", i1 false, i1 false}
!313 = !{ptr @stats_flush_dwork, !311, !"stats_flush_dwork", i1 false, i1 false}
!314 = distinct !{null, !315, !"__warned", i1 false, i1 false}
!315 = !{!"../mm/memcontrol.c", i32 333, i32 10}
!316 = distinct !{null, !317, !"__already_done", i1 false, i1 false}
!317 = !{!"../mm/memcontrol.c", i32 5930, i32 3}
!318 = !{ptr @precharge_walk_ops, !319, !"precharge_walk_ops", i1 false, i1 false}
!319 = !{!"../mm/memcontrol.c", i32 5821, i32 33}
!320 = !{ptr @.str.122, !321, !"<string literal>", i1 false, i1 false}
!321 = !{!"../include/linux/mm.h", i32 717, i32 2}
!322 = !{ptr @charge_walk_ops, !323, !"charge_walk_ops", i1 false, i1 false}
!323 = !{!"../mm/memcontrol.c", i32 6097, i32 33}
!324 = !{ptr @.str.123, !325, !"<string literal>", i1 false, i1 false}
!325 = !{!"../mm/memcontrol.c", i32 5579, i32 2}
!326 = !{ptr @memory_files, !327, !"memory_files", i1 false, i1 false}
!327 = !{!"../mm/memcontrol.c", i32 6430, i32 22}
!328 = !{ptr @.str.124, !329, !"<string literal>", i1 false, i1 false}
!329 = !{!"../mm/memcontrol.c", i32 6158, i32 15}
!330 = !{ptr @.str.125, !331, !"<string literal>", i1 false, i1 false}
!331 = !{!"../mm/memcontrol.c", i32 6160, i32 17}
!332 = !{ptr @.str.126, !333, !"<string literal>", i1 false, i1 false}
!333 = !{!"../mm/memcontrol.c", i32 6187, i32 35}
!334 = !{ptr @.str.127, !335, !"<string literal>", i1 false, i1 false}
!335 = !{!"../mm/memcontrol.c", i32 6323, i32 16}
!336 = !{ptr @.str.128, !337, !"<string literal>", i1 false, i1 false}
!337 = !{!"../mm/memcontrol.c", i32 6324, i32 16}
!338 = !{ptr @.str.129, !339, !"<string literal>", i1 false, i1 false}
!339 = !{!"../mm/memcontrol.c", i32 6325, i32 16}
!340 = !{ptr @.str.130, !341, !"<string literal>", i1 false, i1 false}
!341 = !{!"../mm/memcontrol.c", i32 6326, i32 16}
!342 = !{ptr @.str.131, !343, !"<string literal>", i1 false, i1 false}
!343 = !{!"../mm/memcontrol.c", i32 6327, i32 16}
!344 = !{ptr @.str.132, !345, !"<string literal>", i1 false, i1 false}
!345 = !{!"../mm/memcontrol.c", i32 6329, i32 16}
!346 = !{ptr @.str.133, !347, !"<string literal>", i1 false, i1 false}
!347 = !{!"../mm/memcontrol.c", i32 6403, i32 16}
!348 = !{ptr @mem_cgroup_legacy_files, !349, !"mem_cgroup_legacy_files", i1 false, i1 false}
!349 = !{!"../mm/memcontrol.c", i32 4871, i32 22}
!350 = !{ptr @.str.134, !351, !"<string literal>", i1 false, i1 false}
!351 = !{!"../mm/memcontrol.c", i32 3739, i32 35}
!352 = !{ptr @.str.135, !353, !"<string literal>", i1 false, i1 false}
!353 = !{!"../mm/memcontrol.c", i32 3359, i32 8}
!354 = !{ptr @.str.136, !353, !"<string literal>", i1 false, i1 false}
!355 = !{ptr @memcg_max_mutex, !353, !"memcg_max_mutex", i1 false, i1 false}
!356 = !{ptr @.str.137, !357, !"<string literal>", i1 false, i1 false}
!357 = !{!"../mm/memcontrol.c", i32 4001, i32 16}
!358 = !{ptr @.str.138, !359, !"<string literal>", i1 false, i1 false}
!359 = !{!"../mm/memcontrol.c", i32 4004, i32 17}
!360 = !{ptr @.str.139, !361, !"<string literal>", i1 false, i1 false}
!361 = !{!"../mm/memcontrol.c", i32 4013, i32 17}
!362 = !{ptr @.str.140, !363, !"<string literal>", i1 false, i1 false}
!363 = !{!"../mm/memcontrol.c", i32 4040, i32 17}
!364 = !{ptr @.str.141, !365, !"<string literal>", i1 false, i1 false}
!365 = !{!"../mm/memcontrol.c", i32 4041, i32 17}
!366 = !{ptr @memcg1_stats, !367, !"memcg1_stats", i1 false, i1 false}
!367 = !{!"../mm/memcontrol.c", i32 3932, i32 27}
!368 = !{ptr @.str.142, !369, !"<string literal>", i1 false, i1 false}
!369 = !{!"../mm/memcontrol.c", i32 3946, i32 2}
!370 = !{ptr @.str.143, !371, !"<string literal>", i1 false, i1 false}
!371 = !{!"../mm/memcontrol.c", i32 3947, i32 2}
!372 = !{ptr @.str.144, !373, !"<string literal>", i1 false, i1 false}
!373 = !{!"../mm/memcontrol.c", i32 3952, i32 2}
!374 = !{ptr @.str.145, !375, !"<string literal>", i1 false, i1 false}
!375 = !{!"../mm/memcontrol.c", i32 3953, i32 2}
!376 = !{ptr @.str.146, !377, !"<string literal>", i1 false, i1 false}
!377 = !{!"../mm/memcontrol.c", i32 3954, i32 2}
!378 = !{ptr @.str.147, !379, !"<string literal>", i1 false, i1 false}
!379 = !{!"../mm/memcontrol.c", i32 3955, i32 2}
!380 = !{ptr @memcg1_stat_names, !381, !"memcg1_stat_names", i1 false, i1 false}
!381 = !{!"../mm/memcontrol.c", i32 3945, i32 26}
!382 = distinct !{null, !383, !"memcg1_events", i1 false, i1 false}
!383 = !{!"../mm/memcontrol.c", i32 3959, i32 27}
!384 = distinct !{null, !385, !"__already_done", i1 false, i1 false}
!385 = !{!"../mm/memcontrol.c", i32 3547, i32 2}
!386 = !{ptr @.str.148, !385, !"<string literal>", i1 false, i1 false}
!387 = !{ptr @.str.149, !385, !"<string literal>", i1 false, i1 false}
!388 = !{ptr @mem_cgroup_hierarchy_write._entry, !385, !"_entry", i1 false, i1 false}
!389 = !{ptr @mem_cgroup_hierarchy_write._entry_ptr, !385, !"_entry_ptr", i1 false, i1 false}
!390 = !{ptr @memcg_write_event_control.__key, !391, !"__key", i1 false, i1 false}
!391 = !{!"../mm/memcontrol.c", i32 4763, i32 2}
!392 = !{ptr @.str.150, !391, !"<string literal>", i1 false, i1 false}
!393 = !{ptr @.str.151, !394, !"<string literal>", i1 false, i1 false}
!394 = !{!"../mm/memcontrol.c", i32 4799, i32 20}
!395 = !{ptr @.str.152, !396, !"<string literal>", i1 false, i1 false}
!396 = !{!"../mm/memcontrol.c", i32 4802, i32 27}
!397 = !{ptr @.str.153, !398, !"<string literal>", i1 false, i1 false}
!398 = !{!"../mm/memcontrol.c", i32 4805, i32 27}
!399 = !{ptr @.str.154, !400, !"<string literal>", i1 false, i1 false}
!400 = !{!"../mm/memcontrol.c", i32 4808, i32 27}
!401 = distinct !{null, !402, !"__warned", i1 false, i1 false}
!402 = !{!"../mm/memcontrol.c", i32 4080, i32 7}
!403 = distinct !{null, !404, !"__warned", i1 false, i1 false}
!404 = !{!"../mm/memcontrol.c", i32 4082, i32 7}
!405 = !{ptr @.str.156, !406, !"<string literal>", i1 false, i1 false}
!406 = !{!"../mm/memcontrol.c", i32 4401, i32 17}
!407 = !{ptr @.str.157, !408, !"<string literal>", i1 false, i1 false}
!408 = !{!"../mm/memcontrol.c", i32 4402, i32 17}
!409 = distinct !{null, !410, !"__already_done", i1 false, i1 false}
!410 = !{!"../include/linux/percpu-refcount.h", i32 280, i32 2}
!411 = !{ptr @.str.158, !410, !"<string literal>", i1 false, i1 false}
!412 = !{ptr @.str.159, !413, !"<string literal>", i1 false, i1 false}
!413 = !{!"../include/linux/page-flags.h", i32 698, i32 1}
!414 = !{ptr @.str.160, !415, !"<string literal>", i1 false, i1 false}
!415 = !{!"../mm/memcontrol.c", i32 2739, i32 2}
!416 = distinct !{null, !417, !"<string literal>", i1 false, i1 false}
!417 = !{!"../mm/memcontrol.c", i32 835, i32 8}
!418 = !{ptr @__setup_str_cgroup_memory, !101, !"__setup_str_cgroup_memory", i1 false, i1 false}
!419 = !{ptr @.str.162, !420, !"<string literal>", i1 false, i1 false}
!420 = !{!"../mm/memcontrol.c", i32 7048, i32 29}
!421 = !{ptr @.str.163, !422, !"<string literal>", i1 false, i1 false}
!422 = !{!"../mm/memcontrol.c", i32 7051, i32 22}
!423 = !{ptr @.str.164, !424, !"<string literal>", i1 false, i1 false}
!424 = !{!"../mm/memcontrol.c", i32 7053, i32 22}
!425 = !{ptr @.str.165, !426, !"<string literal>", i1 false, i1 false}
!426 = !{!"../mm/memcontrol.c", i32 7080, i32 49}
!427 = !{ptr @mem_cgroup_init.__key, !428, !"__key", i1 false, i1 false}
!428 = !{!"../mm/memcontrol.c", i32 7084, i32 3}
!429 = !{ptr @.str.166, !428, !"<string literal>", i1 false, i1 false}
!430 = !{ptr @mem_cgroup_init.__key.167, !431, !"__key", i1 false, i1 false}
!431 = !{!"../mm/memcontrol.c", i32 7095, i32 3}
!432 = !{ptr @.str.168, !431, !"<string literal>", i1 false, i1 false}
!433 = !{ptr @.str.169, !434, !"<string literal>", i1 false, i1 false}
!434 = !{!"../include/linux/page-flags.h", i32 422, i32 1}
!435 = distinct !{null, !436, !"__already_done", i1 false, i1 false}
!436 = !{!"../mm/memcontrol.c", i32 7111, i32 7}
!437 = !{ptr @.str.170, !438, !"<string literal>", i1 false, i1 false}
!438 = !{!"../include/linux/mm.h", i32 1368, i32 10}
!439 = !{ptr @__setup_str_setup_swap_account, !118, !"__setup_str_setup_swap_account", i1 false, i1 false}
!440 = !{ptr @.str.171, !441, !"<string literal>", i1 false, i1 false}
!441 = !{!"../mm/memcontrol.c", i32 7306, i32 17}
!442 = !{ptr @.str.172, !443, !"<string literal>", i1 false, i1 false}
!443 = !{!"../mm/memcontrol.c", i32 7308, i32 22}
!444 = !{ptr @swap_files, !445, !"swap_files", i1 false, i1 false}
!445 = !{!"../mm/memcontrol.c", i32 7382, i32 22}
!446 = !{ptr @.str.173, !447, !"<string literal>", i1 false, i1 false}
!447 = !{!"../mm/memcontrol.c", i32 7376, i32 16}
!448 = !{ptr @memsw_files, !449, !"memsw_files", i1 false, i1 false}
!449 = !{!"../mm/memcontrol.c", i32 7409, i32 22}
!450 = !{!"sp"}
!451 = !{i32 1, !"wchar_size", i32 2}
!452 = !{i32 1, !"min_enum_size", i32 4}
!453 = !{i32 8, !"branch-target-enforcement", i32 0}
!454 = !{i32 8, !"sign-return-address", i32 0}
!455 = !{i32 8, !"sign-return-address-all", i32 0}
!456 = !{i32 8, !"sign-return-address-with-bkey", i32 0}
!457 = !{i32 7, !"uwtable", i32 1}
!458 = !{i32 7, !"frame-pointer", i32 2}
!459 = !{!"clang version 15.0.0 (git@github.com:linkeLi0421/llvm-project15-IRDumperPass.git 23ab625cb005cd08da083f9b643a7feed9af8abe)"}
!460 = !{!"branch_weights", i32 2000, i32 1}
!461 = !{i64 2148888476, i64 2148888481, i64 2148888494, i64 2148888538, i64 2148888572, i64 2148888593}
!462 = !{i64 2149519751}
!463 = !{i64 2149520017}
!464 = !{i64 768664, i64 768725}
!465 = !{i64 771396}
!466 = !{!"branch_weights", i32 1, i32 2000}
!467 = !{i64 771681}
!468 = !{i64 2148315337, i64 2148315363, i64 2148315392, i64 2148315426, i64 2148315457, i64 2148315480}
!469 = !{i64 2154069885, i64 2154070369, i64 2154069922, i64 2154069978, i64 2154070012, i64 2154070036, i64 2154070077, i64 2154070098, i64 2154070126, i64 2154070160}
!470 = !{i64 2151194750, i64 2151195241, i64 2151194787, i64 2151194843, i64 2151194877, i64 2151194901, i64 2151194942, i64 2151194963, i64 2151194991, i64 2151195025}
!471 = !{i64 2158224539, i64 2158225013, i64 2158224576, i64 2158224632, i64 2158224666, i64 2158224690, i64 2158224731, i64 2158224752, i64 2158224780, i64 2158224814}
!472 = !{i64 2158226933, i64 2158227407, i64 2158226970, i64 2158227026, i64 2158227060, i64 2158227084, i64 2158227125, i64 2158227146, i64 2158227174, i64 2158227208}
!473 = !{i64 2158843620}
!474 = !{i64 2158860393}
!475 = !{i64 2158892612}
!476 = !{i64 824829, i64 824850, i64 824873, i64 824892, i64 824911}
!477 = !{i64 2158893025}
!478 = !{i64 2158893974}
!479 = !{i64 2158894381}
!480 = !{i64 2158896266, i64 2158900808, i64 2158896303, i64 2158896359, i64 2158896393, i64 2158896417, i64 2158896458, i64 2158896479, i64 2158896507, i64 2158896541}
!481 = !{i64 2158902419, i64 2158902900, i64 2158902456, i64 2158902512, i64 2158902546, i64 2158902570, i64 2158902611, i64 2158902632, i64 2158902660, i64 2158902694}
!482 = !{i64 2158904249, i64 2158904730, i64 2158904286, i64 2158904342, i64 2158904376, i64 2158904400, i64 2158904441, i64 2158904462, i64 2158904490, i64 2158904524}
!483 = !{i64 2154788314, i64 2154788805, i64 2154788351, i64 2154788407, i64 2154788441, i64 2154788465, i64 2154788506, i64 2154788527, i64 2154788555, i64 2154788589}
!484 = !{i64 2154790214, i64 2154790705, i64 2154790251, i64 2154790307, i64 2154790341, i64 2154790365, i64 2154790406, i64 2154790427, i64 2154790455, i64 2154790489}
!485 = !{i64 2154772814, i64 2154773305, i64 2154772851, i64 2154772907, i64 2154772941, i64 2154772965, i64 2154773006, i64 2154773027, i64 2154773055, i64 2154773089}
!486 = !{i64 2154767072, i64 2154767563, i64 2154767109, i64 2154767165, i64 2154767199, i64 2154767223, i64 2154767264, i64 2154767285, i64 2154767313, i64 2154767347}
!487 = !{i64 2158908704, i64 2158909185, i64 2158908741, i64 2158908797, i64 2158908831, i64 2158908855, i64 2158908896, i64 2158908917, i64 2158908945, i64 2158908979}
!488 = !{i8 0, i8 2}
!489 = !{!"branch_weights", i32 2146410443, i32 1073205}
!490 = !{!"branch_weights", i32 1073205, i32 2146410443}
!491 = !{!"branch_weights", i32 2002, i32 2000}
!492 = !{!"auto-init"}
!493 = !{i64 2159030449}
!494 = !{i64 2159030859}
!495 = !{i64 2159024764}
!496 = !{i64 2148578001}
!497 = !{i64 822105, i64 822122, i64 822146, i64 822172, i64 822190}
!498 = !{i64 2148578371}
!499 = !{i64 2159028359}
!500 = !{i64 2159333370}
!501 = !{i64 2159333589}
!502 = !{i64 2149528310}
!503 = !{i64 2149529346}
!504 = !{i64 2159354735}
!505 = !{i64 2159354980}
!506 = !{i64 2154942853}
!507 = !{i64 2154959626}
!508 = !{i64 2159062654, i64 2159063135, i64 2159062691, i64 2159062747, i64 2159062781, i64 2159062805, i64 2159062846, i64 2159062867, i64 2159062895, i64 2159062929}
!509 = !{i64 2159068992}
!510 = !{i64 2158895492}
!511 = !{i64 2158895912}
!512 = !{i64 2159915423, i64 2159915904, i64 2159915460, i64 2159915516, i64 2159915550, i64 2159915574, i64 2159915615, i64 2159915636, i64 2159915664, i64 2159915698}
!513 = !{i64 2159917005, i64 2159917486, i64 2159917042, i64 2159917098, i64 2159917132, i64 2159917156, i64 2159917197, i64 2159917218, i64 2159917246, i64 2159917280}
!514 = !{i64 2159918581, i64 2159919062, i64 2159918618, i64 2159918674, i64 2159918708, i64 2159918732, i64 2159918773, i64 2159918794, i64 2159918822, i64 2159918856}
!515 = !{i64 2159920178, i64 2159920659, i64 2159920215, i64 2159920271, i64 2159920305, i64 2159920329, i64 2159920370, i64 2159920391, i64 2159920419, i64 2159920453}
!516 = !{i64 2159921784, i64 2159922265, i64 2159921821, i64 2159921877, i64 2159921911, i64 2159921935, i64 2159921976, i64 2159921997, i64 2159922025, i64 2159922059}
!517 = !{i64 2159923384, i64 2159923865, i64 2159923421, i64 2159923477, i64 2159923511, i64 2159923535, i64 2159923576, i64 2159923597, i64 2159923625, i64 2159923659}
!518 = !{i64 2159904302, i64 2159904783, i64 2159904339, i64 2159904395, i64 2159904429, i64 2159904453, i64 2159904494, i64 2159904515, i64 2159904543, i64 2159904577}
!519 = !{i64 2151961536, i64 2151962027, i64 2151961573, i64 2151961629, i64 2151961663, i64 2151961687, i64 2151961728, i64 2151961749, i64 2151961777, i64 2151961811}
!520 = !{i64 2159022177, i64 2159022658, i64 2159022214, i64 2159022270, i64 2159022304, i64 2159022328, i64 2159022369, i64 2159022390, i64 2159022418, i64 2159022452}
!521 = !{i64 769099}
!522 = !{i64 768909}
!523 = !{i64 2148314756}
!524 = !{i64 690677, i64 690702, i64 690724, i64 690740, i64 690752, i64 690772, i64 690796, i64 690812, i64 690824}
!525 = !{i64 2148314944}
!526 = !{i64 2159990637, i64 2159991118, i64 2159990674, i64 2159990730, i64 2159990764, i64 2159990788, i64 2159990829, i64 2159990850, i64 2159990878, i64 2159990912}
!527 = !{i64 2159995621, i64 2159996102, i64 2159995658, i64 2159995714, i64 2159995748, i64 2159995772, i64 2159995813, i64 2159995834, i64 2159995862, i64 2159995896}
!528 = !{i64 2159997419, i64 2159997900, i64 2159997456, i64 2159997512, i64 2159997546, i64 2159997570, i64 2159997611, i64 2159997632, i64 2159997660, i64 2159997694}
!529 = !{i64 2159999322, i64 2159999803, i64 2159999359, i64 2159999415, i64 2159999449, i64 2159999473, i64 2159999514, i64 2159999535, i64 2159999563, i64 2159999597}
!530 = !{i64 2160005221, i64 2160005702, i64 2160005258, i64 2160005314, i64 2160005348, i64 2160005372, i64 2160005413, i64 2160005434, i64 2160005462, i64 2160005496}
!531 = !{i64 2151336816, i64 2151337307, i64 2151336853, i64 2151336909, i64 2151336943, i64 2151336967, i64 2151337008, i64 2151337029, i64 2151337057, i64 2151337091}
!532 = !{i64 2160027214, i64 2160027695, i64 2160027251, i64 2160027307, i64 2160027341, i64 2160027365, i64 2160027406, i64 2160027427, i64 2160027455, i64 2160027489}
!533 = !{i64 2160028969, i64 2160029450, i64 2160029006, i64 2160029062, i64 2160029096, i64 2160029120, i64 2160029161, i64 2160029182, i64 2160029210, i64 2160029244}
!534 = !{i64 2154031120, i64 2154031608, i64 2154031157, i64 2154031213, i64 2154031247, i64 2154031271, i64 2154031312, i64 2154031333, i64 2154031361, i64 2154031395}
!535 = !{i64 2160032340, i64 2160032821, i64 2160032377, i64 2160032433, i64 2160032467, i64 2160032491, i64 2160032532, i64 2160032553, i64 2160032581, i64 2160032615}
!536 = !{i64 2160035561, i64 2160036042, i64 2160035598, i64 2160035654, i64 2160035688, i64 2160035712, i64 2160035753, i64 2160035774, i64 2160035802, i64 2160035836}
!537 = !{i64 690171, i64 690195, i64 690216, i64 690233, i64 690250}
!538 = !{i64 2160025474, i64 2160025955, i64 2160025511, i64 2160025567, i64 2160025601, i64 2160025625, i64 2160025666, i64 2160025687, i64 2160025715, i64 2160025749}
!539 = !{i64 2160038935, i64 2160039416, i64 2160038972, i64 2160039028, i64 2160039062, i64 2160039086, i64 2160039127, i64 2160039148, i64 2160039176, i64 2160039210}
!540 = !{i64 2148404868}
!541 = !{i64 2148319332, i64 2148319364, i64 2148319393, i64 2148319427, i64 2148319458, i64 2148319481}
!542 = !{i64 2149827738}
!543 = !{i64 2151202183, i64 2151206735, i64 2151202220, i64 2151202276, i64 2151202310, i64 2151202334, i64 2151202375, i64 2151202396, i64 2151202424, i64 2151202458}
!544 = !{i64 2160060315, i64 2160060796, i64 2160060352, i64 2160060408, i64 2160060442, i64 2160060466, i64 2160060507, i64 2160060528, i64 2160060556, i64 2160060590}
!545 = !{i64 2148403789}
!546 = !{i64 2148318522, i64 2148318554, i64 2148318583, i64 2148318617, i64 2148318648, i64 2148318671}
!547 = !{i64 2148404018}
!548 = !{i32 12, i32 33}
!549 = !{!"branch_weights", i32 2000, i32 2002}
!550 = !{i64 2158991959}
!551 = !{i64 2158993297}
!552 = !{i64 2159071765, i64 2159072246, i64 2159071802, i64 2159071858, i64 2159071892, i64 2159071916, i64 2159071957, i64 2159071978, i64 2159072006, i64 2159072040}
!553 = !{i64 2154294951}
!554 = !{i64 2152450129}
!555 = !{i64 2152450336}
!556 = !{i64 2154297722}
!557 = !{i64 2154040130, i64 2154040613, i64 2154040167, i64 2154040223, i64 2154040257, i64 2154040281, i64 2154040322, i64 2154040343, i64 2154040371, i64 2154040405}
!558 = !{i64 2148317802, i64 2148317828, i64 2148317857, i64 2148317891, i64 2148317922, i64 2148317945}
!559 = !{i64 2148316867, i64 2148316899, i64 2148316928, i64 2148316962, i64 2148316993, i64 2148317016}
!560 = !{i64 2159894549, i64 2159895030, i64 2159894586, i64 2159894642, i64 2159894676, i64 2159894700, i64 2159894741, i64 2159894762, i64 2159894790, i64 2159894824}
!561 = !{i64 2159896339, i64 2159896820, i64 2159896376, i64 2159896432, i64 2159896466, i64 2159896490, i64 2159896531, i64 2159896552, i64 2159896580, i64 2159896614}
!562 = !{i64 2148324195, i64 2148324227, i64 2148324256, i64 2148324290, i64 2148324321, i64 2148324344}
!563 = !{i64 2148413276}
!564 = !{i64 2159899407}
!565 = !{i64 2159947118}
!566 = !{i64 2159947463}
!567 = !{i64 2159059206, i64 2159059687, i64 2159059243, i64 2159059299, i64 2159059333, i64 2159059357, i64 2159059398, i64 2159059419, i64 2159059447, i64 2159059481}
!568 = !{i64 2159061065, i64 2159061546, i64 2159061102, i64 2159061158, i64 2159061192, i64 2159061216, i64 2159061257, i64 2159061278, i64 2159061306, i64 2159061340}
!569 = !{i64 2159073465, i64 2159073946, i64 2159073502, i64 2159073558, i64 2159073592, i64 2159073616, i64 2159073657, i64 2159073678, i64 2159073706, i64 2159073740}
!570 = !{i64 2159074971, i64 2159075452, i64 2159075008, i64 2159075064, i64 2159075098, i64 2159075122, i64 2159075163, i64 2159075184, i64 2159075212, i64 2159075246}
!571 = !{!572}
!572 = distinct !{!572, !573, !"fdget: %agg.result"}
!573 = distinct !{!573, !"fdget"}
!574 = !{!575}
!575 = distinct !{!575, !576, !"fdget: %agg.result"}
!576 = distinct !{!576, !"fdget"}
!577 = !{i64 2152686293}
!578 = !{i64 2159137547}
!579 = !{i64 2159147166}
!580 = !{i64 2160080758}
!581 = !{i64 2160081103}
